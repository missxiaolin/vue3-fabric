var KI = Object.defineProperty;
var GI = (i, n, s) => n in i ? KI(i, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : i[n] = s;
var Te = (i, n, s) => (GI(i, typeof n != "symbol" ? n + "" : n, s), s);
var jd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function SC(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function Vu(i) {
  if (i.__esModule)
    return i;
  var n = i.default;
  if (typeof n == "function") {
    var s = function u() {
      return this instanceof u ? Reflect.construct(n, arguments, this.constructor) : n.apply(this, arguments);
    };
    s.prototype = n.prototype;
  } else
    s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(i).forEach(function(u) {
    var y = Object.getOwnPropertyDescriptor(i, u);
    Object.defineProperty(s, u, y.get ? y : {
      enumerable: !0,
      get: function() {
        return i[u];
      }
    });
  }), s;
}
var op = { exports: {} }, xo = typeof Reflect == "object" ? Reflect : null, ky = xo && typeof xo.apply == "function" ? xo.apply : function(n, s, u) {
  return Function.prototype.apply.call(n, s, u);
}, tu;
xo && typeof xo.ownKeys == "function" ? tu = xo.ownKeys : Object.getOwnPropertySymbols ? tu = function(n) {
  return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));
} : tu = function(n) {
  return Object.getOwnPropertyNames(n);
};
function XI(i) {
  console && console.warn && console.warn(i);
}
var EC = Number.isNaN || function(n) {
  return n !== n;
};
function Ht() {
  Ht.init.call(this);
}
op.exports = Ht;
op.exports.once = ZI;
Ht.EventEmitter = Ht;
Ht.prototype._events = void 0;
Ht.prototype._eventsCount = 0;
Ht.prototype._maxListeners = void 0;
var Sy = 10;
function $u(i) {
  if (typeof i != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof i);
}
Object.defineProperty(Ht, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Sy;
  },
  set: function(i) {
    if (typeof i != "number" || i < 0 || EC(i))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + i + ".");
    Sy = i;
  }
});
Ht.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Ht.prototype.setMaxListeners = function(n) {
  if (typeof n != "number" || n < 0 || EC(n))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  return this._maxListeners = n, this;
};
function xC(i) {
  return i._maxListeners === void 0 ? Ht.defaultMaxListeners : i._maxListeners;
}
Ht.prototype.getMaxListeners = function() {
  return xC(this);
};
Ht.prototype.emit = function(n) {
  for (var s = [], u = 1; u < arguments.length; u++)
    s.push(arguments[u]);
  var y = n === "error", w = this._events;
  if (w !== void 0)
    y = y && w.error === void 0;
  else if (!y)
    return !1;
  if (y) {
    var S;
    if (s.length > 0 && (S = s[0]), S instanceof Error)
      throw S;
    var d = new Error("Unhandled error." + (S ? " (" + S.message + ")" : ""));
    throw d.context = S, d;
  }
  var l = w[n];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    ky(l, this, s);
  else
    for (var p = l.length, v = NC(l, p), u = 0; u < p; ++u)
      ky(v[u], this, s);
  return !0;
};
function _C(i, n, s, u) {
  var y, w, S;
  if ($u(s), w = i._events, w === void 0 ? (w = i._events = /* @__PURE__ */ Object.create(null), i._eventsCount = 0) : (w.newListener !== void 0 && (i.emit(
    "newListener",
    n,
    s.listener ? s.listener : s
  ), w = i._events), S = w[n]), S === void 0)
    S = w[n] = s, ++i._eventsCount;
  else if (typeof S == "function" ? S = w[n] = u ? [s, S] : [S, s] : u ? S.unshift(s) : S.push(s), y = xC(i), y > 0 && S.length > y && !S.warned) {
    S.warned = !0;
    var d = new Error("Possible EventEmitter memory leak detected. " + S.length + " " + String(n) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    d.name = "MaxListenersExceededWarning", d.emitter = i, d.type = n, d.count = S.length, XI(d);
  }
  return i;
}
Ht.prototype.addListener = function(n, s) {
  return _C(this, n, s, !1);
};
Ht.prototype.on = Ht.prototype.addListener;
Ht.prototype.prependListener = function(n, s) {
  return _C(this, n, s, !0);
};
function qI() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function TC(i, n, s) {
  var u = { fired: !1, wrapFn: void 0, target: i, type: n, listener: s }, y = qI.bind(u);
  return y.listener = s, u.wrapFn = y, y;
}
Ht.prototype.once = function(n, s) {
  return $u(s), this.on(n, TC(this, n, s)), this;
};
Ht.prototype.prependOnceListener = function(n, s) {
  return $u(s), this.prependListener(n, TC(this, n, s)), this;
};
Ht.prototype.removeListener = function(n, s) {
  var u, y, w, S, d;
  if ($u(s), y = this._events, y === void 0)
    return this;
  if (u = y[n], u === void 0)
    return this;
  if (u === s || u.listener === s)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete y[n], y.removeListener && this.emit("removeListener", n, u.listener || s));
  else if (typeof u != "function") {
    for (w = -1, S = u.length - 1; S >= 0; S--)
      if (u[S] === s || u[S].listener === s) {
        d = u[S].listener, w = S;
        break;
      }
    if (w < 0)
      return this;
    w === 0 ? u.shift() : JI(u, w), u.length === 1 && (y[n] = u[0]), y.removeListener !== void 0 && this.emit("removeListener", n, d || s);
  }
  return this;
};
Ht.prototype.off = Ht.prototype.removeListener;
Ht.prototype.removeAllListeners = function(n) {
  var s, u, y;
  if (u = this._events, u === void 0)
    return this;
  if (u.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : u[n] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete u[n]), this;
  if (arguments.length === 0) {
    var w = Object.keys(u), S;
    for (y = 0; y < w.length; ++y)
      S = w[y], S !== "removeListener" && this.removeAllListeners(S);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (s = u[n], typeof s == "function")
    this.removeListener(n, s);
  else if (s !== void 0)
    for (y = s.length - 1; y >= 0; y--)
      this.removeListener(n, s[y]);
  return this;
};
function OC(i, n, s) {
  var u = i._events;
  if (u === void 0)
    return [];
  var y = u[n];
  return y === void 0 ? [] : typeof y == "function" ? s ? [y.listener || y] : [y] : s ? QI(y) : NC(y, y.length);
}
Ht.prototype.listeners = function(n) {
  return OC(this, n, !0);
};
Ht.prototype.rawListeners = function(n) {
  return OC(this, n, !1);
};
Ht.listenerCount = function(i, n) {
  return typeof i.listenerCount == "function" ? i.listenerCount(n) : DC.call(i, n);
};
Ht.prototype.listenerCount = DC;
function DC(i) {
  var n = this._events;
  if (n !== void 0) {
    var s = n[i];
    if (typeof s == "function")
      return 1;
    if (s !== void 0)
      return s.length;
  }
  return 0;
}
Ht.prototype.eventNames = function() {
  return this._eventsCount > 0 ? tu(this._events) : [];
};
function NC(i, n) {
  for (var s = new Array(n), u = 0; u < n; ++u)
    s[u] = i[u];
  return s;
}
function JI(i, n) {
  for (; n + 1 < i.length; n++)
    i[n] = i[n + 1];
  i.pop();
}
function QI(i) {
  for (var n = new Array(i.length), s = 0; s < n.length; ++s)
    n[s] = i[s].listener || i[s];
  return n;
}
function ZI(i, n) {
  return new Promise(function(s, u) {
    function y(S) {
      i.removeListener(n, w), u(S);
    }
    function w() {
      typeof i.removeListener == "function" && i.removeListener("error", y), s([].slice.call(arguments));
    }
    BC(i, n, w, { once: !0 }), n !== "error" && eM(i, y, { once: !0 });
  });
}
function eM(i, n, s) {
  typeof i.on == "function" && BC(i, "error", n, s);
}
function BC(i, n, s, u) {
  if (typeof i.on == "function")
    u.once ? i.once(n, s) : i.on(n, s);
  else if (typeof i.addEventListener == "function")
    i.addEventListener(n, function y(w) {
      u.once && i.removeEventListener(n, y), s(w);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof i);
}
var tM = op.exports;
const nM = /* @__PURE__ */ SC(tM), Hd = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function Ud(i, n, s, u) {
  i.addEventListener ? i.addEventListener(n, s, u) : i.attachEvent && i.attachEvent("on".concat(n), s);
}
function Ba(i, n, s, u) {
  i.removeEventListener ? i.removeEventListener(n, s, u) : i.detachEvent && i.detachEvent("on".concat(n), s);
}
function PC(i, n) {
  const s = n.slice(0, n.length - 1);
  for (let u = 0; u < s.length; u++)
    s[u] = i[s[u].toLowerCase()];
  return s;
}
function VC(i) {
  typeof i != "string" && (i = ""), i = i.replace(/\s/g, "");
  const n = i.split(",");
  let s = n.lastIndexOf("");
  for (; s >= 0; )
    n[s - 1] += ",", n.splice(s, 1), s = n.lastIndexOf("");
  return n;
}
function iM(i, n) {
  const s = i.length >= n.length ? i : n, u = i.length >= n.length ? n : i;
  let y = !0;
  for (let w = 0; w < s.length; w++)
    u.indexOf(s[w]) === -1 && (y = !1);
  return y;
}
const tl = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": Hd ? 173 : 189,
  "=": Hd ? 61 : 187,
  ";": Hd ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Ki = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, Sf = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Nn = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, Jt = {};
for (let i = 1; i < 20; i++)
  tl["f".concat(i)] = 111 + i;
let Yt = [], Ua = null, $C = "all";
const hr = /* @__PURE__ */ new Map(), Dl = (i) => tl[i.toLowerCase()] || Ki[i.toLowerCase()] || i.toUpperCase().charCodeAt(0), rM = (i) => Object.keys(tl).find((n) => tl[n] === i), sM = (i) => Object.keys(Ki).find((n) => Ki[n] === i);
function IC(i) {
  $C = i || "all";
}
function nl() {
  return $C || "all";
}
function oM() {
  return Yt.slice(0);
}
function aM() {
  return Yt.map((i) => rM(i) || sM(i) || String.fromCharCode(i));
}
function lM() {
  const i = [];
  return Object.keys(Jt).forEach((n) => {
    Jt[n].forEach((s) => {
      let {
        key: u,
        scope: y,
        mods: w,
        shortcut: S
      } = s;
      i.push({
        scope: y,
        shortcut: S,
        mods: w,
        keys: u.split("+").map((d) => Dl(d))
      });
    });
  }), i;
}
function cM(i) {
  const n = i.target || i.srcElement, {
    tagName: s
  } = n;
  let u = !0;
  const y = s === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(n.type);
  return (n.isContentEditable || (y || s === "TEXTAREA" || s === "SELECT") && !n.readOnly) && (u = !1), u;
}
function uM(i) {
  return typeof i == "string" && (i = Dl(i)), Yt.indexOf(i) !== -1;
}
function hM(i, n) {
  let s, u;
  i || (i = nl());
  for (const y in Jt)
    if (Object.prototype.hasOwnProperty.call(Jt, y))
      for (s = Jt[y], u = 0; u < s.length; )
        s[u].scope === i ? s.splice(u, 1).forEach((S) => {
          let {
            element: d
          } = S;
          return ap(d);
        }) : u++;
  nl() === i && IC(n || "all");
}
function dM(i) {
  let n = i.keyCode || i.which || i.charCode;
  const s = Yt.indexOf(n);
  if (s >= 0 && Yt.splice(s, 1), i.key && i.key.toLowerCase() === "meta" && Yt.splice(0, Yt.length), (n === 93 || n === 224) && (n = 91), n in Nn) {
    Nn[n] = !1;
    for (const u in Ki)
      Ki[u] === n && (pr[u] = !1);
  }
}
function MC(i) {
  if (typeof i > "u")
    Object.keys(Jt).forEach((y) => {
      Array.isArray(Jt[y]) && Jt[y].forEach((w) => Lc(w)), delete Jt[y];
    }), ap(null);
  else if (Array.isArray(i))
    i.forEach((y) => {
      y.key && Lc(y);
    });
  else if (typeof i == "object")
    i.key && Lc(i);
  else if (typeof i == "string") {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), u = 1; u < n; u++)
      s[u - 1] = arguments[u];
    let [y, w] = s;
    typeof y == "function" && (w = y, y = ""), Lc({
      key: i,
      scope: y,
      method: w,
      splitKey: "+"
    });
  }
}
const Lc = (i) => {
  let {
    key: n,
    scope: s,
    method: u,
    splitKey: y = "+"
  } = i;
  VC(n).forEach((S) => {
    const d = S.split(y), l = d.length, p = d[l - 1], v = p === "*" ? "*" : Dl(p);
    if (!Jt[v])
      return;
    s || (s = nl());
    const c = l > 1 ? PC(Ki, d) : [], e = [];
    Jt[v] = Jt[v].filter((h) => {
      const b = (u ? h.method === u : !0) && h.scope === s && iM(h.mods, c);
      return b && e.push(h.element), !b;
    }), e.forEach((h) => ap(h));
  });
};
function Ey(i, n, s, u) {
  if (n.element !== u)
    return;
  let y;
  if (n.scope === s || n.scope === "all") {
    y = n.mods.length > 0;
    for (const w in Nn)
      Object.prototype.hasOwnProperty.call(Nn, w) && (!Nn[w] && n.mods.indexOf(+w) > -1 || Nn[w] && n.mods.indexOf(+w) === -1) && (y = !1);
    (n.mods.length === 0 && !Nn[16] && !Nn[18] && !Nn[17] && !Nn[91] || y || n.shortcut === "*") && (n.keys = [], n.keys = n.keys.concat(Yt), n.method(i, n) === !1 && (i.preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation && i.stopPropagation(), i.cancelBubble && (i.cancelBubble = !0)));
  }
}
function xy(i, n) {
  const s = Jt["*"];
  let u = i.keyCode || i.which || i.charCode;
  if (!pr.filter.call(this, i))
    return;
  if ((u === 93 || u === 224) && (u = 91), Yt.indexOf(u) === -1 && u !== 229 && Yt.push(u), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((d) => {
    const l = Sf[d];
    i[d] && Yt.indexOf(l) === -1 ? Yt.push(l) : !i[d] && Yt.indexOf(l) > -1 ? Yt.splice(Yt.indexOf(l), 1) : d === "metaKey" && i[d] && Yt.length === 3 && (i.ctrlKey || i.shiftKey || i.altKey || (Yt = Yt.slice(Yt.indexOf(l))));
  }), u in Nn) {
    Nn[u] = !0;
    for (const d in Ki)
      Ki[d] === u && (pr[d] = !0);
    if (!s)
      return;
  }
  for (const d in Nn)
    Object.prototype.hasOwnProperty.call(Nn, d) && (Nn[d] = i[Sf[d]]);
  i.getModifierState && !(i.altKey && !i.ctrlKey) && i.getModifierState("AltGraph") && (Yt.indexOf(17) === -1 && Yt.push(17), Yt.indexOf(18) === -1 && Yt.push(18), Nn[17] = !0, Nn[18] = !0);
  const y = nl();
  if (s)
    for (let d = 0; d < s.length; d++)
      s[d].scope === y && (i.type === "keydown" && s[d].keydown || i.type === "keyup" && s[d].keyup) && Ey(i, s[d], y, n);
  if (!(u in Jt))
    return;
  const w = Jt[u], S = w.length;
  for (let d = 0; d < S; d++)
    if ((i.type === "keydown" && w[d].keydown || i.type === "keyup" && w[d].keyup) && w[d].key) {
      const l = w[d], {
        splitKey: p
      } = l, v = l.key.split(p), c = [];
      for (let e = 0; e < v.length; e++)
        c.push(Dl(v[e]));
      c.sort().join("") === Yt.sort().join("") && Ey(i, l, y, n);
    }
}
function pr(i, n, s) {
  Yt = [];
  const u = VC(i);
  let y = [], w = "all", S = document, d = 0, l = !1, p = !0, v = "+", c = !1, e = !1;
  for (s === void 0 && typeof n == "function" && (s = n), Object.prototype.toString.call(n) === "[object Object]" && (n.scope && (w = n.scope), n.element && (S = n.element), n.keyup && (l = n.keyup), n.keydown !== void 0 && (p = n.keydown), n.capture !== void 0 && (c = n.capture), typeof n.splitKey == "string" && (v = n.splitKey), n.single === !0 && (e = !0)), typeof n == "string" && (w = n), e && MC(i, w); d < u.length; d++)
    i = u[d].split(v), y = [], i.length > 1 && (y = PC(Ki, i)), i = i[i.length - 1], i = i === "*" ? "*" : Dl(i), i in Jt || (Jt[i] = []), Jt[i].push({
      keyup: l,
      keydown: p,
      scope: w,
      mods: y,
      shortcut: u[d],
      method: s,
      key: u[d],
      splitKey: v,
      element: S
    });
  if (typeof S < "u" && window) {
    if (!hr.has(S)) {
      const h = function() {
        let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return xy(b, S);
      }, m = function() {
        let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        xy(b, S), dM(b);
      };
      hr.set(S, {
        keydownListener: h,
        keyupListenr: m,
        capture: c
      }), Ud(S, "keydown", h, c), Ud(S, "keyup", m, c);
    }
    if (!Ua) {
      const h = () => {
        Yt = [];
      };
      Ua = {
        listener: h,
        capture: c
      }, Ud(window, "focus", h, c);
    }
  }
}
function fM(i) {
  let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(Jt).forEach((s) => {
    Jt[s].filter((y) => y.scope === n && y.shortcut === i).forEach((y) => {
      y && y.method && y.method();
    });
  });
}
function ap(i) {
  const n = Object.values(Jt).flat();
  if (n.findIndex((u) => {
    let {
      element: y
    } = u;
    return y === i;
  }) < 0) {
    const {
      keydownListener: u,
      keyupListenr: y,
      capture: w
    } = hr.get(i) || {};
    u && y && (Ba(i, "keyup", y, w), Ba(i, "keydown", u, w), hr.delete(i));
  }
  if ((n.length <= 0 || hr.size <= 0) && (Object.keys(hr).forEach((y) => {
    const {
      keydownListener: w,
      keyupListenr: S,
      capture: d
    } = hr.get(y) || {};
    w && S && (Ba(y, "keyup", S, d), Ba(y, "keydown", w, d), hr.delete(y));
  }), hr.clear(), Object.keys(Jt).forEach((y) => delete Jt[y]), Ua)) {
    const {
      listener: y,
      capture: w
    } = Ua;
    Ba(window, "focus", y, w), Ua = null;
  }
}
const Wd = {
  getPressedKeyString: aM,
  setScope: IC,
  getScope: nl,
  deleteScope: hM,
  getPressedKeyCodes: oM,
  getAllKeyCodes: lM,
  isPressed: uM,
  filter: cM,
  trigger: fM,
  unbind: MC,
  keyMap: tl,
  modifier: Ki,
  modifierMap: Sf
};
for (const i in Wd)
  Object.prototype.hasOwnProperty.call(Wd, i) && (pr[i] = Wd[i]);
if (typeof window < "u") {
  const i = window.hotkeys;
  pr.noConflict = (n) => (n && window.hotkeys === pr && (window.hotkeys = i), pr), window.hotkeys = pr;
}
class fu {
  constructor(n, s) {
    this.container = n, this.dom = null, this.shown = !1, this.root = !0, this.parent = null, this.submenus = [], this.items = s, this._onclick = (u) => {
      this.dom && u.target != this.dom && u.target.parentElement != this.dom && !u.target.classList.contains("item") && !u.target.parentElement.classList.contains("item") && this.hideAll();
    }, this._oncontextmenu = (u) => {
      u.preventDefault(), u.target != this.dom && u.target.parentElement != this.dom && !u.target.classList.contains("item") && !u.target.parentElement.classList.contains("item") && (this.hideAll(), this.show(u.clientX, u.clientY));
    }, this._oncontextmenu_keydown = (u) => {
      u.keyCode == 93 && (u.preventDefault(), this.hideAll(), this.show(u.clientX, u.clientY));
    }, this._onblur = () => {
      this.hideAll();
    };
  }
  getMenuDom() {
    const n = document.createElement("div");
    n.classList.add("context");
    for (const s of this.items)
      n.appendChild(this.itemToDomEl(s));
    return n;
  }
  itemToDomEl(n) {
    const s = document.createElement("div");
    if (n === null)
      return s.classList = "separator", s;
    n.hasOwnProperty("color") && /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n.color.toString()) && (s.style.cssText = `color: ${n.color}`), s.classList.add("item");
    const u = document.createElement("span");
    u.classList = "label", u.innerText = n.hasOwnProperty("text") ? n.text.toString() : "", s.appendChild(u), n.hasOwnProperty("disabled") && n.disabled ? s.classList.add("disabled") : s.classList.add("enabled");
    const y = document.createElement("span");
    if (y.classList = "hotkey", y.innerText = n.hasOwnProperty("hotkey") ? n.hotkey.toString() : "", s.appendChild(y), n.hasOwnProperty("subitems") && Array.isArray(n.subitems) && n.subitems.length > 0) {
      const w = new fu(this.container, n.subitems);
      w.root = !1, w.parent = this;
      const S = () => {
        if (n.hasOwnProperty("disabled") && n.disabled == !0)
          return;
        this.hideSubMenus();
        const d = this.dom.offsetLeft + this.dom.clientWidth + s.offsetLeft, l = this.dom.offsetTop + s.offsetTop;
        w.shown ? w.hide() : w.show(d, l);
      };
      this.submenus.push(w), s.classList.add("has-subitems"), s.addEventListener("click", S), s.addEventListener("mousemove", S);
    } else if (n.hasOwnProperty("submenu") && n.submenu instanceof fu) {
      const w = n.submenu;
      w.root = !1, w.parent = this;
      const S = () => {
        if (n.hasOwnProperty("disabled") && n.disabled == !0)
          return;
        this.hideSubMenus();
        const d = this.dom.offsetLeft + this.dom.clientWidth + s.offsetLeft, l = this.dom.offsetTop + s.offsetTop;
        w.shown ? w.hide() : w.show(d, l);
      };
      this.submenus.push(w), s.classList.add("has-subitems"), s.addEventListener("click", S), s.addEventListener("mousemove", S);
    } else
      s.addEventListener("click", () => {
        if (this.hideSubMenus(), !s.classList.contains("disabled"))
          if (n.hasOwnProperty("onclick") && typeof n.onclick == "function") {
            const w = {
              handled: !1,
              item: s,
              label: u,
              hotkey: y,
              items: this.items,
              data: n
            };
            n.onclick(w), w.handled || this.hide();
          } else
            this.hide();
      }), s.addEventListener("mousemove", () => {
        this.hideSubMenus();
      });
    return s;
  }
  hideAll() {
    if (this.root && !this.parent) {
      this.shown && (this.hideSubMenus(), this.shown = !1, this.container.removeChild(this.dom), this.parent && this.parent.shown && this.parent.hide());
      return;
    }
    this.parent.hide();
  }
  hide() {
    this.dom && this.shown && (this.shown = !1, this.hideSubMenus(), this.container.removeChild(this.dom), this.parent && this.parent.shown && this.parent.hide());
  }
  hideSubMenus() {
    for (const n of this.submenus)
      n.shown && (n.shown = !1, n.container.removeChild(n.dom)), n.hideSubMenus();
  }
  show(n, s) {
    this.dom = this.getMenuDom(), this.dom.style.left = `${n}px`, this.dom.style.top = `${s}px`, this.shown = !0, this.container.appendChild(this.dom);
  }
  install() {
    this.container.addEventListener("contextmenu", this._oncontextmenu), this.container.addEventListener("keydown", this._oncontextmenu_keydown), this.container.addEventListener("click", this._onclick), window.addEventListener("blur", this._onblur);
  }
  setData(n) {
    this.items = n;
  }
  uninstall() {
    this.dom = null, this.container.removeEventListener("keydown", this._oncontextmenu_keydown), this.container.removeEventListener("click", this._onclick), window.removeEventListener("blur", this._onblur);
  }
}
var zc, pM = new Uint8Array(16);
function mM() {
  if (!zc && (zc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !zc))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return zc(pM);
}
const gM = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function vM(i) {
  return typeof i == "string" && gM.test(i);
}
var On = [];
for (var Yd = 0; Yd < 256; ++Yd)
  On.push((Yd + 256).toString(16).substr(1));
function yM(i) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = (On[i[n + 0]] + On[i[n + 1]] + On[i[n + 2]] + On[i[n + 3]] + "-" + On[i[n + 4]] + On[i[n + 5]] + "-" + On[i[n + 6]] + On[i[n + 7]] + "-" + On[i[n + 8]] + On[i[n + 9]] + "-" + On[i[n + 10]] + On[i[n + 11]] + On[i[n + 12]] + On[i[n + 13]] + On[i[n + 14]] + On[i[n + 15]]).toLowerCase();
  if (!vM(s))
    throw TypeError("Stringified UUID is invalid");
  return s;
}
function si(i, n, s) {
  i = i || {};
  var u = i.random || (i.rng || mM)();
  if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, n) {
    s = s || 0;
    for (var y = 0; y < 16; ++y)
      n[s + y] = u[y];
    return n;
  }
  return yM(u);
}
var Rc = { exports: {} }, Kd = {};
function fn(i, n) {
  const s = /* @__PURE__ */ Object.create(null), u = i.split(",");
  for (let y = 0; y < u.length; y++)
    s[u[y]] = !0;
  return n ? (y) => !!s[y.toLowerCase()] : (y) => !!s[y];
}
const Ft = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, Bs = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], en = () => {
}, _o = () => !1, bM = /^on[^a-z]/, Gi = (i) => bM.test(i), il = (i) => i.startsWith("onUpdate:"), _t = Object.assign, Iu = (i, n) => {
  const s = i.indexOf(n);
  s > -1 && i.splice(s, 1);
}, CM = Object.prototype.hasOwnProperty, Dt = (i, n) => CM.call(i, n), Je = Array.isArray, Qr = (i) => Ks(i) === "[object Map]", fs = (i) => Ks(i) === "[object Set]", Ef = (i) => Ks(i) === "[object Date]", AC = (i) => Ks(i) === "[object RegExp]", ft = (i) => typeof i == "function", wt = (i) => typeof i == "string", gr = (i) => typeof i == "symbol", Nt = (i) => i !== null && typeof i == "object", Nl = (i) => Nt(i) && ft(i.then) && ft(i.catch), lp = Object.prototype.toString, Ks = (i) => lp.call(i), Mu = (i) => Ks(i).slice(8, -1), cp = (i) => Ks(i) === "[object Object]", Au = (i) => wt(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i, Zr = /* @__PURE__ */ fn(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), up = /* @__PURE__ */ fn(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Fu = (i) => {
  const n = /* @__PURE__ */ Object.create(null);
  return (s) => n[s] || (n[s] = i(s));
}, wM = /-(\w)/g, an = Fu((i) => i.replace(wM, (n, s) => s ? s.toUpperCase() : "")), kM = /\B([A-Z])/g, Bn = Fu(
  (i) => i.replace(kM, "-$1").toLowerCase()
), Pi = Fu(
  (i) => i.charAt(0).toUpperCase() + i.slice(1)
), Oi = Fu(
  (i) => i ? `on${Pi(i)}` : ""
), As = (i, n) => !Object.is(i, n), dr = (i, n) => {
  for (let s = 0; s < i.length; s++)
    i[s](n);
}, rl = (i, n, s) => {
  Object.defineProperty(i, n, {
    configurable: !0,
    enumerable: !1,
    value: s
  });
}, sl = (i) => {
  const n = parseFloat(i);
  return isNaN(n) ? i : n;
}, ol = (i) => {
  const n = wt(i) ? Number(i) : NaN;
  return isNaN(n) ? i : n;
};
let _y;
const Fs = () => _y || (_y = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), SM = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function EM(i) {
  return SM.test(i) ? `__props.${i}` : `__props[${JSON.stringify(i)}]`;
}
const Bi = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "HYDRATE_EVENTS",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, FC = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
}, xM = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", LC = /* @__PURE__ */ fn(xM), Ty = 2;
function zC(i, n = 0, s = i.length) {
  let u = i.split(/(\r?\n)/);
  const y = u.filter((d, l) => l % 2 === 1);
  u = u.filter((d, l) => l % 2 === 0);
  let w = 0;
  const S = [];
  for (let d = 0; d < u.length; d++)
    if (w += u[d].length + (y[d] && y[d].length || 0), w >= n) {
      for (let l = d - Ty; l <= d + Ty || s > w; l++) {
        if (l < 0 || l >= u.length)
          continue;
        const p = l + 1;
        S.push(
          `${p}${" ".repeat(Math.max(3 - String(p).length, 0))}|  ${u[l]}`
        );
        const v = u[l].length, c = y[l] && y[l].length || 0;
        if (l === d) {
          const e = n - (w - (v + c)), h = Math.max(
            1,
            s > w ? v - e : s - n
          );
          S.push("   |  " + " ".repeat(e) + "^".repeat(h));
        } else if (l > d) {
          if (s > w) {
            const e = Math.max(Math.min(s - w, v), 1);
            S.push("   |  " + "^".repeat(e));
          }
          w += v + c;
        }
      }
      break;
    }
  return S.join(`
`);
}
function zo(i) {
  if (Je(i)) {
    const n = {};
    for (let s = 0; s < i.length; s++) {
      const u = i[s], y = wt(u) ? hp(u) : zo(u);
      if (y)
        for (const w in y)
          n[w] = y[w];
    }
    return n;
  } else {
    if (wt(i))
      return i;
    if (Nt(i))
      return i;
  }
}
const _M = /;(?![^(]*\))/g, TM = /:([^]+)/, OM = /\/\*[^]*?\*\//g;
function hp(i) {
  const n = {};
  return i.replace(OM, "").split(_M).forEach((s) => {
    if (s) {
      const u = s.split(TM);
      u.length > 1 && (n[u[0].trim()] = u[1].trim());
    }
  }), n;
}
function DM(i) {
  let n = "";
  if (!i || wt(i))
    return n;
  for (const s in i) {
    const u = i[s], y = s.startsWith("--") ? s : Bn(s);
    (wt(u) || typeof u == "number") && (n += `${y}:${u};`);
  }
  return n;
}
function Ro(i) {
  let n = "";
  if (wt(i))
    n = i;
  else if (Je(i))
    for (let s = 0; s < i.length; s++) {
      const u = Ro(i[s]);
      u && (n += u + " ");
    }
  else if (Nt(i))
    for (const s in i)
      i[s] && (n += s + " ");
  return n.trim();
}
function RC(i) {
  if (!i)
    return null;
  let { class: n, style: s } = i;
  return n && !wt(n) && (i.class = Ro(n)), s && (i.style = zo(s)), i;
}
const NM = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", BM = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", PM = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", dp = /* @__PURE__ */ fn(NM), fp = /* @__PURE__ */ fn(BM), jC = /* @__PURE__ */ fn(PM), HC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", UC = /* @__PURE__ */ fn(HC), VM = /* @__PURE__ */ fn(
  HC + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
);
function pp(i) {
  return !!i || i === "";
}
const $M = /[>/="'\u0009\u000a\u000c\u0020]/, Gd = {};
function IM(i) {
  if (Gd.hasOwnProperty(i))
    return Gd[i];
  const n = $M.test(i);
  return n && console.error(`unsafe attribute name: ${i}`), Gd[i] = !n;
}
const MM = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
}, AM = /* @__PURE__ */ fn(
  "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
), FM = /* @__PURE__ */ fn(
  "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
), LM = /["'&<>]/;
function zM(i) {
  const n = "" + i, s = LM.exec(n);
  if (!s)
    return n;
  let u = "", y, w, S = 0;
  for (w = s.index; w < n.length; w++) {
    switch (n.charCodeAt(w)) {
      case 34:
        y = "&quot;";
        break;
      case 38:
        y = "&amp;";
        break;
      case 39:
        y = "&#39;";
        break;
      case 60:
        y = "&lt;";
        break;
      case 62:
        y = "&gt;";
        break;
      default:
        continue;
    }
    S !== w && (u += n.slice(S, w)), S = w + 1, u += y;
  }
  return S !== w ? u + n.slice(S, w) : u;
}
const RM = /^-?>|<!--|-->|--!>|<!-$/g;
function jM(i) {
  return i.replace(RM, "");
}
function HM(i, n) {
  if (i.length !== n.length)
    return !1;
  let s = !0;
  for (let u = 0; s && u < i.length; u++)
    s = vr(i[u], n[u]);
  return s;
}
function vr(i, n) {
  if (i === n)
    return !0;
  let s = Ef(i), u = Ef(n);
  if (s || u)
    return s && u ? i.getTime() === n.getTime() : !1;
  if (s = gr(i), u = gr(n), s || u)
    return i === n;
  if (s = Je(i), u = Je(n), s || u)
    return s && u ? HM(i, n) : !1;
  if (s = Nt(i), u = Nt(n), s || u) {
    if (!s || !u)
      return !1;
    const y = Object.keys(i).length, w = Object.keys(n).length;
    if (y !== w)
      return !1;
    for (const S in i) {
      const d = i.hasOwnProperty(S), l = n.hasOwnProperty(S);
      if (d && !l || !d && l || !vr(i[S], n[S]))
        return !1;
    }
  }
  return String(i) === String(n);
}
function Bl(i, n) {
  return i.findIndex((s) => vr(s, n));
}
const WC = (i) => wt(i) ? i : i == null ? "" : Je(i) || Nt(i) && (i.toString === lp || !ft(i.toString)) ? JSON.stringify(i, YC, 2) : String(i), YC = (i, n) => n && n.__v_isRef ? YC(i, n.value) : Qr(n) ? {
  [`Map(${n.size})`]: [...n.entries()].reduce((s, [u, y]) => (s[`${u} =>`] = y, s), {})
} : fs(n) ? {
  [`Set(${n.size})`]: [...n.values()]
} : Nt(n) && !Je(n) && !cp(n) ? String(n) : n, UM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EMPTY_ARR: Bs,
  EMPTY_OBJ: Ft,
  NO: _o,
  NOOP: en,
  PatchFlagNames: Bi,
  camelize: an,
  capitalize: Pi,
  def: rl,
  escapeHtml: zM,
  escapeHtmlComment: jM,
  extend: _t,
  genPropsAccessExp: EM,
  generateCodeFrame: zC,
  getGlobalThis: Fs,
  hasChanged: As,
  hasOwn: Dt,
  hyphenate: Bn,
  includeBooleanAttr: pp,
  invokeArrayFns: dr,
  isArray: Je,
  isBooleanAttr: VM,
  isBuiltInDirective: up,
  isDate: Ef,
  isFunction: ft,
  isGloballyWhitelisted: LC,
  isHTMLTag: dp,
  isIntegerKey: Au,
  isKnownHtmlAttr: AM,
  isKnownSvgAttr: FM,
  isMap: Qr,
  isModelListener: il,
  isObject: Nt,
  isOn: Gi,
  isPlainObject: cp,
  isPromise: Nl,
  isRegExp: AC,
  isReservedProp: Zr,
  isSSRSafeAttrName: IM,
  isSVGTag: fp,
  isSet: fs,
  isSpecialBooleanAttr: UC,
  isString: wt,
  isSymbol: gr,
  isVoidTag: jC,
  looseEqual: vr,
  looseIndexOf: Bl,
  looseToNumber: sl,
  makeMap: fn,
  normalizeClass: Ro,
  normalizeProps: RC,
  normalizeStyle: zo,
  objectToString: lp,
  parseStringStyle: hp,
  propsToAttrMap: MM,
  remove: Iu,
  slotFlagsText: FC,
  stringifyStyle: DM,
  toDisplayString: WC,
  toHandlerKey: Oi,
  toNumber: ol,
  toRawType: Mu,
  toTypeString: Ks
}, Symbol.toStringTag, { value: "Module" }));
function mp(i) {
  throw i;
}
function KC(i) {
  process.env.NODE_ENV !== "production" && console.warn(`[Vue warn] ${i.message}`);
}
function zt(i, n, s, u) {
  const y = process.env.NODE_ENV !== "production" ? (s || WM)[i] + (u || "") : i, w = new SyntaxError(String(y));
  return w.code = i, w.loc = n, w;
}
const WM = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // deprecations
  51: "@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.",
  52: 'v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.',
  // just to fulfill types
  53: ""
}, Bo = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : ""), To = Symbol(process.env.NODE_ENV !== "production" ? "Teleport" : ""), Lu = Symbol(process.env.NODE_ENV !== "production" ? "Suspense" : ""), al = Symbol(process.env.NODE_ENV !== "production" ? "KeepAlive" : ""), gp = Symbol(process.env.NODE_ENV !== "production" ? "BaseTransition" : ""), as = Symbol(process.env.NODE_ENV !== "production" ? "openBlock" : ""), vp = Symbol(process.env.NODE_ENV !== "production" ? "createBlock" : ""), yp = Symbol(process.env.NODE_ENV !== "production" ? "createElementBlock" : ""), zu = Symbol(process.env.NODE_ENV !== "production" ? "createVNode" : ""), Ru = Symbol(process.env.NODE_ENV !== "production" ? "createElementVNode" : ""), jo = Symbol(process.env.NODE_ENV !== "production" ? "createCommentVNode" : ""), ju = Symbol(process.env.NODE_ENV !== "production" ? "createTextVNode" : ""), bp = Symbol(process.env.NODE_ENV !== "production" ? "createStaticVNode" : ""), Hu = Symbol(process.env.NODE_ENV !== "production" ? "resolveComponent" : ""), ll = Symbol(
  process.env.NODE_ENV !== "production" ? "resolveDynamicComponent" : ""
), Uu = Symbol(process.env.NODE_ENV !== "production" ? "resolveDirective" : ""), Wu = Symbol(process.env.NODE_ENV !== "production" ? "resolveFilter" : ""), Yu = Symbol(process.env.NODE_ENV !== "production" ? "withDirectives" : ""), Ku = Symbol(process.env.NODE_ENV !== "production" ? "renderList" : ""), Cp = Symbol(process.env.NODE_ENV !== "production" ? "renderSlot" : ""), wp = Symbol(process.env.NODE_ENV !== "production" ? "createSlots" : ""), Pl = Symbol(process.env.NODE_ENV !== "production" ? "toDisplayString" : ""), cl = Symbol(process.env.NODE_ENV !== "production" ? "mergeProps" : ""), Gu = Symbol(process.env.NODE_ENV !== "production" ? "normalizeClass" : ""), Xu = Symbol(process.env.NODE_ENV !== "production" ? "normalizeStyle" : ""), Po = Symbol(process.env.NODE_ENV !== "production" ? "normalizeProps" : ""), Ho = Symbol(process.env.NODE_ENV !== "production" ? "guardReactiveProps" : ""), qu = Symbol(process.env.NODE_ENV !== "production" ? "toHandlers" : ""), pu = Symbol(process.env.NODE_ENV !== "production" ? "camelize" : ""), GC = Symbol(process.env.NODE_ENV !== "production" ? "capitalize" : ""), mu = Symbol(process.env.NODE_ENV !== "production" ? "toHandlerKey" : ""), ul = Symbol(process.env.NODE_ENV !== "production" ? "setBlockTracking" : ""), XC = Symbol(process.env.NODE_ENV !== "production" ? "pushScopeId" : ""), qC = Symbol(process.env.NODE_ENV !== "production" ? "popScopeId" : ""), Ju = Symbol(process.env.NODE_ENV !== "production" ? "withCtx" : ""), JC = Symbol(process.env.NODE_ENV !== "production" ? "unref" : ""), QC = Symbol(process.env.NODE_ENV !== "production" ? "isRef" : ""), Qu = Symbol(process.env.NODE_ENV !== "production" ? "withMemo" : ""), kp = Symbol(process.env.NODE_ENV !== "production" ? "isMemoSame" : ""), Ls = {
  [Bo]: "Fragment",
  [To]: "Teleport",
  [Lu]: "Suspense",
  [al]: "KeepAlive",
  [gp]: "BaseTransition",
  [as]: "openBlock",
  [vp]: "createBlock",
  [yp]: "createElementBlock",
  [zu]: "createVNode",
  [Ru]: "createElementVNode",
  [jo]: "createCommentVNode",
  [ju]: "createTextVNode",
  [bp]: "createStaticVNode",
  [Hu]: "resolveComponent",
  [ll]: "resolveDynamicComponent",
  [Uu]: "resolveDirective",
  [Wu]: "resolveFilter",
  [Yu]: "withDirectives",
  [Ku]: "renderList",
  [Cp]: "renderSlot",
  [wp]: "createSlots",
  [Pl]: "toDisplayString",
  [cl]: "mergeProps",
  [Gu]: "normalizeClass",
  [Xu]: "normalizeStyle",
  [Po]: "normalizeProps",
  [Ho]: "guardReactiveProps",
  [qu]: "toHandlers",
  [pu]: "camelize",
  [GC]: "capitalize",
  [mu]: "toHandlerKey",
  [ul]: "setBlockTracking",
  [XC]: "pushScopeId",
  [qC]: "popScopeId",
  [Ju]: "withCtx",
  [JC]: "unref",
  [QC]: "isRef",
  [Qu]: "withMemo",
  [kp]: "isMemoSame"
};
function ZC(i) {
  Object.getOwnPropertySymbols(i).forEach((n) => {
    Ls[n] = i[n];
  });
}
const kn = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function e1(i, n = kn) {
  return {
    type: 0,
    children: i,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: n
  };
}
function Vo(i, n, s, u, y, w, S, d = !1, l = !1, p = !1, v = kn) {
  return i && (d ? (i.helper(as), i.helper(js(i.inSSR, p))) : i.helper(Rs(i.inSSR, p)), S && i.helper(Yu)), {
    type: 13,
    tag: n,
    props: s,
    children: u,
    patchFlag: y,
    dynamicProps: w,
    directives: S,
    isBlock: d,
    disableTracking: l,
    isComponent: p,
    loc: v
  };
}
function Uo(i, n = kn) {
  return {
    type: 17,
    loc: n,
    elements: i
  };
}
function oi(i, n = kn) {
  return {
    type: 15,
    loc: n,
    properties: i
  };
}
function Qt(i, n) {
  return {
    type: 16,
    loc: kn,
    key: wt(i) ? Ot(i, !0) : i,
    value: n
  };
}
function Ot(i, n = !1, s = kn, u = 0) {
  return {
    type: 4,
    loc: s,
    content: i,
    isStatic: n,
    constType: n ? 3 : u
  };
}
function YM(i, n) {
  return {
    type: 5,
    loc: n,
    content: wt(i) ? Ot(i, !1, n) : i
  };
}
function bi(i, n = kn) {
  return {
    type: 8,
    loc: n,
    children: i
  };
}
function rn(i, n = [], s = kn) {
  return {
    type: 14,
    loc: s,
    callee: i,
    arguments: n
  };
}
function zs(i, n = void 0, s = !1, u = !1, y = kn) {
  return {
    type: 18,
    params: i,
    returns: n,
    newline: s,
    isSlot: u,
    loc: y
  };
}
function gu(i, n, s, u = !0) {
  return {
    type: 19,
    test: i,
    consequent: n,
    alternate: s,
    newline: u,
    loc: kn
  };
}
function t1(i, n, s = !1) {
  return {
    type: 20,
    index: i,
    value: n,
    isVNode: s,
    loc: kn
  };
}
function n1(i) {
  return {
    type: 21,
    body: i,
    loc: kn
  };
}
function KM(i) {
  return {
    type: 22,
    elements: i,
    loc: kn
  };
}
function GM(i, n, s) {
  return {
    type: 23,
    test: i,
    consequent: n,
    alternate: s,
    loc: kn
  };
}
function XM(i, n) {
  return {
    type: 24,
    left: i,
    right: n,
    loc: kn
  };
}
function qM(i) {
  return {
    type: 25,
    expressions: i,
    loc: kn
  };
}
function JM(i) {
  return {
    type: 26,
    returns: i,
    loc: kn
  };
}
function Rs(i, n) {
  return i || n ? zu : Ru;
}
function js(i, n) {
  return i || n ? vp : yp;
}
function Zu(i, { helper: n, removeHelper: s, inSSR: u }) {
  i.isBlock || (i.isBlock = !0, s(Rs(u, i.isComponent)), n(as), n(js(u, i.isComponent)));
}
const Yn = (i) => i.type === 4 && i.isStatic, qr = (i, n) => i === n || i === Bn(n);
function Sp(i) {
  if (qr(i, "Teleport"))
    return To;
  if (qr(i, "Suspense"))
    return Lu;
  if (qr(i, "KeepAlive"))
    return al;
  if (qr(i, "BaseTransition"))
    return gp;
}
const QM = /^\d|[^\$\w]/, Vl = (i) => !QM.test(i), ZM = /[A-Za-z_$\xA0-\uFFFF]/, eA = /[\.\?\w$\xA0-\uFFFF]/, tA = /\s+[.[]\s*|\s*[.[]\s+/g, i1 = (i) => {
  i = i.trim().replace(tA, (S) => S.trim());
  let n = 0, s = [], u = 0, y = 0, w = null;
  for (let S = 0; S < i.length; S++) {
    const d = i.charAt(S);
    switch (n) {
      case 0:
        if (d === "[")
          s.push(n), n = 1, u++;
        else if (d === "(")
          s.push(n), n = 2, y++;
        else if (!(S === 0 ? ZM : eA).test(d))
          return !1;
        break;
      case 1:
        d === "'" || d === '"' || d === "`" ? (s.push(n), n = 3, w = d) : d === "[" ? u++ : d === "]" && (--u || (n = s.pop()));
        break;
      case 2:
        if (d === "'" || d === '"' || d === "`")
          s.push(n), n = 3, w = d;
        else if (d === "(")
          y++;
        else if (d === ")") {
          if (S === i.length - 1)
            return !1;
          --y || (n = s.pop());
        }
        break;
      case 3:
        d === w && (n = s.pop(), w = null);
        break;
    }
  }
  return !u && !y;
}, nA = en, Ep = i1;
function xp(i, n, s) {
  const y = {
    source: i.source.slice(n, n + s),
    start: hl(i.start, i.source, n),
    end: i.end
  };
  return s != null && (y.end = hl(
    i.start,
    i.source,
    n + s
  )), y;
}
function hl(i, n, s = n.length) {
  return dl(
    _t({}, i),
    n,
    s
  );
}
function dl(i, n, s = n.length) {
  let u = 0, y = -1;
  for (let w = 0; w < s; w++)
    n.charCodeAt(w) === 10 && (u++, y = w);
  return i.offset += s, i.line += u, i.column = y === -1 ? i.column + s : s - y, i;
}
function xf(i, n) {
  if (!i)
    throw new Error(n || "unexpected compiler condition");
}
function Xn(i, n, s = !1) {
  for (let u = 0; u < i.props.length; u++) {
    const y = i.props[u];
    if (y.type === 7 && (s || y.exp) && (wt(n) ? y.name === n : n.test(y.name)))
      return y;
  }
}
function Hs(i, n, s = !1, u = !1) {
  for (let y = 0; y < i.props.length; y++) {
    const w = i.props[y];
    if (w.type === 6) {
      if (s)
        continue;
      if (w.name === n && (w.value || u))
        return w;
    } else if (w.name === "bind" && (w.exp || u) && Jr(w.arg, n))
      return w;
  }
}
function Jr(i, n) {
  return !!(i && Yn(i) && i.content === n);
}
function r1(i) {
  return i.props.some(
    (n) => n.type === 7 && n.name === "bind" && (!n.arg || // v-bind="obj"
    n.arg.type !== 4 || // v-bind:[_ctx.foo]
    !n.arg.isStatic)
    // v-bind:[foo]
  );
}
function nu(i) {
  return i.type === 5 || i.type === 2;
}
function _p(i) {
  return i.type === 7 && i.name === "slot";
}
function $o(i) {
  return i.type === 1 && i.tagType === 3;
}
function fl(i) {
  return i.type === 1 && i.tagType === 2;
}
const iA = /* @__PURE__ */ new Set([Po, Ho]);
function s1(i, n = []) {
  if (i && !wt(i) && i.type === 14) {
    const s = i.callee;
    if (!wt(s) && iA.has(s))
      return s1(
        i.arguments[0],
        n.concat(i)
      );
  }
  return [i, n];
}
function pl(i, n, s) {
  let u, y = i.type === 13 ? i.props : i.arguments[2], w = [], S;
  if (y && !wt(y) && y.type === 14) {
    const d = s1(y);
    y = d[0], w = d[1], S = w[w.length - 1];
  }
  if (y == null || wt(y))
    u = oi([n]);
  else if (y.type === 14) {
    const d = y.arguments[0];
    !wt(d) && d.type === 15 ? Oy(n, d) || d.properties.unshift(n) : y.callee === qu ? u = rn(s.helper(cl), [
      oi([n]),
      y
    ]) : y.arguments.unshift(oi([n])), !u && (u = y);
  } else
    y.type === 15 ? (Oy(n, y) || y.properties.unshift(n), u = y) : (u = rn(s.helper(cl), [
      oi([n]),
      y
    ]), S && S.callee === Ho && (S = w[w.length - 2]));
  i.type === 13 ? S ? S.arguments[0] = u : i.props = u : S ? S.arguments[0] = u : i.arguments[2] = u;
}
function Oy(i, n) {
  let s = !1;
  if (i.key.type === 4) {
    const u = i.key.content;
    s = n.properties.some(
      (y) => y.key.type === 4 && y.key.content === u
    );
  }
  return s;
}
function Io(i, n) {
  return `_${n}_${i.replace(/[^\w]/g, (s, u) => s === "-" ? "_" : i.charCodeAt(u).toString())}`;
}
function Ti(i, n) {
  if (!i || Object.keys(n).length === 0)
    return !1;
  switch (i.type) {
    case 1:
      for (let s = 0; s < i.props.length; s++) {
        const u = i.props[s];
        if (u.type === 7 && (Ti(u.arg, n) || Ti(u.exp, n)))
          return !0;
      }
      return i.children.some((s) => Ti(s, n));
    case 11:
      return Ti(i.source, n) ? !0 : i.children.some((s) => Ti(s, n));
    case 9:
      return i.branches.some((s) => Ti(s, n));
    case 10:
      return Ti(i.condition, n) ? !0 : i.children.some((s) => Ti(s, n));
    case 4:
      return !i.isStatic && Vl(i.content) && !!n[i.content];
    case 8:
      return i.children.some((s) => Nt(s) && Ti(s, n));
    case 5:
    case 12:
      return Ti(i.content, n);
    case 2:
    case 3:
      return !1;
    default:
      return process.env.NODE_ENV, !1;
  }
}
function o1(i) {
  return i.type === 14 && i.callee === Qu ? i.arguments[1].returns : i;
}
const rA = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (i) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${i}.sync\` should be changed to \`v-model:${i}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_PROP: {
    message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTER: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function _f(i, n) {
  const s = n.options ? n.options.compatConfig : n.compatConfig, u = s && s[i];
  return i === "MODE" ? u || 3 : u;
}
function es(i, n) {
  const s = _f("MODE", n), u = _f(i, n);
  return s === 3 ? u === !0 : u !== !1;
}
function ls(i, n, s, ...u) {
  const y = es(i, n);
  return process.env.NODE_ENV !== "production" && y && $l(i, n, s, ...u), y;
}
function $l(i, n, s, ...u) {
  if (_f(i, n) === "suppress-warning")
    return;
  const { message: w, link: S } = rA[i], d = `(deprecation ${i}) ${typeof w == "function" ? w(...u) : w}${S ? `
  Details: ${S}` : ""}`, l = new SyntaxError(d);
  l.code = i, s && (l.loc = s), n.onWarn(l);
}
const sA = /&(gt|lt|amp|apos|quot);/g, oA = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
}, Dy = {
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: _o,
  isPreTag: _o,
  isCustomElement: _o,
  decodeEntities: (i) => i.replace(sA, (n, s) => oA[s]),
  onError: mp,
  onWarn: KC,
  comments: process.env.NODE_ENV !== "production"
};
function Tp(i, n = {}) {
  const s = aA(i, n), u = li(s);
  return e1(
    Op(s, 0, []),
    ui(s, u)
  );
}
function aA(i, n) {
  const s = _t({}, Dy);
  let u;
  for (u in n)
    s[u] = n[u] === void 0 ? Dy[u] : n[u];
  return {
    options: s,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: i,
    source: i,
    inPre: !1,
    inVPre: !1,
    onWarn: s.onWarn
  };
}
function Op(i, n, s) {
  const u = eh(s), y = u ? u.ns : 0, w = [];
  for (; !gA(i, n, s); ) {
    const d = i.source;
    let l;
    if (n === 0 || n === 1) {
      if (!i.inVPre && Fn(d, i.options.delimiters[0]))
        l = pA(i, n);
      else if (n === 0 && d[0] === "<")
        if (d.length === 1)
          jt(i, 5, 1);
        else if (d[1] === "!")
          Fn(d, "<!--") ? l = cA(i) : Fn(d, "<!DOCTYPE") ? l = Pa(i) : Fn(d, "<![CDATA[") ? y !== 0 ? l = lA(i, s) : (jt(i, 1), l = Pa(i)) : (jt(i, 11), l = Pa(i));
        else if (d[1] === "/")
          if (d.length === 2)
            jt(i, 5, 2);
          else if (d[2] === ">") {
            jt(i, 14, 2), wn(i, 3);
            continue;
          } else if (/[a-z]/i.test(d[2])) {
            jt(i, 23), Tf(i, vu.End, u);
            continue;
          } else
            jt(
              i,
              12,
              2
            ), l = Pa(i);
        else
          /[a-z]/i.test(d[1]) ? (l = uA(i, s), es(
            "COMPILER_NATIVE_TEMPLATE",
            i
          ) && l && l.tag === "template" && !l.props.some(
            (p) => p.type === 7 && a1(p.name)
          ) && (process.env.NODE_ENV !== "production" && $l(
            "COMPILER_NATIVE_TEMPLATE",
            i,
            l.loc
          ), l = l.children)) : d[1] === "?" ? (jt(
            i,
            21,
            1
          ), l = Pa(i)) : jt(i, 12, 1);
    }
    if (l || (l = mA(i, n)), Je(l))
      for (let p = 0; p < l.length; p++)
        Ny(w, l[p]);
    else
      Ny(w, l);
  }
  let S = !1;
  if (n !== 2 && n !== 1) {
    const d = i.options.whitespace !== "preserve";
    for (let l = 0; l < w.length; l++) {
      const p = w[l];
      if (p.type === 2)
        if (i.inPre)
          p.content = p.content.replace(/\r\n/g, `
`);
        else if (/[^\t\r\n\f ]/.test(p.content))
          d && (p.content = p.content.replace(/[\t\r\n\f ]+/g, " "));
        else {
          const v = w[l - 1], c = w[l + 1];
          !v || !c || d && (v.type === 3 && c.type === 3 || v.type === 3 && c.type === 1 || v.type === 1 && c.type === 3 || v.type === 1 && c.type === 1 && /[\r\n]/.test(p.content)) ? (S = !0, w[l] = null) : p.content = " ";
        }
      else
        p.type === 3 && !i.options.comments && (S = !0, w[l] = null);
    }
    if (i.inPre && u && i.options.isPreTag(u.tag)) {
      const l = w[0];
      l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
    }
  }
  return S ? w.filter(Boolean) : w;
}
function Ny(i, n) {
  if (n.type === 2) {
    const s = eh(i);
    if (s && s.type === 2 && s.loc.end.offset === n.loc.start.offset) {
      s.content += n.content, s.loc.end = n.loc.end, s.loc.source += n.loc.source;
      return;
    }
  }
  i.push(n);
}
function lA(i, n) {
  wn(i, 9);
  const s = Op(i, 3, n);
  return i.source.length === 0 ? jt(i, 6) : wn(i, 3), s;
}
function cA(i) {
  const n = li(i);
  let s;
  const u = /--(\!)?>/.exec(i.source);
  if (!u)
    s = i.source.slice(4), wn(i, i.source.length), jt(i, 7);
  else {
    u.index <= 3 && jt(i, 0), u[1] && jt(i, 10), s = i.source.slice(4, u.index);
    const y = i.source.slice(0, u.index);
    let w = 1, S = 0;
    for (; (S = y.indexOf("<!--", w)) !== -1; )
      wn(i, S - w + 1), S + 4 < y.length && jt(i, 16), w = S + 1;
    wn(i, u.index + u[0].length - w + 1);
  }
  return {
    type: 3,
    content: s,
    loc: ui(i, n)
  };
}
function Pa(i) {
  const n = li(i), s = i.source[1] === "?" ? 1 : 2;
  let u;
  const y = i.source.indexOf(">");
  return y === -1 ? (u = i.source.slice(s), wn(i, i.source.length)) : (u = i.source.slice(s, y), wn(i, y + 1)), {
    type: 3,
    content: u,
    loc: ui(i, n)
  };
}
function uA(i, n) {
  const s = i.inPre, u = i.inVPre, y = eh(n), w = Tf(i, vu.Start, y), S = i.inPre && !s, d = i.inVPre && !u;
  if (w.isSelfClosing || i.options.isVoidTag(w.tag))
    return S && (i.inPre = !1), d && (i.inVPre = !1), w;
  n.push(w);
  const l = i.options.getTextMode(w, y), p = Op(i, l, n);
  n.pop();
  {
    const v = w.props.find(
      (c) => c.type === 6 && c.name === "inline-template"
    );
    if (v && ls(
      "COMPILER_INLINE_TEMPLATE",
      i,
      v.loc
    )) {
      const c = ui(i, w.loc.end);
      v.value = {
        type: 2,
        content: c.source,
        loc: c
      };
    }
  }
  if (w.children = p, Of(i.source, w.tag))
    Tf(i, vu.End, y);
  else if (jt(i, 24, 0, w.loc.start), i.source.length === 0 && w.tag.toLowerCase() === "script") {
    const v = p[0];
    v && Fn(v.loc.source, "<!--") && jt(i, 8);
  }
  return w.loc = ui(i, w.loc.start), S && (i.inPre = !1), d && (i.inVPre = !1), w;
}
var vu = /* @__PURE__ */ ((i) => (i[i.Start = 0] = "Start", i[i.End = 1] = "End", i))(vu || {});
const a1 = /* @__PURE__ */ fn(
  "if,else,else-if,for,slot"
);
function Tf(i, n, s) {
  const u = li(i), y = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(i.source), w = y[1], S = i.options.getNamespace(w, s);
  wn(i, y[0].length), ml(i);
  const d = li(i), l = i.source;
  i.options.isPreTag(w) && (i.inPre = !0);
  let p = By(i, n);
  n === 0 && !i.inVPre && p.some((e) => e.type === 7 && e.name === "pre") && (i.inVPre = !0, _t(i, d), i.source = l, p = By(i, n).filter((e) => e.name !== "v-pre"));
  let v = !1;
  if (i.source.length === 0 ? jt(i, 9) : (v = Fn(i.source, "/>"), n === 1 && v && jt(i, 4), wn(i, v ? 2 : 1)), n === 1)
    return;
  if (process.env.NODE_ENV !== "production" && es(
    "COMPILER_V_IF_V_FOR_PRECEDENCE",
    i
  )) {
    let e = !1, h = !1;
    for (let m = 0; m < p.length; m++) {
      const b = p[m];
      if (b.type === 7 && (b.name === "if" ? e = !0 : b.name === "for" && (h = !0)), e && h) {
        $l(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          i,
          ui(i, u)
        );
        break;
      }
    }
  }
  let c = 0;
  return i.inVPre || (w === "slot" ? c = 2 : w === "template" ? p.some(
    (e) => e.type === 7 && a1(e.name)
  ) && (c = 3) : hA(w, p, i) && (c = 1)), {
    type: 1,
    ns: S,
    tag: w,
    tagType: c,
    props: p,
    isSelfClosing: v,
    children: [],
    loc: ui(i, u),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function hA(i, n, s) {
  const u = s.options;
  if (u.isCustomElement(i))
    return !1;
  if (i === "component" || /^[A-Z]/.test(i) || Sp(i) || u.isBuiltInComponent && u.isBuiltInComponent(i) || u.isNativeTag && !u.isNativeTag(i))
    return !0;
  for (let y = 0; y < n.length; y++) {
    const w = n[y];
    if (w.type === 6) {
      if (w.name === "is" && w.value) {
        if (w.value.content.startsWith("vue:"))
          return !0;
        if (ls(
          "COMPILER_IS_ON_ELEMENT",
          s,
          w.loc
        ))
          return !0;
      }
    } else {
      if (w.name === "is")
        return !0;
      if (
        // :is on plain element - only treat as component in compat mode
        w.name === "bind" && Jr(w.arg, "is") && ls(
          "COMPILER_IS_ON_ELEMENT",
          s,
          w.loc
        )
      )
        return !0;
    }
  }
}
function By(i, n) {
  const s = [], u = /* @__PURE__ */ new Set();
  for (; i.source.length > 0 && !Fn(i.source, ">") && !Fn(i.source, "/>"); ) {
    if (Fn(i.source, "/")) {
      jt(i, 22), wn(i, 1), ml(i);
      continue;
    }
    n === 1 && jt(i, 3);
    const y = dA(i, u);
    y.type === 6 && y.value && y.name === "class" && (y.value.content = y.value.content.replace(/\s+/g, " ").trim()), n === 0 && s.push(y), /^[^\t\r\n\f />]/.test(i.source) && jt(i, 15), ml(i);
  }
  return s;
}
function dA(i, n) {
  var s;
  const u = li(i), w = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(i.source)[0];
  n.has(w) && jt(i, 2), n.add(w), w[0] === "=" && jt(i, 19);
  {
    const l = /["'<]/g;
    let p;
    for (; p = l.exec(w); )
      jt(
        i,
        17,
        p.index
      );
  }
  wn(i, w.length);
  let S;
  /^[\t\r\n\f ]*=/.test(i.source) && (ml(i), wn(i, 1), ml(i), S = fA(i), S || jt(i, 13));
  const d = ui(i, u);
  if (!i.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(w)) {
    const l = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      w
    );
    let p = Fn(w, "."), v = l[1] || (p || Fn(w, ":") ? "bind" : Fn(w, "@") ? "on" : "slot"), c;
    if (l[2]) {
      const h = v === "slot", m = w.lastIndexOf(
        l[2],
        w.length - (((s = l[3]) == null ? void 0 : s.length) || 0)
      ), b = ui(
        i,
        Py(i, u, m),
        Py(
          i,
          u,
          m + l[2].length + (h && l[3] || "").length
        )
      );
      let f = l[2], k = !0;
      f.startsWith("[") ? (k = !1, f.endsWith("]") ? f = f.slice(1, f.length - 1) : (jt(
        i,
        27
      ), f = f.slice(1))) : h && (f += l[3] || ""), c = {
        type: 4,
        content: f,
        isStatic: k,
        constType: k ? 3 : 0,
        loc: b
      };
    }
    if (S && S.isQuoted) {
      const h = S.loc;
      h.start.offset++, h.start.column++, h.end = hl(h.start, S.content), h.source = h.source.slice(1, -1);
    }
    const e = l[3] ? l[3].slice(1).split(".") : [];
    return p && e.push("prop"), v === "bind" && c && (e.includes("sync") && ls(
      "COMPILER_V_BIND_SYNC",
      i,
      d,
      c.loc.source
    ) && (v = "model", e.splice(e.indexOf("sync"), 1)), process.env.NODE_ENV !== "production" && e.includes("prop") && ls(
      "COMPILER_V_BIND_PROP",
      i,
      d
    )), {
      type: 7,
      name: v,
      exp: S && {
        type: 4,
        content: S.content,
        isStatic: !1,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: S.loc
      },
      arg: c,
      modifiers: e,
      loc: d
    };
  }
  return !i.inVPre && Fn(w, "v-") && jt(i, 26), {
    type: 6,
    name: w,
    value: S && {
      type: 2,
      content: S.content,
      loc: S.loc
    },
    loc: d
  };
}
function fA(i) {
  const n = li(i);
  let s;
  const u = i.source[0], y = u === '"' || u === "'";
  if (y) {
    wn(i, 1);
    const w = i.source.indexOf(u);
    w === -1 ? s = Wa(
      i,
      i.source.length,
      4
    ) : (s = Wa(i, w, 4), wn(i, 1));
  } else {
    const w = /^[^\t\r\n\f >]+/.exec(i.source);
    if (!w)
      return;
    const S = /["'<=`]/g;
    let d;
    for (; d = S.exec(w[0]); )
      jt(
        i,
        18,
        d.index
      );
    s = Wa(i, w[0].length, 4);
  }
  return { content: s, isQuoted: y, loc: ui(i, n) };
}
function pA(i, n) {
  const [s, u] = i.options.delimiters, y = i.source.indexOf(u, s.length);
  if (y === -1) {
    jt(i, 25);
    return;
  }
  const w = li(i);
  wn(i, s.length);
  const S = li(i), d = li(i), l = y - s.length, p = i.source.slice(0, l), v = Wa(i, l, n), c = v.trim(), e = v.indexOf(c);
  e > 0 && dl(S, p, e);
  const h = l - (v.length - c.length - e);
  return dl(d, p, h), wn(i, u.length), {
    type: 5,
    content: {
      type: 4,
      isStatic: !1,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content: c,
      loc: ui(i, S, d)
    },
    loc: ui(i, w)
  };
}
function mA(i, n) {
  const s = n === 3 ? ["]]>"] : ["<", i.options.delimiters[0]];
  let u = i.source.length;
  for (let S = 0; S < s.length; S++) {
    const d = i.source.indexOf(s[S], 1);
    d !== -1 && u > d && (u = d);
  }
  const y = li(i);
  return {
    type: 2,
    content: Wa(i, u, n),
    loc: ui(i, y)
  };
}
function Wa(i, n, s) {
  const u = i.source.slice(0, n);
  return wn(i, n), s === 2 || s === 3 || !u.includes("&") ? u : i.options.decodeEntities(
    u,
    s === 4
  );
}
function li(i) {
  const { column: n, line: s, offset: u } = i;
  return { column: n, line: s, offset: u };
}
function ui(i, n, s) {
  return s = s || li(i), {
    start: n,
    end: s,
    source: i.originalSource.slice(n.offset, s.offset)
  };
}
function eh(i) {
  return i[i.length - 1];
}
function Fn(i, n) {
  return i.startsWith(n);
}
function wn(i, n) {
  const { source: s } = i;
  dl(i, s, n), i.source = s.slice(n);
}
function ml(i) {
  const n = /^[\t\r\n\f ]+/.exec(i.source);
  n && wn(i, n[0].length);
}
function Py(i, n, s) {
  return hl(
    n,
    i.originalSource.slice(n.offset, s),
    s
  );
}
function jt(i, n, s, u = li(i)) {
  s && (u.offset += s, u.column += s), i.options.onError(
    zt(n, {
      start: u,
      end: u,
      source: ""
    })
  );
}
function gA(i, n, s) {
  const u = i.source;
  switch (n) {
    case 0:
      if (Fn(u, "</")) {
        for (let y = s.length - 1; y >= 0; --y)
          if (Of(u, s[y].tag))
            return !0;
      }
      break;
    case 1:
    case 2: {
      const y = eh(s);
      if (y && Of(u, y.tag))
        return !0;
      break;
    }
    case 3:
      if (Fn(u, "]]>"))
        return !0;
      break;
  }
  return !u;
}
function Of(i, n) {
  return Fn(i, "</") && i.slice(2, 2 + n.length).toLowerCase() === n.toLowerCase() && /[\t\r\n\f />]/.test(i[2 + n.length] || ">");
}
function vA(i, n) {
  iu(
    i,
    n,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    l1(i, i.children[0])
  );
}
function l1(i, n) {
  const { children: s } = i;
  return s.length === 1 && n.type === 1 && !fl(n);
}
function iu(i, n, s = !1) {
  const { children: u } = i, y = u.length;
  let w = 0;
  for (let S = 0; S < u.length; S++) {
    const d = u[S];
    if (d.type === 1 && d.tagType === 0) {
      const l = s ? 0 : ai(d, n);
      if (l > 0) {
        if (l >= 2) {
          d.codegenNode.patchFlag = -1 + (process.env.NODE_ENV !== "production" ? " /* HOISTED */" : ""), d.codegenNode = n.hoist(d.codegenNode), w++;
          continue;
        }
      } else {
        const p = d.codegenNode;
        if (p.type === 13) {
          const v = d1(p);
          if ((!v || v === 512 || v === 1) && u1(d, n) >= 2) {
            const c = h1(d);
            c && (p.props = n.hoist(c));
          }
          p.dynamicProps && (p.dynamicProps = n.hoist(p.dynamicProps));
        }
      }
    }
    if (d.type === 1) {
      const l = d.tagType === 1;
      l && n.scopes.vSlot++, iu(d, n), l && n.scopes.vSlot--;
    } else if (d.type === 11)
      iu(d, n, d.children.length === 1);
    else if (d.type === 9)
      for (let l = 0; l < d.branches.length; l++)
        iu(
          d.branches[l],
          n,
          d.branches[l].children.length === 1
        );
  }
  w && n.transformHoist && n.transformHoist(u, n, i), w && w === y && i.type === 1 && i.tagType === 0 && i.codegenNode && i.codegenNode.type === 13 && Je(i.codegenNode.children) && (i.codegenNode.children = n.hoist(
    Uo(i.codegenNode.children)
  ));
}
function ai(i, n) {
  const { constantCache: s } = n;
  switch (i.type) {
    case 1:
      if (i.tagType !== 0)
        return 0;
      const u = s.get(i);
      if (u !== void 0)
        return u;
      const y = i.codegenNode;
      if (y.type !== 13 || y.isBlock && i.tag !== "svg" && i.tag !== "foreignObject")
        return 0;
      if (d1(y))
        return s.set(i, 0), 0;
      {
        let d = 3;
        const l = u1(i, n);
        if (l === 0)
          return s.set(i, 0), 0;
        l < d && (d = l);
        for (let p = 0; p < i.children.length; p++) {
          const v = ai(i.children[p], n);
          if (v === 0)
            return s.set(i, 0), 0;
          v < d && (d = v);
        }
        if (d > 1)
          for (let p = 0; p < i.props.length; p++) {
            const v = i.props[p];
            if (v.type === 7 && v.name === "bind" && v.exp) {
              const c = ai(v.exp, n);
              if (c === 0)
                return s.set(i, 0), 0;
              c < d && (d = c);
            }
          }
        if (y.isBlock) {
          for (let p = 0; p < i.props.length; p++)
            if (i.props[p].type === 7)
              return s.set(i, 0), 0;
          n.removeHelper(as), n.removeHelper(
            js(n.inSSR, y.isComponent)
          ), y.isBlock = !1, n.helper(Rs(n.inSSR, y.isComponent));
        }
        return s.set(i, d), d;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return ai(i.content, n);
    case 4:
      return i.constType;
    case 8:
      let S = 3;
      for (let d = 0; d < i.children.length; d++) {
        const l = i.children[d];
        if (wt(l) || gr(l))
          continue;
        const p = ai(l, n);
        if (p === 0)
          return 0;
        p < S && (S = p);
      }
      return S;
    default:
      return process.env.NODE_ENV, 0;
  }
}
const yA = /* @__PURE__ */ new Set([
  Gu,
  Xu,
  Po,
  Ho
]);
function c1(i, n) {
  if (i.type === 14 && !wt(i.callee) && yA.has(i.callee)) {
    const s = i.arguments[0];
    if (s.type === 4)
      return ai(s, n);
    if (s.type === 14)
      return c1(s, n);
  }
  return 0;
}
function u1(i, n) {
  let s = 3;
  const u = h1(i);
  if (u && u.type === 15) {
    const { properties: y } = u;
    for (let w = 0; w < y.length; w++) {
      const { key: S, value: d } = y[w], l = ai(S, n);
      if (l === 0)
        return l;
      l < s && (s = l);
      let p;
      if (d.type === 4 ? p = ai(d, n) : d.type === 14 ? p = c1(d, n) : p = 0, p === 0)
        return p;
      p < s && (s = p);
    }
  }
  return s;
}
function h1(i) {
  const n = i.codegenNode;
  if (n.type === 13)
    return n.props;
}
function d1(i) {
  const n = i.patchFlag;
  return n ? parseInt(n, 10) : void 0;
}
function f1(i, {
  filename: n = "",
  prefixIdentifiers: s = !1,
  hoistStatic: u = !1,
  cacheHandlers: y = !1,
  nodeTransforms: w = [],
  directiveTransforms: S = {},
  transformHoist: d = null,
  isBuiltInComponent: l = en,
  isCustomElement: p = en,
  expressionPlugins: v = [],
  scopeId: c = null,
  slotted: e = !0,
  ssr: h = !1,
  inSSR: m = !1,
  ssrCssVars: b = "",
  bindingMetadata: f = Ft,
  inline: k = !1,
  isTS: E = !1,
  onError: _ = mp,
  onWarn: T = KC,
  compatConfig: D
}) {
  const V = n.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), I = {
    // options
    selfName: V && Pi(an(V[1])),
    prefixIdentifiers: s,
    hoistStatic: u,
    cacheHandlers: y,
    nodeTransforms: w,
    directiveTransforms: S,
    transformHoist: d,
    isBuiltInComponent: l,
    isCustomElement: p,
    expressionPlugins: v,
    scopeId: c,
    slotted: e,
    ssr: h,
    inSSR: m,
    ssrCssVars: b,
    bindingMetadata: f,
    inline: k,
    isTS: E,
    onError: _,
    onWarn: T,
    compatConfig: D,
    // state
    root: i,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: i,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(M) {
      const Q = I.helpers.get(M) || 0;
      return I.helpers.set(M, Q + 1), M;
    },
    removeHelper(M) {
      const Q = I.helpers.get(M);
      if (Q) {
        const G = Q - 1;
        G ? I.helpers.set(M, G) : I.helpers.delete(M);
      }
    },
    helperString(M) {
      return `_${Ls[I.helper(M)]}`;
    },
    replaceNode(M) {
      if (process.env.NODE_ENV !== "production") {
        if (!I.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!I.parent)
          throw new Error("Cannot replace root node.");
      }
      I.parent.children[I.childIndex] = I.currentNode = M;
    },
    removeNode(M) {
      if (process.env.NODE_ENV !== "production" && !I.parent)
        throw new Error("Cannot remove root node.");
      const Q = I.parent.children, G = M ? Q.indexOf(M) : I.currentNode ? I.childIndex : -1;
      if (process.env.NODE_ENV !== "production" && G < 0)
        throw new Error("node being removed is not a child of current parent");
      !M || M === I.currentNode ? (I.currentNode = null, I.onNodeRemoved()) : I.childIndex > G && (I.childIndex--, I.onNodeRemoved()), I.parent.children.splice(G, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(M) {
    },
    removeIdentifiers(M) {
    },
    hoist(M) {
      wt(M) && (M = Ot(M)), I.hoists.push(M);
      const Q = Ot(
        `_hoisted_${I.hoists.length}`,
        !1,
        M.loc,
        2
      );
      return Q.hoisted = M, Q;
    },
    cache(M, Q = !1) {
      return t1(I.cached++, M, Q);
    }
  };
  return I.filters = /* @__PURE__ */ new Set(), I;
}
function p1(i, n) {
  const s = f1(i, n);
  Il(i, s), n.hoistStatic && vA(i, s), n.ssr || bA(i, s), i.helpers = /* @__PURE__ */ new Set([...s.helpers.keys()]), i.components = [...s.components], i.directives = [...s.directives], i.imports = s.imports, i.hoists = s.hoists, i.temps = s.temps, i.cached = s.cached, i.filters = [...s.filters];
}
function bA(i, n) {
  const { helper: s } = n, { children: u } = i;
  if (u.length === 1) {
    const y = u[0];
    if (l1(i, y) && y.codegenNode) {
      const w = y.codegenNode;
      w.type === 13 && Zu(w, n), i.codegenNode = w;
    } else
      i.codegenNode = y;
  } else if (u.length > 1) {
    let y = 64, w = Bi[64];
    process.env.NODE_ENV !== "production" && u.filter((S) => S.type !== 3).length === 1 && (y |= 2048, w += `, ${Bi[2048]}`), i.codegenNode = Vo(
      n,
      s(Bo),
      void 0,
      i.children,
      y + (process.env.NODE_ENV !== "production" ? ` /* ${w} */` : ""),
      void 0,
      void 0,
      !0,
      void 0,
      !1
      /* isComponent */
    );
  }
}
function CA(i, n) {
  let s = 0;
  const u = () => {
    s--;
  };
  for (; s < i.children.length; s++) {
    const y = i.children[s];
    wt(y) || (n.parent = i, n.childIndex = s, n.onNodeRemoved = u, Il(y, n));
  }
}
function Il(i, n) {
  n.currentNode = i;
  const { nodeTransforms: s } = n, u = [];
  for (let w = 0; w < s.length; w++) {
    const S = s[w](i, n);
    if (S && (Je(S) ? u.push(...S) : u.push(S)), n.currentNode)
      i = n.currentNode;
    else
      return;
  }
  switch (i.type) {
    case 3:
      n.ssr || n.helper(jo);
      break;
    case 5:
      n.ssr || n.helper(Pl);
      break;
    case 9:
      for (let w = 0; w < i.branches.length; w++)
        Il(i.branches[w], n);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      CA(i, n);
      break;
  }
  n.currentNode = i;
  let y = u.length;
  for (; y--; )
    u[y]();
}
function Dp(i, n) {
  const s = wt(i) ? (u) => u === i : (u) => i.test(u);
  return (u, y) => {
    if (u.type === 1) {
      const { props: w } = u;
      if (u.tagType === 3 && w.some(_p))
        return;
      const S = [];
      for (let d = 0; d < w.length; d++) {
        const l = w[d];
        if (l.type === 7 && s(l.name)) {
          w.splice(d, 1), d--;
          const p = n(u, l, y);
          p && S.push(p);
        }
      }
      return S;
    }
  };
}
const th = "/*#__PURE__*/", m1 = (i) => `${Ls[i]}: _${Ls[i]}`;
function Vy(i, {
  mode: n = "function",
  prefixIdentifiers: s = n === "module",
  sourceMap: u = !1,
  filename: y = "template.vue.html",
  scopeId: w = null,
  optimizeImports: S = !1,
  runtimeGlobalName: d = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: p = "vue/server-renderer",
  ssr: v = !1,
  isTS: c = !1,
  inSSR: e = !1
}) {
  const h = {
    mode: n,
    prefixIdentifiers: s,
    sourceMap: u,
    filename: y,
    scopeId: w,
    optimizeImports: S,
    runtimeGlobalName: d,
    runtimeModuleName: l,
    ssrRuntimeModuleName: p,
    ssr: v,
    isTS: c,
    inSSR: e,
    source: i.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(b) {
      return `_${Ls[b]}`;
    },
    push(b, f) {
      h.code += b;
    },
    indent() {
      m(++h.indentLevel);
    },
    deindent(b = !1) {
      b ? --h.indentLevel : m(--h.indentLevel);
    },
    newline() {
      m(h.indentLevel);
    }
  };
  function m(b) {
    h.push(`
` + "  ".repeat(b));
  }
  return h;
}
function g1(i, n = {}) {
  const s = Vy(i, n);
  n.onContextCreated && n.onContextCreated(s);
  const {
    mode: u,
    push: y,
    prefixIdentifiers: w,
    indent: S,
    deindent: d,
    newline: l,
    scopeId: p,
    ssr: v
  } = s, c = Array.from(i.helpers), e = c.length > 0, h = !w && u !== "module", m = !1, b = m ? Vy(i, n) : s;
  wA(i, b);
  const f = v ? "ssrRender" : "render", E = (v ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (y(`function ${f}(${E}) {`), S(), h && (y("with (_ctx) {"), S(), e && (y(`const { ${c.map(m1).join(", ")} } = _Vue`), y(`
`), l())), i.components.length && (Xd(i.components, "component", s), (i.directives.length || i.temps > 0) && l()), i.directives.length && (Xd(i.directives, "directive", s), i.temps > 0 && l()), i.filters && i.filters.length && (l(), Xd(i.filters, "filter", s), l()), i.temps > 0) {
    y("let ");
    for (let _ = 0; _ < i.temps; _++)
      y(`${_ > 0 ? ", " : ""}_temp${_}`);
  }
  return (i.components.length || i.directives.length || i.temps) && (y(`
`), l()), v || y("return "), i.codegenNode ? Ln(i.codegenNode, s) : y("null"), h && (d(), y("}")), d(), y("}"), {
    ast: i,
    code: s.code,
    preamble: m ? b.code : "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: s.map ? s.map.toJSON() : void 0
  };
}
function wA(i, n) {
  const {
    ssr: s,
    prefixIdentifiers: u,
    push: y,
    newline: w,
    runtimeModuleName: S,
    runtimeGlobalName: d,
    ssrRuntimeModuleName: l
  } = n, p = d, v = Array.from(i.helpers);
  if (v.length > 0 && (y(`const _Vue = ${p}
`), i.hoists.length)) {
    const c = [
      zu,
      Ru,
      jo,
      ju,
      bp
    ].filter((e) => v.includes(e)).map(m1).join(", ");
    y(`const { ${c} } = _Vue
`);
  }
  kA(i.hoists, n), w(), y("return ");
}
function Xd(i, n, { helper: s, push: u, newline: y, isTS: w }) {
  const S = s(
    n === "filter" ? Wu : n === "component" ? Hu : Uu
  );
  for (let d = 0; d < i.length; d++) {
    let l = i[d];
    const p = l.endsWith("__self");
    p && (l = l.slice(0, -6)), u(
      `const ${Io(l, n)} = ${S}(${JSON.stringify(l)}${p ? ", true" : ""})${w ? "!" : ""}`
    ), d < i.length - 1 && y();
  }
}
function kA(i, n) {
  if (!i.length)
    return;
  n.pure = !0;
  const { push: s, newline: u, helper: y, scopeId: w, mode: S } = n;
  u();
  for (let d = 0; d < i.length; d++) {
    const l = i[d];
    l && (s(
      `const _hoisted_${d + 1} = `
    ), Ln(l, n), u());
  }
  n.pure = !1;
}
function SA(i) {
  return wt(i) || i.type === 4 || i.type === 2 || i.type === 5 || i.type === 8;
}
function Np(i, n) {
  const s = i.length > 3 || process.env.NODE_ENV !== "production" && i.some((u) => Je(u) || !SA(u));
  n.push("["), s && n.indent(), Ml(i, n, s), s && n.deindent(), n.push("]");
}
function Ml(i, n, s = !1, u = !0) {
  const { push: y, newline: w } = n;
  for (let S = 0; S < i.length; S++) {
    const d = i[S];
    wt(d) ? y(d) : Je(d) ? Np(d, n) : Ln(d, n), S < i.length - 1 && (s ? (u && y(","), w()) : u && y(", "));
  }
}
function Ln(i, n) {
  if (wt(i)) {
    n.push(i);
    return;
  }
  if (gr(i)) {
    n.push(n.helper(i));
    return;
  }
  switch (i.type) {
    case 1:
    case 9:
    case 11:
      process.env.NODE_ENV !== "production" && xf(
        i.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), Ln(i.codegenNode, n);
      break;
    case 2:
      EA(i, n);
      break;
    case 4:
      v1(i, n);
      break;
    case 5:
      xA(i, n);
      break;
    case 12:
      Ln(i.codegenNode, n);
      break;
    case 8:
      y1(i, n);
      break;
    case 3:
      TA(i, n);
      break;
    case 13:
      OA(i, n);
      break;
    case 14:
      NA(i, n);
      break;
    case 15:
      BA(i, n);
      break;
    case 17:
      PA(i, n);
      break;
    case 18:
      VA(i, n);
      break;
    case 19:
      $A(i, n);
      break;
    case 20:
      IA(i, n);
      break;
    case 21:
      Ml(i.body, n, !0, !1);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (process.env.NODE_ENV !== "production")
        return xf(!1, `unhandled codegen node type: ${i.type}`), i;
  }
}
function EA(i, n) {
  n.push(JSON.stringify(i.content), i);
}
function v1(i, n) {
  const { content: s, isStatic: u } = i;
  n.push(u ? JSON.stringify(s) : s, i);
}
function xA(i, n) {
  const { push: s, helper: u, pure: y } = n;
  y && s(th), s(`${u(Pl)}(`), Ln(i.content, n), s(")");
}
function y1(i, n) {
  for (let s = 0; s < i.children.length; s++) {
    const u = i.children[s];
    wt(u) ? n.push(u) : Ln(u, n);
  }
}
function _A(i, n) {
  const { push: s } = n;
  if (i.type === 8)
    s("["), y1(i, n), s("]");
  else if (i.isStatic) {
    const u = Vl(i.content) ? i.content : JSON.stringify(i.content);
    s(u, i);
  } else
    s(`[${i.content}]`, i);
}
function TA(i, n) {
  const { push: s, helper: u, pure: y } = n;
  y && s(th), s(`${u(jo)}(${JSON.stringify(i.content)})`, i);
}
function OA(i, n) {
  const { push: s, helper: u, pure: y } = n, {
    tag: w,
    props: S,
    children: d,
    patchFlag: l,
    dynamicProps: p,
    directives: v,
    isBlock: c,
    disableTracking: e,
    isComponent: h
  } = i;
  v && s(u(Yu) + "("), c && s(`(${u(as)}(${e ? "true" : ""}), `), y && s(th);
  const m = c ? js(n.inSSR, h) : Rs(n.inSSR, h);
  s(u(m) + "(", i), Ml(
    DA([w, S, d, l, p]),
    n
  ), s(")"), c && s(")"), v && (s(", "), Ln(v, n), s(")"));
}
function DA(i) {
  let n = i.length;
  for (; n-- && i[n] == null; )
    ;
  return i.slice(0, n + 1).map((s) => s || "null");
}
function NA(i, n) {
  const { push: s, helper: u, pure: y } = n, w = wt(i.callee) ? i.callee : u(i.callee);
  y && s(th), s(w + "(", i), Ml(i.arguments, n), s(")");
}
function BA(i, n) {
  const { push: s, indent: u, deindent: y, newline: w } = n, { properties: S } = i;
  if (!S.length) {
    s("{}", i);
    return;
  }
  const d = S.length > 1 || process.env.NODE_ENV !== "production" && S.some((l) => l.value.type !== 4);
  s(d ? "{" : "{ "), d && u();
  for (let l = 0; l < S.length; l++) {
    const { key: p, value: v } = S[l];
    _A(p, n), s(": "), Ln(v, n), l < S.length - 1 && (s(","), w());
  }
  d && y(), s(d ? "}" : " }");
}
function PA(i, n) {
  Np(i.elements, n);
}
function VA(i, n) {
  const { push: s, indent: u, deindent: y } = n, { params: w, returns: S, body: d, newline: l, isSlot: p } = i;
  p && s(`_${Ls[Ju]}(`), s("(", i), Je(w) ? Ml(w, n) : w && Ln(w, n), s(") => "), (l || d) && (s("{"), u()), S ? (l && s("return "), Je(S) ? Np(S, n) : Ln(S, n)) : d && Ln(d, n), (l || d) && (y(), s("}")), p && (i.isNonScopedSlot && s(", undefined, true"), s(")"));
}
function $A(i, n) {
  const { test: s, consequent: u, alternate: y, newline: w } = i, { push: S, indent: d, deindent: l, newline: p } = n;
  if (s.type === 4) {
    const c = !Vl(s.content);
    c && S("("), v1(s, n), c && S(")");
  } else
    S("("), Ln(s, n), S(")");
  w && d(), n.indentLevel++, w || S(" "), S("? "), Ln(u, n), n.indentLevel--, w && p(), w || S(" "), S(": ");
  const v = y.type === 19;
  v || n.indentLevel++, Ln(y, n), v || n.indentLevel--, w && l(
    !0
    /* without newline */
  );
}
function IA(i, n) {
  const { push: s, helper: u, indent: y, deindent: w, newline: S } = n;
  s(`_cache[${i.index}] || (`), i.isVNode && (y(), s(`${u(ul)}(-1),`), S()), s(`_cache[${i.index}] = `), Ln(i.value, n), i.isVNode && (s(","), S(), s(`${u(ul)}(1),`), S(), s(`_cache[${i.index}]`), w()), s(")");
}
function MA(i, n, s = !1, u = [], y = /* @__PURE__ */ Object.create(null)) {
}
function AA(i, n, s) {
  return !1;
}
function FA(i, n) {
  if (i && (i.type === "ObjectProperty" || i.type === "ArrayPattern")) {
    let s = n.length;
    for (; s--; ) {
      const u = n[s];
      if (u.type === "AssignmentExpression")
        return !0;
      if (u.type !== "ObjectProperty" && !u.type.endsWith("Pattern"))
        break;
    }
  }
  return !1;
}
function LA(i, n) {
  for (const s of i.params)
    for (const u of Kr(s))
      n(u);
}
function zA(i, n) {
  for (const s of i.body)
    if (s.type === "VariableDeclaration") {
      if (s.declare)
        continue;
      for (const u of s.declarations)
        for (const y of Kr(u.id))
          n(y);
    } else if (s.type === "FunctionDeclaration" || s.type === "ClassDeclaration") {
      if (s.declare || !s.id)
        continue;
      n(s.id);
    }
}
function Kr(i, n = []) {
  switch (i.type) {
    case "Identifier":
      n.push(i);
      break;
    case "MemberExpression":
      let s = i;
      for (; s.type === "MemberExpression"; )
        s = s.object;
      n.push(s);
      break;
    case "ObjectPattern":
      for (const u of i.properties)
        u.type === "RestElement" ? Kr(u.argument, n) : Kr(u.value, n);
      break;
    case "ArrayPattern":
      i.elements.forEach((u) => {
        u && Kr(u, n);
      });
      break;
    case "RestElement":
      Kr(i.argument, n);
      break;
    case "AssignmentPattern":
      Kr(i.left, n);
      break;
  }
  return n;
}
const RA = (i) => /Function(?:Expression|Declaration)$|Method$/.test(i.type), b1 = (i) => i && (i.type === "ObjectProperty" || i.type === "ObjectMethod") && !i.computed, jA = (i, n) => b1(n) && n.key === i, HA = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
], UA = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
), WA = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function Ds(i, n, s = !1, u = !1) {
  const y = i.content;
  if (y.trim())
    try {
      new Function(
        u ? ` ${y} ` : `return ${s ? `(${y}) => {}` : `(${y})`}`
      );
    } catch (w) {
      let S = w.message;
      const d = y.replace(WA, "").match(UA);
      d && (S = `avoid using JavaScript keyword as property name: "${d[0]}"`), n.onError(
        zt(
          45,
          i.loc,
          void 0,
          S
        )
      );
    }
}
const C1 = (i, n) => {
  if (i.type === 5)
    i.content = ru(
      i.content,
      n
    );
  else if (i.type === 1)
    for (let s = 0; s < i.props.length; s++) {
      const u = i.props[s];
      if (u.type === 7 && u.name !== "for") {
        const y = u.exp, w = u.arg;
        y && y.type === 4 && !(u.name === "on" && w) && (u.exp = ru(
          y,
          n,
          // slot args must be processed as function params
          u.name === "slot"
        )), w && w.type === 4 && !w.isStatic && (u.arg = ru(w, n));
      }
    }
};
function ru(i, n, s = !1, u = !1, y = Object.create(n.identifiers)) {
  return process.env.NODE_ENV !== "production" && Ds(i, n, s, u), i;
}
function w1(i) {
  return wt(i) ? i : i.type === 4 ? i.content : i.children.map(w1).join("");
}
const YA = Dp(
  /^(if|else|else-if)$/,
  (i, n, s) => k1(i, n, s, (u, y, w) => {
    const S = s.parent.children;
    let d = S.indexOf(u), l = 0;
    for (; d-- >= 0; ) {
      const p = S[d];
      p && p.type === 9 && (l += p.branches.length);
    }
    return () => {
      if (w)
        u.codegenNode = Iy(
          y,
          l,
          s
        );
      else {
        const p = GA(u.codegenNode);
        p.alternate = Iy(
          y,
          l + u.branches.length - 1,
          s
        );
      }
    };
  })
);
function k1(i, n, s, u) {
  if (n.name !== "else" && (!n.exp || !n.exp.content.trim())) {
    const y = n.exp ? n.exp.loc : i.loc;
    s.onError(
      zt(28, n.loc)
    ), n.exp = Ot("true", !1, y);
  }
  if (process.env.NODE_ENV !== "production" && n.exp && Ds(n.exp, s), n.name === "if") {
    const y = $y(i, n), w = {
      type: 9,
      loc: i.loc,
      branches: [y]
    };
    if (s.replaceNode(w), u)
      return u(w, y, !0);
  } else {
    const y = s.parent.children, w = [];
    let S = y.indexOf(i);
    for (; S-- >= -1; ) {
      const d = y[S];
      if (d && d.type === 3) {
        s.removeNode(d), process.env.NODE_ENV !== "production" && w.unshift(d);
        continue;
      }
      if (d && d.type === 2 && !d.content.trim().length) {
        s.removeNode(d);
        continue;
      }
      if (d && d.type === 9) {
        n.name === "else-if" && d.branches[d.branches.length - 1].condition === void 0 && s.onError(
          zt(30, i.loc)
        ), s.removeNode();
        const l = $y(i, n);
        if (process.env.NODE_ENV !== "production" && w.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(s.parent && s.parent.type === 1 && qr(s.parent.tag, "transition")) && (l.children = [...w, ...l.children]), process.env.NODE_ENV !== "production") {
          const v = l.userKey;
          v && d.branches.forEach(({ userKey: c }) => {
            KA(c, v) && s.onError(
              zt(
                29,
                l.userKey.loc
              )
            );
          });
        }
        d.branches.push(l);
        const p = u && u(d, l, !1);
        Il(l, s), p && p(), s.currentNode = null;
      } else
        s.onError(
          zt(30, i.loc)
        );
      break;
    }
  }
}
function $y(i, n) {
  const s = i.tagType === 3;
  return {
    type: 10,
    loc: i.loc,
    condition: n.name === "else" ? void 0 : n.exp,
    children: s && !Xn(i, "for") ? i.children : [i],
    userKey: Hs(i, "key"),
    isTemplateIf: s
  };
}
function Iy(i, n, s) {
  return i.condition ? gu(
    i.condition,
    My(i, n, s),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    rn(s.helper(jo), [
      process.env.NODE_ENV !== "production" ? '"v-if"' : '""',
      "true"
    ])
  ) : My(i, n, s);
}
function My(i, n, s) {
  const { helper: u } = s, y = Qt(
    "key",
    Ot(
      `${n}`,
      !1,
      kn,
      2
    )
  ), { children: w } = i, S = w[0];
  if (w.length !== 1 || S.type !== 1)
    if (w.length === 1 && S.type === 11) {
      const l = S.codegenNode;
      return pl(l, y, s), l;
    } else {
      let l = 64, p = Bi[64];
      return process.env.NODE_ENV !== "production" && !i.isTemplateIf && w.filter((v) => v.type !== 3).length === 1 && (l |= 2048, p += `, ${Bi[2048]}`), Vo(
        s,
        u(Bo),
        oi([y]),
        w,
        l + (process.env.NODE_ENV !== "production" ? ` /* ${p} */` : ""),
        void 0,
        void 0,
        !0,
        !1,
        !1,
        i.loc
      );
    }
  else {
    const l = S.codegenNode, p = o1(l);
    return p.type === 13 && Zu(p, s), pl(p, y, s), l;
  }
}
function KA(i, n) {
  if (!i || i.type !== n.type)
    return !1;
  if (i.type === 6) {
    if (i.value.content !== n.value.content)
      return !1;
  } else {
    const s = i.exp, u = n.exp;
    if (s.type !== u.type || s.type !== 4 || s.isStatic !== u.isStatic || s.content !== u.content)
      return !1;
  }
  return !0;
}
function GA(i) {
  for (; ; )
    if (i.type === 19)
      if (i.alternate.type === 19)
        i = i.alternate;
      else
        return i;
    else
      i.type === 20 && (i = i.value);
}
const XA = Dp(
  "for",
  (i, n, s) => {
    const { helper: u, removeHelper: y } = s;
    return S1(i, n, s, (w) => {
      const S = rn(u(Ku), [
        w.source
      ]), d = $o(i), l = Xn(i, "memo"), p = Hs(i, "key"), v = p && (p.type === 6 ? Ot(p.value.content, !0) : p.exp), c = p ? Qt("key", v) : null, e = w.source.type === 4 && w.source.constType > 0, h = e ? 64 : p ? 128 : 256;
      return w.codegenNode = Vo(
        s,
        u(Bo),
        void 0,
        S,
        h + (process.env.NODE_ENV !== "production" ? ` /* ${Bi[h]} */` : ""),
        void 0,
        void 0,
        !0,
        !e,
        !1,
        i.loc
      ), () => {
        let m;
        const { children: b } = w;
        process.env.NODE_ENV !== "production" && d && i.children.some((E) => {
          if (E.type === 1) {
            const _ = Hs(E, "key");
            if (_)
              return s.onError(
                zt(
                  33,
                  _.loc
                )
              ), !0;
          }
        });
        const f = b.length !== 1 || b[0].type !== 1, k = fl(i) ? i : d && i.children.length === 1 && fl(i.children[0]) ? i.children[0] : null;
        if (k ? (m = k.codegenNode, d && c && pl(m, c, s)) : f ? m = Vo(
          s,
          u(Bo),
          c ? oi([c]) : void 0,
          i.children,
          64 + (process.env.NODE_ENV !== "production" ? ` /* ${Bi[64]} */` : ""),
          void 0,
          void 0,
          !0,
          void 0,
          !1
          /* isComponent */
        ) : (m = b[0].codegenNode, d && c && pl(m, c, s), m.isBlock !== !e && (m.isBlock ? (y(as), y(
          js(s.inSSR, m.isComponent)
        )) : y(
          Rs(s.inSSR, m.isComponent)
        )), m.isBlock = !e, m.isBlock ? (u(as), u(js(s.inSSR, m.isComponent))) : u(Rs(s.inSSR, m.isComponent))), l) {
          const E = zs(
            yu(w.parseResult, [
              Ot("_cached")
            ])
          );
          E.body = n1([
            bi(["const _memo = (", l.exp, ")"]),
            bi([
              "if (_cached",
              ...v ? [" && _cached.key === ", v] : [],
              ` && ${s.helperString(
                kp
              )}(_cached, _memo)) return _cached`
            ]),
            bi(["const _item = ", m]),
            Ot("_item.memo = _memo"),
            Ot("return _item")
          ]), S.arguments.push(
            E,
            Ot("_cache"),
            Ot(String(s.cached++))
          );
        } else
          S.arguments.push(
            zs(
              yu(w.parseResult),
              m,
              !0
              /* force newline */
            )
          );
      };
    });
  }
);
function S1(i, n, s, u) {
  if (!n.exp) {
    s.onError(
      zt(31, n.loc)
    );
    return;
  }
  const y = Bp(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    n.exp,
    s
  );
  if (!y) {
    s.onError(
      zt(32, n.loc)
    );
    return;
  }
  const { addIdentifiers: w, removeIdentifiers: S, scopes: d } = s, { source: l, value: p, key: v, index: c } = y, e = {
    type: 11,
    loc: n.loc,
    source: l,
    valueAlias: p,
    keyAlias: v,
    objectIndexAlias: c,
    parseResult: y,
    children: $o(i) ? i.children : [i]
  };
  s.replaceNode(e), d.vFor++;
  const h = u && u(e);
  return () => {
    d.vFor--, h && h();
  };
}
const qA = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, Ay = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, JA = /^\(|\)$/g;
function Bp(i, n) {
  const s = i.loc, u = i.content, y = u.match(qA);
  if (!y)
    return;
  const [, w, S] = y, d = {
    source: jc(
      s,
      S.trim(),
      u.indexOf(S, w.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  process.env.NODE_ENV !== "production" && Ds(d.source, n);
  let l = w.trim().replace(JA, "").trim();
  const p = w.indexOf(l), v = l.match(Ay);
  if (v) {
    l = l.replace(Ay, "").trim();
    const c = v[1].trim();
    let e;
    if (c && (e = u.indexOf(c, p + l.length), d.key = jc(s, c, e), process.env.NODE_ENV !== "production" && Ds(
      d.key,
      n,
      !0
    )), v[2]) {
      const h = v[2].trim();
      h && (d.index = jc(
        s,
        h,
        u.indexOf(
          h,
          d.key ? e + c.length : p + l.length
        )
      ), process.env.NODE_ENV !== "production" && Ds(
        d.index,
        n,
        !0
      ));
    }
  }
  return l && (d.value = jc(s, l, p), process.env.NODE_ENV !== "production" && Ds(
    d.value,
    n,
    !0
  )), d;
}
function jc(i, n, s) {
  return Ot(
    n,
    !1,
    xp(i, s, n.length)
  );
}
function yu({ value: i, key: n, index: s }, u = []) {
  return QA([i, n, s, ...u]);
}
function QA(i) {
  let n = i.length;
  for (; n-- && !i[n]; )
    ;
  return i.slice(0, n + 1).map((s, u) => s || Ot("_".repeat(u + 1), !1));
}
const Fy = Ot("undefined", !1), E1 = (i, n) => {
  if (i.type === 1 && (i.tagType === 1 || i.tagType === 3)) {
    const s = Xn(i, "slot");
    if (s)
      return s.exp, n.scopes.vSlot++, () => {
        n.scopes.vSlot--;
      };
  }
}, ZA = (i, n) => {
  let s;
  if ($o(i) && i.props.some(_p) && (s = Xn(i, "for"))) {
    const u = s.parseResult = Bp(
      s.exp,
      n
    );
    if (u) {
      const { value: y, key: w, index: S } = u, { addIdentifiers: d, removeIdentifiers: l } = n;
      return y && d(y), w && d(w), S && d(S), () => {
        y && l(y), w && l(w), S && l(S);
      };
    }
  }
}, e3 = (i, n, s) => zs(
  i,
  n,
  !1,
  !0,
  n.length ? n[0].loc : s
);
function x1(i, n, s = e3) {
  n.helper(Ju);
  const { children: u, loc: y } = i, w = [], S = [];
  let d = n.scopes.vSlot > 0 || n.scopes.vFor > 0;
  const l = Xn(i, "slot", !0);
  if (l) {
    const { arg: f, exp: k } = l;
    f && !Yn(f) && (d = !0), w.push(
      Qt(
        f || Ot("default", !0),
        s(k, u, y)
      )
    );
  }
  let p = !1, v = !1;
  const c = [], e = /* @__PURE__ */ new Set();
  let h = 0;
  for (let f = 0; f < u.length; f++) {
    const k = u[f];
    let E;
    if (!$o(k) || !(E = Xn(k, "slot", !0))) {
      k.type !== 3 && c.push(k);
      continue;
    }
    if (l) {
      n.onError(
        zt(37, E.loc)
      );
      break;
    }
    p = !0;
    const { children: _, loc: T } = k, {
      arg: D = Ot("default", !0),
      exp: V,
      loc: I
    } = E;
    let M;
    Yn(D) ? M = D ? D.content : "default" : d = !0;
    const Q = s(V, _, T);
    let G, z, re;
    if (G = Xn(k, "if"))
      d = !0, S.push(
        gu(
          G.exp,
          Hc(D, Q, h++),
          Fy
        )
      );
    else if (z = Xn(
      k,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let he = f, de;
      for (; he-- && (de = u[he], de.type === 3); )
        ;
      if (de && $o(de) && Xn(de, "if")) {
        u.splice(f, 1), f--;
        let Ce = S[S.length - 1];
        for (; Ce.alternate.type === 19; )
          Ce = Ce.alternate;
        Ce.alternate = z.exp ? gu(
          z.exp,
          Hc(
            D,
            Q,
            h++
          ),
          Fy
        ) : Hc(D, Q, h++);
      } else
        n.onError(
          zt(30, z.loc)
        );
    } else if (re = Xn(k, "for")) {
      d = !0;
      const he = re.parseResult || Bp(re.exp, n);
      he ? S.push(
        rn(n.helper(Ku), [
          he.source,
          zs(
            yu(he),
            Hc(D, Q),
            !0
            /* force newline */
          )
        ])
      ) : n.onError(
        zt(32, re.loc)
      );
    } else {
      if (M) {
        if (e.has(M)) {
          n.onError(
            zt(
              38,
              I
            )
          );
          continue;
        }
        e.add(M), M === "default" && (v = !0);
      }
      w.push(Qt(D, Q));
    }
  }
  if (!l) {
    const f = (k, E) => {
      const _ = s(k, E, y);
      return n.compatConfig && (_.isNonScopedSlot = !0), Qt("default", _);
    };
    p ? c.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    c.some((k) => _1(k)) && (v ? n.onError(
      zt(
        39,
        c[0].loc
      )
    ) : w.push(
      f(void 0, c)
    )) : w.push(f(void 0, u));
  }
  const m = d ? 2 : su(i.children) ? 3 : 1;
  let b = oi(
    w.concat(
      Qt(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        Ot(
          m + (process.env.NODE_ENV !== "production" ? ` /* ${FC[m]} */` : ""),
          !1
        )
      )
    ),
    y
  );
  return S.length && (b = rn(n.helper(wp), [
    b,
    Uo(S)
  ])), {
    slots: b,
    hasDynamicSlots: d
  };
}
function Hc(i, n, s) {
  const u = [
    Qt("name", i),
    Qt("fn", n)
  ];
  return s != null && u.push(
    Qt("key", Ot(String(s), !0))
  ), oi(u);
}
function su(i) {
  for (let n = 0; n < i.length; n++) {
    const s = i[n];
    switch (s.type) {
      case 1:
        if (s.tagType === 2 || su(s.children))
          return !0;
        break;
      case 9:
        if (su(s.branches))
          return !0;
        break;
      case 10:
      case 11:
        if (su(s.children))
          return !0;
        break;
    }
  }
  return !1;
}
function _1(i) {
  return i.type !== 2 && i.type !== 12 ? !0 : i.type === 2 ? !!i.content.trim() : _1(i.content);
}
const T1 = /* @__PURE__ */ new WeakMap(), O1 = (i, n) => function() {
  if (i = n.currentNode, !(i.type === 1 && (i.tagType === 0 || i.tagType === 1)))
    return;
  const { tag: u, props: y } = i, w = i.tagType === 1;
  let S = w ? D1(i, n) : `"${u}"`;
  const d = Nt(S) && S.callee === ll;
  let l, p, v, c = 0, e, h, m, b = (
    // dynamic component may resolve to plain elements
    d || S === To || S === Lu || !w && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (u === "svg" || u === "foreignObject")
  );
  if (y.length > 0) {
    const f = Pp(
      i,
      n,
      void 0,
      w,
      d
    );
    l = f.props, c = f.patchFlag, h = f.dynamicPropNames;
    const k = f.directives;
    m = k && k.length ? Uo(
      k.map((E) => N1(E, n))
    ) : void 0, f.shouldUseBlock && (b = !0);
  }
  if (i.children.length > 0)
    if (S === al && (b = !0, c |= 1024, process.env.NODE_ENV !== "production" && i.children.length > 1 && n.onError(
      zt(46, {
        start: i.children[0].loc.start,
        end: i.children[i.children.length - 1].loc.end,
        source: ""
      })
    )), w && // Teleport is not a real component and has dedicated runtime handling
    S !== To && // explained above.
    S !== al) {
      const { slots: k, hasDynamicSlots: E } = x1(i, n);
      p = k, E && (c |= 1024);
    } else if (i.children.length === 1 && S !== To) {
      const k = i.children[0], E = k.type, _ = E === 5 || E === 8;
      _ && ai(k, n) === 0 && (c |= 1), _ || E === 2 ? p = k : p = i.children;
    } else
      p = i.children;
  if (c !== 0) {
    if (process.env.NODE_ENV !== "production")
      if (c < 0)
        v = c + ` /* ${Bi[c]} */`;
      else {
        const f = Object.keys(Bi).map(Number).filter((k) => k > 0 && c & k).map((k) => Bi[k]).join(", ");
        v = c + ` /* ${f} */`;
      }
    else
      v = String(c);
    h && h.length && (e = n3(h));
  }
  i.codegenNode = Vo(
    n,
    S,
    l,
    p,
    v,
    e,
    m,
    !!b,
    !1,
    w,
    i.loc
  );
};
function D1(i, n, s = !1) {
  let { tag: u } = i;
  const y = Df(u), w = Hs(i, "is");
  if (w)
    if (y || es(
      "COMPILER_IS_ON_ELEMENT",
      n
    )) {
      const l = w.type === 6 ? w.value && Ot(w.value.content, !0) : w.exp;
      if (l)
        return rn(n.helper(ll), [
          l
        ]);
    } else
      w.type === 6 && w.value.content.startsWith("vue:") && (u = w.value.content.slice(4));
  const S = !y && Xn(i, "is");
  if (S && S.exp)
    return process.env.NODE_ENV !== "production" && n.onWarn(
      zt(52, S.loc)
    ), rn(n.helper(ll), [
      S.exp
    ]);
  const d = Sp(u) || n.isBuiltInComponent(u);
  return d ? (s || n.helper(d), d) : (n.helper(Hu), n.components.add(u), Io(u, "component"));
}
function Pp(i, n, s = i.props, u, y, w = !1) {
  const { tag: S, loc: d, children: l } = i;
  let p = [];
  const v = [], c = [], e = l.length > 0;
  let h = !1, m = 0, b = !1, f = !1, k = !1, E = !1, _ = !1, T = !1;
  const D = [], V = (Q) => {
    p.length && (v.push(
      oi(Ly(p), d)
    ), p = []), Q && v.push(Q);
  }, I = ({ key: Q, value: G }) => {
    if (Yn(Q)) {
      const z = Q.content, re = Gi(z);
      if (re && (!u || y) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      z.toLowerCase() !== "onclick" && // omit v-model handlers
      z !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !Zr(z) && (E = !0), re && Zr(z) && (T = !0), G.type === 20 || (G.type === 4 || G.type === 8) && ai(G, n) > 0)
        return;
      z === "ref" ? b = !0 : z === "class" ? f = !0 : z === "style" ? k = !0 : z !== "key" && !D.includes(z) && D.push(z), u && (z === "class" || z === "style") && !D.includes(z) && D.push(z);
    } else
      _ = !0;
  };
  for (let Q = 0; Q < s.length; Q++) {
    const G = s[Q];
    if (G.type === 6) {
      const { loc: z, name: re, value: he } = G;
      let de = !0;
      if (re === "ref" && (b = !0, n.scopes.vFor > 0 && p.push(
        Qt(
          Ot("ref_for", !0),
          Ot("true")
        )
      )), re === "is" && (Df(S) || he && he.content.startsWith("vue:") || es(
        "COMPILER_IS_ON_ELEMENT",
        n
      )))
        continue;
      p.push(
        Qt(
          Ot(
            re,
            !0,
            xp(z, 0, re.length)
          ),
          Ot(
            he ? he.content : "",
            de,
            he ? he.loc : z
          )
        )
      );
    } else {
      const { name: z, arg: re, exp: he, loc: de } = G, Ce = z === "bind", xe = z === "on";
      if (z === "slot") {
        u || n.onError(
          zt(40, de)
        );
        continue;
      }
      if (z === "once" || z === "memo" || z === "is" || Ce && Jr(re, "is") && (Df(S) || es(
        "COMPILER_IS_ON_ELEMENT",
        n
      )) || xe && w)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (Ce && Jr(re, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        xe && e && Jr(re, "vue:before-update")) && (h = !0), Ce && Jr(re, "ref") && n.scopes.vFor > 0 && p.push(
          Qt(
            Ot("ref_for", !0),
            Ot("true")
          )
        ), !re && (Ce || xe)
      ) {
        if (_ = !0, he)
          if (Ce) {
            if (V(), process.env.NODE_ENV !== "production" && v.some((L) => L.type === 15 ? L.properties.some(({ key: Z }) => Z.type !== 4 || !Z.isStatic ? !0 : Z.content !== "class" && Z.content !== "style" && !Gi(Z.content)) : !0) && ls(
              "COMPILER_V_BIND_OBJECT_ORDER",
              n,
              de
            ), es(
              "COMPILER_V_BIND_OBJECT_ORDER",
              n
            )) {
              v.unshift(he);
              continue;
            }
            v.push(he);
          } else
            V({
              type: 14,
              loc: de,
              callee: n.helper(qu),
              arguments: u ? [he] : [he, "true"]
            });
        else
          n.onError(
            zt(
              Ce ? 34 : 35,
              de
            )
          );
        continue;
      }
      const Ie = n.directiveTransforms[z];
      if (Ie) {
        const { props: Be, needRuntime: L } = Ie(G, i, n);
        !w && Be.forEach(I), xe && re && !Yn(re) ? V(oi(Be, d)) : p.push(...Be), L && (c.push(G), gr(L) && T1.set(G, L));
      } else
        up(z) || (c.push(G), e && (h = !0));
    }
  }
  let M;
  if (v.length ? (V(), v.length > 1 ? M = rn(
    n.helper(cl),
    v,
    d
  ) : M = v[0]) : p.length && (M = oi(
    Ly(p),
    d
  )), _ ? m |= 16 : (f && !u && (m |= 2), k && !u && (m |= 4), D.length && (m |= 8), E && (m |= 32)), !h && (m === 0 || m === 32) && (b || T || c.length > 0) && (m |= 512), !n.inSSR && M)
    switch (M.type) {
      case 15:
        let Q = -1, G = -1, z = !1;
        for (let de = 0; de < M.properties.length; de++) {
          const Ce = M.properties[de].key;
          Yn(Ce) ? Ce.content === "class" ? Q = de : Ce.content === "style" && (G = de) : Ce.isHandlerKey || (z = !0);
        }
        const re = M.properties[Q], he = M.properties[G];
        z ? M = rn(
          n.helper(Po),
          [M]
        ) : (re && !Yn(re.value) && (re.value = rn(
          n.helper(Gu),
          [re.value]
        )), he && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (k || he.value.type === 4 && he.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        he.value.type === 17) && (he.value = rn(
          n.helper(Xu),
          [he.value]
        )));
        break;
      case 14:
        break;
      default:
        M = rn(
          n.helper(Po),
          [
            rn(n.helper(Ho), [
              M
            ])
          ]
        );
        break;
    }
  return {
    props: M,
    directives: c,
    patchFlag: m,
    dynamicPropNames: D,
    shouldUseBlock: h
  };
}
function Ly(i) {
  const n = /* @__PURE__ */ new Map(), s = [];
  for (let u = 0; u < i.length; u++) {
    const y = i[u];
    if (y.key.type === 8 || !y.key.isStatic) {
      s.push(y);
      continue;
    }
    const w = y.key.content, S = n.get(w);
    S ? (w === "style" || w === "class" || Gi(w)) && t3(S, y) : (n.set(w, y), s.push(y));
  }
  return s;
}
function t3(i, n) {
  i.value.type === 17 ? i.value.elements.push(n.value) : i.value = Uo(
    [i.value, n.value],
    i.loc
  );
}
function N1(i, n) {
  const s = [], u = T1.get(i);
  u ? s.push(n.helperString(u)) : (n.helper(Uu), n.directives.add(i.name), s.push(Io(i.name, "directive")));
  const { loc: y } = i;
  if (i.exp && s.push(i.exp), i.arg && (i.exp || s.push("void 0"), s.push(i.arg)), Object.keys(i.modifiers).length) {
    i.arg || (i.exp || s.push("void 0"), s.push("void 0"));
    const w = Ot("true", !1, y);
    s.push(
      oi(
        i.modifiers.map(
          (S) => Qt(S, w)
        ),
        y
      )
    );
  }
  return Uo(s, i.loc);
}
function n3(i) {
  let n = "[";
  for (let s = 0, u = i.length; s < u; s++)
    n += JSON.stringify(i[s]), s < u - 1 && (n += ", ");
  return n + "]";
}
function Df(i) {
  return i === "component" || i === "Component";
}
const i3 = (i, n) => {
  if (fl(i)) {
    const { children: s, loc: u } = i, { slotName: y, slotProps: w } = B1(i, n), S = [
      n.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      y,
      "{}",
      "undefined",
      "true"
    ];
    let d = 2;
    w && (S[2] = w, d = 3), s.length && (S[3] = zs([], s, !1, !1, u), d = 4), n.scopeId && !n.slotted && (d = 5), S.splice(d), i.codegenNode = rn(
      n.helper(Cp),
      S,
      u
    );
  }
};
function B1(i, n) {
  let s = '"default"', u;
  const y = [];
  for (let w = 0; w < i.props.length; w++) {
    const S = i.props[w];
    S.type === 6 ? S.value && (S.name === "name" ? s = JSON.stringify(S.value.content) : (S.name = an(S.name), y.push(S))) : S.name === "bind" && Jr(S.arg, "name") ? S.exp && (s = S.exp) : (S.name === "bind" && S.arg && Yn(S.arg) && (S.arg.content = an(S.arg.content)), y.push(S));
  }
  if (y.length > 0) {
    const { props: w, directives: S } = Pp(
      i,
      n,
      y,
      !1,
      !1
    );
    u = w, S.length && n.onError(
      zt(
        36,
        S[0].loc
      )
    );
  }
  return {
    slotName: s,
    slotProps: u
  };
}
const r3 = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, Vp = (i, n, s, u) => {
  const { loc: y, modifiers: w, arg: S } = i;
  !i.exp && !w.length && s.onError(zt(35, y));
  let d;
  if (S.type === 4)
    if (S.isStatic) {
      let c = S.content;
      process.env.NODE_ENV !== "production" && c.startsWith("vnode") && s.onWarn(
        zt(51, S.loc)
      ), c.startsWith("vue:") && (c = `vnode-${c.slice(4)}`);
      const e = n.tagType !== 0 || c.startsWith("vnode") || !/[A-Z]/.test(c) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        Oi(an(c))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${c}`
      );
      d = Ot(e, !0, S.loc);
    } else
      d = bi([
        `${s.helperString(mu)}(`,
        S,
        ")"
      ]);
  else
    d = S, d.children.unshift(`${s.helperString(mu)}(`), d.children.push(")");
  let l = i.exp;
  l && !l.content.trim() && (l = void 0);
  let p = s.cacheHandlers && !l && !s.inVOnce;
  if (l) {
    const c = Ep(l.content), e = !(c || r3.test(l.content)), h = l.content.includes(";");
    process.env.NODE_ENV !== "production" && Ds(
      l,
      s,
      !1,
      h
    ), (e || p && c) && (l = bi([
      `${e ? "$event" : "(...args)"} => ${h ? "{" : "("}`,
      l,
      h ? "}" : ")"
    ]));
  }
  let v = {
    props: [
      Qt(
        d,
        l || Ot("() => {}", !1, y)
      )
    ]
  };
  return u && (v = u(v)), p && (v.props[0].value = s.cache(v.props[0].value)), v.props.forEach((c) => c.key.isHandlerKey = !0), v;
}, P1 = (i, n, s) => {
  const { exp: u, modifiers: y, loc: w } = i, S = i.arg;
  return S.type !== 4 ? (S.children.unshift("("), S.children.push(') || ""')) : S.isStatic || (S.content = `${S.content} || ""`), y.includes("camel") && (S.type === 4 ? S.isStatic ? S.content = an(S.content) : S.content = `${s.helperString(pu)}(${S.content})` : (S.children.unshift(`${s.helperString(pu)}(`), S.children.push(")"))), s.inSSR || (y.includes("prop") && zy(S, "."), y.includes("attr") && zy(S, "^")), !u || u.type === 4 && !u.content.trim() ? (s.onError(zt(34, w)), {
    props: [Qt(S, Ot("", !0, w))]
  }) : {
    props: [Qt(S, u)]
  };
}, zy = (i, n) => {
  i.type === 4 ? i.isStatic ? i.content = n + i.content : i.content = `\`${n}\${${i.content}}\`` : (i.children.unshift(`'${n}' + (`), i.children.push(")"));
}, s3 = (i, n) => {
  if (i.type === 0 || i.type === 1 || i.type === 11 || i.type === 10)
    return () => {
      const s = i.children;
      let u, y = !1;
      for (let w = 0; w < s.length; w++) {
        const S = s[w];
        if (nu(S)) {
          y = !0;
          for (let d = w + 1; d < s.length; d++) {
            const l = s[d];
            if (nu(l))
              u || (u = s[w] = bi(
                [S],
                S.loc
              )), u.children.push(" + ", l), s.splice(d, 1), d--;
            else {
              u = void 0;
              break;
            }
          }
        }
      }
      if (!(!y || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      s.length === 1 && (i.type === 0 || i.type === 1 && i.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !i.props.find(
        (w) => w.type === 7 && !n.directiveTransforms[w.name]
      ) && i.tag !== "template")))
        for (let w = 0; w < s.length; w++) {
          const S = s[w];
          if (nu(S) || S.type === 8) {
            const d = [];
            (S.type !== 2 || S.content !== " ") && d.push(S), !n.ssr && ai(S, n) === 0 && d.push(
              1 + (process.env.NODE_ENV !== "production" ? ` /* ${Bi[1]} */` : "")
            ), s[w] = {
              type: 12,
              content: S,
              loc: S.loc,
              codegenNode: rn(
                n.helper(ju),
                d
              )
            };
          }
        }
    };
}, Ry = /* @__PURE__ */ new WeakSet(), o3 = (i, n) => {
  if (i.type === 1 && Xn(i, "once", !0))
    return Ry.has(i) || n.inVOnce || n.inSSR ? void 0 : (Ry.add(i), n.inVOnce = !0, n.helper(ul), () => {
      n.inVOnce = !1;
      const s = n.currentNode;
      s.codegenNode && (s.codegenNode = n.cache(
        s.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, $p = (i, n, s) => {
  const { exp: u, arg: y } = i;
  if (!u)
    return s.onError(
      zt(41, i.loc)
    ), Uc();
  const w = u.loc.source, S = u.type === 4 ? u.content : w, d = s.bindingMetadata[w];
  if (d === "props" || d === "props-aliased")
    return s.onError(zt(44, u.loc)), Uc();
  if (!S.trim() || !Ep(S) && !!1)
    return s.onError(
      zt(42, u.loc)
    ), Uc();
  const p = y || Ot("modelValue", !0), v = y ? Yn(y) ? `onUpdate:${an(y.content)}` : bi(['"onUpdate:" + ', y]) : "onUpdate:modelValue";
  let c;
  const e = s.isTS ? "($event: any)" : "$event";
  c = bi([
    `${e} => ((`,
    u,
    ") = $event)"
  ]);
  const h = [
    // modelValue: foo
    Qt(p, i.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Qt(v, c)
  ];
  if (i.modifiers.length && n.tagType === 1) {
    const m = i.modifiers.map((f) => (Vl(f) ? f : JSON.stringify(f)) + ": true").join(", "), b = y ? Yn(y) ? `${y.content}Modifiers` : bi([y, ' + "Modifiers"']) : "modelModifiers";
    h.push(
      Qt(
        b,
        Ot(
          `{ ${m} }`,
          !1,
          i.loc,
          2
        )
      )
    );
  }
  return Uc(h);
};
function Uc(i = []) {
  return { props: i };
}
const a3 = /[\w).+\-_$\]]/, l3 = (i, n) => {
  es("COMPILER_FILTER", n) && (i.type === 5 && bu(i.content, n), i.type === 1 && i.props.forEach((s) => {
    s.type === 7 && s.name !== "for" && s.exp && bu(s.exp, n);
  }));
};
function bu(i, n) {
  if (i.type === 4)
    jy(i, n);
  else
    for (let s = 0; s < i.children.length; s++) {
      const u = i.children[s];
      typeof u == "object" && (u.type === 4 ? jy(u, n) : u.type === 8 ? bu(i, n) : u.type === 5 && bu(u.content, n));
    }
}
function jy(i, n) {
  const s = i.content;
  let u = !1, y = !1, w = !1, S = !1, d = 0, l = 0, p = 0, v = 0, c, e, h, m, b = [];
  for (h = 0; h < s.length; h++)
    if (e = c, c = s.charCodeAt(h), u)
      c === 39 && e !== 92 && (u = !1);
    else if (y)
      c === 34 && e !== 92 && (y = !1);
    else if (w)
      c === 96 && e !== 92 && (w = !1);
    else if (S)
      c === 47 && e !== 92 && (S = !1);
    else if (c === 124 && // pipe
    s.charCodeAt(h + 1) !== 124 && s.charCodeAt(h - 1) !== 124 && !d && !l && !p)
      m === void 0 ? (v = h + 1, m = s.slice(0, h).trim()) : f();
    else {
      switch (c) {
        case 34:
          y = !0;
          break;
        case 39:
          u = !0;
          break;
        case 96:
          w = !0;
          break;
        case 40:
          p++;
          break;
        case 41:
          p--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          d++;
          break;
        case 125:
          d--;
          break;
      }
      if (c === 47) {
        let k = h - 1, E;
        for (; k >= 0 && (E = s.charAt(k), E === " "); k--)
          ;
        (!E || !a3.test(E)) && (S = !0);
      }
    }
  m === void 0 ? m = s.slice(0, h).trim() : v !== 0 && f();
  function f() {
    b.push(s.slice(v, h).trim()), v = h + 1;
  }
  if (b.length) {
    for (process.env.NODE_ENV !== "production" && $l(
      "COMPILER_FILTER",
      n,
      i.loc
    ), h = 0; h < b.length; h++)
      m = c3(m, b[h], n);
    i.content = m;
  }
}
function c3(i, n, s) {
  s.helper(Wu);
  const u = n.indexOf("(");
  if (u < 0)
    return s.filters.add(n), `${Io(n, "filter")}(${i})`;
  {
    const y = n.slice(0, u), w = n.slice(u + 1);
    return s.filters.add(y), `${Io(y, "filter")}(${i}${w !== ")" ? "," + w : w}`;
  }
}
const Hy = /* @__PURE__ */ new WeakSet(), u3 = (i, n) => {
  if (i.type === 1) {
    const s = Xn(i, "memo");
    return !s || Hy.has(i) ? void 0 : (Hy.add(i), () => {
      const u = i.codegenNode || n.currentNode.codegenNode;
      u && u.type === 13 && (i.tagType !== 1 && Zu(u, n), i.codegenNode = rn(n.helper(Qu), [
        s.exp,
        zs(void 0, u),
        "_cache",
        String(n.cached++)
      ]));
    });
  }
};
function V1(i) {
  return [
    [
      o3,
      YA,
      u3,
      XA,
      l3,
      ...process.env.NODE_ENV !== "production" ? [C1] : [],
      i3,
      O1,
      E1,
      s3
    ],
    {
      on: Vp,
      bind: P1,
      model: $p
    }
  ];
}
function $1(i, n = {}) {
  const s = n.onError || mp, u = n.mode === "module";
  n.prefixIdentifiers === !0 ? s(zt(47)) : u && s(zt(48));
  const y = !1;
  n.cacheHandlers && s(zt(49)), n.scopeId && !u && s(zt(50));
  const w = wt(i) ? Tp(i, n) : i, [S, d] = V1();
  return p1(
    w,
    _t({}, n, {
      prefixIdentifiers: y,
      nodeTransforms: [
        ...S,
        ...n.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: _t(
        {},
        d,
        n.directiveTransforms || {}
        // user transforms
      )
    })
  ), g1(
    w,
    _t({}, n, {
      prefixIdentifiers: y
    })
  );
}
const I1 = () => ({ props: [] }), Ip = Symbol(process.env.NODE_ENV !== "production" ? "vModelRadio" : ""), Mp = Symbol(process.env.NODE_ENV !== "production" ? "vModelCheckbox" : ""), Ap = Symbol(process.env.NODE_ENV !== "production" ? "vModelText" : ""), Fp = Symbol(process.env.NODE_ENV !== "production" ? "vModelSelect" : ""), Cu = Symbol(process.env.NODE_ENV !== "production" ? "vModelDynamic" : ""), Lp = Symbol(process.env.NODE_ENV !== "production" ? "vOnModifiersGuard" : ""), zp = Symbol(process.env.NODE_ENV !== "production" ? "vOnKeysGuard" : ""), Rp = Symbol(process.env.NODE_ENV !== "production" ? "vShow" : ""), nh = Symbol(process.env.NODE_ENV !== "production" ? "Transition" : ""), jp = Symbol(process.env.NODE_ENV !== "production" ? "TransitionGroup" : "");
ZC({
  [Ip]: "vModelRadio",
  [Mp]: "vModelCheckbox",
  [Ap]: "vModelText",
  [Fp]: "vModelSelect",
  [Cu]: "vModelDynamic",
  [Lp]: "withModifiers",
  [zp]: "withKeys",
  [Rp]: "vShow",
  [nh]: "Transition",
  [jp]: "TransitionGroup"
});
let bo;
function h3(i, n = !1) {
  return bo || (bo = document.createElement("div")), n ? (bo.innerHTML = `<div foo="${i.replace(/"/g, "&quot;")}">`, bo.children[0].getAttribute("foo")) : (bo.innerHTML = i, bo.textContent);
}
const d3 = /* @__PURE__ */ fn(
  "style,iframe,script,noscript",
  !0
), Hp = {
  isVoidTag: jC,
  isNativeTag: (i) => dp(i) || fp(i),
  isPreTag: (i) => i === "pre",
  decodeEntities: h3,
  isBuiltInComponent: (i) => {
    if (qr(i, "Transition"))
      return nh;
    if (qr(i, "TransitionGroup"))
      return jp;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(i, n) {
    let s = n ? n.ns : 0;
    if (n && s === 2)
      if (n.tag === "annotation-xml") {
        if (i === "svg")
          return 1;
        n.props.some(
          (u) => u.type === 6 && u.name === "encoding" && u.value != null && (u.value.content === "text/html" || u.value.content === "application/xhtml+xml")
        ) && (s = 0);
      } else
        /^m(?:[ions]|text)$/.test(n.tag) && i !== "mglyph" && i !== "malignmark" && (s = 0);
    else
      n && s === 1 && (n.tag === "foreignObject" || n.tag === "desc" || n.tag === "title") && (s = 0);
    if (s === 0) {
      if (i === "svg")
        return 1;
      if (i === "math")
        return 2;
    }
    return s;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag: i, ns: n }) {
    if (n === 0) {
      if (i === "textarea" || i === "title")
        return 1;
      if (d3(i))
        return 2;
    }
    return 0;
  }
}, M1 = (i) => {
  i.type === 1 && i.props.forEach((n, s) => {
    n.type === 6 && n.name === "style" && n.value && (i.props[s] = {
      type: 7,
      name: "bind",
      arg: Ot("style", !0, n.loc),
      exp: f3(n.value.content, n.loc),
      modifiers: [],
      loc: n.loc
    });
  });
}, f3 = (i, n) => {
  const s = hp(i);
  return Ot(
    JSON.stringify(s),
    !1,
    n,
    3
  );
};
function yi(i, n) {
  return zt(
    i,
    n,
    process.env.NODE_ENV !== "production" ? p3 : void 0
  );
}
const p3 = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, m3 = (i, n, s) => {
  const { exp: u, loc: y } = i;
  return u || s.onError(
    yi(53, y)
  ), n.children.length && (s.onError(
    yi(54, y)
  ), n.children.length = 0), {
    props: [
      Qt(
        Ot("innerHTML", !0, y),
        u || Ot("", !0)
      )
    ]
  };
}, g3 = (i, n, s) => {
  const { exp: u, loc: y } = i;
  return u || s.onError(
    yi(55, y)
  ), n.children.length && (s.onError(
    yi(56, y)
  ), n.children.length = 0), {
    props: [
      Qt(
        Ot("textContent", !0),
        u ? ai(u, s) > 0 ? u : rn(
          s.helperString(Pl),
          [u],
          y
        ) : Ot("", !0)
      )
    ]
  };
}, v3 = (i, n, s) => {
  const u = $p(i, n, s);
  if (!u.props.length || n.tagType === 1)
    return u;
  i.arg && s.onError(
    yi(
      58,
      i.arg.loc
    )
  );
  function y() {
    const d = Hs(n, "value");
    d && s.onError(
      yi(
        60,
        d.loc
      )
    );
  }
  const { tag: w } = n, S = s.isCustomElement(w);
  if (w === "input" || w === "textarea" || w === "select" || S) {
    let d = Ap, l = !1;
    if (w === "input" || S) {
      const p = Hs(n, "type");
      if (p) {
        if (p.type === 7)
          d = Cu;
        else if (p.value)
          switch (p.value.content) {
            case "radio":
              d = Ip;
              break;
            case "checkbox":
              d = Mp;
              break;
            case "file":
              l = !0, s.onError(
                yi(
                  59,
                  i.loc
                )
              );
              break;
            default:
              process.env.NODE_ENV !== "production" && y();
              break;
          }
      } else
        r1(n) ? d = Cu : process.env.NODE_ENV !== "production" && y();
    } else
      w === "select" ? d = Fp : process.env.NODE_ENV !== "production" && y();
    l || (u.needRuntime = s.helper(d));
  } else
    s.onError(
      yi(
        57,
        i.loc
      )
    );
  return u.props = u.props.filter(
    (d) => !(d.key.type === 4 && d.key.content === "modelValue")
  ), u;
}, y3 = /* @__PURE__ */ fn("passive,once,capture"), b3 = /* @__PURE__ */ fn(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), C3 = /* @__PURE__ */ fn("left,right"), A1 = /* @__PURE__ */ fn(
  "onkeyup,onkeydown,onkeypress",
  !0
), w3 = (i, n, s, u) => {
  const y = [], w = [], S = [];
  for (let d = 0; d < n.length; d++) {
    const l = n[d];
    l === "native" && ls(
      "COMPILER_V_ON_NATIVE",
      s,
      u
    ) || y3(l) ? S.push(l) : C3(l) ? Yn(i) ? A1(i.content) ? y.push(l) : w.push(l) : (y.push(l), w.push(l)) : b3(l) ? w.push(l) : y.push(l);
  }
  return {
    keyModifiers: y,
    nonKeyModifiers: w,
    eventOptionModifiers: S
  };
}, Uy = (i, n) => Yn(i) && i.content.toLowerCase() === "onclick" ? Ot(n, !0) : i.type !== 4 ? bi([
  "(",
  i,
  `) === "onClick" ? "${n}" : (`,
  i,
  ")"
]) : i, k3 = (i, n, s) => Vp(i, n, s, (u) => {
  const { modifiers: y } = i;
  if (!y.length)
    return u;
  let { key: w, value: S } = u.props[0];
  const { keyModifiers: d, nonKeyModifiers: l, eventOptionModifiers: p } = w3(w, y, s, i.loc);
  if (l.includes("right") && (w = Uy(w, "onContextmenu")), l.includes("middle") && (w = Uy(w, "onMouseup")), l.length && (S = rn(s.helper(Lp), [
    S,
    JSON.stringify(l)
  ])), d.length && // if event name is dynamic, always wrap with keys guard
  (!Yn(w) || A1(w.content)) && (S = rn(s.helper(zp), [
    S,
    JSON.stringify(d)
  ])), p.length) {
    const v = p.map(Pi).join("");
    w = Yn(w) ? Ot(`${w.content}${v}`, !0) : bi(["(", w, `) + "${v}"`]);
  }
  return {
    props: [Qt(w, S)]
  };
}), S3 = (i, n, s) => {
  const { exp: u, loc: y } = i;
  return u || s.onError(
    yi(61, y)
  ), {
    props: [],
    needRuntime: s.helper(Rp)
  };
}, E3 = (i, n) => {
  if (i.type === 1 && i.tagType === 1 && n.isBuiltInComponent(i.tag) === nh)
    return () => {
      if (!i.children.length)
        return;
      F1(i) && n.onError(
        yi(
          62,
          {
            start: i.children[0].loc.start,
            end: i.children[i.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const u = i.children[0];
      if (u.type === 1)
        for (const y of u.props)
          y.type === 7 && y.name === "show" && i.props.push({
            type: 6,
            name: "persisted",
            value: void 0,
            loc: i.loc
          });
    };
};
function F1(i) {
  const n = i.children = i.children.filter(
    (u) => u.type !== 3 && !(u.type === 2 && !u.content.trim())
  ), s = n[0];
  return n.length !== 1 || s.type === 11 || s.type === 9 && s.branches.some(F1);
}
const x3 = (i, n) => {
  i.type === 1 && i.tagType === 0 && (i.tag === "script" || i.tag === "style") && (process.env.NODE_ENV !== "production" && n.onError(
    yi(
      63,
      i.loc
    )
  ), n.removeNode());
}, L1 = [
  M1,
  ...process.env.NODE_ENV !== "production" ? [E3] : []
], z1 = {
  cloak: I1,
  html: m3,
  text: g3,
  model: v3,
  // override compiler-core
  on: k3,
  // override compiler-core
  show: S3
};
function _3(i, n = {}) {
  return $1(
    i,
    _t({}, Hp, n, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        x3,
        ...L1,
        ...n.nodeTransforms || []
      ],
      directiveTransforms: _t(
        {},
        z1,
        n.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function T3(i, n = {}) {
  return Tp(i, _t({}, Hp, n));
}
const O3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BASE_TRANSITION: gp,
  CAMELIZE: pu,
  CAPITALIZE: GC,
  CREATE_BLOCK: vp,
  CREATE_COMMENT: jo,
  CREATE_ELEMENT_BLOCK: yp,
  CREATE_ELEMENT_VNODE: Ru,
  CREATE_SLOTS: wp,
  CREATE_STATIC: bp,
  CREATE_TEXT: ju,
  CREATE_VNODE: zu,
  DOMDirectiveTransforms: z1,
  DOMNodeTransforms: L1,
  FRAGMENT: Bo,
  GUARD_REACTIVE_PROPS: Ho,
  IS_MEMO_SAME: kp,
  IS_REF: QC,
  KEEP_ALIVE: al,
  MERGE_PROPS: cl,
  NORMALIZE_CLASS: Gu,
  NORMALIZE_PROPS: Po,
  NORMALIZE_STYLE: Xu,
  OPEN_BLOCK: as,
  POP_SCOPE_ID: qC,
  PUSH_SCOPE_ID: XC,
  RENDER_LIST: Ku,
  RENDER_SLOT: Cp,
  RESOLVE_COMPONENT: Hu,
  RESOLVE_DIRECTIVE: Uu,
  RESOLVE_DYNAMIC_COMPONENT: ll,
  RESOLVE_FILTER: Wu,
  SET_BLOCK_TRACKING: ul,
  SUSPENSE: Lu,
  TELEPORT: To,
  TO_DISPLAY_STRING: Pl,
  TO_HANDLERS: qu,
  TO_HANDLER_KEY: mu,
  TRANSITION: nh,
  TRANSITION_GROUP: jp,
  TS_NODE_TYPES: HA,
  UNREF: JC,
  V_MODEL_CHECKBOX: Mp,
  V_MODEL_DYNAMIC: Cu,
  V_MODEL_RADIO: Ip,
  V_MODEL_SELECT: Fp,
  V_MODEL_TEXT: Ap,
  V_ON_WITH_KEYS: zp,
  V_ON_WITH_MODIFIERS: Lp,
  V_SHOW: Rp,
  WITH_CTX: Ju,
  WITH_DIRECTIVES: Yu,
  WITH_MEMO: Qu,
  advancePositionWithClone: hl,
  advancePositionWithMutation: dl,
  assert: xf,
  baseCompile: $1,
  baseParse: Tp,
  buildDirectiveArgs: N1,
  buildProps: Pp,
  buildSlots: x1,
  checkCompatEnabled: ls,
  compile: _3,
  convertToBlock: Zu,
  createArrayExpression: Uo,
  createAssignmentExpression: XM,
  createBlockStatement: n1,
  createCacheExpression: t1,
  createCallExpression: rn,
  createCompilerError: zt,
  createCompoundExpression: bi,
  createConditionalExpression: gu,
  createDOMCompilerError: yi,
  createForLoopParams: yu,
  createFunctionExpression: zs,
  createIfStatement: GM,
  createInterpolation: YM,
  createObjectExpression: oi,
  createObjectProperty: Qt,
  createReturnStatement: JM,
  createRoot: e1,
  createSequenceExpression: qM,
  createSimpleExpression: Ot,
  createStructuralDirectiveTransform: Dp,
  createTemplateLiteral: KM,
  createTransformContext: f1,
  createVNodeCall: Vo,
  extractIdentifiers: Kr,
  findDir: Xn,
  findProp: Hs,
  generate: g1,
  generateCodeFrame: zC,
  getBaseTransformPreset: V1,
  getConstantType: ai,
  getInnerRange: xp,
  getMemoedVNodeCall: o1,
  getVNodeBlockHelper: js,
  getVNodeHelper: Rs,
  hasDynamicKeyVBind: r1,
  hasScopeRef: Ti,
  helperNameMap: Ls,
  injectProp: pl,
  isBuiltInType: qr,
  isCoreComponent: Sp,
  isFunctionType: RA,
  isInDestructureAssignment: FA,
  isMemberExpression: Ep,
  isMemberExpressionBrowser: i1,
  isMemberExpressionNode: nA,
  isReferencedIdentifier: AA,
  isSimpleIdentifier: Vl,
  isSlotOutlet: fl,
  isStaticArgOf: Jr,
  isStaticExp: Yn,
  isStaticProperty: b1,
  isStaticPropertyKey: jA,
  isTemplateNode: $o,
  isText: nu,
  isVSlot: _p,
  locStub: kn,
  noopDirectiveTransform: I1,
  parse: T3,
  parserOptions: Hp,
  processExpression: ru,
  processFor: S1,
  processIf: k1,
  processSlotOutlet: B1,
  registerRuntimeHelpers: ZC,
  resolveComponentType: D1,
  stringifyExpression: w1,
  toValidAssetId: Io,
  trackSlotScopes: E1,
  trackVForSlotScopes: ZA,
  transform: p1,
  transformBind: P1,
  transformElement: O1,
  transformExpression: C1,
  transformModel: $p,
  transformOn: Vp,
  transformStyle: M1,
  traverseNode: Il,
  walkBlockDeclarations: zA,
  walkFunctionParams: LA,
  walkIdentifiers: MA,
  warnDeprecation: $l
}, Symbol.toStringTag, { value: "Module" })), R1 = /* @__PURE__ */ Vu(O3);
function wu(i, ...n) {
  console.warn(`[Vue warn] ${i}`, ...n);
}
let ri;
class Up {
  constructor(n = !1) {
    this.detached = n, this._active = !0, this.effects = [], this.cleanups = [], this.parent = ri, !n && ri && (this.index = (ri.scopes || (ri.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(n) {
    if (this._active) {
      const s = ri;
      try {
        return ri = this, n();
      } finally {
        ri = s;
      }
    } else
      process.env.NODE_ENV !== "production" && wu("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ri = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    ri = this.parent;
  }
  stop(n) {
    if (this._active) {
      let s, u;
      for (s = 0, u = this.effects.length; s < u; s++)
        this.effects[s].stop();
      for (s = 0, u = this.cleanups.length; s < u; s++)
        this.cleanups[s]();
      if (this.scopes)
        for (s = 0, u = this.scopes.length; s < u; s++)
          this.scopes[s].stop(!0);
      if (!this.detached && this.parent && !n) {
        const y = this.parent.scopes.pop();
        y && y !== this && (this.parent.scopes[this.index] = y, y.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function D3(i) {
  return new Up(i);
}
function j1(i, n = ri) {
  n && n.active && n.effects.push(i);
}
function H1() {
  return ri;
}
function N3(i) {
  ri ? ri.cleanups.push(i) : process.env.NODE_ENV !== "production" && wu(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
const gl = (i) => {
  const n = new Set(i);
  return n.w = 0, n.n = 0, n;
}, U1 = (i) => (i.w & cs) > 0, W1 = (i) => (i.n & cs) > 0, B3 = ({ deps: i }) => {
  if (i.length)
    for (let n = 0; n < i.length; n++)
      i[n].w |= cs;
}, P3 = (i) => {
  const { deps: n } = i;
  if (n.length) {
    let s = 0;
    for (let u = 0; u < n.length; u++) {
      const y = n[u];
      U1(y) && !W1(y) ? y.delete(i) : n[s++] = y, y.w &= ~cs, y.n &= ~cs;
    }
    n.length = s;
  }
}, ku = /* @__PURE__ */ new WeakMap();
let za = 0, cs = 1;
const Nf = 30;
let Wn;
const Ps = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : ""), Bf = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class Al {
  constructor(n, s = null, u) {
    this.fn = n, this.scheduler = s, this.active = !0, this.deps = [], this.parent = void 0, j1(this, u);
  }
  run() {
    if (!this.active)
      return this.fn();
    let n = Wn, s = ts;
    for (; n; ) {
      if (n === this)
        return;
      n = n.parent;
    }
    try {
      return this.parent = Wn, Wn = this, ts = !0, cs = 1 << ++za, za <= Nf ? B3(this) : Wy(this), this.fn();
    } finally {
      za <= Nf && P3(this), cs = 1 << --za, Wn = this.parent, ts = s, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Wn === this ? this.deferStop = !0 : this.active && (Wy(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function Wy(i) {
  const { deps: n } = i;
  if (n.length) {
    for (let s = 0; s < n.length; s++)
      n[s].delete(i);
    n.length = 0;
  }
}
function V3(i, n) {
  i.effect && (i = i.effect.fn);
  const s = new Al(i);
  n && (_t(s, n), n.scope && j1(s, n.scope)), (!n || !n.lazy) && s.run();
  const u = s.run.bind(s);
  return u.effect = s, u;
}
function $3(i) {
  i.effect.stop();
}
let ts = !0;
const Y1 = [];
function Gs() {
  Y1.push(ts), ts = !1;
}
function Xs() {
  const i = Y1.pop();
  ts = i === void 0 ? !0 : i;
}
function Pn(i, n, s) {
  if (ts && Wn) {
    let u = ku.get(i);
    u || ku.set(i, u = /* @__PURE__ */ new Map());
    let y = u.get(s);
    y || u.set(s, y = gl());
    const w = process.env.NODE_ENV !== "production" ? { effect: Wn, target: i, type: n, key: s } : void 0;
    Pf(y, w);
  }
}
function Pf(i, n) {
  let s = !1;
  za <= Nf ? W1(i) || (i.n |= cs, s = !U1(i)) : s = !i.has(Wn), s && (i.add(Wn), Wn.deps.push(i), process.env.NODE_ENV !== "production" && Wn.onTrack && Wn.onTrack(
    _t(
      {
        effect: Wn
      },
      n
    )
  ));
}
function Xi(i, n, s, u, y, w) {
  const S = ku.get(i);
  if (!S)
    return;
  let d = [];
  if (n === "clear")
    d = [...S.values()];
  else if (s === "length" && Je(i)) {
    const p = Number(u);
    S.forEach((v, c) => {
      (c === "length" || c >= p) && d.push(v);
    });
  } else
    switch (s !== void 0 && d.push(S.get(s)), n) {
      case "add":
        Je(i) ? Au(s) && d.push(S.get("length")) : (d.push(S.get(Ps)), Qr(i) && d.push(S.get(Bf)));
        break;
      case "delete":
        Je(i) || (d.push(S.get(Ps)), Qr(i) && d.push(S.get(Bf)));
        break;
      case "set":
        Qr(i) && d.push(S.get(Ps));
        break;
    }
  const l = process.env.NODE_ENV !== "production" ? { target: i, type: n, key: s, newValue: u, oldValue: y, oldTarget: w } : void 0;
  if (d.length === 1)
    d[0] && (process.env.NODE_ENV !== "production" ? ko(d[0], l) : ko(d[0]));
  else {
    const p = [];
    for (const v of d)
      v && p.push(...v);
    process.env.NODE_ENV !== "production" ? ko(gl(p), l) : ko(gl(p));
  }
}
function ko(i, n) {
  const s = Je(i) ? i : [...i];
  for (const u of s)
    u.computed && Yy(u, n);
  for (const u of s)
    u.computed || Yy(u, n);
}
function Yy(i, n) {
  (i !== Wn || i.allowRecurse) && (process.env.NODE_ENV !== "production" && i.onTrigger && i.onTrigger(_t({ effect: i }, n)), i.scheduler ? i.scheduler() : i.run());
}
function I3(i, n) {
  var s;
  return (s = ku.get(i)) == null ? void 0 : s.get(n);
}
const M3 = /* @__PURE__ */ fn("__proto__,__v_isRef,__isVue"), K1 = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((i) => i !== "arguments" && i !== "caller").map((i) => Symbol[i]).filter(gr)
), A3 = /* @__PURE__ */ ih(), F3 = /* @__PURE__ */ ih(!1, !0), L3 = /* @__PURE__ */ ih(!0), z3 = /* @__PURE__ */ ih(!0, !0), Ky = /* @__PURE__ */ R3();
function R3() {
  const i = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((n) => {
    i[n] = function(...s) {
      const u = Et(this);
      for (let w = 0, S = this.length; w < S; w++)
        Pn(u, "get", w + "");
      const y = u[n](...s);
      return y === -1 || y === !1 ? u[n](...s.map(Et)) : y;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((n) => {
    i[n] = function(...s) {
      Gs();
      const u = Et(this)[n].apply(this, s);
      return Xs(), u;
    };
  }), i;
}
function j3(i) {
  const n = Et(this);
  return Pn(n, "has", i), n.hasOwnProperty(i);
}
function ih(i = !1, n = !1) {
  return function(u, y, w) {
    if (y === "__v_isReactive")
      return !i;
    if (y === "__v_isReadonly")
      return i;
    if (y === "__v_isShallow")
      return n;
    if (y === "__v_raw" && w === (i ? n ? tw : ew : n ? Z1 : Q1).get(u))
      return u;
    const S = Je(u);
    if (!i) {
      if (S && Dt(Ky, y))
        return Reflect.get(Ky, y, w);
      if (y === "hasOwnProperty")
        return j3;
    }
    const d = Reflect.get(u, y, w);
    return (gr(y) ? K1.has(y) : M3(y)) || (i || Pn(u, "get", y), n) ? d : tn(d) ? S && Au(y) ? d : d.value : Nt(d) ? i ? Yp(d) : oh(d) : d;
  };
}
const H3 = /* @__PURE__ */ G1(), U3 = /* @__PURE__ */ G1(!0);
function G1(i = !1) {
  return function(s, u, y, w) {
    let S = s[u];
    if (yr(S) && tn(S) && !tn(y))
      return !1;
    if (!i && (!vl(y) && !yr(y) && (S = Et(S), y = Et(y)), !Je(s) && tn(S) && !tn(y)))
      return S.value = y, !0;
    const d = Je(s) && Au(u) ? Number(u) < s.length : Dt(s, u), l = Reflect.set(s, u, y, w);
    return s === Et(w) && (d ? As(y, S) && Xi(s, "set", u, y, S) : Xi(s, "add", u, y)), l;
  };
}
function W3(i, n) {
  const s = Dt(i, n), u = i[n], y = Reflect.deleteProperty(i, n);
  return y && s && Xi(i, "delete", n, void 0, u), y;
}
function Y3(i, n) {
  const s = Reflect.has(i, n);
  return (!gr(n) || !K1.has(n)) && Pn(i, "has", n), s;
}
function K3(i) {
  return Pn(i, "iterate", Je(i) ? "length" : Ps), Reflect.ownKeys(i);
}
const X1 = {
  get: A3,
  set: H3,
  deleteProperty: W3,
  has: Y3,
  ownKeys: K3
}, q1 = {
  get: L3,
  set(i, n) {
    return process.env.NODE_ENV !== "production" && wu(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      i
    ), !0;
  },
  deleteProperty(i, n) {
    return process.env.NODE_ENV !== "production" && wu(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      i
    ), !0;
  }
}, G3 = /* @__PURE__ */ _t(
  {},
  X1,
  {
    get: F3,
    set: U3
  }
), X3 = /* @__PURE__ */ _t(
  {},
  q1,
  {
    get: z3
  }
), Wp = (i) => i, rh = (i) => Reflect.getPrototypeOf(i);
function Wc(i, n, s = !1, u = !1) {
  i = i.__v_raw;
  const y = Et(i), w = Et(n);
  s || (n !== w && Pn(y, "get", n), Pn(y, "get", w));
  const { has: S } = rh(y), d = u ? Wp : s ? Gp : bl;
  if (S.call(y, n))
    return d(i.get(n));
  if (S.call(y, w))
    return d(i.get(w));
  i !== y && i.get(n);
}
function Yc(i, n = !1) {
  const s = this.__v_raw, u = Et(s), y = Et(i);
  return n || (i !== y && Pn(u, "has", i), Pn(u, "has", y)), i === y ? s.has(i) : s.has(i) || s.has(y);
}
function Kc(i, n = !1) {
  return i = i.__v_raw, !n && Pn(Et(i), "iterate", Ps), Reflect.get(i, "size", i);
}
function Gy(i) {
  i = Et(i);
  const n = Et(this);
  return rh(n).has.call(n, i) || (n.add(i), Xi(n, "add", i, i)), this;
}
function Xy(i, n) {
  n = Et(n);
  const s = Et(this), { has: u, get: y } = rh(s);
  let w = u.call(s, i);
  w ? process.env.NODE_ENV !== "production" && J1(s, u, i) : (i = Et(i), w = u.call(s, i));
  const S = y.call(s, i);
  return s.set(i, n), w ? As(n, S) && Xi(s, "set", i, n, S) : Xi(s, "add", i, n), this;
}
function qy(i) {
  const n = Et(this), { has: s, get: u } = rh(n);
  let y = s.call(n, i);
  y ? process.env.NODE_ENV !== "production" && J1(n, s, i) : (i = Et(i), y = s.call(n, i));
  const w = u ? u.call(n, i) : void 0, S = n.delete(i);
  return y && Xi(n, "delete", i, void 0, w), S;
}
function Jy() {
  const i = Et(this), n = i.size !== 0, s = process.env.NODE_ENV !== "production" ? Qr(i) ? new Map(i) : new Set(i) : void 0, u = i.clear();
  return n && Xi(i, "clear", void 0, void 0, s), u;
}
function Gc(i, n) {
  return function(u, y) {
    const w = this, S = w.__v_raw, d = Et(S), l = n ? Wp : i ? Gp : bl;
    return !i && Pn(d, "iterate", Ps), S.forEach((p, v) => u.call(y, l(p), l(v), w));
  };
}
function Xc(i, n, s) {
  return function(...u) {
    const y = this.__v_raw, w = Et(y), S = Qr(w), d = i === "entries" || i === Symbol.iterator && S, l = i === "keys" && S, p = y[i](...u), v = s ? Wp : n ? Gp : bl;
    return !n && Pn(
      w,
      "iterate",
      l ? Bf : Ps
    ), {
      // iterator protocol
      next() {
        const { value: c, done: e } = p.next();
        return e ? { value: c, done: e } : {
          value: d ? [v(c[0]), v(c[1])] : v(c),
          done: e
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Lr(i) {
  return function(...n) {
    if (process.env.NODE_ENV !== "production") {
      const s = n[0] ? `on key "${n[0]}" ` : "";
      console.warn(
        `${Pi(i)} operation ${s}failed: target is readonly.`,
        Et(this)
      );
    }
    return i === "delete" ? !1 : this;
  };
}
function q3() {
  const i = {
    get(w) {
      return Wc(this, w);
    },
    get size() {
      return Kc(this);
    },
    has: Yc,
    add: Gy,
    set: Xy,
    delete: qy,
    clear: Jy,
    forEach: Gc(!1, !1)
  }, n = {
    get(w) {
      return Wc(this, w, !1, !0);
    },
    get size() {
      return Kc(this);
    },
    has: Yc,
    add: Gy,
    set: Xy,
    delete: qy,
    clear: Jy,
    forEach: Gc(!1, !0)
  }, s = {
    get(w) {
      return Wc(this, w, !0);
    },
    get size() {
      return Kc(this, !0);
    },
    has(w) {
      return Yc.call(this, w, !0);
    },
    add: Lr("add"),
    set: Lr("set"),
    delete: Lr("delete"),
    clear: Lr("clear"),
    forEach: Gc(!0, !1)
  }, u = {
    get(w) {
      return Wc(this, w, !0, !0);
    },
    get size() {
      return Kc(this, !0);
    },
    has(w) {
      return Yc.call(this, w, !0);
    },
    add: Lr("add"),
    set: Lr("set"),
    delete: Lr("delete"),
    clear: Lr("clear"),
    forEach: Gc(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((w) => {
    i[w] = Xc(
      w,
      !1,
      !1
    ), s[w] = Xc(
      w,
      !0,
      !1
    ), n[w] = Xc(
      w,
      !1,
      !0
    ), u[w] = Xc(
      w,
      !0,
      !0
    );
  }), [
    i,
    s,
    n,
    u
  ];
}
const [
  J3,
  Q3,
  Z3,
  eF
] = /* @__PURE__ */ q3();
function sh(i, n) {
  const s = n ? i ? eF : Z3 : i ? Q3 : J3;
  return (u, y, w) => y === "__v_isReactive" ? !i : y === "__v_isReadonly" ? i : y === "__v_raw" ? u : Reflect.get(
    Dt(s, y) && y in u ? s : u,
    y,
    w
  );
}
const tF = {
  get: /* @__PURE__ */ sh(!1, !1)
}, nF = {
  get: /* @__PURE__ */ sh(!1, !0)
}, iF = {
  get: /* @__PURE__ */ sh(!0, !1)
}, rF = {
  get: /* @__PURE__ */ sh(!0, !0)
};
function J1(i, n, s) {
  const u = Et(s);
  if (u !== s && n.call(i, u)) {
    const y = Mu(i);
    console.warn(
      `Reactive ${y} contains both the raw and reactive versions of the same object${y === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const Q1 = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), ew = /* @__PURE__ */ new WeakMap(), tw = /* @__PURE__ */ new WeakMap();
function sF(i) {
  switch (i) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function oF(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : sF(Mu(i));
}
function oh(i) {
  return yr(i) ? i : ah(
    i,
    !1,
    X1,
    tF,
    Q1
  );
}
function nw(i) {
  return ah(
    i,
    !1,
    G3,
    nF,
    Z1
  );
}
function Yp(i) {
  return ah(
    i,
    !0,
    q1,
    iF,
    ew
  );
}
function So(i) {
  return ah(
    i,
    !0,
    X3,
    rF,
    tw
  );
}
function ah(i, n, s, u, y) {
  if (!Nt(i))
    return process.env.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(i)}`), i;
  if (i.__v_raw && !(n && i.__v_isReactive))
    return i;
  const w = y.get(i);
  if (w)
    return w;
  const S = oF(i);
  if (S === 0)
    return i;
  const d = new Proxy(
    i,
    S === 2 ? u : s
  );
  return y.set(i, d), d;
}
function ns(i) {
  return yr(i) ? ns(i.__v_raw) : !!(i && i.__v_isReactive);
}
function yr(i) {
  return !!(i && i.__v_isReadonly);
}
function vl(i) {
  return !!(i && i.__v_isShallow);
}
function yl(i) {
  return ns(i) || yr(i);
}
function Et(i) {
  const n = i && i.__v_raw;
  return n ? Et(n) : i;
}
function Kp(i) {
  return rl(i, "__v_skip", !0), i;
}
const bl = (i) => Nt(i) ? oh(i) : i, Gp = (i) => Nt(i) ? Yp(i) : i;
function Xp(i) {
  ts && Wn && (i = Et(i), process.env.NODE_ENV !== "production" ? Pf(i.dep || (i.dep = gl()), {
    target: i,
    type: "get",
    key: "value"
  }) : Pf(i.dep || (i.dep = gl())));
}
function lh(i, n) {
  i = Et(i);
  const s = i.dep;
  s && (process.env.NODE_ENV !== "production" ? ko(s, {
    target: i,
    type: "set",
    key: "value",
    newValue: n
  }) : ko(s));
}
function tn(i) {
  return !!(i && i.__v_isRef === !0);
}
function is(i) {
  return iw(i, !1);
}
function aF(i) {
  return iw(i, !0);
}
function iw(i, n) {
  return tn(i) ? i : new lF(i, n);
}
class lF {
  constructor(n, s) {
    this.__v_isShallow = s, this.dep = void 0, this.__v_isRef = !0, this._rawValue = s ? n : Et(n), this._value = s ? n : bl(n);
  }
  get value() {
    return Xp(this), this._value;
  }
  set value(n) {
    const s = this.__v_isShallow || vl(n) || yr(n);
    n = s ? n : Et(n), As(n, this._rawValue) && (this._rawValue = n, this._value = s ? n : bl(n), lh(this, n));
  }
}
function cF(i) {
  lh(i, process.env.NODE_ENV !== "production" ? i.value : void 0);
}
function qp(i) {
  return tn(i) ? i.value : i;
}
function uF(i) {
  return ft(i) ? i() : qp(i);
}
const hF = {
  get: (i, n, s) => qp(Reflect.get(i, n, s)),
  set: (i, n, s, u) => {
    const y = i[n];
    return tn(y) && !tn(s) ? (y.value = s, !0) : Reflect.set(i, n, s, u);
  }
};
function Jp(i) {
  return ns(i) ? i : new Proxy(i, hF);
}
class dF {
  constructor(n) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: s, set: u } = n(
      () => Xp(this),
      () => lh(this)
    );
    this._get = s, this._set = u;
  }
  get value() {
    return this._get();
  }
  set value(n) {
    this._set(n);
  }
}
function fF(i) {
  return new dF(i);
}
function pF(i) {
  process.env.NODE_ENV !== "production" && !yl(i) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const n = Je(i) ? new Array(i.length) : {};
  for (const s in i)
    n[s] = rw(i, s);
  return n;
}
class mF {
  constructor(n, s, u) {
    this._object = n, this._key = s, this._defaultValue = u, this.__v_isRef = !0;
  }
  get value() {
    const n = this._object[this._key];
    return n === void 0 ? this._defaultValue : n;
  }
  set value(n) {
    this._object[this._key] = n;
  }
  get dep() {
    return I3(Et(this._object), this._key);
  }
}
class gF {
  constructor(n) {
    this._getter = n, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function vF(i, n, s) {
  return tn(i) ? i : ft(i) ? new gF(i) : Nt(i) && arguments.length > 1 ? rw(i, n, s) : is(i);
}
function rw(i, n, s) {
  const u = i[n];
  return tn(u) ? u : new mF(
    i,
    n,
    s
  );
}
class yF {
  constructor(n, s, u, y) {
    this._setter = s, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Al(n, () => {
      this._dirty || (this._dirty = !0, lh(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !y, this.__v_isReadonly = u;
  }
  get value() {
    const n = Et(this);
    return Xp(n), (n._dirty || !n._cacheable) && (n._dirty = !1, n._value = n.effect.run()), n._value;
  }
  set value(n) {
    this._setter(n);
  }
}
function bF(i, n, s = !1) {
  let u, y;
  const w = ft(i);
  w ? (u = i, y = process.env.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : en) : (u = i.get, y = i.set);
  const S = new yF(u, y, w || !y, s);
  return process.env.NODE_ENV !== "production" && n && !s && (S.effect.onTrack = n.onTrack, S.effect.onTrigger = n.onTrigger), S;
}
const Vs = [];
function Ya(i) {
  Vs.push(i);
}
function Ka() {
  Vs.pop();
}
function _e(i, ...n) {
  if (process.env.NODE_ENV === "production")
    return;
  Gs();
  const s = Vs.length ? Vs[Vs.length - 1].component : null, u = s && s.appContext.config.warnHandler, y = CF();
  if (u)
    Yi(
      u,
      s,
      11,
      [
        i + n.join(""),
        s && s.proxy,
        y.map(
          ({ vnode: w }) => `at <${Ch(s, w.type)}>`
        ).join(`
`),
        y
      ]
    );
  else {
    const w = [`[Vue warn]: ${i}`, ...n];
    y.length && w.push(`
`, ...wF(y)), console.warn(...w);
  }
  Xs();
}
function CF() {
  let i = Vs[Vs.length - 1];
  if (!i)
    return [];
  const n = [];
  for (; i; ) {
    const s = n[0];
    s && s.vnode === i ? s.recurseCount++ : n.push({
      vnode: i,
      recurseCount: 0
    });
    const u = i.component && i.component.parent;
    i = u && u.vnode;
  }
  return n;
}
function wF(i) {
  const n = [];
  return i.forEach((s, u) => {
    n.push(...u === 0 ? [] : [`
`], ...kF(s));
  }), n;
}
function kF({ vnode: i, recurseCount: n }) {
  const s = n > 0 ? `... (${n} recursive calls)` : "", u = i.component ? i.component.parent == null : !1, y = ` at <${Ch(
    i.component,
    i.type,
    u
  )}`, w = ">" + s;
  return i.props ? [y, ...SF(i.props), w] : [y + w];
}
function SF(i) {
  const n = [], s = Object.keys(i);
  return s.slice(0, 3).forEach((u) => {
    n.push(...sw(u, i[u]));
  }), s.length > 3 && n.push(" ..."), n;
}
function sw(i, n, s) {
  return wt(n) ? (n = JSON.stringify(n), s ? n : [`${i}=${n}`]) : typeof n == "number" || typeof n == "boolean" || n == null ? s ? n : [`${i}=${n}`] : tn(n) ? (n = sw(i, Et(n.value), !0), s ? n : [`${i}=Ref<`, n, ">"]) : ft(n) ? [`${i}=fn${n.name ? `<${n.name}>` : ""}`] : (n = Et(n), s ? n : [`${i}=`, n]);
}
function Qp(i, n) {
  process.env.NODE_ENV !== "production" && i !== void 0 && (typeof i != "number" ? _e(`${n} is not a valid number - got ${JSON.stringify(i)}.`) : isNaN(i) && _e(`${n} is NaN - the duration expression might be incorrect.`));
}
const Zp = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Yi(i, n, s, u) {
  let y;
  try {
    y = u ? i(...u) : i();
  } catch (w) {
    qs(w, n, s);
  }
  return y;
}
function ci(i, n, s, u) {
  if (ft(i)) {
    const w = Yi(i, n, s, u);
    return w && Nl(w) && w.catch((S) => {
      qs(S, n, s);
    }), w;
  }
  const y = [];
  for (let w = 0; w < i.length; w++)
    y.push(ci(i[w], n, s, u));
  return y;
}
function qs(i, n, s, u = !0) {
  const y = n ? n.vnode : null;
  if (n) {
    let w = n.parent;
    const S = n.proxy, d = process.env.NODE_ENV !== "production" ? Zp[s] : s;
    for (; w; ) {
      const p = w.ec;
      if (p) {
        for (let v = 0; v < p.length; v++)
          if (p[v](i, S, d) === !1)
            return;
      }
      w = w.parent;
    }
    const l = n.appContext.config.errorHandler;
    if (l) {
      Yi(
        l,
        null,
        10,
        [i, S, d]
      );
      return;
    }
  }
  EF(i, s, y, u);
}
function EF(i, n, s, u = !0) {
  if (process.env.NODE_ENV !== "production") {
    const y = Zp[n];
    if (s && Ya(s), _e(`Unhandled error${y ? ` during execution of ${y}` : ""}`), s && Ka(), u)
      throw i;
    console.error(i);
  } else
    console.error(i);
}
let Cl = !1, Vf = !1;
const An = [];
let Ui = 0;
const Oo = [];
let ji = null, Wr = 0;
const ow = /* @__PURE__ */ Promise.resolve();
let em = null;
const xF = 100;
function tm(i) {
  const n = em || ow;
  return i ? n.then(this ? i.bind(this) : i) : n;
}
function _F(i) {
  let n = Ui + 1, s = An.length;
  for (; n < s; ) {
    const u = n + s >>> 1;
    wl(An[u]) < i ? n = u + 1 : s = u;
  }
  return n;
}
function Fl(i) {
  (!An.length || !An.includes(
    i,
    Cl && i.allowRecurse ? Ui + 1 : Ui
  )) && (i.id == null ? An.push(i) : An.splice(_F(i.id), 0, i), aw());
}
function aw() {
  !Cl && !Vf && (Vf = !0, em = ow.then(lw));
}
function TF(i) {
  const n = An.indexOf(i);
  n > Ui && An.splice(n, 1);
}
function ch(i) {
  Je(i) ? Oo.push(...i) : (!ji || !ji.includes(
    i,
    i.allowRecurse ? Wr + 1 : Wr
  )) && Oo.push(i), aw();
}
function Qy(i, n = Cl ? Ui + 1 : 0) {
  for (process.env.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()); n < An.length; n++) {
    const s = An[n];
    if (s && s.pre) {
      if (process.env.NODE_ENV !== "production" && nm(i, s))
        continue;
      An.splice(n, 1), n--, s();
    }
  }
}
function Su(i) {
  if (Oo.length) {
    const n = [...new Set(Oo)];
    if (Oo.length = 0, ji) {
      ji.push(...n);
      return;
    }
    for (ji = n, process.env.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()), ji.sort((s, u) => wl(s) - wl(u)), Wr = 0; Wr < ji.length; Wr++)
      process.env.NODE_ENV !== "production" && nm(i, ji[Wr]) || ji[Wr]();
    ji = null, Wr = 0;
  }
}
const wl = (i) => i.id == null ? 1 / 0 : i.id, OF = (i, n) => {
  const s = wl(i) - wl(n);
  if (s === 0) {
    if (i.pre && !n.pre)
      return -1;
    if (n.pre && !i.pre)
      return 1;
  }
  return s;
};
function lw(i) {
  Vf = !1, Cl = !0, process.env.NODE_ENV !== "production" && (i = i || /* @__PURE__ */ new Map()), An.sort(OF);
  const n = process.env.NODE_ENV !== "production" ? (s) => nm(i, s) : en;
  try {
    for (Ui = 0; Ui < An.length; Ui++) {
      const s = An[Ui];
      if (s && s.active !== !1) {
        if (process.env.NODE_ENV !== "production" && n(s))
          continue;
        Yi(s, null, 14);
      }
    }
  } finally {
    Ui = 0, An.length = 0, Su(i), Cl = !1, em = null, (An.length || Oo.length) && lw(i);
  }
}
function nm(i, n) {
  if (!i.has(n))
    i.set(n, 1);
  else {
    const s = i.get(n);
    if (s > xF) {
      const u = n.ownerInstance, y = u && _l(u.type);
      return _e(
        `Maximum recursive updates exceeded${y ? ` in component <${y}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      i.set(n, s + 1);
  }
}
let rs = !1;
const wo = /* @__PURE__ */ new Set();
process.env.NODE_ENV !== "production" && (Fs().__VUE_HMR_RUNTIME__ = {
  createRecord: qd(cw),
  rerender: qd(BF),
  reload: qd(PF)
});
const Us = /* @__PURE__ */ new Map();
function DF(i) {
  const n = i.type.__hmrId;
  let s = Us.get(n);
  s || (cw(n, i.type), s = Us.get(n)), s.instances.add(i);
}
function NF(i) {
  Us.get(i.type.__hmrId).instances.delete(i);
}
function cw(i, n) {
  return Us.has(i) ? !1 : (Us.set(i, {
    initialDef: Ga(n),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Ga(i) {
  return ik(i) ? i.__vccOpts : i;
}
function BF(i, n) {
  const s = Us.get(i);
  s && (s.initialDef.render = n, [...s.instances].forEach((u) => {
    n && (u.render = n, Ga(u.type).render = n), u.renderCache = [], rs = !0, u.update(), rs = !1;
  }));
}
function PF(i, n) {
  const s = Us.get(i);
  if (!s)
    return;
  n = Ga(n), Zy(s.initialDef, n);
  const u = [...s.instances];
  for (const y of u) {
    const w = Ga(y.type);
    wo.has(w) || (w !== s.initialDef && Zy(w, n), wo.add(w)), y.appContext.propsCache.delete(y.type), y.appContext.emitsCache.delete(y.type), y.appContext.optionsCache.delete(y.type), y.ceReload ? (wo.add(w), y.ceReload(n.styles), wo.delete(w)) : y.parent ? Fl(y.parent.update) : y.appContext.reload ? y.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  ch(() => {
    for (const y of u)
      wo.delete(
        Ga(y.type)
      );
  });
}
function Zy(i, n) {
  _t(i, n);
  for (const s in i)
    s !== "__file" && !(s in n) && delete i[s];
}
function qd(i) {
  return (n, s) => {
    try {
      return i(n, s);
    } catch (u) {
      console.error(u), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Di, Ra = [], $f = !1;
function Ll(i, ...n) {
  Di ? Di.emit(i, ...n) : $f || Ra.push({ event: i, args: n });
}
function im(i, n) {
  var s, u;
  Di = i, Di ? (Di.enabled = !0, Ra.forEach(({ event: y, args: w }) => Di.emit(y, ...w)), Ra = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((u = (s = window.navigator) == null ? void 0 : s.userAgent) != null && u.includes("jsdom")) ? ((n.__VUE_DEVTOOLS_HOOK_REPLAY__ = n.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((w) => {
    im(w, n);
  }), setTimeout(() => {
    Di || (n.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, $f = !0, Ra = []);
  }, 3e3)) : ($f = !0, Ra = []);
}
function VF(i, n) {
  Ll("app:init", i, n, {
    Fragment: _n,
    Text: us,
    Comment: ln,
    Static: ss
  });
}
function $F(i) {
  Ll("app:unmount", i);
}
const If = /* @__PURE__ */ rm(
  "component:added"
  /* COMPONENT_ADDED */
), uw = /* @__PURE__ */ rm(
  "component:updated"
  /* COMPONENT_UPDATED */
), IF = /* @__PURE__ */ rm(
  "component:removed"
  /* COMPONENT_REMOVED */
), MF = (i) => {
  Di && typeof Di.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Di.cleanupBuffer(i) && IF(i);
};
function rm(i) {
  return (n) => {
    Ll(
      i,
      n.appContext.app,
      n.uid,
      n.parent ? n.parent.uid : void 0,
      n
    );
  };
}
const AF = /* @__PURE__ */ hw(
  "perf:start"
  /* PERFORMANCE_START */
), FF = /* @__PURE__ */ hw(
  "perf:end"
  /* PERFORMANCE_END */
);
function hw(i) {
  return (n, s, u) => {
    Ll(i, n.appContext.app, n.uid, n, s, u);
  };
}
function LF(i, n, s) {
  Ll(
    "component:emit",
    i.appContext.app,
    i,
    n,
    s
  );
}
function zF(i, n, ...s) {
  if (i.isUnmounted)
    return;
  const u = i.vnode.props || Ft;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: v,
      propsOptions: [c]
    } = i;
    if (v)
      if (!(n in v))
        (!c || !(Oi(n) in c)) && _e(
          `Component emitted event "${n}" but it is neither declared in the emits option nor as an "${Oi(n)}" prop.`
        );
      else {
        const e = v[n];
        ft(e) && (e(...s) || _e(
          `Invalid event arguments: event validation failed for event "${n}".`
        ));
      }
  }
  let y = s;
  const w = n.startsWith("update:"), S = w && n.slice(7);
  if (S && S in u) {
    const v = `${S === "modelValue" ? "model" : S}Modifiers`, { number: c, trim: e } = u[v] || Ft;
    e && (y = s.map((h) => wt(h) ? h.trim() : h)), c && (y = s.map(sl));
  }
  if ((process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && LF(i, n, y), process.env.NODE_ENV !== "production") {
    const v = n.toLowerCase();
    v !== n && u[Oi(v)] && _e(
      `Event "${v}" is emitted in component ${Ch(
        i,
        i.type
      )} but the handler is registered for "${n}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Bn(n)}" instead of "${n}".`
    );
  }
  let d, l = u[d = Oi(n)] || // also try camelCase event handler (#2249)
  u[d = Oi(an(n))];
  !l && w && (l = u[d = Oi(Bn(n))]), l && ci(
    l,
    i,
    6,
    y
  );
  const p = u[d + "Once"];
  if (p) {
    if (!i.emitted)
      i.emitted = {};
    else if (i.emitted[d])
      return;
    i.emitted[d] = !0, ci(
      p,
      i,
      6,
      y
    );
  }
}
function dw(i, n, s = !1) {
  const u = n.emitsCache, y = u.get(i);
  if (y !== void 0)
    return y;
  const w = i.emits;
  let S = {}, d = !1;
  if (__VUE_OPTIONS_API__ && !ft(i)) {
    const l = (p) => {
      const v = dw(p, n, !0);
      v && (d = !0, _t(S, v));
    };
    !s && n.mixins.length && n.mixins.forEach(l), i.extends && l(i.extends), i.mixins && i.mixins.forEach(l);
  }
  return !w && !d ? (Nt(i) && u.set(i, null), null) : (Je(w) ? w.forEach((l) => S[l] = null) : _t(S, w), Nt(i) && u.set(i, S), S);
}
function uh(i, n) {
  return !i || !Gi(n) ? !1 : (n = n.slice(2).replace(/Once$/, ""), Dt(i, n[0].toLowerCase() + n.slice(1)) || Dt(i, Bn(n)) || Dt(i, n));
}
let on = null, hh = null;
function kl(i) {
  const n = on;
  return on = i, hh = i && i.type.__scopeId || null, n;
}
function RF(i) {
  hh = i;
}
function jF() {
  hh = null;
}
const HF = (i) => sm;
function sm(i, n = on, s) {
  if (!n || i._n)
    return i;
  const u = (...y) => {
    u._d && Hf(-1);
    const w = kl(n);
    let S;
    try {
      S = i(...y);
    } finally {
      kl(w), u._d && Hf(1);
    }
    return (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && uw(n), S;
  };
  return u._n = !0, u._c = !0, u._d = !0, u;
}
let Mf = !1;
function Eu() {
  Mf = !0;
}
function ou(i) {
  const {
    type: n,
    vnode: s,
    proxy: u,
    withProxy: y,
    props: w,
    propsOptions: [S],
    slots: d,
    attrs: l,
    emit: p,
    render: v,
    renderCache: c,
    data: e,
    setupState: h,
    ctx: m,
    inheritAttrs: b
  } = i;
  let f, k;
  const E = kl(i);
  process.env.NODE_ENV !== "production" && (Mf = !1);
  try {
    if (s.shapeFlag & 4) {
      const D = y || u;
      f = qn(
        v.call(
          D,
          D,
          c,
          w,
          h,
          e,
          m
        )
      ), k = l;
    } else {
      const D = n;
      process.env.NODE_ENV !== "production" && l === w && Eu(), f = qn(
        D.length > 1 ? D(
          w,
          process.env.NODE_ENV !== "production" ? {
            get attrs() {
              return Eu(), l;
            },
            slots: d,
            emit: p
          } : { attrs: l, slots: d, emit: p }
        ) : D(
          w,
          null
          /* we know it doesn't need it */
        )
      ), k = n.props ? l : WF(l);
    }
  } catch (D) {
    Qa.length = 0, qs(D, i, 1), f = Xt(ln);
  }
  let _ = f, T;
  if (process.env.NODE_ENV !== "production" && f.patchFlag > 0 && f.patchFlag & 2048 && ([_, T] = UF(f)), k && b !== !1) {
    const D = Object.keys(k), { shapeFlag: V } = _;
    if (D.length) {
      if (V & 7)
        S && D.some(il) && (k = YF(
          k,
          S
        )), _ = wi(_, k);
      else if (process.env.NODE_ENV !== "production" && !Mf && _.type !== ln) {
        const I = Object.keys(l), M = [], Q = [];
        for (let G = 0, z = I.length; G < z; G++) {
          const re = I[G];
          Gi(re) ? il(re) || M.push(re[2].toLowerCase() + re.slice(3)) : Q.push(re);
        }
        Q.length && _e(
          `Extraneous non-props attributes (${Q.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), M.length && _e(
          `Extraneous non-emits event listeners (${M.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return s.dirs && (process.env.NODE_ENV !== "production" && !eb(_) && _e(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), _ = wi(_), _.dirs = _.dirs ? _.dirs.concat(s.dirs) : s.dirs), s.transition && (process.env.NODE_ENV !== "production" && !eb(_) && _e(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), _.transition = s.transition), process.env.NODE_ENV !== "production" && T ? T(_) : f = _, kl(E), f;
}
const UF = (i) => {
  const n = i.children, s = i.dynamicChildren, u = om(n);
  if (!u)
    return [i, void 0];
  const y = n.indexOf(u), w = s ? s.indexOf(u) : -1, S = (d) => {
    n[y] = d, s && (w > -1 ? s[w] = d : d.patchFlag > 0 && (i.dynamicChildren = [...s, d]));
  };
  return [qn(u), S];
};
function om(i) {
  let n;
  for (let s = 0; s < i.length; s++) {
    const u = i[s];
    if (br(u)) {
      if (u.type !== ln || u.children === "v-if") {
        if (n)
          return;
        n = u;
      }
    } else
      return;
  }
  return n;
}
const WF = (i) => {
  let n;
  for (const s in i)
    (s === "class" || s === "style" || Gi(s)) && ((n || (n = {}))[s] = i[s]);
  return n;
}, YF = (i, n) => {
  const s = {};
  for (const u in i)
    (!il(u) || !(u.slice(9) in n)) && (s[u] = i[u]);
  return s;
}, eb = (i) => i.shapeFlag & 7 || i.type === ln;
function KF(i, n, s) {
  const { props: u, children: y, component: w } = i, { props: S, children: d, patchFlag: l } = n, p = w.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (y || d) && rs || n.dirs || n.transition)
    return !0;
  if (s && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return u ? tb(u, S, p) : !!S;
    if (l & 8) {
      const v = n.dynamicProps;
      for (let c = 0; c < v.length; c++) {
        const e = v[c];
        if (S[e] !== u[e] && !uh(p, e))
          return !0;
      }
    }
  } else
    return (y || d) && (!d || !d.$stable) ? !0 : u === S ? !1 : u ? S ? tb(u, S, p) : !0 : !!S;
  return !1;
}
function tb(i, n, s) {
  const u = Object.keys(n);
  if (u.length !== Object.keys(i).length)
    return !0;
  for (let y = 0; y < u.length; y++) {
    const w = u[y];
    if (n[w] !== i[w] && !uh(s, w))
      return !0;
  }
  return !1;
}
function am({ vnode: i, parent: n }, s) {
  for (; n && n.subTree === i; )
    (i = n.vnode).el = s, n = n.parent;
}
const fw = (i) => i.__isSuspense, GF = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(i, n, s, u, y, w, S, d, l, p) {
    i == null ? qF(
      n,
      s,
      u,
      y,
      w,
      S,
      d,
      l,
      p
    ) : JF(
      i,
      n,
      s,
      u,
      y,
      S,
      d,
      l,
      p
    );
  },
  hydrate: QF,
  create: lm,
  normalize: ZF
}, XF = GF;
function Sl(i, n) {
  const s = i.props && i.props[n];
  ft(s) && s();
}
function qF(i, n, s, u, y, w, S, d, l) {
  const {
    p,
    o: { createElement: v }
  } = l, c = v("div"), e = i.suspense = lm(
    i,
    y,
    u,
    n,
    c,
    s,
    w,
    S,
    d,
    l
  );
  p(
    null,
    e.pendingBranch = i.ssContent,
    c,
    null,
    u,
    e,
    w,
    S
  ), e.deps > 0 ? (Sl(i, "onPending"), Sl(i, "onFallback"), p(
    null,
    i.ssFallback,
    n,
    s,
    u,
    null,
    // fallback tree will not have suspense context
    w,
    S
  ), Do(e, i.ssFallback)) : e.resolve(!1, !0);
}
function JF(i, n, s, u, y, w, S, d, { p: l, um: p, o: { createElement: v } }) {
  const c = n.suspense = i.suspense;
  c.vnode = n, n.el = i.el;
  const e = n.ssContent, h = n.ssFallback, { activeBranch: m, pendingBranch: b, isInFallback: f, isHydrating: k } = c;
  if (b)
    c.pendingBranch = e, Ni(e, b) ? (l(
      b,
      e,
      c.hiddenContainer,
      null,
      y,
      c,
      w,
      S,
      d
    ), c.deps <= 0 ? c.resolve() : f && (l(
      m,
      h,
      s,
      u,
      y,
      null,
      // fallback tree will not have suspense context
      w,
      S,
      d
    ), Do(c, h))) : (c.pendingId++, k ? (c.isHydrating = !1, c.activeBranch = b) : p(b, y, c), c.deps = 0, c.effects.length = 0, c.hiddenContainer = v("div"), f ? (l(
      null,
      e,
      c.hiddenContainer,
      null,
      y,
      c,
      w,
      S,
      d
    ), c.deps <= 0 ? c.resolve() : (l(
      m,
      h,
      s,
      u,
      y,
      null,
      // fallback tree will not have suspense context
      w,
      S,
      d
    ), Do(c, h))) : m && Ni(e, m) ? (l(
      m,
      e,
      s,
      u,
      y,
      c,
      w,
      S,
      d
    ), c.resolve(!0)) : (l(
      null,
      e,
      c.hiddenContainer,
      null,
      y,
      c,
      w,
      S,
      d
    ), c.deps <= 0 && c.resolve()));
  else if (m && Ni(e, m))
    l(
      m,
      e,
      s,
      u,
      y,
      c,
      w,
      S,
      d
    ), Do(c, e);
  else if (Sl(n, "onPending"), c.pendingBranch = e, c.pendingId++, l(
    null,
    e,
    c.hiddenContainer,
    null,
    y,
    c,
    w,
    S,
    d
  ), c.deps <= 0)
    c.resolve();
  else {
    const { timeout: E, pendingId: _ } = c;
    E > 0 ? setTimeout(() => {
      c.pendingId === _ && c.fallback(h);
    }, E) : E === 0 && c.fallback(h);
  }
}
let nb = !1;
function lm(i, n, s, u, y, w, S, d, l, p, v = !1) {
  process.env.NODE_ENV !== "production" && !nb && (nb = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: c,
    m: e,
    um: h,
    n: m,
    o: { parentNode: b, remove: f }
  } = p;
  let k;
  const E = e6(i);
  E && n != null && n.pendingBranch && (k = n.pendingId, n.deps++);
  const _ = i.props ? ol(i.props.timeout) : void 0;
  process.env.NODE_ENV !== "production" && Qp(_, "Suspense timeout");
  const T = {
    vnode: i,
    parent: n,
    parentComponent: s,
    isSVG: S,
    container: u,
    hiddenContainer: y,
    anchor: w,
    deps: 0,
    pendingId: 0,
    timeout: typeof _ == "number" ? _ : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: v,
    isUnmounted: !1,
    effects: [],
    resolve(D = !1, V = !1) {
      if (process.env.NODE_ENV !== "production") {
        if (!D && !T.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (T.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: I,
        activeBranch: M,
        pendingBranch: Q,
        pendingId: G,
        effects: z,
        parentComponent: re,
        container: he
      } = T;
      if (T.isHydrating)
        T.isHydrating = !1;
      else if (!D) {
        const xe = M && Q.transition && Q.transition.mode === "out-in";
        xe && (M.transition.afterLeave = () => {
          G === T.pendingId && e(Q, he, Ie, 0);
        });
        let { anchor: Ie } = T;
        M && (Ie = m(M), h(M, re, T, !0)), xe || e(Q, he, Ie, 0);
      }
      Do(T, Q), T.pendingBranch = null, T.isInFallback = !1;
      let de = T.parent, Ce = !1;
      for (; de; ) {
        if (de.pendingBranch) {
          de.effects.push(...z), Ce = !0;
          break;
        }
        de = de.parent;
      }
      Ce || ch(z), T.effects = [], E && n && n.pendingBranch && k === n.pendingId && (n.deps--, n.deps === 0 && !V && n.resolve()), Sl(I, "onResolve");
    },
    fallback(D) {
      if (!T.pendingBranch)
        return;
      const { vnode: V, activeBranch: I, parentComponent: M, container: Q, isSVG: G } = T;
      Sl(V, "onFallback");
      const z = m(I), re = () => {
        T.isInFallback && (c(
          null,
          D,
          Q,
          z,
          M,
          null,
          // fallback tree will not have suspense context
          G,
          d,
          l
        ), Do(T, D));
      }, he = D.transition && D.transition.mode === "out-in";
      he && (I.transition.afterLeave = re), T.isInFallback = !0, h(
        I,
        M,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), he || re();
    },
    move(D, V, I) {
      T.activeBranch && e(T.activeBranch, D, V, I), T.container = D;
    },
    next() {
      return T.activeBranch && m(T.activeBranch);
    },
    registerDep(D, V) {
      const I = !!T.pendingBranch;
      I && T.deps++;
      const M = D.vnode.el;
      D.asyncDep.catch((Q) => {
        qs(Q, D, 0);
      }).then((Q) => {
        if (D.isUnmounted || T.isUnmounted || T.pendingId !== D.suspenseId)
          return;
        D.asyncResolved = !0;
        const { vnode: G } = D;
        process.env.NODE_ENV !== "production" && Ya(G), Yf(D, Q, !1), M && (G.el = M);
        const z = !M && D.subTree.el;
        V(
          D,
          G,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          b(M || D.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          M ? null : m(D.subTree),
          T,
          S,
          l
        ), z && f(z), am(D, G.el), process.env.NODE_ENV !== "production" && Ka(), I && --T.deps === 0 && T.resolve();
      });
    },
    unmount(D, V) {
      T.isUnmounted = !0, T.activeBranch && h(
        T.activeBranch,
        s,
        D,
        V
      ), T.pendingBranch && h(
        T.pendingBranch,
        s,
        D,
        V
      );
    }
  };
  return T;
}
function QF(i, n, s, u, y, w, S, d, l) {
  const p = n.suspense = lm(
    n,
    u,
    s,
    i.parentNode,
    document.createElement("div"),
    null,
    y,
    w,
    S,
    d,
    !0
    /* hydrating */
  ), v = l(
    i,
    p.pendingBranch = n.ssContent,
    s,
    p,
    w,
    S
  );
  return p.deps === 0 && p.resolve(!1, !0), v;
}
function ZF(i) {
  const { shapeFlag: n, children: s } = i, u = n & 32;
  i.ssContent = ib(
    u ? s.default : s
  ), i.ssFallback = u ? ib(s.fallback) : Xt(ln);
}
function ib(i) {
  let n;
  if (ft(i)) {
    const s = Ys && i._c;
    s && (i._d = !1, vh()), i = i(), s && (i._d = !0, n = Jn, Ww());
  }
  if (Je(i)) {
    const s = om(i);
    process.env.NODE_ENV !== "production" && !s && _e("<Suspense> slots expect a single root node."), i = s;
  }
  return i = qn(i), n && !i.dynamicChildren && (i.dynamicChildren = n.filter((s) => s !== i)), i;
}
function pw(i, n) {
  n && n.pendingBranch ? Je(i) ? n.effects.push(...i) : n.effects.push(i) : ch(i);
}
function Do(i, n) {
  i.activeBranch = n;
  const { vnode: s, parentComponent: u } = i, y = s.el = n.el;
  u && u.subTree === s && (u.vnode.el = y, am(u, y));
}
function e6(i) {
  var n;
  return ((n = i.props) == null ? void 0 : n.suspensible) != null && i.props.suspensible !== !1;
}
function t6(i, n) {
  return zl(i, null, n);
}
function mw(i, n) {
  return zl(
    i,
    null,
    process.env.NODE_ENV !== "production" ? _t({}, n, { flush: "post" }) : { flush: "post" }
  );
}
function n6(i, n) {
  return zl(
    i,
    null,
    process.env.NODE_ENV !== "production" ? _t({}, n, { flush: "sync" }) : { flush: "sync" }
  );
}
const qc = {};
function $s(i, n, s) {
  return process.env.NODE_ENV !== "production" && !ft(n) && _e(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), zl(i, n, s);
}
function zl(i, n, { immediate: s, deep: u, flush: y, onTrack: w, onTrigger: S } = Ft) {
  var d;
  process.env.NODE_ENV !== "production" && !n && (s !== void 0 && _e(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), u !== void 0 && _e(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = (D) => {
    _e(
      "Invalid watch source: ",
      D,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, p = H1() === ((d = sn) == null ? void 0 : d.scope) ? sn : null;
  let v, c = !1, e = !1;
  if (tn(i) ? (v = () => i.value, c = vl(i)) : ns(i) ? (v = () => i, u = !0) : Je(i) ? (e = !0, c = i.some((D) => ns(D) || vl(D)), v = () => i.map((D) => {
    if (tn(D))
      return D.value;
    if (ns(D))
      return Ns(D);
    if (ft(D))
      return Yi(D, p, 2);
    process.env.NODE_ENV !== "production" && l(D);
  })) : ft(i) ? n ? v = () => Yi(i, p, 2) : v = () => {
    if (!(p && p.isUnmounted))
      return h && h(), ci(
        i,
        p,
        3,
        [m]
      );
  } : (v = en, process.env.NODE_ENV !== "production" && l(i)), n && u) {
    const D = v;
    v = () => Ns(D());
  }
  let h, m = (D) => {
    h = _.onStop = () => {
      Yi(D, p, 4);
    };
  }, b;
  if (Ao)
    if (m = en, n ? s && ci(n, p, 3, [
      v(),
      e ? [] : void 0,
      m
    ]) : v(), y === "sync") {
      const D = ak();
      b = D.__watcherHandles || (D.__watcherHandles = []);
    } else
      return en;
  let f = e ? new Array(i.length).fill(qc) : qc;
  const k = () => {
    if (_.active)
      if (n) {
        const D = _.run();
        (u || c || (e ? D.some(
          (V, I) => As(V, f[I])
        ) : As(D, f))) && (h && h(), ci(n, p, 3, [
          D,
          // pass undefined as the old value when it's changed for the first time
          f === qc ? void 0 : e && f[0] === qc ? [] : f,
          m
        ]), f = D);
      } else
        _.run();
  };
  k.allowRecurse = !!n;
  let E;
  y === "sync" ? E = k : y === "post" ? E = () => Dn(k, p && p.suspense) : (k.pre = !0, p && (k.id = p.uid), E = () => Fl(k));
  const _ = new Al(v, E);
  process.env.NODE_ENV !== "production" && (_.onTrack = w, _.onTrigger = S), n ? s ? k() : f = _.run() : y === "post" ? Dn(
    _.run.bind(_),
    p && p.suspense
  ) : _.run();
  const T = () => {
    _.stop(), p && p.scope && Iu(p.scope.effects, _);
  };
  return b && b.push(T), T;
}
function i6(i, n, s) {
  const u = this.proxy, y = wt(i) ? i.includes(".") ? gw(u, i) : () => u[i] : i.bind(u, u);
  let w;
  ft(n) ? w = n : (w = n.handler, s = n);
  const S = sn;
  hs(this);
  const d = zl(y, w.bind(u), s);
  return S ? hs(S) : os(), d;
}
function gw(i, n) {
  const s = n.split(".");
  return () => {
    let u = i;
    for (let y = 0; y < s.length && u; y++)
      u = u[s[y]];
    return u;
  };
}
function Ns(i, n) {
  if (!Nt(i) || i.__v_skip || (n = n || /* @__PURE__ */ new Set(), n.has(i)))
    return i;
  if (n.add(i), tn(i))
    Ns(i.value, n);
  else if (Je(i))
    for (let s = 0; s < i.length; s++)
      Ns(i[s], n);
  else if (fs(i) || Qr(i))
    i.forEach((s) => {
      Ns(s, n);
    });
  else if (cp(i))
    for (const s in i)
      Ns(i[s], n);
  return i;
}
function vw(i) {
  up(i) && _e("Do not use built-in directive ids as custom directive id: " + i);
}
function r6(i, n) {
  const s = on;
  if (s === null)
    return process.env.NODE_ENV !== "production" && _e("withDirectives can only be used inside render functions."), i;
  const u = bh(s) || s.proxy, y = i.dirs || (i.dirs = []);
  for (let w = 0; w < n.length; w++) {
    let [S, d, l, p = Ft] = n[w];
    S && (ft(S) && (S = {
      mounted: S,
      updated: S
    }), S.deep && Ns(d), y.push({
      dir: S,
      instance: u,
      value: d,
      oldValue: void 0,
      arg: l,
      modifiers: p
    }));
  }
  return i;
}
function Hi(i, n, s, u) {
  const y = i.dirs, w = n && n.dirs;
  for (let S = 0; S < y.length; S++) {
    const d = y[S];
    w && (d.oldValue = w[S].value);
    let l = d.dir[u];
    l && (Gs(), ci(l, s, 8, [
      i.el,
      d,
      i,
      n
    ]), Xs());
  }
}
function cm() {
  const i = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Rl(() => {
    i.isMounted = !0;
  }), mh(() => {
    i.isUnmounting = !0;
  }), i;
}
const vi = [Function, Array], um = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: vi,
  onEnter: vi,
  onAfterEnter: vi,
  onEnterCancelled: vi,
  // leave
  onBeforeLeave: vi,
  onLeave: vi,
  onAfterLeave: vi,
  onLeaveCancelled: vi,
  // appear
  onBeforeAppear: vi,
  onAppear: vi,
  onAfterAppear: vi,
  onAppearCancelled: vi
}, s6 = {
  name: "BaseTransition",
  props: um,
  setup(i, { slots: n }) {
    const s = wr(), u = cm();
    let y;
    return () => {
      const w = n.default && dh(n.default(), !0);
      if (!w || !w.length)
        return;
      let S = w[0];
      if (w.length > 1) {
        let b = !1;
        for (const f of w)
          if (f.type !== ln) {
            if (process.env.NODE_ENV !== "production" && b) {
              _e(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (S = f, b = !0, process.env.NODE_ENV === "production")
              break;
          }
      }
      const d = Et(i), { mode: l } = d;
      if (process.env.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && _e(`invalid <transition> mode: ${l}`), u.isLeaving)
        return Jd(S);
      const p = rb(S);
      if (!p)
        return Jd(S);
      const v = Mo(
        p,
        d,
        u,
        s
      );
      Ws(p, v);
      const c = s.subTree, e = c && rb(c);
      let h = !1;
      const { getTransitionKey: m } = p.type;
      if (m) {
        const b = m();
        y === void 0 ? y = b : b !== y && (y = b, h = !0);
      }
      if (e && e.type !== ln && (!Ni(p, e) || h)) {
        const b = Mo(
          e,
          d,
          u,
          s
        );
        if (Ws(e, b), l === "out-in")
          return u.isLeaving = !0, b.afterLeave = () => {
            u.isLeaving = !1, s.update.active !== !1 && s.update();
          }, Jd(S);
        l === "in-out" && p.type !== ln && (b.delayLeave = (f, k, E) => {
          const _ = bw(
            u,
            e
          );
          _[String(e.key)] = e, f._leaveCb = () => {
            k(), f._leaveCb = void 0, delete v.delayedLeave;
          }, v.delayedLeave = E;
        });
      }
      return S;
    };
  }
}, yw = s6;
function bw(i, n) {
  const { leavingVNodes: s } = i;
  let u = s.get(n.type);
  return u || (u = /* @__PURE__ */ Object.create(null), s.set(n.type, u)), u;
}
function Mo(i, n, s, u) {
  const {
    appear: y,
    mode: w,
    persisted: S = !1,
    onBeforeEnter: d,
    onEnter: l,
    onAfterEnter: p,
    onEnterCancelled: v,
    onBeforeLeave: c,
    onLeave: e,
    onAfterLeave: h,
    onLeaveCancelled: m,
    onBeforeAppear: b,
    onAppear: f,
    onAfterAppear: k,
    onAppearCancelled: E
  } = n, _ = String(i.key), T = bw(s, i), D = (M, Q) => {
    M && ci(
      M,
      u,
      9,
      Q
    );
  }, V = (M, Q) => {
    const G = Q[1];
    D(M, Q), Je(M) ? M.every((z) => z.length <= 1) && G() : M.length <= 1 && G();
  }, I = {
    mode: w,
    persisted: S,
    beforeEnter(M) {
      let Q = d;
      if (!s.isMounted)
        if (y)
          Q = b || d;
        else
          return;
      M._leaveCb && M._leaveCb(
        !0
        /* cancelled */
      );
      const G = T[_];
      G && Ni(i, G) && G.el._leaveCb && G.el._leaveCb(), D(Q, [M]);
    },
    enter(M) {
      let Q = l, G = p, z = v;
      if (!s.isMounted)
        if (y)
          Q = f || l, G = k || p, z = E || v;
        else
          return;
      let re = !1;
      const he = M._enterCb = (de) => {
        re || (re = !0, de ? D(z, [M]) : D(G, [M]), I.delayedLeave && I.delayedLeave(), M._enterCb = void 0);
      };
      Q ? V(Q, [M, he]) : he();
    },
    leave(M, Q) {
      const G = String(i.key);
      if (M._enterCb && M._enterCb(
        !0
        /* cancelled */
      ), s.isUnmounting)
        return Q();
      D(c, [M]);
      let z = !1;
      const re = M._leaveCb = (he) => {
        z || (z = !0, Q(), he ? D(m, [M]) : D(h, [M]), M._leaveCb = void 0, T[G] === i && delete T[G]);
      };
      T[G] = i, e ? V(e, [M, re]) : re();
    },
    clone(M) {
      return Mo(M, n, s, u);
    }
  };
  return I;
}
function Jd(i) {
  if (Wo(i))
    return i = wi(i), i.children = null, i;
}
function rb(i) {
  return Wo(i) ? i.children ? i.children[0] : void 0 : i;
}
function Ws(i, n) {
  i.shapeFlag & 6 && i.component ? Ws(i.component.subTree, n) : i.shapeFlag & 128 ? (i.ssContent.transition = n.clone(i.ssContent), i.ssFallback.transition = n.clone(i.ssFallback)) : i.transition = n;
}
function dh(i, n = !1, s) {
  let u = [], y = 0;
  for (let w = 0; w < i.length; w++) {
    let S = i[w];
    const d = s == null ? S.key : String(s) + String(S.key != null ? S.key : w);
    S.type === _n ? (S.patchFlag & 128 && y++, u = u.concat(
      dh(S.children, n, d)
    )) : (n || S.type !== ln) && u.push(d != null ? wi(S, { key: d }) : S);
  }
  if (y > 1)
    for (let w = 0; w < u.length; w++)
      u[w].patchFlag = -2;
  return u;
}
function hm(i, n) {
  return ft(i) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    _t({ name: i.name }, n, { setup: i })
  ) : i;
}
const Is = (i) => !!i.type.__asyncLoader;
function o6(i) {
  ft(i) && (i = { loader: i });
  const {
    loader: n,
    loadingComponent: s,
    errorComponent: u,
    delay: y = 200,
    timeout: w,
    // undefined = never times out
    suspensible: S = !0,
    onError: d
  } = i;
  let l = null, p, v = 0;
  const c = () => (v++, l = null, e()), e = () => {
    let h;
    return l || (h = l = n().catch((m) => {
      if (m = m instanceof Error ? m : new Error(String(m)), d)
        return new Promise((b, f) => {
          d(m, () => b(c()), () => f(m), v + 1);
        });
      throw m;
    }).then((m) => {
      if (h !== l && l)
        return l;
      if (process.env.NODE_ENV !== "production" && !m && _e(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), m && (m.__esModule || m[Symbol.toStringTag] === "Module") && (m = m.default), process.env.NODE_ENV !== "production" && m && !Nt(m) && !ft(m))
        throw new Error(`Invalid async component load result: ${m}`);
      return p = m, m;
    }));
  };
  return hm({
    name: "AsyncComponentWrapper",
    __asyncLoader: e,
    get __asyncResolved() {
      return p;
    },
    setup() {
      const h = sn;
      if (p)
        return () => Qd(p, h);
      const m = (E) => {
        l = null, qs(
          E,
          h,
          13,
          !u
          /* do not throw in dev if user provided error component */
        );
      };
      if (S && h.suspense || Ao)
        return e().then((E) => () => Qd(E, h)).catch((E) => (m(E), () => u ? Xt(u, {
          error: E
        }) : null));
      const b = is(!1), f = is(), k = is(!!y);
      return y && setTimeout(() => {
        k.value = !1;
      }, y), w != null && setTimeout(() => {
        if (!b.value && !f.value) {
          const E = new Error(
            `Async component timed out after ${w}ms.`
          );
          m(E), f.value = E;
        }
      }, w), e().then(() => {
        b.value = !0, h.parent && Wo(h.parent.vnode) && Fl(h.parent.update);
      }).catch((E) => {
        m(E), f.value = E;
      }), () => {
        if (b.value && p)
          return Qd(p, h);
        if (f.value && u)
          return Xt(u, {
            error: f.value
          });
        if (s && !k.value)
          return Xt(s);
      };
    }
  });
}
function Qd(i, n) {
  const { ref: s, props: u, children: y, ce: w } = n.vnode, S = Xt(i, u, y);
  return S.ref = s, S.ce = w, delete n.vnode.ce, S;
}
const Wo = (i) => i.type.__isKeepAlive, a6 = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(i, { slots: n }) {
    const s = wr(), u = s.ctx;
    if (!u.renderer)
      return () => {
        const E = n.default && n.default();
        return E && E.length === 1 ? E[0] : E;
      };
    const y = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Set();
    let S = null;
    (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && (s.__v_cache = y);
    const d = s.suspense, {
      renderer: {
        p: l,
        m: p,
        um: v,
        o: { createElement: c }
      }
    } = u, e = c("div");
    u.activate = (E, _, T, D, V) => {
      const I = E.component;
      p(E, _, T, 0, d), l(
        I.vnode,
        E,
        _,
        T,
        I,
        d,
        D,
        E.slotScopeIds,
        V
      ), Dn(() => {
        I.isDeactivated = !1, I.a && dr(I.a);
        const M = E.props && E.props.onVnodeMounted;
        M && Gn(M, I.parent, E);
      }, d), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && If(I);
    }, u.deactivate = (E) => {
      const _ = E.component;
      p(E, e, null, 1, d), Dn(() => {
        _.da && dr(_.da);
        const T = E.props && E.props.onVnodeUnmounted;
        T && Gn(T, _.parent, E), _.isDeactivated = !0;
      }, d), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && If(_);
    };
    function h(E) {
      Zd(E), v(E, s, d, !0);
    }
    function m(E) {
      y.forEach((_, T) => {
        const D = _l(_.type);
        D && (!E || !E(D)) && b(T);
      });
    }
    function b(E) {
      const _ = y.get(E);
      !S || !Ni(_, S) ? h(_) : S && Zd(S), y.delete(E), w.delete(E);
    }
    $s(
      () => [i.include, i.exclude],
      ([E, _]) => {
        E && m((T) => ja(E, T)), _ && m((T) => !ja(_, T));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let f = null;
    const k = () => {
      f != null && y.set(f, ef(s.subTree));
    };
    return Rl(k), ph(k), mh(() => {
      y.forEach((E) => {
        const { subTree: _, suspense: T } = s, D = ef(_);
        if (E.type === D.type && E.key === D.key) {
          Zd(D);
          const V = D.component.da;
          V && Dn(V, T);
          return;
        }
        h(E);
      });
    }), () => {
      if (f = null, !n.default)
        return null;
      const E = n.default(), _ = E[0];
      if (E.length > 1)
        return process.env.NODE_ENV !== "production" && _e("KeepAlive should contain exactly one component child."), S = null, E;
      if (!br(_) || !(_.shapeFlag & 4) && !(_.shapeFlag & 128))
        return S = null, _;
      let T = ef(_);
      const D = T.type, V = _l(
        Is(T) ? T.type.__asyncResolved || {} : D
      ), { include: I, exclude: M, max: Q } = i;
      if (I && (!V || !ja(I, V)) || M && V && ja(M, V))
        return S = T, _;
      const G = T.key == null ? D : T.key, z = y.get(G);
      return T.el && (T = wi(T), _.shapeFlag & 128 && (_.ssContent = T)), f = G, z ? (T.el = z.el, T.component = z.component, T.transition && Ws(T, T.transition), T.shapeFlag |= 512, w.delete(G), w.add(G)) : (w.add(G), Q && w.size > parseInt(Q, 10) && b(w.values().next().value)), T.shapeFlag |= 256, S = T, fw(_.type) ? _ : T;
    };
  }
}, l6 = a6;
function ja(i, n) {
  return Je(i) ? i.some((s) => ja(s, n)) : wt(i) ? i.split(",").includes(n) : AC(i) ? i.test(n) : !1;
}
function Cw(i, n) {
  kw(i, "a", n);
}
function ww(i, n) {
  kw(i, "da", n);
}
function kw(i, n, s = sn) {
  const u = i.__wdc || (i.__wdc = () => {
    let y = s;
    for (; y; ) {
      if (y.isDeactivated)
        return;
      y = y.parent;
    }
    return i();
  });
  if (fh(n, u, s), s) {
    let y = s.parent;
    for (; y && y.parent; )
      Wo(y.parent.vnode) && c6(u, n, s, y), y = y.parent;
  }
}
function c6(i, n, s, u) {
  const y = fh(
    n,
    i,
    u,
    !0
    /* prepend */
  );
  gh(() => {
    Iu(u[n], y);
  }, s);
}
function Zd(i) {
  i.shapeFlag &= -257, i.shapeFlag &= -513;
}
function ef(i) {
  return i.shapeFlag & 128 ? i.ssContent : i;
}
function fh(i, n, s = sn, u = !1) {
  if (s) {
    const y = s[i] || (s[i] = []), w = n.__weh || (n.__weh = (...S) => {
      if (s.isUnmounted)
        return;
      Gs(), hs(s);
      const d = ci(n, s, i, S);
      return os(), Xs(), d;
    });
    return u ? y.unshift(w) : y.push(w), w;
  } else if (process.env.NODE_ENV !== "production") {
    const y = Oi(Zp[i].replace(/ hook$/, ""));
    _e(
      `${y} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const Cr = (i) => (n, s = sn) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Ao || i === "sp") && fh(i, (...u) => n(...u), s)
), Sw = Cr("bm"), Rl = Cr("m"), Ew = Cr("bu"), ph = Cr("u"), mh = Cr("bum"), gh = Cr("um"), xw = Cr("sp"), _w = Cr(
  "rtg"
), Tw = Cr(
  "rtc"
);
function Ow(i, n = sn) {
  fh("ec", i, n);
}
const xu = "components", u6 = "directives";
function h6(i, n) {
  return dm(xu, i, !0, n) || i;
}
const Dw = Symbol.for("v-ndc");
function d6(i) {
  return wt(i) ? dm(xu, i, !1) || i : i || Dw;
}
function f6(i) {
  return dm(u6, i);
}
function dm(i, n, s = !0, u = !1) {
  const y = on || sn;
  if (y) {
    const w = y.type;
    if (i === xu) {
      const d = _l(
        w,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (d && (d === n || d === an(n) || d === Pi(an(n))))
        return w;
    }
    const S = (
      // local registration
      // check instance[type] first which is resolved for options API
      sb(y[i] || w[i], n) || // global registration
      sb(y.appContext[i], n)
    );
    if (!S && u)
      return w;
    if (process.env.NODE_ENV !== "production" && s && !S) {
      const d = i === xu ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      _e(`Failed to resolve ${i.slice(0, -1)}: ${n}${d}`);
    }
    return S;
  } else
    process.env.NODE_ENV !== "production" && _e(
      `resolve${Pi(i.slice(0, -1))} can only be used in render() or setup().`
    );
}
function sb(i, n) {
  return i && (i[n] || i[an(n)] || i[Pi(an(n))]);
}
function p6(i, n, s, u) {
  let y;
  const w = s && s[u];
  if (Je(i) || wt(i)) {
    y = new Array(i.length);
    for (let S = 0, d = i.length; S < d; S++)
      y[S] = n(i[S], S, void 0, w && w[S]);
  } else if (typeof i == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(i) && _e(`The v-for range expect an integer value but got ${i}.`), y = new Array(i);
    for (let S = 0; S < i; S++)
      y[S] = n(S + 1, S, void 0, w && w[S]);
  } else if (Nt(i))
    if (i[Symbol.iterator])
      y = Array.from(
        i,
        (S, d) => n(S, d, void 0, w && w[d])
      );
    else {
      const S = Object.keys(i);
      y = new Array(S.length);
      for (let d = 0, l = S.length; d < l; d++) {
        const p = S[d];
        y[d] = n(i[p], p, d, w && w[d]);
      }
    }
  else
    y = [];
  return s && (s[u] = y), y;
}
function m6(i, n) {
  for (let s = 0; s < n.length; s++) {
    const u = n[s];
    if (Je(u))
      for (let y = 0; y < u.length; y++)
        i[u[y].name] = u[y].fn;
    else
      u && (i[u.name] = u.key ? (...y) => {
        const w = u.fn(...y);
        return w && (w.key = u.key), w;
      } : u.fn);
  }
  return i;
}
function g6(i, n, s = {}, u, y) {
  if (on.isCE || on.parent && Is(on.parent) && on.parent.isCE)
    return n !== "default" && (s.name = n), Xt("slot", s, u && u());
  let w = i[n];
  process.env.NODE_ENV !== "production" && w && w.length > 1 && (_e(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), w = () => []), w && w._c && (w._d = !1), vh();
  const S = w && Nw(w(s)), d = gm(
    _n,
    {
      key: s.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      S && S.key || `_${n}`
    },
    S || (u ? u() : []),
    S && i._ === 1 ? 64 : -2
  );
  return !y && d.scopeId && (d.slotScopeIds = [d.scopeId + "-s"]), w && w._c && (w._d = !0), d;
}
function Nw(i) {
  return i.some((n) => br(n) ? !(n.type === ln || n.type === _n && !Nw(n.children)) : !0) ? i : null;
}
function v6(i, n) {
  const s = {};
  if (process.env.NODE_ENV !== "production" && !Nt(i))
    return _e("v-on with no argument expects an object value."), s;
  for (const u in i)
    s[n && /[A-Z]/.test(u) ? `on:${u}` : Oi(u)] = i[u];
  return s;
}
const Af = (i) => i ? Zw(i) ? bh(i) || i.proxy : Af(i.parent) : null, Ms = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ _t(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => process.env.NODE_ENV !== "production" ? So(i.props) : i.props,
    $attrs: (i) => process.env.NODE_ENV !== "production" ? So(i.attrs) : i.attrs,
    $slots: (i) => process.env.NODE_ENV !== "production" ? So(i.slots) : i.slots,
    $refs: (i) => process.env.NODE_ENV !== "production" ? So(i.refs) : i.refs,
    $parent: (i) => Af(i.parent),
    $root: (i) => Af(i.root),
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? pm(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => Fl(i.update)),
    $nextTick: (i) => i.n || (i.n = tm.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? i6.bind(i) : en
  })
), fm = (i) => i === "_" || i === "$", tf = (i, n) => i !== Ft && !i.__isScriptSetup && Dt(i, n), Xa = {
  get({ _: i }, n) {
    const { ctx: s, setupState: u, data: y, props: w, accessCache: S, type: d, appContext: l } = i;
    if (process.env.NODE_ENV !== "production" && n === "__isVue")
      return !0;
    let p;
    if (n[0] !== "$") {
      const h = S[n];
      if (h !== void 0)
        switch (h) {
          case 1:
            return u[n];
          case 2:
            return y[n];
          case 4:
            return s[n];
          case 3:
            return w[n];
        }
      else {
        if (tf(u, n))
          return S[n] = 1, u[n];
        if (y !== Ft && Dt(y, n))
          return S[n] = 2, y[n];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (p = i.propsOptions[0]) && Dt(p, n)
        )
          return S[n] = 3, w[n];
        if (s !== Ft && Dt(s, n))
          return S[n] = 4, s[n];
        (!__VUE_OPTIONS_API__ || Ff) && (S[n] = 0);
      }
    }
    const v = Ms[n];
    let c, e;
    if (v)
      return n === "$attrs" ? (Pn(i, "get", n), process.env.NODE_ENV !== "production" && Eu()) : process.env.NODE_ENV !== "production" && n === "$slots" && Pn(i, "get", n), v(i);
    if (
      // css module (injected by vue-loader)
      (c = d.__cssModules) && (c = c[n])
    )
      return c;
    if (s !== Ft && Dt(s, n))
      return S[n] = 4, s[n];
    if (
      // global properties
      e = l.config.globalProperties, Dt(e, n)
    )
      return e[n];
    process.env.NODE_ENV !== "production" && on && (!wt(n) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    n.indexOf("__v") !== 0) && (y !== Ft && fm(n[0]) && Dt(y, n) ? _e(
      `Property ${JSON.stringify(
        n
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : i === on && _e(
      `Property ${JSON.stringify(n)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: i }, n, s) {
    const { data: u, setupState: y, ctx: w } = i;
    return tf(y, n) ? (y[n] = s, !0) : process.env.NODE_ENV !== "production" && y.__isScriptSetup && Dt(y, n) ? (_e(`Cannot mutate <script setup> binding "${n}" from Options API.`), !1) : u !== Ft && Dt(u, n) ? (u[n] = s, !0) : Dt(i.props, n) ? (process.env.NODE_ENV !== "production" && _e(`Attempting to mutate prop "${n}". Props are readonly.`), !1) : n[0] === "$" && n.slice(1) in i ? (process.env.NODE_ENV !== "production" && _e(
      `Attempting to mutate public property "${n}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && n in i.appContext.config.globalProperties ? Object.defineProperty(w, n, {
      enumerable: !0,
      configurable: !0,
      value: s
    }) : w[n] = s, !0);
  },
  has({
    _: { data: i, setupState: n, accessCache: s, ctx: u, appContext: y, propsOptions: w }
  }, S) {
    let d;
    return !!s[S] || i !== Ft && Dt(i, S) || tf(n, S) || (d = w[0]) && Dt(d, S) || Dt(u, S) || Dt(Ms, S) || Dt(y.config.globalProperties, S);
  },
  defineProperty(i, n, s) {
    return s.get != null ? i._.accessCache[n] = 0 : Dt(s, "value") && this.set(i, n, s.value, null), Reflect.defineProperty(i, n, s);
  }
};
process.env.NODE_ENV !== "production" && (Xa.ownKeys = (i) => (_e(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(i)));
const y6 = /* @__PURE__ */ _t(
  {},
  Xa,
  {
    get(i, n) {
      if (n !== Symbol.unscopables)
        return Xa.get(i, n, i);
    },
    has(i, n) {
      const s = n[0] !== "_" && !LC(n);
      return process.env.NODE_ENV !== "production" && !s && Xa.has(i, n) && _e(
        `Property ${JSON.stringify(
          n
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), s;
    }
  }
);
function b6(i) {
  const n = {};
  return Object.defineProperty(n, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => i
  }), Object.keys(Ms).forEach((s) => {
    Object.defineProperty(n, s, {
      configurable: !0,
      enumerable: !1,
      get: () => Ms[s](i),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: en
    });
  }), n;
}
function C6(i) {
  const {
    ctx: n,
    propsOptions: [s]
  } = i;
  s && Object.keys(s).forEach((u) => {
    Object.defineProperty(n, u, {
      enumerable: !0,
      configurable: !0,
      get: () => i.props[u],
      set: en
    });
  });
}
function w6(i) {
  const { ctx: n, setupState: s } = i;
  Object.keys(Et(s)).forEach((u) => {
    if (!s.__isScriptSetup) {
      if (fm(u[0])) {
        _e(
          `setup() return property ${JSON.stringify(
            u
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(n, u, {
        enumerable: !0,
        configurable: !0,
        get: () => s[u],
        set: en
      });
    }
  });
}
const Js = (i) => _e(
  `${i}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function k6() {
  return process.env.NODE_ENV !== "production" && Js("defineProps"), null;
}
function S6() {
  return process.env.NODE_ENV !== "production" && Js("defineEmits"), null;
}
function E6(i) {
  process.env.NODE_ENV !== "production" && Js("defineExpose");
}
function x6(i) {
  process.env.NODE_ENV !== "production" && Js("defineOptions");
}
function _6() {
  return process.env.NODE_ENV !== "production" && Js("defineSlots"), null;
}
function T6() {
  process.env.NODE_ENV !== "production" && Js("defineModel");
}
function O6(i, n) {
  return process.env.NODE_ENV !== "production" && Js("withDefaults"), null;
}
function D6() {
  return Bw().slots;
}
function N6() {
  return Bw().attrs;
}
function B6(i, n, s) {
  const u = wr();
  if (process.env.NODE_ENV !== "production" && !u)
    return _e("useModel() called without active instance."), is();
  if (process.env.NODE_ENV !== "production" && !u.propsOptions[0][n])
    return _e(`useModel() called with prop "${n}" which is not declared.`), is();
  if (s && s.local) {
    const y = is(i[n]);
    return $s(
      () => i[n],
      (w) => y.value = w
    ), $s(y, (w) => {
      w !== i[n] && u.emit(`update:${n}`, w);
    }), y;
  } else
    return {
      __v_isRef: !0,
      get value() {
        return i[n];
      },
      set value(y) {
        u.emit(`update:${n}`, y);
      }
    };
}
function Bw() {
  const i = wr();
  return process.env.NODE_ENV !== "production" && !i && _e("useContext() called without active instance."), i.setupContext || (i.setupContext = nk(i));
}
function El(i) {
  return Je(i) ? i.reduce(
    (n, s) => (n[s] = null, n),
    {}
  ) : i;
}
function P6(i, n) {
  const s = El(i);
  for (const u in n) {
    if (u.startsWith("__skip"))
      continue;
    let y = s[u];
    y ? Je(y) || ft(y) ? y = s[u] = { type: y, default: n[u] } : y.default = n[u] : y === null ? y = s[u] = { default: n[u] } : process.env.NODE_ENV !== "production" && _e(`props default key "${u}" has no corresponding declaration.`), y && n[`__skip_${u}`] && (y.skipFactory = !0);
  }
  return s;
}
function V6(i, n) {
  return !i || !n ? i || n : Je(i) && Je(n) ? i.concat(n) : _t({}, El(i), El(n));
}
function $6(i, n) {
  const s = {};
  for (const u in i)
    n.includes(u) || Object.defineProperty(s, u, {
      enumerable: !0,
      get: () => i[u]
    });
  return s;
}
function I6(i) {
  const n = wr();
  process.env.NODE_ENV !== "production" && !n && _e(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let s = i();
  return os(), Nl(s) && (s = s.catch((u) => {
    throw hs(n), u;
  })), [s, () => hs(n)];
}
function M6() {
  const i = /* @__PURE__ */ Object.create(null);
  return (n, s) => {
    i[s] ? _e(`${n} property "${s}" is already defined in ${i[s]}.`) : i[s] = n;
  };
}
let Ff = !0;
function A6(i) {
  const n = pm(i), s = i.proxy, u = i.ctx;
  Ff = !1, n.beforeCreate && ob(n.beforeCreate, i, "bc");
  const {
    // state
    data: y,
    computed: w,
    methods: S,
    watch: d,
    provide: l,
    inject: p,
    // lifecycle
    created: v,
    beforeMount: c,
    mounted: e,
    beforeUpdate: h,
    updated: m,
    activated: b,
    deactivated: f,
    beforeDestroy: k,
    beforeUnmount: E,
    destroyed: _,
    unmounted: T,
    render: D,
    renderTracked: V,
    renderTriggered: I,
    errorCaptured: M,
    serverPrefetch: Q,
    // public API
    expose: G,
    inheritAttrs: z,
    // assets
    components: re,
    directives: he,
    filters: de
  } = n, Ce = process.env.NODE_ENV !== "production" ? M6() : null;
  if (process.env.NODE_ENV !== "production") {
    const [Ie] = i.propsOptions;
    if (Ie)
      for (const Be in Ie)
        Ce("Props", Be);
  }
  if (p && F6(p, u, Ce), S)
    for (const Ie in S) {
      const Be = S[Ie];
      ft(Be) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(u, Ie, {
        value: Be.bind(s),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : u[Ie] = Be.bind(s), process.env.NODE_ENV !== "production" && Ce("Methods", Ie)) : process.env.NODE_ENV !== "production" && _e(
        `Method "${Ie}" has type "${typeof Be}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (y) {
    process.env.NODE_ENV !== "production" && !ft(y) && _e(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const Ie = y.call(s, s);
    if (process.env.NODE_ENV !== "production" && Nl(Ie) && _e(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Nt(Ie))
      process.env.NODE_ENV !== "production" && _e("data() should return an object.");
    else if (i.data = oh(Ie), process.env.NODE_ENV !== "production")
      for (const Be in Ie)
        Ce("Data", Be), fm(Be[0]) || Object.defineProperty(u, Be, {
          configurable: !0,
          enumerable: !0,
          get: () => Ie[Be],
          set: en
        });
  }
  if (Ff = !0, w)
    for (const Ie in w) {
      const Be = w[Ie], L = ft(Be) ? Be.bind(s, s) : ft(Be.get) ? Be.get.bind(s, s) : en;
      process.env.NODE_ENV !== "production" && L === en && _e(`Computed property "${Ie}" has no getter.`);
      const Z = !ft(Be) && ft(Be.set) ? Be.set.bind(s) : process.env.NODE_ENV !== "production" ? () => {
        _e(
          `Write operation failed: computed property "${Ie}" is readonly.`
        );
      } : en, W = rk({
        get: L,
        set: Z
      });
      Object.defineProperty(u, Ie, {
        enumerable: !0,
        configurable: !0,
        get: () => W.value,
        set: (Y) => W.value = Y
      }), process.env.NODE_ENV !== "production" && Ce("Computed", Ie);
    }
  if (d)
    for (const Ie in d)
      Pw(d[Ie], u, s, Ie);
  if (l) {
    const Ie = ft(l) ? l.call(s) : l;
    Reflect.ownKeys(Ie).forEach((Be) => {
      $w(Be, Ie[Be]);
    });
  }
  v && ob(v, i, "c");
  function xe(Ie, Be) {
    Je(Be) ? Be.forEach((L) => Ie(L.bind(s))) : Be && Ie(Be.bind(s));
  }
  if (xe(Sw, c), xe(Rl, e), xe(Ew, h), xe(ph, m), xe(Cw, b), xe(ww, f), xe(Ow, M), xe(Tw, V), xe(_w, I), xe(mh, E), xe(gh, T), xe(xw, Q), Je(G))
    if (G.length) {
      const Ie = i.exposed || (i.exposed = {});
      G.forEach((Be) => {
        Object.defineProperty(Ie, Be, {
          get: () => s[Be],
          set: (L) => s[Be] = L
        });
      });
    } else
      i.exposed || (i.exposed = {});
  D && i.render === en && (i.render = D), z != null && (i.inheritAttrs = z), re && (i.components = re), he && (i.directives = he);
}
function F6(i, n, s = en) {
  Je(i) && (i = Lf(i));
  for (const u in i) {
    const y = i[u];
    let w;
    Nt(y) ? "default" in y ? w = qa(
      y.from || u,
      y.default,
      !0
      /* treat default function as factory */
    ) : w = qa(y.from || u) : w = qa(y), tn(w) ? Object.defineProperty(n, u, {
      enumerable: !0,
      configurable: !0,
      get: () => w.value,
      set: (S) => w.value = S
    }) : n[u] = w, process.env.NODE_ENV !== "production" && s("Inject", u);
  }
}
function ob(i, n, s) {
  ci(
    Je(i) ? i.map((u) => u.bind(n.proxy)) : i.bind(n.proxy),
    n,
    s
  );
}
function Pw(i, n, s, u) {
  const y = u.includes(".") ? gw(s, u) : () => s[u];
  if (wt(i)) {
    const w = n[i];
    ft(w) ? $s(y, w) : process.env.NODE_ENV !== "production" && _e(`Invalid watch handler specified by key "${i}"`, w);
  } else if (ft(i))
    $s(y, i.bind(s));
  else if (Nt(i))
    if (Je(i))
      i.forEach((w) => Pw(w, n, s, u));
    else {
      const w = ft(i.handler) ? i.handler.bind(s) : n[i.handler];
      ft(w) ? $s(y, w, i) : process.env.NODE_ENV !== "production" && _e(`Invalid watch handler specified by key "${i.handler}"`, w);
    }
  else
    process.env.NODE_ENV !== "production" && _e(`Invalid watch option: "${u}"`, i);
}
function pm(i) {
  const n = i.type, { mixins: s, extends: u } = n, {
    mixins: y,
    optionsCache: w,
    config: { optionMergeStrategies: S }
  } = i.appContext, d = w.get(n);
  let l;
  return d ? l = d : !y.length && !s && !u ? l = n : (l = {}, y.length && y.forEach(
    (p) => _u(l, p, S, !0)
  ), _u(l, n, S)), Nt(n) && w.set(n, l), l;
}
function _u(i, n, s, u = !1) {
  const { mixins: y, extends: w } = n;
  w && _u(i, w, s, !0), y && y.forEach(
    (S) => _u(i, S, s, !0)
  );
  for (const S in n)
    if (u && S === "expose")
      process.env.NODE_ENV !== "production" && _e(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const d = L6[S] || s && s[S];
      i[S] = d ? d(i[S], n[S]) : n[S];
    }
  return i;
}
const L6 = {
  data: ab,
  props: lb,
  emits: lb,
  // objects
  methods: Ha,
  computed: Ha,
  // lifecycle
  beforeCreate: Un,
  created: Un,
  beforeMount: Un,
  mounted: Un,
  beforeUpdate: Un,
  updated: Un,
  beforeDestroy: Un,
  beforeUnmount: Un,
  destroyed: Un,
  unmounted: Un,
  activated: Un,
  deactivated: Un,
  errorCaptured: Un,
  serverPrefetch: Un,
  // assets
  components: Ha,
  directives: Ha,
  // watch
  watch: R6,
  // provide / inject
  provide: ab,
  inject: z6
};
function ab(i, n) {
  return n ? i ? function() {
    return _t(
      ft(i) ? i.call(this, this) : i,
      ft(n) ? n.call(this, this) : n
    );
  } : n : i;
}
function z6(i, n) {
  return Ha(Lf(i), Lf(n));
}
function Lf(i) {
  if (Je(i)) {
    const n = {};
    for (let s = 0; s < i.length; s++)
      n[i[s]] = i[s];
    return n;
  }
  return i;
}
function Un(i, n) {
  return i ? [...new Set([].concat(i, n))] : n;
}
function Ha(i, n) {
  return i ? _t(/* @__PURE__ */ Object.create(null), i, n) : n;
}
function lb(i, n) {
  return i ? Je(i) && Je(n) ? [.../* @__PURE__ */ new Set([...i, ...n])] : _t(
    /* @__PURE__ */ Object.create(null),
    El(i),
    El(n ?? {})
  ) : n;
}
function R6(i, n) {
  if (!i)
    return n;
  if (!n)
    return i;
  const s = _t(/* @__PURE__ */ Object.create(null), i);
  for (const u in n)
    s[u] = Un(i[u], n[u]);
  return s;
}
function Vw() {
  return {
    app: null,
    config: {
      isNativeTag: _o,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let j6 = 0;
function H6(i, n) {
  return function(u, y = null) {
    ft(u) || (u = _t({}, u)), y != null && !Nt(y) && (process.env.NODE_ENV !== "production" && _e("root props passed to app.mount() must be an object."), y = null);
    const w = Vw();
    process.env.NODE_ENV !== "production" && Object.defineProperty(w.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        _e(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const S = /* @__PURE__ */ new Set();
    let d = !1;
    const l = w.app = {
      _uid: j6++,
      _component: u,
      _props: y,
      _container: null,
      _context: w,
      _instance: null,
      version: Gf,
      get config() {
        return w.config;
      },
      set config(p) {
        process.env.NODE_ENV !== "production" && _e(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(p, ...v) {
        return S.has(p) ? process.env.NODE_ENV !== "production" && _e("Plugin has already been applied to target app.") : p && ft(p.install) ? (S.add(p), p.install(l, ...v)) : ft(p) ? (S.add(p), p(l, ...v)) : process.env.NODE_ENV !== "production" && _e(
          'A plugin must either be a function or an object with an "install" function.'
        ), l;
      },
      mixin(p) {
        return __VUE_OPTIONS_API__ ? w.mixins.includes(p) ? process.env.NODE_ENV !== "production" && _e(
          "Mixin has already been applied to target app" + (p.name ? `: ${p.name}` : "")
        ) : w.mixins.push(p) : process.env.NODE_ENV !== "production" && _e("Mixins are only available in builds supporting Options API"), l;
      },
      component(p, v) {
        return process.env.NODE_ENV !== "production" && Wf(p, w.config), v ? (process.env.NODE_ENV !== "production" && w.components[p] && _e(`Component "${p}" has already been registered in target app.`), w.components[p] = v, l) : w.components[p];
      },
      directive(p, v) {
        return process.env.NODE_ENV !== "production" && vw(p), v ? (process.env.NODE_ENV !== "production" && w.directives[p] && _e(`Directive "${p}" has already been registered in target app.`), w.directives[p] = v, l) : w.directives[p];
      },
      mount(p, v, c) {
        if (d)
          process.env.NODE_ENV !== "production" && _e(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          process.env.NODE_ENV !== "production" && p.__vue_app__ && _e(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const e = Xt(
            u,
            y
          );
          return e.appContext = w, process.env.NODE_ENV !== "production" && (w.reload = () => {
            i(wi(e), p, c);
          }), v && n ? n(e, p) : i(e, p, c), d = !0, l._container = p, p.__vue_app__ = l, (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && (l._instance = e.component, VF(l, Gf)), bh(e.component) || e.component.proxy;
        }
      },
      unmount() {
        d ? (i(null, l._container), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && (l._instance = null, $F(l)), delete l._container.__vue_app__) : process.env.NODE_ENV !== "production" && _e("Cannot unmount an app that is not mounted.");
      },
      provide(p, v) {
        return process.env.NODE_ENV !== "production" && p in w.provides && _e(
          `App already provides property with key "${String(p)}". It will be overwritten with the new value.`
        ), w.provides[p] = v, l;
      },
      runWithContext(p) {
        xl = l;
        try {
          return p();
        } finally {
          xl = null;
        }
      }
    };
    return l;
  };
}
let xl = null;
function $w(i, n) {
  if (!sn)
    process.env.NODE_ENV !== "production" && _e("provide() can only be used inside setup().");
  else {
    let s = sn.provides;
    const u = sn.parent && sn.parent.provides;
    u === s && (s = sn.provides = Object.create(u)), s[i] = n;
  }
}
function qa(i, n, s = !1) {
  const u = sn || on;
  if (u || xl) {
    const y = u ? u.parent == null ? u.vnode.appContext && u.vnode.appContext.provides : u.parent.provides : xl._context.provides;
    if (y && i in y)
      return y[i];
    if (arguments.length > 1)
      return s && ft(n) ? n.call(u && u.proxy) : n;
    process.env.NODE_ENV !== "production" && _e(`injection "${String(i)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" && _e("inject() can only be used inside setup() or functional components.");
}
function U6() {
  return !!(sn || on || xl);
}
function W6(i, n, s, u = !1) {
  const y = {}, w = {};
  rl(w, yh, 1), i.propsDefaults = /* @__PURE__ */ Object.create(null), Iw(i, n, y, w);
  for (const S in i.propsOptions[0])
    S in y || (y[S] = void 0);
  process.env.NODE_ENV !== "production" && Aw(n || {}, y, i), s ? i.props = u ? y : nw(y) : i.type.props ? i.props = y : i.props = w, i.attrs = w;
}
function Y6(i) {
  for (; i; ) {
    if (i.type.__hmrId)
      return !0;
    i = i.parent;
  }
}
function K6(i, n, s, u) {
  const {
    props: y,
    attrs: w,
    vnode: { patchFlag: S }
  } = i, d = Et(y), [l] = i.propsOptions;
  let p = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && Y6(i)) && (u || S > 0) && !(S & 16)
  ) {
    if (S & 8) {
      const v = i.vnode.dynamicProps;
      for (let c = 0; c < v.length; c++) {
        let e = v[c];
        if (uh(i.emitsOptions, e))
          continue;
        const h = n[e];
        if (l)
          if (Dt(w, e))
            h !== w[e] && (w[e] = h, p = !0);
          else {
            const m = an(e);
            y[m] = zf(
              l,
              d,
              m,
              h,
              i,
              !1
              /* isAbsent */
            );
          }
        else
          h !== w[e] && (w[e] = h, p = !0);
      }
    }
  } else {
    Iw(i, n, y, w) && (p = !0);
    let v;
    for (const c in d)
      (!n || // for camelCase
      !Dt(n, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((v = Bn(c)) === c || !Dt(n, v))) && (l ? s && // for camelCase
      (s[c] !== void 0 || // for kebab-case
      s[v] !== void 0) && (y[c] = zf(
        l,
        d,
        c,
        void 0,
        i,
        !0
        /* isAbsent */
      )) : delete y[c]);
    if (w !== d)
      for (const c in w)
        (!n || !Dt(n, c)) && (delete w[c], p = !0);
  }
  p && Xi(i, "set", "$attrs"), process.env.NODE_ENV !== "production" && Aw(n || {}, y, i);
}
function Iw(i, n, s, u) {
  const [y, w] = i.propsOptions;
  let S = !1, d;
  if (n)
    for (let l in n) {
      if (Zr(l))
        continue;
      const p = n[l];
      let v;
      y && Dt(y, v = an(l)) ? !w || !w.includes(v) ? s[v] = p : (d || (d = {}))[v] = p : uh(i.emitsOptions, l) || (!(l in u) || p !== u[l]) && (u[l] = p, S = !0);
    }
  if (w) {
    const l = Et(s), p = d || Ft;
    for (let v = 0; v < w.length; v++) {
      const c = w[v];
      s[c] = zf(
        y,
        l,
        c,
        p[c],
        i,
        !Dt(p, c)
      );
    }
  }
  return S;
}
function zf(i, n, s, u, y, w) {
  const S = i[s];
  if (S != null) {
    const d = Dt(S, "default");
    if (d && u === void 0) {
      const l = S.default;
      if (S.type !== Function && !S.skipFactory && ft(l)) {
        const { propsDefaults: p } = y;
        s in p ? u = p[s] : (hs(y), u = p[s] = l.call(
          null,
          n
        ), os());
      } else
        u = l;
    }
    S[
      0
      /* shouldCast */
    ] && (w && !d ? u = !1 : S[
      1
      /* shouldCastTrue */
    ] && (u === "" || u === Bn(s)) && (u = !0));
  }
  return u;
}
function Mw(i, n, s = !1) {
  const u = n.propsCache, y = u.get(i);
  if (y)
    return y;
  const w = i.props, S = {}, d = [];
  let l = !1;
  if (__VUE_OPTIONS_API__ && !ft(i)) {
    const v = (c) => {
      l = !0;
      const [e, h] = Mw(c, n, !0);
      _t(S, e), h && d.push(...h);
    };
    !s && n.mixins.length && n.mixins.forEach(v), i.extends && v(i.extends), i.mixins && i.mixins.forEach(v);
  }
  if (!w && !l)
    return Nt(i) && u.set(i, Bs), Bs;
  if (Je(w))
    for (let v = 0; v < w.length; v++) {
      process.env.NODE_ENV !== "production" && !wt(w[v]) && _e("props must be strings when using array syntax.", w[v]);
      const c = an(w[v]);
      cb(c) && (S[c] = Ft);
    }
  else if (w) {
    process.env.NODE_ENV !== "production" && !Nt(w) && _e("invalid props options", w);
    for (const v in w) {
      const c = an(v);
      if (cb(c)) {
        const e = w[v], h = S[c] = Je(e) || ft(e) ? { type: e } : _t({}, e);
        if (h) {
          const m = hb(Boolean, h.type), b = hb(String, h.type);
          h[
            0
            /* shouldCast */
          ] = m > -1, h[
            1
            /* shouldCastTrue */
          ] = b < 0 || m < b, (m > -1 || Dt(h, "default")) && d.push(c);
        }
      }
    }
  }
  const p = [S, d];
  return Nt(i) && u.set(i, p), p;
}
function cb(i) {
  return i[0] !== "$" ? !0 : (process.env.NODE_ENV !== "production" && _e(`Invalid prop name: "${i}" is a reserved property.`), !1);
}
function Rf(i) {
  const n = i && i.toString().match(/^\s*(function|class) (\w+)/);
  return n ? n[2] : i === null ? "null" : "";
}
function ub(i, n) {
  return Rf(i) === Rf(n);
}
function hb(i, n) {
  return Je(n) ? n.findIndex((s) => ub(s, i)) : ft(n) && ub(n, i) ? 0 : -1;
}
function Aw(i, n, s) {
  const u = Et(n), y = s.propsOptions[0];
  for (const w in y) {
    let S = y[w];
    S != null && G6(
      w,
      u[w],
      S,
      !Dt(i, w) && !Dt(i, Bn(w))
    );
  }
}
function G6(i, n, s, u) {
  const { type: y, required: w, validator: S, skipCheck: d } = s;
  if (w && u) {
    _e('Missing required prop: "' + i + '"');
    return;
  }
  if (!(n == null && !w)) {
    if (y != null && y !== !0 && !d) {
      let l = !1;
      const p = Je(y) ? y : [y], v = [];
      for (let c = 0; c < p.length && !l; c++) {
        const { valid: e, expectedType: h } = q6(n, p[c]);
        v.push(h || ""), l = e;
      }
      if (!l) {
        _e(J6(i, n, v));
        return;
      }
    }
    S && !S(n) && _e('Invalid prop: custom validator check failed for prop "' + i + '".');
  }
}
const X6 = /* @__PURE__ */ fn(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function q6(i, n) {
  let s;
  const u = Rf(n);
  if (X6(u)) {
    const y = typeof i;
    s = y === u.toLowerCase(), !s && y === "object" && (s = i instanceof n);
  } else
    u === "Object" ? s = Nt(i) : u === "Array" ? s = Je(i) : u === "null" ? s = i === null : s = i instanceof n;
  return {
    valid: s,
    expectedType: u
  };
}
function J6(i, n, s) {
  let u = `Invalid prop: type check failed for prop "${i}". Expected ${s.map(Pi).join(" | ")}`;
  const y = s[0], w = Mu(n), S = db(n, y), d = db(n, w);
  return s.length === 1 && fb(y) && !Q6(y, w) && (u += ` with value ${S}`), u += `, got ${w} `, fb(w) && (u += `with value ${d}.`), u;
}
function db(i, n) {
  return n === "String" ? `"${i}"` : n === "Number" ? `${Number(i)}` : `${i}`;
}
function fb(i) {
  return ["string", "number", "boolean"].some((s) => i.toLowerCase() === s);
}
function Q6(...i) {
  return i.some((n) => n.toLowerCase() === "boolean");
}
const Fw = (i) => i[0] === "_" || i === "$stable", mm = (i) => Je(i) ? i.map(qn) : [qn(i)], Z6 = (i, n, s) => {
  if (n._n)
    return n;
  const u = sm((...y) => (process.env.NODE_ENV !== "production" && sn && _e(
    `Slot "${i}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), mm(n(...y))), s);
  return u._c = !1, u;
}, Lw = (i, n, s) => {
  const u = i._ctx;
  for (const y in i) {
    if (Fw(y))
      continue;
    const w = i[y];
    if (ft(w))
      n[y] = Z6(y, w, u);
    else if (w != null) {
      process.env.NODE_ENV !== "production" && _e(
        `Non-function value encountered for slot "${y}". Prefer function slots for better performance.`
      );
      const S = mm(w);
      n[y] = () => S;
    }
  }
}, zw = (i, n) => {
  process.env.NODE_ENV !== "production" && !Wo(i.vnode) && _e(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const s = mm(n);
  i.slots.default = () => s;
}, eL = (i, n) => {
  if (i.vnode.shapeFlag & 32) {
    const s = n._;
    s ? (i.slots = Et(n), rl(n, "_", s)) : Lw(
      n,
      i.slots = {}
    );
  } else
    i.slots = {}, n && zw(i, n);
  rl(i.slots, yh, 1);
}, tL = (i, n, s) => {
  const { vnode: u, slots: y } = i;
  let w = !0, S = Ft;
  if (u.shapeFlag & 32) {
    const d = n._;
    d ? process.env.NODE_ENV !== "production" && rs ? (_t(y, n), Xi(i, "set", "$slots")) : s && d === 1 ? w = !1 : (_t(y, n), !s && d === 1 && delete y._) : (w = !n.$stable, Lw(n, y)), S = n;
  } else
    n && (zw(i, n), S = { default: 1 });
  if (w)
    for (const d in y)
      !Fw(d) && !(d in S) && delete y[d];
};
function Tu(i, n, s, u, y = !1) {
  if (Je(i)) {
    i.forEach(
      (e, h) => Tu(
        e,
        n && (Je(n) ? n[h] : n),
        s,
        u,
        y
      )
    );
    return;
  }
  if (Is(u) && !y)
    return;
  const w = u.shapeFlag & 4 ? bh(u.component) || u.component.proxy : u.el, S = y ? null : w, { i: d, r: l } = i;
  if (process.env.NODE_ENV !== "production" && !d) {
    _e(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const p = n && n.r, v = d.refs === Ft ? d.refs = {} : d.refs, c = d.setupState;
  if (p != null && p !== l && (wt(p) ? (v[p] = null, Dt(c, p) && (c[p] = null)) : tn(p) && (p.value = null)), ft(l))
    Yi(l, d, 12, [S, v]);
  else {
    const e = wt(l), h = tn(l);
    if (e || h) {
      const m = () => {
        if (i.f) {
          const b = e ? Dt(c, l) ? c[l] : v[l] : l.value;
          y ? Je(b) && Iu(b, w) : Je(b) ? b.includes(w) || b.push(w) : e ? (v[l] = [w], Dt(c, l) && (c[l] = v[l])) : (l.value = [w], i.k && (v[i.k] = l.value));
        } else
          e ? (v[l] = S, Dt(c, l) && (c[l] = S)) : h ? (l.value = S, i.k && (v[i.k] = S)) : process.env.NODE_ENV !== "production" && _e("Invalid template ref type:", l, `(${typeof l})`);
      };
      S ? (m.id = -1, Dn(m, s)) : m();
    } else
      process.env.NODE_ENV !== "production" && _e("Invalid template ref type:", l, `(${typeof l})`);
  }
}
let zr = !1;
const Jc = (i) => /svg/.test(i.namespaceURI) && i.tagName !== "foreignObject", Va = (i) => i.nodeType === 8;
function nL(i) {
  const {
    mt: n,
    p: s,
    o: {
      patchProp: u,
      createText: y,
      nextSibling: w,
      parentNode: S,
      remove: d,
      insert: l,
      createComment: p
    }
  } = i, v = (k, E) => {
    if (!E.hasChildNodes()) {
      process.env.NODE_ENV !== "production" && _e(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), s(null, k, E), Su(), E._vnode = k;
      return;
    }
    zr = !1, c(E.firstChild, k, null, null, null), Su(), E._vnode = k, zr && console.error("Hydration completed but contains mismatches.");
  }, c = (k, E, _, T, D, V = !1) => {
    const I = Va(k) && k.data === "[", M = () => b(
      k,
      E,
      _,
      T,
      D,
      I
    ), { type: Q, ref: G, shapeFlag: z, patchFlag: re } = E;
    let he = k.nodeType;
    E.el = k, re === -2 && (V = !1, E.dynamicChildren = null);
    let de = null;
    switch (Q) {
      case us:
        he !== 3 ? E.children === "" ? (l(E.el = y(""), S(k), k), de = k) : de = M() : (k.data !== E.children && (zr = !0, process.env.NODE_ENV !== "production" && _e(
          `Hydration text mismatch:
- Client: ${JSON.stringify(k.data)}
- Server: ${JSON.stringify(E.children)}`
        ), k.data = E.children), de = w(k));
        break;
      case ln:
        he !== 8 || I ? de = M() : de = w(k);
        break;
      case ss:
        if (I && (k = w(k), he = k.nodeType), he === 1 || he === 3) {
          de = k;
          const Ce = !E.children.length;
          for (let xe = 0; xe < E.staticCount; xe++)
            Ce && (E.children += de.nodeType === 1 ? de.outerHTML : de.data), xe === E.staticCount - 1 && (E.anchor = de), de = w(de);
          return I ? w(de) : de;
        } else
          M();
        break;
      case _n:
        I ? de = m(
          k,
          E,
          _,
          T,
          D,
          V
        ) : de = M();
        break;
      default:
        if (z & 1)
          he !== 1 || E.type.toLowerCase() !== k.tagName.toLowerCase() ? de = M() : de = e(
            k,
            E,
            _,
            T,
            D,
            V
          );
        else if (z & 6) {
          E.slotScopeIds = D;
          const Ce = S(k);
          if (n(
            E,
            Ce,
            null,
            _,
            T,
            Jc(Ce),
            V
          ), de = I ? f(k) : w(k), de && Va(de) && de.data === "teleport end" && (de = w(de)), Is(E)) {
            let xe;
            I ? (xe = Xt(_n), xe.anchor = de ? de.previousSibling : Ce.lastChild) : xe = k.nodeType === 3 ? ym("") : Xt("div"), xe.el = k, E.component.subTree = xe;
          }
        } else
          z & 64 ? he !== 8 ? de = M() : de = E.type.hydrate(
            k,
            E,
            _,
            T,
            D,
            V,
            i,
            h
          ) : z & 128 ? de = E.type.hydrate(
            k,
            E,
            _,
            T,
            Jc(S(k)),
            D,
            V,
            i,
            c
          ) : process.env.NODE_ENV !== "production" && _e("Invalid HostVNode type:", Q, `(${typeof Q})`);
    }
    return G != null && Tu(G, null, T, E), de;
  }, e = (k, E, _, T, D, V) => {
    V = V || !!E.dynamicChildren;
    const { type: I, props: M, patchFlag: Q, shapeFlag: G, dirs: z } = E, re = I === "input" && z || I === "option";
    if (process.env.NODE_ENV !== "production" || re || Q !== -1) {
      if (z && Hi(E, null, _, "created"), M)
        if (re || !V || Q & 48)
          for (const de in M)
            (re && de.endsWith("value") || Gi(de) && !Zr(de)) && u(
              k,
              de,
              null,
              M[de],
              !1,
              void 0,
              _
            );
        else
          M.onClick && u(
            k,
            "onClick",
            null,
            M.onClick,
            !1,
            void 0,
            _
          );
      let he;
      if ((he = M && M.onVnodeBeforeMount) && Gn(he, _, E), z && Hi(E, null, _, "beforeMount"), ((he = M && M.onVnodeMounted) || z) && pw(() => {
        he && Gn(he, _, E), z && Hi(E, null, _, "mounted");
      }, T), G & 16 && // skip if element has innerHTML / textContent
      !(M && (M.innerHTML || M.textContent))) {
        let de = h(
          k.firstChild,
          E,
          k,
          _,
          T,
          D,
          V
        ), Ce = !1;
        for (; de; ) {
          zr = !0, process.env.NODE_ENV !== "production" && !Ce && (_e(
            `Hydration children mismatch in <${E.type}>: server rendered element contains more child nodes than client vdom.`
          ), Ce = !0);
          const xe = de;
          de = de.nextSibling, d(xe);
        }
      } else
        G & 8 && k.textContent !== E.children && (zr = !0, process.env.NODE_ENV !== "production" && _e(
          `Hydration text content mismatch in <${E.type}>:
- Client: ${k.textContent}
- Server: ${E.children}`
        ), k.textContent = E.children);
    }
    return k.nextSibling;
  }, h = (k, E, _, T, D, V, I) => {
    I = I || !!E.dynamicChildren;
    const M = E.children, Q = M.length;
    let G = !1;
    for (let z = 0; z < Q; z++) {
      const re = I ? M[z] : M[z] = qn(M[z]);
      if (k)
        k = c(
          k,
          re,
          T,
          D,
          V,
          I
        );
      else {
        if (re.type === us && !re.children)
          continue;
        zr = !0, process.env.NODE_ENV !== "production" && !G && (_e(
          `Hydration children mismatch in <${_.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`
        ), G = !0), s(
          null,
          re,
          _,
          null,
          T,
          D,
          Jc(_),
          V
        );
      }
    }
    return k;
  }, m = (k, E, _, T, D, V) => {
    const { slotScopeIds: I } = E;
    I && (D = D ? D.concat(I) : I);
    const M = S(k), Q = h(
      w(k),
      E,
      M,
      _,
      T,
      D,
      V
    );
    return Q && Va(Q) && Q.data === "]" ? w(E.anchor = Q) : (zr = !0, l(E.anchor = p("]"), M, Q), Q);
  }, b = (k, E, _, T, D, V) => {
    if (zr = !0, process.env.NODE_ENV !== "production" && _e(
      `Hydration node mismatch:
- Client vnode:`,
      E.type,
      `
- Server rendered DOM:`,
      k,
      k.nodeType === 3 ? "(text)" : Va(k) && k.data === "[" ? "(start of fragment)" : ""
    ), E.el = null, V) {
      const Q = f(k);
      for (; ; ) {
        const G = w(k);
        if (G && G !== Q)
          d(G);
        else
          break;
      }
    }
    const I = w(k), M = S(k);
    return d(k), s(
      null,
      E,
      M,
      I,
      _,
      T,
      Jc(M),
      D
    ), I;
  }, f = (k) => {
    let E = 0;
    for (; k; )
      if (k = w(k), k && Va(k) && (k.data === "[" && E++, k.data === "]")) {
        if (E === 0)
          return w(k);
        E--;
      }
    return k;
  };
  return [v, c];
}
let $a, Gr;
function lr(i, n) {
  i.appContext.config.performance && Ou() && Gr.mark(`vue-${n}-${i.uid}`), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && AF(i, n, Ou() ? Gr.now() : Date.now());
}
function cr(i, n) {
  if (i.appContext.config.performance && Ou()) {
    const s = `vue-${n}-${i.uid}`, u = s + ":end";
    Gr.mark(u), Gr.measure(
      `<${Ch(i, i.type)}> ${n}`,
      s,
      u
    ), Gr.clearMarks(s), Gr.clearMarks(u);
  }
  (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && FF(i, n, Ou() ? Gr.now() : Date.now());
}
function Ou() {
  return $a !== void 0 || (typeof window < "u" && window.performance ? ($a = !0, Gr = window.performance) : $a = !1), $a;
}
function iL() {
  const i = [];
  if (typeof __VUE_OPTIONS_API__ != "boolean" && (process.env.NODE_ENV !== "production" && i.push("__VUE_OPTIONS_API__"), Fs().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != "boolean" && (process.env.NODE_ENV !== "production" && i.push("__VUE_PROD_DEVTOOLS__"), Fs().__VUE_PROD_DEVTOOLS__ = !1), process.env.NODE_ENV !== "production" && i.length) {
    const n = i.length > 1;
    console.warn(
      `Feature flag${n ? "s" : ""} ${i.join(", ")} ${n ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Dn = pw;
function Rw(i) {
  return Hw(i);
}
function jw(i) {
  return Hw(i, nL);
}
function Hw(i, n) {
  iL();
  const s = Fs();
  s.__VUE__ = !0, (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && im(s.__VUE_DEVTOOLS_GLOBAL_HOOK__, s);
  const {
    insert: u,
    remove: y,
    patchProp: w,
    createElement: S,
    createText: d,
    createComment: l,
    setText: p,
    setElementText: v,
    parentNode: c,
    nextSibling: e,
    setScopeId: h = en,
    insertStaticContent: m
  } = i, b = ($, A, X, te = null, J = null, ae = null, ge = !1, be = null, ke = process.env.NODE_ENV !== "production" && rs ? !1 : !!A.dynamicChildren) => {
    if ($ === A)
      return;
    $ && !Ni($, A) && (te = Se($), me($, J, ae, !0), $ = null), A.patchFlag === -2 && (ke = !1, A.dynamicChildren = null);
    const { type: ne, ref: Ve, shapeFlag: Ae } = A;
    switch (ne) {
      case us:
        f($, A, X, te);
        break;
      case ln:
        k($, A, X, te);
        break;
      case ss:
        $ == null ? E(A, X, te, ge) : process.env.NODE_ENV !== "production" && _($, A, X, ge);
        break;
      case _n:
        he(
          $,
          A,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke
        );
        break;
      default:
        Ae & 1 ? V(
          $,
          A,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke
        ) : Ae & 6 ? de(
          $,
          A,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke
        ) : Ae & 64 || Ae & 128 ? ne.process(
          $,
          A,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke,
          De
        ) : process.env.NODE_ENV !== "production" && _e("Invalid VNode type:", ne, `(${typeof ne})`);
    }
    Ve != null && J && Tu(Ve, $ && $.ref, ae, A || $, !A);
  }, f = ($, A, X, te) => {
    if ($ == null)
      u(
        A.el = d(A.children),
        X,
        te
      );
    else {
      const J = A.el = $.el;
      A.children !== $.children && p(J, A.children);
    }
  }, k = ($, A, X, te) => {
    $ == null ? u(
      A.el = l(A.children || ""),
      X,
      te
    ) : A.el = $.el;
  }, E = ($, A, X, te) => {
    [$.el, $.anchor] = m(
      $.children,
      A,
      X,
      te,
      $.el,
      $.anchor
    );
  }, _ = ($, A, X, te) => {
    if (A.children !== $.children) {
      const J = e($.anchor);
      D($), [A.el, A.anchor] = m(
        A.children,
        X,
        J,
        te
      );
    } else
      A.el = $.el, A.anchor = $.anchor;
  }, T = ({ el: $, anchor: A }, X, te) => {
    let J;
    for (; $ && $ !== A; )
      J = e($), u($, X, te), $ = J;
    u(A, X, te);
  }, D = ({ el: $, anchor: A }) => {
    let X;
    for (; $ && $ !== A; )
      X = e($), y($), $ = X;
    y(A);
  }, V = ($, A, X, te, J, ae, ge, be, ke) => {
    ge = ge || A.type === "svg", $ == null ? I(
      A,
      X,
      te,
      J,
      ae,
      ge,
      be,
      ke
    ) : G(
      $,
      A,
      J,
      ae,
      ge,
      be,
      ke
    );
  }, I = ($, A, X, te, J, ae, ge, be) => {
    let ke, ne;
    const { type: Ve, props: Ae, shapeFlag: je, transition: rt, dirs: st } = $;
    if (ke = $.el = S(
      $.type,
      ae,
      Ae && Ae.is,
      Ae
    ), je & 8 ? v(ke, $.children) : je & 16 && Q(
      $.children,
      ke,
      null,
      te,
      J,
      ae && Ve !== "foreignObject",
      ge,
      be
    ), st && Hi($, null, te, "created"), M(ke, $, $.scopeId, ge, te), Ae) {
      for (const vt in Ae)
        vt !== "value" && !Zr(vt) && w(
          ke,
          vt,
          null,
          Ae[vt],
          ae,
          $.children,
          te,
          J,
          fe
        );
      "value" in Ae && w(ke, "value", null, Ae.value), (ne = Ae.onVnodeBeforeMount) && Gn(ne, te, $);
    }
    (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && (Object.defineProperty(ke, "__vnode", {
      value: $,
      enumerable: !1
    }), Object.defineProperty(ke, "__vueParentComponent", {
      value: te,
      enumerable: !1
    })), st && Hi($, null, te, "beforeMount");
    const pt = (!J || J && !J.pendingBranch) && rt && !rt.persisted;
    pt && rt.beforeEnter(ke), u(ke, A, X), ((ne = Ae && Ae.onVnodeMounted) || pt || st) && Dn(() => {
      ne && Gn(ne, te, $), pt && rt.enter(ke), st && Hi($, null, te, "mounted");
    }, J);
  }, M = ($, A, X, te, J) => {
    if (X && h($, X), te)
      for (let ae = 0; ae < te.length; ae++)
        h($, te[ae]);
    if (J) {
      let ae = J.subTree;
      if (process.env.NODE_ENV !== "production" && ae.patchFlag > 0 && ae.patchFlag & 2048 && (ae = om(ae.children) || ae), A === ae) {
        const ge = J.vnode;
        M(
          $,
          ge,
          ge.scopeId,
          ge.slotScopeIds,
          J.parent
        );
      }
    }
  }, Q = ($, A, X, te, J, ae, ge, be, ke = 0) => {
    for (let ne = ke; ne < $.length; ne++) {
      const Ve = $[ne] = be ? Yr($[ne]) : qn($[ne]);
      b(
        null,
        Ve,
        A,
        X,
        te,
        J,
        ae,
        ge,
        be
      );
    }
  }, G = ($, A, X, te, J, ae, ge) => {
    const be = A.el = $.el;
    let { patchFlag: ke, dynamicChildren: ne, dirs: Ve } = A;
    ke |= $.patchFlag & 16;
    const Ae = $.props || Ft, je = A.props || Ft;
    let rt;
    X && _s(X, !1), (rt = je.onVnodeBeforeUpdate) && Gn(rt, X, A, $), Ve && Hi(A, $, X, "beforeUpdate"), X && _s(X, !0), process.env.NODE_ENV !== "production" && rs && (ke = 0, ge = !1, ne = null);
    const st = J && A.type !== "foreignObject";
    if (ne ? (z(
      $.dynamicChildren,
      ne,
      be,
      X,
      te,
      st,
      ae
    ), process.env.NODE_ENV !== "production" && Ja($, A)) : ge || L(
      $,
      A,
      be,
      null,
      X,
      te,
      st,
      ae,
      !1
    ), ke > 0) {
      if (ke & 16)
        re(
          be,
          A,
          Ae,
          je,
          X,
          te,
          J
        );
      else if (ke & 2 && Ae.class !== je.class && w(be, "class", null, je.class, J), ke & 4 && w(be, "style", Ae.style, je.style, J), ke & 8) {
        const pt = A.dynamicProps;
        for (let vt = 0; vt < pt.length; vt++) {
          const Lt = pt[vt], cn = Ae[Lt], Ut = je[Lt];
          (Ut !== cn || Lt === "value") && w(
            be,
            Lt,
            cn,
            Ut,
            J,
            $.children,
            X,
            te,
            fe
          );
        }
      }
      ke & 1 && $.children !== A.children && v(be, A.children);
    } else
      !ge && ne == null && re(
        be,
        A,
        Ae,
        je,
        X,
        te,
        J
      );
    ((rt = je.onVnodeUpdated) || Ve) && Dn(() => {
      rt && Gn(rt, X, A, $), Ve && Hi(A, $, X, "updated");
    }, te);
  }, z = ($, A, X, te, J, ae, ge) => {
    for (let be = 0; be < A.length; be++) {
      const ke = $[be], ne = A[be], Ve = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        ke.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (ke.type === _n || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Ni(ke, ne) || // - In the case of a component, it could contain anything.
        ke.shapeFlag & 70) ? c(ke.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          X
        )
      );
      b(
        ke,
        ne,
        Ve,
        null,
        te,
        J,
        ae,
        ge,
        !0
      );
    }
  }, re = ($, A, X, te, J, ae, ge) => {
    if (X !== te) {
      if (X !== Ft)
        for (const be in X)
          !Zr(be) && !(be in te) && w(
            $,
            be,
            X[be],
            null,
            ge,
            A.children,
            J,
            ae,
            fe
          );
      for (const be in te) {
        if (Zr(be))
          continue;
        const ke = te[be], ne = X[be];
        ke !== ne && be !== "value" && w(
          $,
          be,
          ne,
          ke,
          ge,
          A.children,
          J,
          ae,
          fe
        );
      }
      "value" in te && w($, "value", X.value, te.value);
    }
  }, he = ($, A, X, te, J, ae, ge, be, ke) => {
    const ne = A.el = $ ? $.el : d(""), Ve = A.anchor = $ ? $.anchor : d("");
    let { patchFlag: Ae, dynamicChildren: je, slotScopeIds: rt } = A;
    process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (rs || Ae & 2048) && (Ae = 0, ke = !1, je = null), rt && (be = be ? be.concat(rt) : rt), $ == null ? (u(ne, X, te), u(Ve, X, te), Q(
      A.children,
      X,
      Ve,
      J,
      ae,
      ge,
      be,
      ke
    )) : Ae > 0 && Ae & 64 && je && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    $.dynamicChildren ? (z(
      $.dynamicChildren,
      je,
      X,
      J,
      ae,
      ge,
      be
    ), process.env.NODE_ENV !== "production" ? Ja($, A) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (A.key != null || J && A === J.subTree) && Ja(
        $,
        A,
        !0
        /* shallow */
      )
    )) : L(
      $,
      A,
      X,
      Ve,
      J,
      ae,
      ge,
      be,
      ke
    );
  }, de = ($, A, X, te, J, ae, ge, be, ke) => {
    A.slotScopeIds = be, $ == null ? A.shapeFlag & 512 ? J.ctx.activate(
      A,
      X,
      te,
      ge,
      ke
    ) : Ce(
      A,
      X,
      te,
      J,
      ae,
      ge,
      ke
    ) : xe($, A, ke);
  }, Ce = ($, A, X, te, J, ae, ge) => {
    const be = $.component = Qw(
      $,
      te,
      J
    );
    if (process.env.NODE_ENV !== "production" && be.type.__hmrId && DF(be), process.env.NODE_ENV !== "production" && (Ya($), lr(be, "mount")), Wo($) && (be.ctx.renderer = De), process.env.NODE_ENV !== "production" && lr(be, "init"), ek(be), process.env.NODE_ENV !== "production" && cr(be, "init"), be.asyncDep) {
      if (J && J.registerDep(be, Ie), !$.el) {
        const ke = be.subTree = Xt(ln);
        k(null, ke, A, X);
      }
      return;
    }
    Ie(
      be,
      $,
      A,
      X,
      J,
      ae,
      ge
    ), process.env.NODE_ENV !== "production" && (Ka(), cr(be, "mount"));
  }, xe = ($, A, X) => {
    const te = A.component = $.component;
    if (KF($, A, X))
      if (te.asyncDep && !te.asyncResolved) {
        process.env.NODE_ENV !== "production" && Ya(A), Be(te, A, X), process.env.NODE_ENV !== "production" && Ka();
        return;
      } else
        te.next = A, TF(te.update), te.update();
    else
      A.el = $.el, te.vnode = A;
  }, Ie = ($, A, X, te, J, ae, ge) => {
    const be = () => {
      if ($.isMounted) {
        let { next: Ve, bu: Ae, u: je, parent: rt, vnode: st } = $, pt = Ve, vt;
        process.env.NODE_ENV !== "production" && Ya(Ve || $.vnode), _s($, !1), Ve ? (Ve.el = st.el, Be($, Ve, ge)) : Ve = st, Ae && dr(Ae), (vt = Ve.props && Ve.props.onVnodeBeforeUpdate) && Gn(vt, rt, Ve, st), _s($, !0), process.env.NODE_ENV !== "production" && lr($, "render");
        const Lt = ou($);
        process.env.NODE_ENV !== "production" && cr($, "render");
        const cn = $.subTree;
        $.subTree = Lt, process.env.NODE_ENV !== "production" && lr($, "patch"), b(
          cn,
          Lt,
          // parent may have changed if it's in a teleport
          c(cn.el),
          // anchor may have changed if it's in a fragment
          Se(cn),
          $,
          J,
          ae
        ), process.env.NODE_ENV !== "production" && cr($, "patch"), Ve.el = Lt.el, pt === null && am($, Lt.el), je && Dn(je, J), (vt = Ve.props && Ve.props.onVnodeUpdated) && Dn(
          () => Gn(vt, rt, Ve, st),
          J
        ), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && uw($), process.env.NODE_ENV !== "production" && Ka();
      } else {
        let Ve;
        const { el: Ae, props: je } = A, { bm: rt, m: st, parent: pt } = $, vt = Is(A);
        if (_s($, !1), rt && dr(rt), !vt && (Ve = je && je.onVnodeBeforeMount) && Gn(Ve, pt, A), _s($, !0), Ae && Ye) {
          const Lt = () => {
            process.env.NODE_ENV !== "production" && lr($, "render"), $.subTree = ou($), process.env.NODE_ENV !== "production" && cr($, "render"), process.env.NODE_ENV !== "production" && lr($, "hydrate"), Ye(
              Ae,
              $.subTree,
              $,
              J,
              null
            ), process.env.NODE_ENV !== "production" && cr($, "hydrate");
          };
          vt ? A.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !$.isUnmounted && Lt()
          ) : Lt();
        } else {
          process.env.NODE_ENV !== "production" && lr($, "render");
          const Lt = $.subTree = ou($);
          process.env.NODE_ENV !== "production" && cr($, "render"), process.env.NODE_ENV !== "production" && lr($, "patch"), b(
            null,
            Lt,
            X,
            te,
            $,
            J,
            ae
          ), process.env.NODE_ENV !== "production" && cr($, "patch"), A.el = Lt.el;
        }
        if (st && Dn(st, J), !vt && (Ve = je && je.onVnodeMounted)) {
          const Lt = A;
          Dn(
            () => Gn(Ve, pt, Lt),
            J
          );
        }
        (A.shapeFlag & 256 || pt && Is(pt.vnode) && pt.vnode.shapeFlag & 256) && $.a && Dn($.a, J), $.isMounted = !0, (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && If($), A = X = te = null;
      }
    }, ke = $.effect = new Al(
      be,
      () => Fl(ne),
      $.scope
      // track it in component's effect scope
    ), ne = $.update = () => ke.run();
    ne.id = $.uid, _s($, !0), process.env.NODE_ENV !== "production" && (ke.onTrack = $.rtc ? (Ve) => dr($.rtc, Ve) : void 0, ke.onTrigger = $.rtg ? (Ve) => dr($.rtg, Ve) : void 0, ne.ownerInstance = $), ne();
  }, Be = ($, A, X) => {
    A.component = $;
    const te = $.vnode.props;
    $.vnode = A, $.next = null, K6($, A.props, te, X), tL($, A.children, X), Gs(), Qy(), Xs();
  }, L = ($, A, X, te, J, ae, ge, be, ke = !1) => {
    const ne = $ && $.children, Ve = $ ? $.shapeFlag : 0, Ae = A.children, { patchFlag: je, shapeFlag: rt } = A;
    if (je > 0) {
      if (je & 128) {
        W(
          ne,
          Ae,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke
        );
        return;
      } else if (je & 256) {
        Z(
          ne,
          Ae,
          X,
          te,
          J,
          ae,
          ge,
          be,
          ke
        );
        return;
      }
    }
    rt & 8 ? (Ve & 16 && fe(ne, J, ae), Ae !== ne && v(X, Ae)) : Ve & 16 ? rt & 16 ? W(
      ne,
      Ae,
      X,
      te,
      J,
      ae,
      ge,
      be,
      ke
    ) : fe(ne, J, ae, !0) : (Ve & 8 && v(X, ""), rt & 16 && Q(
      Ae,
      X,
      te,
      J,
      ae,
      ge,
      be,
      ke
    ));
  }, Z = ($, A, X, te, J, ae, ge, be, ke) => {
    $ = $ || Bs, A = A || Bs;
    const ne = $.length, Ve = A.length, Ae = Math.min(ne, Ve);
    let je;
    for (je = 0; je < Ae; je++) {
      const rt = A[je] = ke ? Yr(A[je]) : qn(A[je]);
      b(
        $[je],
        rt,
        X,
        null,
        J,
        ae,
        ge,
        be,
        ke
      );
    }
    ne > Ve ? fe(
      $,
      J,
      ae,
      !0,
      !1,
      Ae
    ) : Q(
      A,
      X,
      te,
      J,
      ae,
      ge,
      be,
      ke,
      Ae
    );
  }, W = ($, A, X, te, J, ae, ge, be, ke) => {
    let ne = 0;
    const Ve = A.length;
    let Ae = $.length - 1, je = Ve - 1;
    for (; ne <= Ae && ne <= je; ) {
      const rt = $[ne], st = A[ne] = ke ? Yr(A[ne]) : qn(A[ne]);
      if (Ni(rt, st))
        b(
          rt,
          st,
          X,
          null,
          J,
          ae,
          ge,
          be,
          ke
        );
      else
        break;
      ne++;
    }
    for (; ne <= Ae && ne <= je; ) {
      const rt = $[Ae], st = A[je] = ke ? Yr(A[je]) : qn(A[je]);
      if (Ni(rt, st))
        b(
          rt,
          st,
          X,
          null,
          J,
          ae,
          ge,
          be,
          ke
        );
      else
        break;
      Ae--, je--;
    }
    if (ne > Ae) {
      if (ne <= je) {
        const rt = je + 1, st = rt < Ve ? A[rt].el : te;
        for (; ne <= je; )
          b(
            null,
            A[ne] = ke ? Yr(A[ne]) : qn(A[ne]),
            X,
            st,
            J,
            ae,
            ge,
            be,
            ke
          ), ne++;
      }
    } else if (ne > je)
      for (; ne <= Ae; )
        me($[ne], J, ae, !0), ne++;
    else {
      const rt = ne, st = ne, pt = /* @__PURE__ */ new Map();
      for (ne = st; ne <= je; ne++) {
        const pn = A[ne] = ke ? Yr(A[ne]) : qn(A[ne]);
        pn.key != null && (process.env.NODE_ENV !== "production" && pt.has(pn.key) && _e(
          "Duplicate keys found during update:",
          JSON.stringify(pn.key),
          "Make sure keys are unique."
        ), pt.set(pn.key, ne));
      }
      let vt, Lt = 0;
      const cn = je - st + 1;
      let Ut = !1, Zi = 0;
      const Vn = new Array(cn);
      for (ne = 0; ne < cn; ne++)
        Vn[ne] = 0;
      for (ne = rt; ne <= Ae; ne++) {
        const pn = $[ne];
        if (Lt >= cn) {
          me(pn, J, ae, !0);
          continue;
        }
        let hi;
        if (pn.key != null)
          hi = pt.get(pn.key);
        else
          for (vt = st; vt <= je; vt++)
            if (Vn[vt - st] === 0 && Ni(pn, A[vt])) {
              hi = vt;
              break;
            }
        hi === void 0 ? me(pn, J, ae, !0) : (Vn[hi - st] = ne + 1, hi >= Zi ? Zi = hi : Ut = !0, b(
          pn,
          A[hi],
          X,
          null,
          J,
          ae,
          ge,
          be,
          ke
        ), Lt++);
      }
      const Qs = Ut ? rL(Vn) : Bs;
      for (vt = Qs.length - 1, ne = cn - 1; ne >= 0; ne--) {
        const pn = st + ne, hi = A[pn], er = pn + 1 < Ve ? A[pn + 1].el : te;
        Vn[ne] === 0 ? b(
          null,
          hi,
          X,
          er,
          J,
          ae,
          ge,
          be,
          ke
        ) : Ut && (vt < 0 || ne !== Qs[vt] ? Y(hi, X, er, 2) : vt--);
      }
    }
  }, Y = ($, A, X, te, J = null) => {
    const { el: ae, type: ge, transition: be, children: ke, shapeFlag: ne } = $;
    if (ne & 6) {
      Y($.component.subTree, A, X, te);
      return;
    }
    if (ne & 128) {
      $.suspense.move(A, X, te);
      return;
    }
    if (ne & 64) {
      ge.move($, A, X, De);
      return;
    }
    if (ge === _n) {
      u(ae, A, X);
      for (let Ae = 0; Ae < ke.length; Ae++)
        Y(ke[Ae], A, X, te);
      u($.anchor, A, X);
      return;
    }
    if (ge === ss) {
      T($, A, X);
      return;
    }
    if (te !== 2 && ne & 1 && be)
      if (te === 0)
        be.beforeEnter(ae), u(ae, A, X), Dn(() => be.enter(ae), J);
      else {
        const { leave: Ae, delayLeave: je, afterLeave: rt } = be, st = () => u(ae, A, X), pt = () => {
          Ae(ae, () => {
            st(), rt && rt();
          });
        };
        je ? je(ae, st, pt) : pt();
      }
    else
      u(ae, A, X);
  }, me = ($, A, X, te = !1, J = !1) => {
    const {
      type: ae,
      props: ge,
      ref: be,
      children: ke,
      dynamicChildren: ne,
      shapeFlag: Ve,
      patchFlag: Ae,
      dirs: je
    } = $;
    if (be != null && Tu(be, null, X, $, !0), Ve & 256) {
      A.ctx.deactivate($);
      return;
    }
    const rt = Ve & 1 && je, st = !Is($);
    let pt;
    if (st && (pt = ge && ge.onVnodeBeforeUnmount) && Gn(pt, A, $), Ve & 6)
      le($.component, X, te);
    else {
      if (Ve & 128) {
        $.suspense.unmount(X, te);
        return;
      }
      rt && Hi($, null, A, "beforeUnmount"), Ve & 64 ? $.type.remove(
        $,
        A,
        X,
        J,
        De,
        te
      ) : ne && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ae !== _n || Ae > 0 && Ae & 64) ? fe(
        ne,
        A,
        X,
        !1,
        !0
      ) : (ae === _n && Ae & 384 || !J && Ve & 16) && fe(ke, A, X), te && K($);
    }
    (st && (pt = ge && ge.onVnodeUnmounted) || rt) && Dn(() => {
      pt && Gn(pt, A, $), rt && Hi($, null, A, "unmounted");
    }, X);
  }, K = ($) => {
    const { type: A, el: X, anchor: te, transition: J } = $;
    if (A === _n) {
      process.env.NODE_ENV !== "production" && $.patchFlag > 0 && $.patchFlag & 2048 && J && !J.persisted ? $.children.forEach((ge) => {
        ge.type === ln ? y(ge.el) : K(ge);
      }) : R(X, te);
      return;
    }
    if (A === ss) {
      D($);
      return;
    }
    const ae = () => {
      y(X), J && !J.persisted && J.afterLeave && J.afterLeave();
    };
    if ($.shapeFlag & 1 && J && !J.persisted) {
      const { leave: ge, delayLeave: be } = J, ke = () => ge(X, ae);
      be ? be($.el, ae, ke) : ke();
    } else
      ae();
  }, R = ($, A) => {
    let X;
    for (; $ !== A; )
      X = e($), y($), $ = X;
    y(A);
  }, le = ($, A, X) => {
    process.env.NODE_ENV !== "production" && $.type.__hmrId && NF($);
    const { bum: te, scope: J, update: ae, subTree: ge, um: be } = $;
    te && dr(te), J.stop(), ae && (ae.active = !1, me(ge, $, A, X)), be && Dn(be, A), Dn(() => {
      $.isUnmounted = !0;
    }, A), A && A.pendingBranch && !A.isUnmounted && $.asyncDep && !$.asyncResolved && $.suspenseId === A.pendingId && (A.deps--, A.deps === 0 && A.resolve()), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && MF($);
  }, fe = ($, A, X, te = !1, J = !1, ae = 0) => {
    for (let ge = ae; ge < $.length; ge++)
      me($[ge], A, X, te, J);
  }, Se = ($) => $.shapeFlag & 6 ? Se($.component.subTree) : $.shapeFlag & 128 ? $.suspense.next() : e($.anchor || $.el), we = ($, A, X) => {
    $ == null ? A._vnode && me(A._vnode, null, null, !0) : b(A._vnode || null, $, A, null, null, null, X), Qy(), Su(), A._vnode = $;
  }, De = {
    p: b,
    um: me,
    m: Y,
    r: K,
    mt: Ce,
    mc: Q,
    pc: L,
    pbc: z,
    n: Se,
    o: i
  };
  let Le, Ye;
  return n && ([Le, Ye] = n(
    De
  )), {
    render: we,
    hydrate: Le,
    createApp: H6(we, Le)
  };
}
function _s({ effect: i, update: n }, s) {
  i.allowRecurse = n.allowRecurse = s;
}
function Ja(i, n, s = !1) {
  const u = i.children, y = n.children;
  if (Je(u) && Je(y))
    for (let w = 0; w < u.length; w++) {
      const S = u[w];
      let d = y[w];
      d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = y[w] = Yr(y[w]), d.el = S.el), s || Ja(S, d)), d.type === us && (d.el = S.el), process.env.NODE_ENV !== "production" && d.type === ln && !d.el && (d.el = S.el);
    }
}
function rL(i) {
  const n = i.slice(), s = [0];
  let u, y, w, S, d;
  const l = i.length;
  for (u = 0; u < l; u++) {
    const p = i[u];
    if (p !== 0) {
      if (y = s[s.length - 1], i[y] < p) {
        n[u] = y, s.push(u);
        continue;
      }
      for (w = 0, S = s.length - 1; w < S; )
        d = w + S >> 1, i[s[d]] < p ? w = d + 1 : S = d;
      p < i[s[w]] && (w > 0 && (n[u] = s[w - 1]), s[w] = u);
    }
  }
  for (w = s.length, S = s[w - 1]; w-- > 0; )
    s[w] = S, S = n[S];
  return s;
}
const sL = (i) => i.__isTeleport, No = (i) => i && (i.disabled || i.disabled === ""), pb = (i) => typeof SVGElement < "u" && i instanceof SVGElement, jf = (i, n) => {
  const s = i && i.to;
  if (wt(s))
    if (n) {
      const u = n(s);
      return u || process.env.NODE_ENV !== "production" && _e(
        `Failed to locate Teleport target with selector "${s}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), u;
    } else
      return process.env.NODE_ENV !== "production" && _e(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return process.env.NODE_ENV !== "production" && !s && !No(i) && _e(`Invalid Teleport target: ${s}`), s;
}, oL = {
  __isTeleport: !0,
  process(i, n, s, u, y, w, S, d, l, p) {
    const {
      mc: v,
      pc: c,
      pbc: e,
      o: { insert: h, querySelector: m, createText: b, createComment: f }
    } = p, k = No(n.props);
    let { shapeFlag: E, children: _, dynamicChildren: T } = n;
    if (process.env.NODE_ENV !== "production" && rs && (l = !1, T = null), i == null) {
      const D = n.el = process.env.NODE_ENV !== "production" ? f("teleport start") : b(""), V = n.anchor = process.env.NODE_ENV !== "production" ? f("teleport end") : b("");
      h(D, s, u), h(V, s, u);
      const I = n.target = jf(n.props, m), M = n.targetAnchor = b("");
      I ? (h(M, I), S = S || pb(I)) : process.env.NODE_ENV !== "production" && !k && _e("Invalid Teleport target on mount:", I, `(${typeof I})`);
      const Q = (G, z) => {
        E & 16 && v(
          _,
          G,
          z,
          y,
          w,
          S,
          d,
          l
        );
      };
      k ? Q(s, V) : I && Q(I, M);
    } else {
      n.el = i.el;
      const D = n.anchor = i.anchor, V = n.target = i.target, I = n.targetAnchor = i.targetAnchor, M = No(i.props), Q = M ? s : V, G = M ? D : I;
      if (S = S || pb(V), T ? (e(
        i.dynamicChildren,
        T,
        Q,
        y,
        w,
        S,
        d
      ), Ja(i, n, !0)) : l || c(
        i,
        n,
        Q,
        G,
        y,
        w,
        S,
        d,
        !1
      ), k)
        M || Qc(
          n,
          s,
          D,
          p,
          1
        );
      else if ((n.props && n.props.to) !== (i.props && i.props.to)) {
        const z = n.target = jf(
          n.props,
          m
        );
        z ? Qc(
          n,
          z,
          null,
          p,
          0
        ) : process.env.NODE_ENV !== "production" && _e(
          "Invalid Teleport target on update:",
          V,
          `(${typeof V})`
        );
      } else
        M && Qc(
          n,
          V,
          I,
          p,
          1
        );
    }
    Uw(n);
  },
  remove(i, n, s, u, { um: y, o: { remove: w } }, S) {
    const { shapeFlag: d, children: l, anchor: p, targetAnchor: v, target: c, props: e } = i;
    if (c && w(v), (S || !No(e)) && (w(p), d & 16))
      for (let h = 0; h < l.length; h++) {
        const m = l[h];
        y(
          m,
          n,
          s,
          !0,
          !!m.dynamicChildren
        );
      }
  },
  move: Qc,
  hydrate: aL
};
function Qc(i, n, s, { o: { insert: u }, m: y }, w = 2) {
  w === 0 && u(i.targetAnchor, n, s);
  const { el: S, anchor: d, shapeFlag: l, children: p, props: v } = i, c = w === 2;
  if (c && u(S, n, s), (!c || No(v)) && l & 16)
    for (let e = 0; e < p.length; e++)
      y(
        p[e],
        n,
        s,
        2
      );
  c && u(d, n, s);
}
function aL(i, n, s, u, y, w, {
  o: { nextSibling: S, parentNode: d, querySelector: l }
}, p) {
  const v = n.target = jf(
    n.props,
    l
  );
  if (v) {
    const c = v._lpa || v.firstChild;
    if (n.shapeFlag & 16)
      if (No(n.props))
        n.anchor = p(
          S(i),
          n,
          d(i),
          s,
          u,
          y,
          w
        ), n.targetAnchor = c;
      else {
        n.anchor = S(i);
        let e = c;
        for (; e; )
          if (e = S(e), e && e.nodeType === 8 && e.data === "teleport anchor") {
            n.targetAnchor = e, v._lpa = n.targetAnchor && S(n.targetAnchor);
            break;
          }
        p(
          c,
          n,
          v,
          s,
          u,
          y,
          w
        );
      }
    Uw(n);
  }
  return n.anchor && S(n.anchor);
}
const lL = oL;
function Uw(i) {
  const n = i.ctx;
  if (n && n.ut) {
    let s = i.children[0].el;
    for (; s !== i.targetAnchor; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", n.uid), s = s.nextSibling;
    n.ut();
  }
}
const _n = Symbol.for("v-fgt"), us = Symbol.for("v-txt"), ln = Symbol.for("v-cmt"), ss = Symbol.for("v-stc"), Qa = [];
let Jn = null;
function vh(i = !1) {
  Qa.push(Jn = i ? null : []);
}
function Ww() {
  Qa.pop(), Jn = Qa[Qa.length - 1] || null;
}
let Ys = 1;
function Hf(i) {
  Ys += i;
}
function Yw(i) {
  return i.dynamicChildren = Ys > 0 ? Jn || Bs : null, Ww(), Ys > 0 && Jn && Jn.push(i), i;
}
function cL(i, n, s, u, y, w) {
  return Yw(
    vm(
      i,
      n,
      s,
      u,
      y,
      w,
      !0
      /* isBlock */
    )
  );
}
function gm(i, n, s, u, y) {
  return Yw(
    Xt(
      i,
      n,
      s,
      u,
      y,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function br(i) {
  return i ? i.__v_isVNode === !0 : !1;
}
function Ni(i, n) {
  return process.env.NODE_ENV !== "production" && n.shapeFlag & 6 && wo.has(n.type) ? (i.shapeFlag &= -257, n.shapeFlag &= -513, !1) : i.type === n.type && i.key === n.key;
}
let Uf;
function uL(i) {
  Uf = i;
}
const hL = (...i) => Gw(
  ...Uf ? Uf(i, on) : i
), yh = "__vInternal", Kw = ({ key: i }) => i ?? null, au = ({
  ref: i,
  ref_key: n,
  ref_for: s
}) => (typeof i == "number" && (i = "" + i), i != null ? wt(i) || tn(i) || ft(i) ? { i: on, r: i, k: n, f: !!s } : i : null);
function vm(i, n = null, s = null, u = 0, y = null, w = i === _n ? 0 : 1, S = !1, d = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i,
    props: n,
    key: n && Kw(n),
    ref: n && au(n),
    scopeId: hh,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: w,
    patchFlag: u,
    dynamicProps: y,
    dynamicChildren: null,
    appContext: null,
    ctx: on
  };
  return d ? (bm(l, s), w & 128 && i.normalize(l)) : s && (l.shapeFlag |= wt(s) ? 8 : 16), process.env.NODE_ENV !== "production" && l.key !== l.key && _e("VNode created with invalid key (NaN). VNode type:", l.type), Ys > 0 && // avoid a block node from tracking itself
  !S && // has current parent block
  Jn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || w & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && Jn.push(l), l;
}
const Xt = process.env.NODE_ENV !== "production" ? hL : Gw;
function Gw(i, n = null, s = null, u = 0, y = null, w = !1) {
  if ((!i || i === Dw) && (process.env.NODE_ENV !== "production" && !i && _e(`Invalid vnode type when creating vnode: ${i}.`), i = ln), br(i)) {
    const d = wi(
      i,
      n,
      !0
      /* mergeRef: true */
    );
    return s && bm(d, s), Ys > 0 && !w && Jn && (d.shapeFlag & 6 ? Jn[Jn.indexOf(i)] = d : Jn.push(d)), d.patchFlag |= -2, d;
  }
  if (ik(i) && (i = i.__vccOpts), n) {
    n = Xw(n);
    let { class: d, style: l } = n;
    d && !wt(d) && (n.class = Ro(d)), Nt(l) && (yl(l) && !Je(l) && (l = _t({}, l)), n.style = zo(l));
  }
  const S = wt(i) ? 1 : fw(i) ? 128 : sL(i) ? 64 : Nt(i) ? 4 : ft(i) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && S & 4 && yl(i) && (i = Et(i), _e(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    i
  )), vm(
    i,
    n,
    s,
    u,
    y,
    S,
    w,
    !0
  );
}
function Xw(i) {
  return i ? yl(i) || yh in i ? _t({}, i) : i : null;
}
function wi(i, n, s = !1) {
  const { props: u, ref: y, patchFlag: w, children: S } = i, d = n ? Jw(u || {}, n) : u;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: i.type,
    props: d,
    key: d && Kw(d),
    ref: n && n.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && y ? Je(y) ? y.concat(au(n)) : [y, au(n)] : au(n)
    ) : y,
    scopeId: i.scopeId,
    slotScopeIds: i.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && w === -1 && Je(S) ? S.map(qw) : S,
    target: i.target,
    targetAnchor: i.targetAnchor,
    staticCount: i.staticCount,
    shapeFlag: i.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: n && i.type !== _n ? w === -1 ? 16 : w | 16 : w,
    dynamicProps: i.dynamicProps,
    dynamicChildren: i.dynamicChildren,
    appContext: i.appContext,
    dirs: i.dirs,
    transition: i.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: i.component,
    suspense: i.suspense,
    ssContent: i.ssContent && wi(i.ssContent),
    ssFallback: i.ssFallback && wi(i.ssFallback),
    el: i.el,
    anchor: i.anchor,
    ctx: i.ctx,
    ce: i.ce
  };
}
function qw(i) {
  const n = wi(i);
  return Je(i.children) && (n.children = i.children.map(qw)), n;
}
function ym(i = " ", n = 0) {
  return Xt(us, null, i, n);
}
function dL(i, n) {
  const s = Xt(ss, null, i);
  return s.staticCount = n, s;
}
function fL(i = "", n = !1) {
  return n ? (vh(), gm(ln, null, i)) : Xt(ln, null, i);
}
function qn(i) {
  return i == null || typeof i == "boolean" ? Xt(ln) : Je(i) ? Xt(
    _n,
    null,
    // #3666, avoid reference pollution when reusing vnode
    i.slice()
  ) : typeof i == "object" ? Yr(i) : Xt(us, null, String(i));
}
function Yr(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : wi(i);
}
function bm(i, n) {
  let s = 0;
  const { shapeFlag: u } = i;
  if (n == null)
    n = null;
  else if (Je(n))
    s = 16;
  else if (typeof n == "object")
    if (u & 65) {
      const y = n.default;
      y && (y._c && (y._d = !1), bm(i, y()), y._c && (y._d = !0));
      return;
    } else {
      s = 32;
      const y = n._;
      !y && !(yh in n) ? n._ctx = on : y === 3 && on && (on.slots._ === 1 ? n._ = 1 : (n._ = 2, i.patchFlag |= 1024));
    }
  else
    ft(n) ? (n = { default: n, _ctx: on }, s = 32) : (n = String(n), u & 64 ? (s = 16, n = [ym(n)]) : s = 8);
  i.children = n, i.shapeFlag |= s;
}
function Jw(...i) {
  const n = {};
  for (let s = 0; s < i.length; s++) {
    const u = i[s];
    for (const y in u)
      if (y === "class")
        n.class !== u.class && (n.class = Ro([n.class, u.class]));
      else if (y === "style")
        n.style = zo([n.style, u.style]);
      else if (Gi(y)) {
        const w = n[y], S = u[y];
        S && w !== S && !(Je(w) && w.includes(S)) && (n[y] = w ? [].concat(w, S) : S);
      } else
        y !== "" && (n[y] = u[y]);
  }
  return n;
}
function Gn(i, n, s, u = null) {
  ci(i, n, 7, [
    s,
    u
  ]);
}
const pL = Vw();
let mL = 0;
function Qw(i, n, s) {
  const u = i.type, y = (n ? n.appContext : i.appContext) || pL, w = {
    uid: mL++,
    vnode: i,
    type: u,
    parent: n,
    appContext: y,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new Up(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: n ? n.provides : Object.create(y.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Mw(u, y),
    emitsOptions: dw(u, y),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Ft,
    // inheritAttrs
    inheritAttrs: u.inheritAttrs,
    // state
    ctx: Ft,
    data: Ft,
    props: Ft,
    attrs: Ft,
    slots: Ft,
    refs: Ft,
    setupState: Ft,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? w.ctx = b6(w) : w.ctx = { _: w }, w.root = n ? n.root : w, w.emit = zF.bind(null, w), i.ce && i.ce(w), w;
}
let sn = null;
const wr = () => sn || on;
let Cm, Co, mb = "__VUE_INSTANCE_SETTERS__";
(Co = Fs()[mb]) || (Co = Fs()[mb] = []), Co.push((i) => sn = i), Cm = (i) => {
  Co.length > 1 ? Co.forEach((n) => n(i)) : Co[0](i);
};
const hs = (i) => {
  Cm(i), i.scope.on();
}, os = () => {
  sn && sn.scope.off(), Cm(null);
}, gL = /* @__PURE__ */ fn("slot,component");
function Wf(i, n) {
  const s = n.isNativeTag || _o;
  (gL(i) || s(i)) && _e(
    "Do not use built-in or reserved HTML elements as component id: " + i
  );
}
function Zw(i) {
  return i.vnode.shapeFlag & 4;
}
let Ao = !1;
function ek(i, n = !1) {
  Ao = n;
  const { props: s, children: u } = i.vnode, y = Zw(i);
  W6(i, s, y, n), eL(i, u);
  const w = y ? vL(i, n) : void 0;
  return Ao = !1, w;
}
function vL(i, n) {
  var s;
  const u = i.type;
  if (process.env.NODE_ENV !== "production") {
    if (u.name && Wf(u.name, i.appContext.config), u.components) {
      const w = Object.keys(u.components);
      for (let S = 0; S < w.length; S++)
        Wf(w[S], i.appContext.config);
    }
    if (u.directives) {
      const w = Object.keys(u.directives);
      for (let S = 0; S < w.length; S++)
        vw(w[S]);
    }
    u.compilerOptions && wm() && _e(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  i.accessCache = /* @__PURE__ */ Object.create(null), i.proxy = Kp(new Proxy(i.ctx, Xa)), process.env.NODE_ENV !== "production" && C6(i);
  const { setup: y } = u;
  if (y) {
    const w = i.setupContext = y.length > 1 ? nk(i) : null;
    hs(i), Gs();
    const S = Yi(
      y,
      i,
      0,
      [process.env.NODE_ENV !== "production" ? So(i.props) : i.props, w]
    );
    if (Xs(), os(), Nl(S)) {
      if (S.then(os, os), n)
        return S.then((d) => {
          Yf(i, d, n);
        }).catch((d) => {
          qs(d, i, 0);
        });
      if (i.asyncDep = S, process.env.NODE_ENV !== "production" && !i.suspense) {
        const d = (s = u.name) != null ? s : "Anonymous";
        _e(
          `Component <${d}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      Yf(i, S, n);
  } else
    tk(i, n);
}
function Yf(i, n, s) {
  ft(n) ? i.type.__ssrInlineRender ? i.ssrRender = n : i.render = n : Nt(n) ? (process.env.NODE_ENV !== "production" && br(n) && _e(
    "setup() should not return VNodes directly - return a render function instead."
  ), (process.env.NODE_ENV !== "production" || __VUE_PROD_DEVTOOLS__) && (i.devtoolsRawSetupState = n), i.setupState = Jp(n), process.env.NODE_ENV !== "production" && w6(i)) : process.env.NODE_ENV !== "production" && n !== void 0 && _e(
    `setup() should return an object. Received: ${n === null ? "null" : typeof n}`
  ), tk(i, s);
}
let Za, Kf;
function yL(i) {
  Za = i, Kf = (n) => {
    n.render._rc && (n.withProxy = new Proxy(n.ctx, y6));
  };
}
const wm = () => !Za;
function tk(i, n, s) {
  const u = i.type;
  if (!i.render) {
    if (!n && Za && !u.render) {
      const y = u.template || pm(i).template;
      if (y) {
        process.env.NODE_ENV !== "production" && lr(i, "compile");
        const { isCustomElement: w, compilerOptions: S } = i.appContext.config, { delimiters: d, compilerOptions: l } = u, p = _t(
          _t(
            {
              isCustomElement: w,
              delimiters: d
            },
            S
          ),
          l
        );
        u.render = Za(y, p), process.env.NODE_ENV !== "production" && cr(i, "compile");
      }
    }
    i.render = u.render || en, Kf && Kf(i);
  }
  __VUE_OPTIONS_API__ && (hs(i), Gs(), A6(i), Xs(), os()), process.env.NODE_ENV !== "production" && !u.render && i.render === en && !n && (!Za && u.template ? _e(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : _e("Component is missing template or render function."));
}
function gb(i) {
  return i.attrsProxy || (i.attrsProxy = new Proxy(
    i.attrs,
    process.env.NODE_ENV !== "production" ? {
      get(n, s) {
        return Eu(), Pn(i, "get", "$attrs"), n[s];
      },
      set() {
        return _e("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return _e("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(n, s) {
        return Pn(i, "get", "$attrs"), n[s];
      }
    }
  ));
}
function bL(i) {
  return i.slotsProxy || (i.slotsProxy = new Proxy(i.slots, {
    get(n, s) {
      return Pn(i, "get", "$slots"), n[s];
    }
  }));
}
function nk(i) {
  const n = (s) => {
    if (process.env.NODE_ENV !== "production" && (i.exposed && _e("expose() should be called only once per setup()."), s != null)) {
      let u = typeof s;
      u === "object" && (Je(s) ? u = "array" : tn(s) && (u = "ref")), u !== "object" && _e(
        `expose() should be passed a plain object, received ${u}.`
      );
    }
    i.exposed = s || {};
  };
  return process.env.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return gb(i);
    },
    get slots() {
      return bL(i);
    },
    get emit() {
      return (s, ...u) => i.emit(s, ...u);
    },
    expose: n
  }) : {
    get attrs() {
      return gb(i);
    },
    slots: i.slots,
    emit: i.emit,
    expose: n
  };
}
function bh(i) {
  if (i.exposed)
    return i.exposeProxy || (i.exposeProxy = new Proxy(Jp(Kp(i.exposed)), {
      get(n, s) {
        if (s in n)
          return n[s];
        if (s in Ms)
          return Ms[s](i);
      },
      has(n, s) {
        return s in n || s in Ms;
      }
    }));
}
const CL = /(?:^|[-_])(\w)/g, wL = (i) => i.replace(CL, (n) => n.toUpperCase()).replace(/[-_]/g, "");
function _l(i, n = !0) {
  return ft(i) ? i.displayName || i.name : i.name || n && i.__name;
}
function Ch(i, n, s = !1) {
  let u = _l(n);
  if (!u && n.__file) {
    const y = n.__file.match(/([^/\\]+)\.\w+$/);
    y && (u = y[1]);
  }
  if (!u && i && i.parent) {
    const y = (w) => {
      for (const S in w)
        if (w[S] === n)
          return S;
    };
    u = y(
      i.components || i.parent.type.components
    ) || y(i.appContext.components);
  }
  return u ? wL(u) : s ? "App" : "Anonymous";
}
function ik(i) {
  return ft(i) && "__vccOpts" in i;
}
const rk = (i, n) => bF(i, n, Ao);
function sk(i, n, s) {
  const u = arguments.length;
  return u === 2 ? Nt(n) && !Je(n) ? br(n) ? Xt(i, null, [n]) : Xt(i, n) : Xt(i, null, n) : (u > 3 ? s = Array.prototype.slice.call(arguments, 2) : u === 3 && br(s) && (s = [s]), Xt(i, n, s));
}
const ok = Symbol.for("v-scx"), ak = () => {
  {
    const i = qa(ok);
    return i || process.env.NODE_ENV !== "production" && _e(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), i;
  }
};
function nf(i) {
  return !!(i && i.__v_isShallow);
}
function kL() {
  if (process.env.NODE_ENV === "production" || typeof window > "u")
    return;
  const i = { style: "color:#3ba776" }, n = { style: "color:#0b1bc9" }, s = { style: "color:#b62e24" }, u = { style: "color:#9d288c" }, y = {
    header(c) {
      return Nt(c) ? c.__isVue ? ["div", i, "VueInstance"] : tn(c) ? [
        "div",
        {},
        ["span", i, v(c)],
        "<",
        d(c.value),
        ">"
      ] : ns(c) ? [
        "div",
        {},
        ["span", i, nf(c) ? "ShallowReactive" : "Reactive"],
        "<",
        d(c),
        `>${yr(c) ? " (readonly)" : ""}`
      ] : yr(c) ? [
        "div",
        {},
        ["span", i, nf(c) ? "ShallowReadonly" : "Readonly"],
        "<",
        d(c),
        ">"
      ] : null : null;
    },
    hasBody(c) {
      return c && c.__isVue;
    },
    body(c) {
      if (c && c.__isVue)
        return [
          "div",
          {},
          ...w(c.$)
        ];
    }
  };
  function w(c) {
    const e = [];
    c.type.props && c.props && e.push(S("props", Et(c.props))), c.setupState !== Ft && e.push(S("setup", c.setupState)), c.data !== Ft && e.push(S("data", Et(c.data)));
    const h = l(c, "computed");
    h && e.push(S("computed", h));
    const m = l(c, "inject");
    return m && e.push(S("injected", m)), e.push([
      "div",
      {},
      [
        "span",
        {
          style: u.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: c }]
    ]), e;
  }
  function S(c, e) {
    return e = _t({}, e), Object.keys(e).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        c
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(e).map((h) => [
          "div",
          {},
          ["span", u, h + ": "],
          d(e[h], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function d(c, e = !0) {
    return typeof c == "number" ? ["span", n, c] : typeof c == "string" ? ["span", s, JSON.stringify(c)] : typeof c == "boolean" ? ["span", u, c] : Nt(c) ? ["object", { object: e ? Et(c) : c }] : ["span", s, String(c)];
  }
  function l(c, e) {
    const h = c.type;
    if (ft(h))
      return;
    const m = {};
    for (const b in c.ctx)
      p(h, b, e) && (m[b] = c.ctx[b]);
    return m;
  }
  function p(c, e, h) {
    const m = c[h];
    if (Je(m) && m.includes(e) || Nt(m) && e in m || c.extends && p(c.extends, e, h) || c.mixins && c.mixins.some((b) => p(b, e, h)))
      return !0;
  }
  function v(c) {
    return nf(c) ? "ShallowRef" : c.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(y) : window.devtoolsFormatters = [y];
}
function SL(i, n, s, u) {
  const y = s[u];
  if (y && lk(y, i))
    return y;
  const w = n();
  return w.memo = i.slice(), s[u] = w;
}
function lk(i, n) {
  const s = i.memo;
  if (s.length != n.length)
    return !1;
  for (let u = 0; u < s.length; u++)
    if (As(s[u], n[u]))
      return !1;
  return Ys > 0 && Jn && Jn.push(i), !0;
}
const Gf = "3.3.4", EL = {
  createComponentInstance: Qw,
  setupComponent: ek,
  renderComponentRoot: ou,
  setCurrentRenderingInstance: kl,
  isVNode: br,
  normalizeVNode: qn
}, xL = EL, _L = null, TL = null, OL = "http://www.w3.org/2000/svg", Os = typeof document < "u" ? document : null, vb = Os && /* @__PURE__ */ Os.createElement("template"), DL = {
  insert: (i, n, s) => {
    n.insertBefore(i, s || null);
  },
  remove: (i) => {
    const n = i.parentNode;
    n && n.removeChild(i);
  },
  createElement: (i, n, s, u) => {
    const y = n ? Os.createElementNS(OL, i) : Os.createElement(i, s ? { is: s } : void 0);
    return i === "select" && u && u.multiple != null && y.setAttribute("multiple", u.multiple), y;
  },
  createText: (i) => Os.createTextNode(i),
  createComment: (i) => Os.createComment(i),
  setText: (i, n) => {
    i.nodeValue = n;
  },
  setElementText: (i, n) => {
    i.textContent = n;
  },
  parentNode: (i) => i.parentNode,
  nextSibling: (i) => i.nextSibling,
  querySelector: (i) => Os.querySelector(i),
  setScopeId(i, n) {
    i.setAttribute(n, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(i, n, s, u, y, w) {
    const S = s ? s.previousSibling : n.lastChild;
    if (y && (y === w || y.nextSibling))
      for (; n.insertBefore(y.cloneNode(!0), s), !(y === w || !(y = y.nextSibling)); )
        ;
    else {
      vb.innerHTML = u ? `<svg>${i}</svg>` : i;
      const d = vb.content;
      if (u) {
        const l = d.firstChild;
        for (; l.firstChild; )
          d.appendChild(l.firstChild);
        d.removeChild(l);
      }
      n.insertBefore(d, s);
    }
    return [
      // first
      S ? S.nextSibling : n.firstChild,
      // last
      s ? s.previousSibling : n.lastChild
    ];
  }
};
function NL(i, n, s) {
  const u = i._vtc;
  u && (n = (n ? [n, ...u] : [...u]).join(" ")), n == null ? i.removeAttribute("class") : s ? i.setAttribute("class", n) : i.className = n;
}
function BL(i, n, s) {
  const u = i.style, y = wt(s);
  if (s && !y) {
    if (n && !wt(n))
      for (const w in n)
        s[w] == null && Xf(u, w, "");
    for (const w in s)
      Xf(u, w, s[w]);
  } else {
    const w = u.display;
    y ? n !== s && (u.cssText = s) : n && i.removeAttribute("style"), "_vod" in i && (u.display = w);
  }
}
const PL = /[^\\];\s*$/, yb = /\s*!important$/;
function Xf(i, n, s) {
  if (Je(s))
    s.forEach((u) => Xf(i, n, u));
  else if (s == null && (s = ""), process.env.NODE_ENV !== "production" && PL.test(s) && _e(
    `Unexpected semicolon at the end of '${n}' style value: '${s}'`
  ), n.startsWith("--"))
    i.setProperty(n, s);
  else {
    const u = VL(i, n);
    yb.test(s) ? i.setProperty(
      Bn(u),
      s.replace(yb, ""),
      "important"
    ) : i[u] = s;
  }
}
const bb = ["Webkit", "Moz", "ms"], rf = {};
function VL(i, n) {
  const s = rf[n];
  if (s)
    return s;
  let u = an(n);
  if (u !== "filter" && u in i)
    return rf[n] = u;
  u = Pi(u);
  for (let y = 0; y < bb.length; y++) {
    const w = bb[y] + u;
    if (w in i)
      return rf[n] = w;
  }
  return n;
}
const Cb = "http://www.w3.org/1999/xlink";
function $L(i, n, s, u, y) {
  if (u && n.startsWith("xlink:"))
    s == null ? i.removeAttributeNS(Cb, n.slice(6, n.length)) : i.setAttributeNS(Cb, n, s);
  else {
    const w = UC(n);
    s == null || w && !pp(s) ? i.removeAttribute(n) : i.setAttribute(n, w ? "" : s);
  }
}
function IL(i, n, s, u, y, w, S) {
  if (n === "innerHTML" || n === "textContent") {
    u && S(u, y, w), i[n] = s ?? "";
    return;
  }
  const d = i.tagName;
  if (n === "value" && d !== "PROGRESS" && // custom elements may use _value internally
  !d.includes("-")) {
    i._value = s;
    const p = d === "OPTION" ? i.getAttribute("value") : i.value, v = s ?? "";
    p !== v && (i.value = v), s == null && i.removeAttribute(n);
    return;
  }
  let l = !1;
  if (s === "" || s == null) {
    const p = typeof i[n];
    p === "boolean" ? s = pp(s) : s == null && p === "string" ? (s = "", l = !0) : p === "number" && (s = 0, l = !0);
  }
  try {
    i[n] = s;
  } catch (p) {
    process.env.NODE_ENV !== "production" && !l && _e(
      `Failed setting prop "${n}" on <${d.toLowerCase()}>: value ${s} is invalid.`,
      p
    );
  }
  l && i.removeAttribute(n);
}
function fr(i, n, s, u) {
  i.addEventListener(n, s, u);
}
function ML(i, n, s, u) {
  i.removeEventListener(n, s, u);
}
function AL(i, n, s, u, y = null) {
  const w = i._vei || (i._vei = {}), S = w[n];
  if (u && S)
    S.value = u;
  else {
    const [d, l] = FL(n);
    if (u) {
      const p = w[n] = RL(u, y);
      fr(i, d, p, l);
    } else
      S && (ML(i, d, S, l), w[n] = void 0);
  }
}
const wb = /(?:Once|Passive|Capture)$/;
function FL(i) {
  let n;
  if (wb.test(i)) {
    n = {};
    let u;
    for (; u = i.match(wb); )
      i = i.slice(0, i.length - u[0].length), n[u[0].toLowerCase()] = !0;
  }
  return [i[2] === ":" ? i.slice(3) : Bn(i.slice(2)), n];
}
let sf = 0;
const LL = /* @__PURE__ */ Promise.resolve(), zL = () => sf || (LL.then(() => sf = 0), sf = Date.now());
function RL(i, n) {
  const s = (u) => {
    if (!u._vts)
      u._vts = Date.now();
    else if (u._vts <= s.attached)
      return;
    ci(
      jL(u, s.value),
      n,
      5,
      [u]
    );
  };
  return s.value = i, s.attached = zL(), s;
}
function jL(i, n) {
  if (Je(n)) {
    const s = i.stopImmediatePropagation;
    return i.stopImmediatePropagation = () => {
      s.call(i), i._stopped = !0;
    }, n.map((u) => (y) => !y._stopped && u && u(y));
  } else
    return n;
}
const kb = /^on[a-z]/, HL = (i, n, s, u, y = !1, w, S, d, l) => {
  n === "class" ? NL(i, u, y) : n === "style" ? BL(i, s, u) : Gi(n) ? il(n) || AL(i, n, s, u, S) : (n[0] === "." ? (n = n.slice(1), !0) : n[0] === "^" ? (n = n.slice(1), !1) : UL(i, n, u, y)) ? IL(
    i,
    n,
    u,
    w,
    S,
    d,
    l
  ) : (n === "true-value" ? i._trueValue = u : n === "false-value" && (i._falseValue = u), $L(i, n, u, y));
};
function UL(i, n, s, u) {
  return u ? !!(n === "innerHTML" || n === "textContent" || n in i && kb.test(n) && ft(s)) : n === "spellcheck" || n === "draggable" || n === "translate" || n === "form" || n === "list" && i.tagName === "INPUT" || n === "type" && i.tagName === "TEXTAREA" || kb.test(n) && wt(s) ? !1 : n in i;
}
function ck(i, n) {
  const s = hm(i);
  class u extends wh {
    constructor(w) {
      super(s, w, n);
    }
  }
  return u.def = s, u;
}
const WL = (i) => ck(i, xk), YL = typeof HTMLElement < "u" ? HTMLElement : class {
};
class wh extends YL {
  constructor(n, s = {}, u) {
    super(), this._def = n, this._props = s, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && u ? u(this._createVNode(), this.shadowRoot) : (process.env.NODE_ENV !== "production" && this.shadowRoot && _e(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, tm(() => {
      this._connected || (Qf(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let u = 0; u < this.attributes.length; u++)
      this._setAttr(this.attributes[u].name);
    new MutationObserver((u) => {
      for (const y of u)
        this._setAttr(y.attributeName);
    }).observe(this, { attributes: !0 });
    const n = (u, y = !1) => {
      const { props: w, styles: S } = u;
      let d;
      if (w && !Je(w))
        for (const l in w) {
          const p = w[l];
          (p === Number || p && p.type === Number) && (l in this._props && (this._props[l] = ol(this._props[l])), (d || (d = /* @__PURE__ */ Object.create(null)))[an(l)] = !0);
        }
      this._numberProps = d, y && this._resolveProps(u), this._applyStyles(S), this._update();
    }, s = this._def.__asyncLoader;
    s ? s().then((u) => n(u, !0)) : n(this._def);
  }
  _resolveProps(n) {
    const { props: s } = n, u = Je(s) ? s : Object.keys(s || {});
    for (const y of Object.keys(this))
      y[0] !== "_" && u.includes(y) && this._setProp(y, this[y], !0, !1);
    for (const y of u.map(an))
      Object.defineProperty(this, y, {
        get() {
          return this._getProp(y);
        },
        set(w) {
          this._setProp(y, w);
        }
      });
  }
  _setAttr(n) {
    let s = this.getAttribute(n);
    const u = an(n);
    this._numberProps && this._numberProps[u] && (s = ol(s)), this._setProp(u, s, !1);
  }
  /**
   * @internal
   */
  _getProp(n) {
    return this._props[n];
  }
  /**
   * @internal
   */
  _setProp(n, s, u = !0, y = !0) {
    s !== this._props[n] && (this._props[n] = s, y && this._instance && this._update(), u && (s === !0 ? this.setAttribute(Bn(n), "") : typeof s == "string" || typeof s == "number" ? this.setAttribute(Bn(n), s + "") : s || this.removeAttribute(Bn(n))));
  }
  _update() {
    Qf(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const n = Xt(this._def, _t({}, this._props));
    return this._instance || (n.ce = (s) => {
      this._instance = s, s.isCE = !0, process.env.NODE_ENV !== "production" && (s.ceReload = (w) => {
        this._styles && (this._styles.forEach((S) => this.shadowRoot.removeChild(S)), this._styles.length = 0), this._applyStyles(w), this._instance = null, this._update();
      });
      const u = (w, S) => {
        this.dispatchEvent(
          new CustomEvent(w, {
            detail: S
          })
        );
      };
      s.emit = (w, ...S) => {
        u(w, S), Bn(w) !== w && u(Bn(w), S);
      };
      let y = this;
      for (; y = y && (y.parentNode || y.host); )
        if (y instanceof wh) {
          s.parent = y._instance, s.provides = y._instance.provides;
          break;
        }
    }), n;
  }
  _applyStyles(n) {
    n && n.forEach((s) => {
      const u = document.createElement("style");
      u.textContent = s, this.shadowRoot.appendChild(u), process.env.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(u);
    });
  }
}
function KL(i = "$style") {
  {
    const n = wr();
    if (!n)
      return process.env.NODE_ENV !== "production" && _e("useCssModule must be called inside setup()"), Ft;
    const s = n.type.__cssModules;
    if (!s)
      return process.env.NODE_ENV !== "production" && _e("Current instance does not have CSS modules injected."), Ft;
    const u = s[i];
    return u || (process.env.NODE_ENV !== "production" && _e(`Current instance does not have CSS module named "${i}".`), Ft);
  }
}
function GL(i) {
  const n = wr();
  if (!n) {
    process.env.NODE_ENV !== "production" && _e("useCssVars is called without current active component instance.");
    return;
  }
  const s = n.ut = (y = i(n.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${n.uid}"]`)
    ).forEach((w) => Jf(w, y));
  }, u = () => {
    const y = i(n.proxy);
    qf(n.subTree, y), s(y);
  };
  mw(u), Rl(() => {
    const y = new MutationObserver(u);
    y.observe(n.subTree.el.parentNode, { childList: !0 }), gh(() => y.disconnect());
  });
}
function qf(i, n) {
  if (i.shapeFlag & 128) {
    const s = i.suspense;
    i = s.activeBranch, s.pendingBranch && !s.isHydrating && s.effects.push(() => {
      qf(s.activeBranch, n);
    });
  }
  for (; i.component; )
    i = i.component.subTree;
  if (i.shapeFlag & 1 && i.el)
    Jf(i.el, n);
  else if (i.type === _n)
    i.children.forEach((s) => qf(s, n));
  else if (i.type === ss) {
    let { el: s, anchor: u } = i;
    for (; s && (Jf(s, n), s !== u); )
      s = s.nextSibling;
  }
}
function Jf(i, n) {
  if (i.nodeType === 1) {
    const s = i.style;
    for (const u in n)
      s.setProperty(`--${u}`, n[u]);
  }
}
const Rr = "transition", Ia = "animation", km = (i, { slots: n }) => sk(yw, hk(i), n);
km.displayName = "Transition";
const uk = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, XL = km.props = /* @__PURE__ */ _t(
  {},
  um,
  uk
), Ts = (i, n = []) => {
  Je(i) ? i.forEach((s) => s(...n)) : i && i(...n);
}, Sb = (i) => i ? Je(i) ? i.some((n) => n.length > 1) : i.length > 1 : !1;
function hk(i) {
  const n = {};
  for (const re in i)
    re in uk || (n[re] = i[re]);
  if (i.css === !1)
    return n;
  const {
    name: s = "v",
    type: u,
    duration: y,
    enterFromClass: w = `${s}-enter-from`,
    enterActiveClass: S = `${s}-enter-active`,
    enterToClass: d = `${s}-enter-to`,
    appearFromClass: l = w,
    appearActiveClass: p = S,
    appearToClass: v = d,
    leaveFromClass: c = `${s}-leave-from`,
    leaveActiveClass: e = `${s}-leave-active`,
    leaveToClass: h = `${s}-leave-to`
  } = i, m = qL(y), b = m && m[0], f = m && m[1], {
    onBeforeEnter: k,
    onEnter: E,
    onEnterCancelled: _,
    onLeave: T,
    onLeaveCancelled: D,
    onBeforeAppear: V = k,
    onAppear: I = E,
    onAppearCancelled: M = _
  } = n, Q = (re, he, de) => {
    Ur(re, he ? v : d), Ur(re, he ? p : S), de && de();
  }, G = (re, he) => {
    re._isLeaving = !1, Ur(re, c), Ur(re, h), Ur(re, e), he && he();
  }, z = (re) => (he, de) => {
    const Ce = re ? I : E, xe = () => Q(he, re, de);
    Ts(Ce, [he, xe]), Eb(() => {
      Ur(he, re ? l : w), ur(he, re ? v : d), Sb(Ce) || xb(he, u, b, xe);
    });
  };
  return _t(n, {
    onBeforeEnter(re) {
      Ts(k, [re]), ur(re, w), ur(re, S);
    },
    onBeforeAppear(re) {
      Ts(V, [re]), ur(re, l), ur(re, p);
    },
    onEnter: z(!1),
    onAppear: z(!0),
    onLeave(re, he) {
      re._isLeaving = !0;
      const de = () => G(re, he);
      ur(re, c), fk(), ur(re, e), Eb(() => {
        re._isLeaving && (Ur(re, c), ur(re, h), Sb(T) || xb(re, u, f, de));
      }), Ts(T, [re, de]);
    },
    onEnterCancelled(re) {
      Q(re, !1), Ts(_, [re]);
    },
    onAppearCancelled(re) {
      Q(re, !0), Ts(M, [re]);
    },
    onLeaveCancelled(re) {
      G(re), Ts(D, [re]);
    }
  });
}
function qL(i) {
  if (i == null)
    return null;
  if (Nt(i))
    return [of(i.enter), of(i.leave)];
  {
    const n = of(i);
    return [n, n];
  }
}
function of(i) {
  const n = ol(i);
  return process.env.NODE_ENV !== "production" && Qp(n, "<transition> explicit duration"), n;
}
function ur(i, n) {
  n.split(/\s+/).forEach((s) => s && i.classList.add(s)), (i._vtc || (i._vtc = /* @__PURE__ */ new Set())).add(n);
}
function Ur(i, n) {
  n.split(/\s+/).forEach((u) => u && i.classList.remove(u));
  const { _vtc: s } = i;
  s && (s.delete(n), s.size || (i._vtc = void 0));
}
function Eb(i) {
  requestAnimationFrame(() => {
    requestAnimationFrame(i);
  });
}
let JL = 0;
function xb(i, n, s, u) {
  const y = i._endId = ++JL, w = () => {
    y === i._endId && u();
  };
  if (s)
    return setTimeout(w, s);
  const { type: S, timeout: d, propCount: l } = dk(i, n);
  if (!S)
    return u();
  const p = S + "end";
  let v = 0;
  const c = () => {
    i.removeEventListener(p, e), w();
  }, e = (h) => {
    h.target === i && ++v >= l && c();
  };
  setTimeout(() => {
    v < l && c();
  }, d + 1), i.addEventListener(p, e);
}
function dk(i, n) {
  const s = window.getComputedStyle(i), u = (m) => (s[m] || "").split(", "), y = u(`${Rr}Delay`), w = u(`${Rr}Duration`), S = _b(y, w), d = u(`${Ia}Delay`), l = u(`${Ia}Duration`), p = _b(d, l);
  let v = null, c = 0, e = 0;
  n === Rr ? S > 0 && (v = Rr, c = S, e = w.length) : n === Ia ? p > 0 && (v = Ia, c = p, e = l.length) : (c = Math.max(S, p), v = c > 0 ? S > p ? Rr : Ia : null, e = v ? v === Rr ? w.length : l.length : 0);
  const h = v === Rr && /\b(transform|all)(,|$)/.test(
    u(`${Rr}Property`).toString()
  );
  return {
    type: v,
    timeout: c,
    propCount: e,
    hasTransform: h
  };
}
function _b(i, n) {
  for (; i.length < n.length; )
    i = i.concat(i);
  return Math.max(...n.map((s, u) => Tb(s) + Tb(i[u])));
}
function Tb(i) {
  return Number(i.slice(0, -1).replace(",", ".")) * 1e3;
}
function fk() {
  return document.body.offsetHeight;
}
const pk = /* @__PURE__ */ new WeakMap(), mk = /* @__PURE__ */ new WeakMap(), gk = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ _t({}, XL, {
    tag: String,
    moveClass: String
  }),
  setup(i, { slots: n }) {
    const s = wr(), u = cm();
    let y, w;
    return ph(() => {
      if (!y.length)
        return;
      const S = i.moveClass || `${i.name || "v"}-move`;
      if (!i4(
        y[0].el,
        s.vnode.el,
        S
      ))
        return;
      y.forEach(e4), y.forEach(t4);
      const d = y.filter(n4);
      fk(), d.forEach((l) => {
        const p = l.el, v = p.style;
        ur(p, S), v.transform = v.webkitTransform = v.transitionDuration = "";
        const c = p._moveCb = (e) => {
          e && e.target !== p || (!e || /transform$/.test(e.propertyName)) && (p.removeEventListener("transitionend", c), p._moveCb = null, Ur(p, S));
        };
        p.addEventListener("transitionend", c);
      });
    }), () => {
      const S = Et(i), d = hk(S);
      let l = S.tag || _n;
      y = w, w = n.default ? dh(n.default()) : [];
      for (let p = 0; p < w.length; p++) {
        const v = w[p];
        v.key != null ? Ws(
          v,
          Mo(v, d, u, s)
        ) : process.env.NODE_ENV !== "production" && _e("<TransitionGroup> children must be keyed.");
      }
      if (y)
        for (let p = 0; p < y.length; p++) {
          const v = y[p];
          Ws(
            v,
            Mo(v, d, u, s)
          ), pk.set(v, v.el.getBoundingClientRect());
        }
      return Xt(l, null, w);
    };
  }
}, QL = (i) => delete i.mode;
gk.props;
const ZL = gk;
function e4(i) {
  const n = i.el;
  n._moveCb && n._moveCb(), n._enterCb && n._enterCb();
}
function t4(i) {
  mk.set(i, i.el.getBoundingClientRect());
}
function n4(i) {
  const n = pk.get(i), s = mk.get(i), u = n.left - s.left, y = n.top - s.top;
  if (u || y) {
    const w = i.el.style;
    return w.transform = w.webkitTransform = `translate(${u}px,${y}px)`, w.transitionDuration = "0s", i;
  }
}
function i4(i, n, s) {
  const u = i.cloneNode();
  i._vtc && i._vtc.forEach((S) => {
    S.split(/\s+/).forEach((d) => d && u.classList.remove(d));
  }), s.split(/\s+/).forEach((S) => S && u.classList.add(S)), u.style.display = "none";
  const y = n.nodeType === 1 ? n : n.parentNode;
  y.appendChild(u);
  const { hasTransform: w } = dk(u);
  return y.removeChild(u), w;
}
const ds = (i) => {
  const n = i.props["onUpdate:modelValue"] || !1;
  return Je(n) ? (s) => dr(n, s) : n;
};
function r4(i) {
  i.target.composing = !0;
}
function Ob(i) {
  const n = i.target;
  n.composing && (n.composing = !1, n.dispatchEvent(new Event("input")));
}
const Du = {
  created(i, { modifiers: { lazy: n, trim: s, number: u } }, y) {
    i._assign = ds(y);
    const w = u || y.props && y.props.type === "number";
    fr(i, n ? "change" : "input", (S) => {
      if (S.target.composing)
        return;
      let d = i.value;
      s && (d = d.trim()), w && (d = sl(d)), i._assign(d);
    }), s && fr(i, "change", () => {
      i.value = i.value.trim();
    }), n || (fr(i, "compositionstart", r4), fr(i, "compositionend", Ob), fr(i, "change", Ob));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(i, { value: n }) {
    i.value = n ?? "";
  },
  beforeUpdate(i, { value: n, modifiers: { lazy: s, trim: u, number: y } }, w) {
    if (i._assign = ds(w), i.composing || document.activeElement === i && i.type !== "range" && (s || u && i.value.trim() === n || (y || i.type === "number") && sl(i.value) === n))
      return;
    const S = n ?? "";
    i.value !== S && (i.value = S);
  }
}, Sm = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(i, n, s) {
    i._assign = ds(s), fr(i, "change", () => {
      const u = i._modelValue, y = Fo(i), w = i.checked, S = i._assign;
      if (Je(u)) {
        const d = Bl(u, y), l = d !== -1;
        if (w && !l)
          S(u.concat(y));
        else if (!w && l) {
          const p = [...u];
          p.splice(d, 1), S(p);
        }
      } else if (fs(u)) {
        const d = new Set(u);
        w ? d.add(y) : d.delete(y), S(d);
      } else
        S(yk(i, w));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Db,
  beforeUpdate(i, n, s) {
    i._assign = ds(s), Db(i, n, s);
  }
};
function Db(i, { value: n, oldValue: s }, u) {
  i._modelValue = n, Je(n) ? i.checked = Bl(n, u.props.value) > -1 : fs(n) ? i.checked = n.has(u.props.value) : n !== s && (i.checked = vr(n, yk(i, !0)));
}
const Em = {
  created(i, { value: n }, s) {
    i.checked = vr(n, s.props.value), i._assign = ds(s), fr(i, "change", () => {
      i._assign(Fo(i));
    });
  },
  beforeUpdate(i, { value: n, oldValue: s }, u) {
    i._assign = ds(u), n !== s && (i.checked = vr(n, u.props.value));
  }
}, vk = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(i, { value: n, modifiers: { number: s } }, u) {
    const y = fs(n);
    fr(i, "change", () => {
      const w = Array.prototype.filter.call(i.options, (S) => S.selected).map(
        (S) => s ? sl(Fo(S)) : Fo(S)
      );
      i._assign(
        i.multiple ? y ? new Set(w) : w : w[0]
      );
    }), i._assign = ds(u);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(i, { value: n }) {
    Nb(i, n);
  },
  beforeUpdate(i, n, s) {
    i._assign = ds(s);
  },
  updated(i, { value: n }) {
    Nb(i, n);
  }
};
function Nb(i, n) {
  const s = i.multiple;
  if (s && !Je(n) && !fs(n)) {
    process.env.NODE_ENV !== "production" && _e(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(n).slice(8, -1)}.`
    );
    return;
  }
  for (let u = 0, y = i.options.length; u < y; u++) {
    const w = i.options[u], S = Fo(w);
    if (s)
      Je(n) ? w.selected = Bl(n, S) > -1 : w.selected = n.has(S);
    else if (vr(Fo(w), n)) {
      i.selectedIndex !== u && (i.selectedIndex = u);
      return;
    }
  }
  !s && i.selectedIndex !== -1 && (i.selectedIndex = -1);
}
function Fo(i) {
  return "_value" in i ? i._value : i.value;
}
function yk(i, n) {
  const s = n ? "_trueValue" : "_falseValue";
  return s in i ? i[s] : n;
}
const bk = {
  created(i, n, s) {
    Zc(i, n, s, null, "created");
  },
  mounted(i, n, s) {
    Zc(i, n, s, null, "mounted");
  },
  beforeUpdate(i, n, s, u) {
    Zc(i, n, s, u, "beforeUpdate");
  },
  updated(i, n, s, u) {
    Zc(i, n, s, u, "updated");
  }
};
function Ck(i, n) {
  switch (i) {
    case "SELECT":
      return vk;
    case "TEXTAREA":
      return Du;
    default:
      switch (n) {
        case "checkbox":
          return Sm;
        case "radio":
          return Em;
        default:
          return Du;
      }
  }
}
function Zc(i, n, s, u, y) {
  const S = Ck(
    i.tagName,
    s.props && s.props.type
  )[y];
  S && S(i, n, s, u);
}
function s4() {
  Du.getSSRProps = ({ value: i }) => ({ value: i }), Em.getSSRProps = ({ value: i }, n) => {
    if (n.props && vr(n.props.value, i))
      return { checked: !0 };
  }, Sm.getSSRProps = ({ value: i }, n) => {
    if (Je(i)) {
      if (n.props && Bl(i, n.props.value) > -1)
        return { checked: !0 };
    } else if (fs(i)) {
      if (n.props && i.has(n.props.value))
        return { checked: !0 };
    } else if (i)
      return { checked: !0 };
  }, bk.getSSRProps = (i, n) => {
    if (typeof n.type != "string")
      return;
    const s = Ck(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      n.type.toUpperCase(),
      n.props && n.props.type
    );
    if (s.getSSRProps)
      return s.getSSRProps(i, n);
  };
}
const o4 = ["ctrl", "shift", "alt", "meta"], a4 = {
  stop: (i) => i.stopPropagation(),
  prevent: (i) => i.preventDefault(),
  self: (i) => i.target !== i.currentTarget,
  ctrl: (i) => !i.ctrlKey,
  shift: (i) => !i.shiftKey,
  alt: (i) => !i.altKey,
  meta: (i) => !i.metaKey,
  left: (i) => "button" in i && i.button !== 0,
  middle: (i) => "button" in i && i.button !== 1,
  right: (i) => "button" in i && i.button !== 2,
  exact: (i, n) => o4.some((s) => i[`${s}Key`] && !n.includes(s))
}, l4 = (i, n) => (s, ...u) => {
  for (let y = 0; y < n.length; y++) {
    const w = a4[n[y]];
    if (w && w(s, n))
      return;
  }
  return i(s, ...u);
}, c4 = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, u4 = (i, n) => (s) => {
  if (!("key" in s))
    return;
  const u = Bn(s.key);
  if (n.some((y) => y === u || c4[y] === u))
    return i(s);
}, wk = {
  beforeMount(i, { value: n }, { transition: s }) {
    i._vod = i.style.display === "none" ? "" : i.style.display, s && n ? s.beforeEnter(i) : Ma(i, n);
  },
  mounted(i, { value: n }, { transition: s }) {
    s && n && s.enter(i);
  },
  updated(i, { value: n, oldValue: s }, { transition: u }) {
    !n != !s && (u ? n ? (u.beforeEnter(i), Ma(i, !0), u.enter(i)) : u.leave(i, () => {
      Ma(i, !1);
    }) : Ma(i, n));
  },
  beforeUnmount(i, { value: n }) {
    Ma(i, n);
  }
};
function Ma(i, n) {
  i.style.display = n ? i._vod : "none";
}
function h4() {
  wk.getSSRProps = ({ value: i }) => {
    if (!i)
      return { style: { display: "none" } };
  };
}
const kk = /* @__PURE__ */ _t({ patchProp: HL }, DL);
let el, Bb = !1;
function Sk() {
  return el || (el = Rw(kk));
}
function Ek() {
  return el = Bb ? el : jw(kk), Bb = !0, el;
}
const Qf = (...i) => {
  Sk().render(...i);
}, xk = (...i) => {
  Ek().hydrate(...i);
}, d4 = (...i) => {
  const n = Sk().createApp(...i);
  process.env.NODE_ENV !== "production" && (_k(n), Tk(n));
  const { mount: s } = n;
  return n.mount = (u) => {
    const y = Ok(u);
    if (!y)
      return;
    const w = n._component;
    !ft(w) && !w.render && !w.template && (w.template = y.innerHTML), y.innerHTML = "";
    const S = s(y, !1, y instanceof SVGElement);
    return y instanceof Element && (y.removeAttribute("v-cloak"), y.setAttribute("data-v-app", "")), S;
  }, n;
}, f4 = (...i) => {
  const n = Ek().createApp(...i);
  process.env.NODE_ENV !== "production" && (_k(n), Tk(n));
  const { mount: s } = n;
  return n.mount = (u) => {
    const y = Ok(u);
    if (y)
      return s(y, !0, y instanceof SVGElement);
  }, n;
};
function _k(i) {
  Object.defineProperty(i.config, "isNativeTag", {
    value: (n) => dp(n) || fp(n),
    writable: !1
  });
}
function Tk(i) {
  if (wm()) {
    const n = i.config.isCustomElement;
    Object.defineProperty(i.config, "isCustomElement", {
      get() {
        return n;
      },
      set() {
        _e(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const s = i.config.compilerOptions, u = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(i.config, "compilerOptions", {
      get() {
        return _e(u), s;
      },
      set() {
        _e(u);
      }
    });
  }
}
function Ok(i) {
  if (wt(i)) {
    const n = document.querySelector(i);
    return process.env.NODE_ENV !== "production" && !n && _e(
      `Failed to mount app: mount target selector "${i}" returned null.`
    ), n;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && i instanceof window.ShadowRoot && i.mode === "closed" && _e(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), i;
}
let Pb = !1;
const p4 = () => {
  Pb || (Pb = !0, s4(), h4());
}, m4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: yw,
  BaseTransitionPropsValidators: um,
  Comment: ln,
  EffectScope: Up,
  Fragment: _n,
  KeepAlive: l6,
  ReactiveEffect: Al,
  Static: ss,
  Suspense: XF,
  Teleport: lL,
  Text: us,
  Transition: km,
  TransitionGroup: ZL,
  VueElement: wh,
  assertNumber: Qp,
  callWithAsyncErrorHandling: ci,
  callWithErrorHandling: Yi,
  camelize: an,
  capitalize: Pi,
  cloneVNode: wi,
  compatUtils: TL,
  computed: rk,
  createApp: d4,
  createBlock: gm,
  createCommentVNode: fL,
  createElementBlock: cL,
  createElementVNode: vm,
  createHydrationRenderer: jw,
  createPropsRestProxy: $6,
  createRenderer: Rw,
  createSSRApp: f4,
  createSlots: m6,
  createStaticVNode: dL,
  createTextVNode: ym,
  createVNode: Xt,
  customRef: fF,
  defineAsyncComponent: o6,
  defineComponent: hm,
  defineCustomElement: ck,
  defineEmits: S6,
  defineExpose: E6,
  defineModel: T6,
  defineOptions: x6,
  defineProps: k6,
  defineSSRCustomElement: WL,
  defineSlots: _6,
  get devtools() {
    return Di;
  },
  effect: V3,
  effectScope: D3,
  getCurrentInstance: wr,
  getCurrentScope: H1,
  getTransitionRawChildren: dh,
  guardReactiveProps: Xw,
  h: sk,
  handleError: qs,
  hasInjectionContext: U6,
  hydrate: xk,
  initCustomFormatter: kL,
  initDirectivesForSSR: p4,
  inject: qa,
  isMemoSame: lk,
  isProxy: yl,
  isReactive: ns,
  isReadonly: yr,
  isRef: tn,
  isRuntimeOnly: wm,
  isShallow: vl,
  isVNode: br,
  markRaw: Kp,
  mergeDefaults: P6,
  mergeModels: V6,
  mergeProps: Jw,
  nextTick: tm,
  normalizeClass: Ro,
  normalizeProps: RC,
  normalizeStyle: zo,
  onActivated: Cw,
  onBeforeMount: Sw,
  onBeforeUnmount: mh,
  onBeforeUpdate: Ew,
  onDeactivated: ww,
  onErrorCaptured: Ow,
  onMounted: Rl,
  onRenderTracked: Tw,
  onRenderTriggered: _w,
  onScopeDispose: N3,
  onServerPrefetch: xw,
  onUnmounted: gh,
  onUpdated: ph,
  openBlock: vh,
  popScopeId: jF,
  provide: $w,
  proxyRefs: Jp,
  pushScopeId: RF,
  queuePostFlushCb: ch,
  reactive: oh,
  readonly: Yp,
  ref: is,
  registerRuntimeCompiler: yL,
  render: Qf,
  renderList: p6,
  renderSlot: g6,
  resolveComponent: h6,
  resolveDirective: f6,
  resolveDynamicComponent: d6,
  resolveFilter: _L,
  resolveTransitionHooks: Mo,
  setBlockTracking: Hf,
  setDevtoolsHook: im,
  setTransitionHooks: Ws,
  shallowReactive: nw,
  shallowReadonly: So,
  shallowRef: aF,
  ssrContextKey: ok,
  ssrUtils: xL,
  stop: $3,
  toDisplayString: WC,
  toHandlerKey: Oi,
  toHandlers: v6,
  toRaw: Et,
  toRef: vF,
  toRefs: pF,
  toValue: uF,
  transformVNodeArgs: uL,
  triggerRef: cF,
  unref: qp,
  useAttrs: N6,
  useCssModule: KL,
  useCssVars: GL,
  useModel: B6,
  useSSRContext: ak,
  useSlots: D6,
  useTransitionState: cm,
  vModelCheckbox: Sm,
  vModelDynamic: bk,
  vModelRadio: Em,
  vModelSelect: vk,
  vModelText: Du,
  vShow: wk,
  version: Gf,
  warn: _e,
  watch: $s,
  watchEffect: t6,
  watchPostEffect: mw,
  watchSyncEffect: n6,
  withAsyncContext: I6,
  withCtx: sm,
  withDefaults: O6,
  withDirectives: r6,
  withKeys: u4,
  withMemo: SL,
  withModifiers: l4,
  withScopeId: HF
}, Symbol.toStringTag, { value: "Module" })), Dk = /* @__PURE__ */ Vu(m4), Nk = /* @__PURE__ */ Vu(UM);
var Vb;
function g4() {
  return Vb || (Vb = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 });
    var n = R1, s = Dk, u = Nk;
    function y(l) {
      var p = /* @__PURE__ */ Object.create(null);
      if (l)
        for (var v in l)
          p[v] = l[v];
      return p.default = l, Object.freeze(p);
    }
    var w = /* @__PURE__ */ y(s);
    const S = /* @__PURE__ */ Object.create(null);
    function d(l, p) {
      if (!u.isString(l))
        if (l.nodeType)
          l = l.innerHTML;
        else
          return u.NOOP;
      const v = l, c = S[v];
      if (c)
        return c;
      if (l[0] === "#") {
        const b = document.querySelector(l);
        l = b ? b.innerHTML : "";
      }
      const e = u.extend(
        {
          hoistStatic: !0,
          onError: void 0,
          onWarn: u.NOOP
        },
        p
      );
      !e.isCustomElement && typeof customElements < "u" && (e.isCustomElement = (b) => !!customElements.get(b));
      const { code: h } = n.compile(l, e), m = new Function("Vue", h)(w);
      return m._rc = !0, S[v] = m;
    }
    s.registerRuntimeCompiler(d), i.compile = d, Object.keys(s).forEach(function(l) {
      l !== "default" && !i.hasOwnProperty(l) && (i[l] = s[l]);
    });
  }(Kd)), Kd;
}
var af = {}, $b;
function v4() {
  return $b || ($b = 1, function(i) {
    Object.defineProperty(i, "__esModule", { value: !0 });
    var n = R1, s = Dk, u = Nk;
    function y(l) {
      var p = /* @__PURE__ */ Object.create(null);
      if (l)
        for (var v in l)
          p[v] = l[v];
      return p.default = l, Object.freeze(p);
    }
    var w = /* @__PURE__ */ y(s);
    const S = /* @__PURE__ */ Object.create(null);
    function d(l, p) {
      if (!u.isString(l))
        if (l.nodeType)
          l = l.innerHTML;
        else
          return s.warn("invalid template option: ", l), u.NOOP;
      const v = l, c = S[v];
      if (c)
        return c;
      if (l[0] === "#") {
        const f = document.querySelector(l);
        f || s.warn(`Template element not found or is empty: ${l}`), l = f ? f.innerHTML : "";
      }
      const e = u.extend(
        {
          hoistStatic: !0,
          onError: m,
          onWarn: (f) => m(f, !0)
        },
        p
      );
      !e.isCustomElement && typeof customElements < "u" && (e.isCustomElement = (f) => !!customElements.get(f));
      const { code: h } = n.compile(l, e);
      function m(f, k = !1) {
        const E = k ? f.message : `Template compilation error: ${f.message}`, _ = f.loc && u.generateCodeFrame(
          l,
          f.loc.start.offset,
          f.loc.end.offset
        );
        s.warn(_ ? `${E}
${_}` : E);
      }
      const b = new Function("Vue", h)(w);
      return b._rc = !0, S[v] = b;
    }
    s.registerRuntimeCompiler(d), i.compile = d, Object.keys(s).forEach(function(l) {
      l !== "default" && !i.hasOwnProperty(l) && (i[l] = s[l]);
    });
  }(af)), af;
}
var Ib;
function Bk() {
  return Ib || (Ib = 1, process.env.NODE_ENV === "production" ? Rc.exports = g4() : Rc.exports = v4()), Rc.exports;
}
var Cn = Bk();
function xm(i) {
  return Cn.getCurrentScope() ? (Cn.onScopeDispose(i), !0) : !1;
}
function y4() {
  const i = /* @__PURE__ */ new Set(), n = (y) => {
    i.delete(y);
  };
  return {
    on: (y) => {
      i.add(y);
      const w = () => n(y);
      return xm(w), {
        off: w
      };
    },
    off: n,
    trigger: (y) => Promise.all(Array.from(i).map((w) => w(y)))
  };
}
function jl(i) {
  return typeof i == "function" ? i() : Cn.unref(i);
}
const Hl = typeof window < "u", b4 = () => {
}, C4 = (i, n) => Object.prototype.hasOwnProperty.call(i, n);
function w4(i, n, s = {}) {
  const {
    immediate: u = !0
  } = s, y = Cn.ref(!1);
  let w = null;
  function S() {
    w && (clearTimeout(w), w = null);
  }
  function d() {
    y.value = !1, S();
  }
  function l(...p) {
    S(), y.value = !0, w = setTimeout(() => {
      y.value = !1, w = null, i(...p);
    }, jl(n));
  }
  return u && (y.value = !0, Hl && l()), xm(d), {
    isPending: Cn.readonly(y),
    start: l,
    stop: d
  };
}
function k4(i) {
  var n;
  const s = jl(i);
  return (n = s == null ? void 0 : s.$el) != null ? n : s;
}
const S4 = Hl ? window : void 0, E4 = Hl ? window.document : void 0, x4 = Hl ? window.navigator : void 0;
function _4(...i) {
  let n, s, u, y;
  if (typeof i[0] == "string" || Array.isArray(i[0]) ? ([s, u, y] = i, n = S4) : [n, s, u, y] = i, !n)
    return b4;
  Array.isArray(s) || (s = [s]), Array.isArray(u) || (u = [u]);
  const w = [], S = () => {
    w.forEach((v) => v()), w.length = 0;
  }, d = (v, c, e, h) => (v.addEventListener(c, e, h), () => v.removeEventListener(c, e, h)), l = Cn.watch(
    () => [k4(n), jl(y)],
    ([v, c]) => {
      S(), v && w.push(
        ...s.flatMap((e) => u.map((h) => d(v, e, h, c)))
      );
    },
    { immediate: !0, flush: "post" }
  ), p = () => {
    l(), S();
  };
  return xm(p), p;
}
function T4() {
  const i = Cn.ref(!1);
  return Cn.getCurrentInstance() && Cn.onMounted(() => {
    i.value = !0;
  }), i;
}
function O4(i) {
  const n = T4();
  return Cn.computed(() => (n.value, !!i()));
}
const Aa = {
  array: (i) => JSON.stringify(i),
  object: (i) => JSON.stringify(i),
  set: (i) => JSON.stringify(Array.from(i)),
  map: (i) => JSON.stringify(Object.fromEntries(i)),
  null: () => ""
};
function D4(i) {
  return i ? i instanceof Map ? Aa.map : i instanceof Set ? Aa.set : Array.isArray(i) ? Aa.array : Aa.object : Aa.null;
}
function N4(i, n) {
  const s = Cn.ref(""), u = Cn.ref();
  function y() {
    if (Hl)
      return u.value = new Promise((w, S) => {
        try {
          const d = jl(i);
          if (d == null)
            w("");
          else if (typeof d == "string")
            w(lf(new Blob([d], { type: "text/plain" })));
          else if (d instanceof Blob)
            w(lf(d));
          else if (d instanceof ArrayBuffer)
            w(window.btoa(String.fromCharCode(...new Uint8Array(d))));
          else if (d instanceof HTMLCanvasElement)
            w(d.toDataURL(n == null ? void 0 : n.type, n == null ? void 0 : n.quality));
          else if (d instanceof HTMLImageElement) {
            const l = d.cloneNode(!1);
            l.crossOrigin = "Anonymous", B4(l).then(() => {
              const p = document.createElement("canvas"), v = p.getContext("2d");
              p.width = l.width, p.height = l.height, v.drawImage(l, 0, 0, p.width, p.height), w(p.toDataURL(n == null ? void 0 : n.type, n == null ? void 0 : n.quality));
            }).catch(S);
          } else if (typeof d == "object") {
            const p = ((n == null ? void 0 : n.serializer) || D4(d))(d);
            return w(lf(new Blob([p], { type: "application/json" })));
          } else
            S(new Error("target is unsupported types"));
        } catch (d) {
          S(d);
        }
      }), u.value.then((w) => s.value = w), u.value;
  }
  return Cn.isRef(i) || typeof i == "function" ? Cn.watch(i, y, { immediate: !0 }) : y(), {
    base64: s,
    promise: u,
    execute: y
  };
}
function B4(i) {
  return new Promise((n, s) => {
    i.complete ? n() : (i.onload = () => {
      n();
    }, i.onerror = s);
  });
}
function lf(i) {
  return new Promise((n, s) => {
    const u = new FileReader();
    u.onload = (y) => {
      n(y.target.result);
    }, u.onerror = s, u.readAsDataURL(i);
  });
}
function P4(i = {}) {
  const {
    navigator: n = x4,
    read: s = !1,
    source: u,
    copiedDuring: y = 1500,
    legacy: w = !1
  } = i, S = ["copy", "cut"], d = O4(() => n && "clipboard" in n), l = Cn.computed(() => d.value || w), p = Cn.ref(""), v = Cn.ref(!1), c = w4(() => v.value = !1, y);
  function e() {
    d.value ? n.clipboard.readText().then((f) => {
      p.value = f;
    }) : p.value = b();
  }
  if (l.value && s)
    for (const f of S)
      _4(f, e);
  async function h(f = jl(u)) {
    l.value && f != null && (d.value ? await n.clipboard.writeText(f) : m(f), p.value = f, v.value = !0, c.start());
  }
  function m(f) {
    const k = document.createElement("textarea");
    k.value = f ?? "", k.style.position = "absolute", k.style.opacity = "0", document.body.appendChild(k), k.select(), document.execCommand("copy"), k.remove();
  }
  function b() {
    var f, k, E;
    return (E = (k = (f = document == null ? void 0 : document.getSelection) == null ? void 0 : f.call(document)) == null ? void 0 : k.toString()) != null ? E : "";
  }
  return {
    isSupported: l,
    text: p,
    copied: v,
    copy: h
  };
}
var V4 = Object.defineProperty, Mb = Object.getOwnPropertySymbols, $4 = Object.prototype.hasOwnProperty, I4 = Object.prototype.propertyIsEnumerable, Ab = (i, n, s) => n in i ? V4(i, n, { enumerable: !0, configurable: !0, writable: !0, value: s }) : i[n] = s, cf = (i, n) => {
  for (var s in n || (n = {}))
    $4.call(n, s) && Ab(i, s, n[s]);
  if (Mb)
    for (var s of Mb(n))
      I4.call(n, s) && Ab(i, s, n[s]);
  return i;
};
const M4 = {
  multiple: !0,
  accept: "*",
  reset: !1
};
function A4(i = {}) {
  const {
    document: n = E4
  } = i, s = Cn.ref(null), { on: u, trigger: y } = y4();
  let w;
  n && (w = n.createElement("input"), w.type = "file", w.onchange = (l) => {
    const p = l.target;
    s.value = p.files, y(s.value);
  });
  const S = () => {
    s.value = null, w && (w.value = "");
  }, d = (l) => {
    if (!w)
      return;
    const p = cf(cf(cf({}, M4), i), l);
    w.multiple = p.multiple, w.accept = p.accept, C4(p, "capture") && (w.capture = p.capture), p.reset && S(), w.click();
  };
  return {
    files: Cn.readonly(s),
    open: d,
    reset: S,
    onChange: u
  };
}
var Zf = { exports: {} };
(function(i, n) {
  var s = Object.defineProperty, u = Object.defineProperties, y = Object.getOwnPropertyDescriptors, w = Object.getOwnPropertySymbols, S = Object.prototype.hasOwnProperty, d = Object.prototype.propertyIsEnumerable, l = (c, e, h) => e in c ? s(c, e, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[e] = h, p = (c, e) => {
    for (var h in e || (e = {}))
      S.call(e, h) && l(c, h, e[h]);
    if (w)
      for (var h of w(e))
        d.call(e, h) && l(c, h, e[h]);
    return c;
  }, v = (c, e) => u(c, y(e));
  (function(c, e) {
    e(n, Bk());
  })(jd, function(c, e) {
    const h = typeof window < "u", m = function() {
      return h && document.addEventListener ? function(t, r, o, C = !1) {
        t && r && o && t.addEventListener(r, o, C);
      } : function(t, r, o) {
        t && r && o && t.attachEvent("on" + r, o);
      };
    }(), b = function() {
      return h && document.removeEventListener ? function(t, r, o, C = !1) {
        t && r && t.removeEventListener(r, o, C);
      } : function(t, r, o) {
        t && r && t.detachEvent("on" + r, o);
      };
    }();
    var f = (t, r) => {
      const o = t.__vccOpts || t;
      for (const [C, g] of r)
        o[C] = g;
      return o;
    };
    const k = "ivu-affix";
    function E(t, r) {
      const o = r ? "pageYOffset" : "pageXOffset", C = r ? "scrollTop" : "scrollLeft";
      let g = t[o];
      return h && typeof g != "number" && (g = window.document.documentElement[C]), g;
    }
    function _(t) {
      if (!h)
        return;
      const r = t.getBoundingClientRect(), o = E(window, !0), C = E(window), g = window.document.body, a = g.clientTop || 0, x = g.clientLeft || 0;
      return { top: r.top + o - a, left: r.left + C - x };
    }
    const T = { name: "Affix", emits: ["on-change"], props: { offsetTop: { type: Number, default: 0 }, offsetBottom: { type: Number }, useCapture: { type: Boolean, default: !1 } }, data() {
      return { affix: !1, styles: {}, slot: !1, slotStyle: {} };
    }, computed: { offsetType() {
      let t = "top";
      return this.offsetBottom >= 0 && (t = "bottom"), t;
    }, classes() {
      return [{ [`${k}`]: this.affix }];
    } }, mounted() {
      m(window, "scroll", this.handleScroll, this.useCapture), m(window, "resize", this.handleScroll, this.useCapture), e.nextTick(() => {
        this.handleScroll();
      });
    }, beforeUnmount() {
      b(window, "scroll", this.handleScroll, this.useCapture), b(window, "resize", this.handleScroll, this.useCapture);
    }, methods: { handleScroll() {
      if (!h)
        return;
      const t = this.affix, r = E(window, !0), o = _(this.$el), C = window.innerHeight, g = this.$el.getElementsByTagName("div")[0].offsetHeight;
      o.top - this.offsetTop < r && this.offsetType == "top" && !t ? (this.affix = !0, this.slotStyle = { width: this.$refs.point.clientWidth + "px", height: this.$refs.point.clientHeight + "px" }, this.slot = !0, this.styles = { top: `${this.offsetTop}px`, left: `${o.left}px`, width: `${this.$el.offsetWidth}px` }, this.$emit("on-change", !0)) : o.top - this.offsetTop > r && this.offsetType == "top" && t && (this.slot = !1, this.slotStyle = {}, this.affix = !1, this.styles = null, this.$emit("on-change", !1)), o.top + this.offsetBottom + g > r + C && this.offsetType == "bottom" && !t ? (this.affix = !0, this.styles = { bottom: `${this.offsetBottom}px`, left: `${o.left}px`, width: `${this.$el.offsetWidth}px` }, this.$emit("on-change", !0)) : o.top + this.offsetBottom + g < r + C && this.offsetType == "bottom" && t && (this.affix = !1, this.styles = null, this.$emit("on-change", !1));
    } } };
    function D(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", null, [e.createElementVNode("div", { ref: "point", class: e.normalizeClass(a.classes), style: e.normalizeStyle(g.styles) }, [e.renderSlot(t.$slots, "default")], 6), e.withDirectives(e.createElementVNode("div", { style: e.normalizeStyle(g.slotStyle) }, null, 4), [[e.vShow, g.slot]])]);
    }
    var V = f(T, [["render", D]]);
    const I = "ivu-icon", M = { name: "Icon", props: { type: { type: String, default: "" }, size: [Number, String], color: String, custom: { type: String, default: "" } }, computed: { classes() {
      return [`${I}`, { [`${I}-${this.type}`]: this.type !== "", [`${this.custom}`]: this.custom !== "" }];
    }, styles() {
      let t = {};
      return this.size && (t["font-size"] = `${this.size}px`), this.color && (t.color = this.color), t;
    } } };
    function Q(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("i", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, null, 6);
    }
    var G = f(M, [["render", Q]]);
    function z(t, r) {
      for (let o = 0; o < r.length; o++)
        if (t === r[o])
          return !0;
      return !1;
    }
    let re;
    function he(t) {
      if (h && (t || re === void 0)) {
        const r = document.createElement("div");
        r.style.width = "100%", r.style.height = "200px";
        const o = document.createElement("div"), C = o.style;
        C.position = "absolute", C.top = 0, C.left = 0, C.pointerEvents = "none", C.visibility = "hidden", C.width = "200px", C.height = "150px", C.overflow = "hidden", o.appendChild(r), document.body.appendChild(o);
        const g = r.offsetWidth;
        o.style.overflow = "scroll";
        let a = r.offsetWidth;
        g === a && (a = o.clientWidth), document.body.removeChild(o), re = g - a;
      }
      return re;
    }
    const de = h && (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver) || !1, Ce = /([\:\-\_]+(.))/g, xe = /^moz([A-Z])/;
    function Ie(t) {
      return t.replace(Ce, function(r, o, C, g) {
        return g ? C.toUpperCase() : C;
      }).replace(xe, "Moz$1");
    }
    function Be(t, r) {
      if (h) {
        if (!t || !r)
          return null;
        r = Ie(r), r === "float" && (r = "cssFloat");
        try {
          const o = document.defaultView.getComputedStyle(t, "");
          return t.style[r] || o ? o[r] : null;
        } catch {
          return t.style[r];
        }
      }
    }
    function L(t) {
      return t.toString()[0].toUpperCase() + t.toString().slice(1);
    }
    function Z(t) {
      return { "[object Boolean]": "boolean", "[object Number]": "number", "[object String]": "string", "[object Function]": "function", "[object Array]": "array", "[object Date]": "date", "[object RegExp]": "regExp", "[object Undefined]": "undefined", "[object Null]": "null", "[object Object]": "object" }[Object.prototype.toString.call(t)];
    }
    function W(t) {
      const r = Z(t);
      let o;
      if (r === "array")
        o = [];
      else if (r === "object")
        o = {};
      else
        return t;
      if (r === "array")
        for (let C = 0; C < t.length; C++)
          o.push(W(t[C]));
      else if (r === "object")
        for (let C in t)
          o[C] = W(t[C]);
      return o;
    }
    function Y(t, r = 0, o, C = 500, g) {
      if (!h)
        return;
      window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(P) {
        return window.setTimeout(P, 1e3 / 60);
      });
      const a = Math.abs(r - o), x = Math.ceil(a / C * 50);
      function O(P, N, B) {
        if (P === N) {
          g && g();
          return;
        }
        let H = P + B > N ? N : P + B;
        P > N && (H = P - B < N ? N : P - B), t === window ? window.scrollTo(H, H) : t.scrollTop = H, window.requestAnimationFrame(() => O(H, N, B));
      }
      O(r, o, x);
    }
    function me(t, r, o) {
      typeof r == "string" ? o = [r] : o = r;
      let C = t.$parent, g = C.$options.name;
      for (; C && (!g || o.indexOf(g) < 0); )
        C = C.$parent, C && (g = C.$options.name);
      return C;
    }
    function K(t, r) {
      let o = [];
      const C = t.$parent;
      return C ? (C.$options.name === r && o.push(C), o.concat(K(C, r))) : [];
    }
    const R = function(t) {
      return (t || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
    };
    function le(t, r) {
      if (!t || !r)
        return !1;
      if (r.indexOf(" ") !== -1)
        throw new Error("className should not contain space.");
      return t.classList ? t.classList.contains(r) : (" " + t.className + " ").indexOf(" " + r + " ") > -1;
    }
    function fe(t, r) {
      if (!t)
        return;
      let o = t.className;
      const C = (r || "").split(" ");
      for (let g = 0, a = C.length; g < a; g++) {
        const x = C[g];
        !x || (t.classList ? t.classList.add(x) : le(t, x) || (o += " " + x));
      }
      t.classList || (t.className = o);
    }
    function Se(t, r) {
      if (!t || !r)
        return;
      const o = r.split(" ");
      let C = " " + t.className + " ";
      for (let g = 0, a = o.length; g < a; g++) {
        const x = o[g];
        !x || (t.classList ? t.classList.remove(x) : le(t, x) && (C = C.replace(" " + x + " ", " ")));
      }
      t.classList || (t.className = R(C));
    }
    const we = { xs: "480px", sm: "576px", md: "768px", lg: "992px", xl: "1200px", xxl: "1600px" };
    function De() {
      if (!h)
        return;
      const t = (r) => ({ media: r, matches: !1, on() {
      }, off() {
      } });
      window.matchMedia = window.matchMedia || t;
    }
    const Le = /#([^#]+)$/;
    async function Ye(t, r = "unnamed") {
      if (!h)
        return Promise.reject();
      try {
        const o = await (await fetch(t)).blob();
        if (!o)
          return Promise.reject();
        const C = URL.createObjectURL(o), g = document.createElement("a");
        return g.setAttribute("href", C), g.setAttribute("download", r), g.click(), URL.revokeObjectURL(C), Promise.resolve();
      } catch (o) {
        return Promise.reject(o);
      }
    }
    const $ = "ivu-alert", A = { name: "Alert", components: { Icon: G }, props: { type: { validator(t) {
      return z(t, ["success", "info", "warning", "error"]);
    }, default: "info" }, closable: { type: Boolean, default: !1 }, showIcon: { type: Boolean, default: !1 }, banner: { type: Boolean, default: !1 }, fade: { type: Boolean, default: !0 } }, data() {
      return { closed: !1, desc: !1 };
    }, computed: { wrapClasses() {
      return [`${$}`, `${$}-${this.type}`, { [`${$}-with-icon`]: this.showIcon, [`${$}-with-desc`]: this.desc, [`${$}-with-banner`]: this.banner }];
    }, messageClasses() {
      return `${$}-message`;
    }, descClasses() {
      return `${$}-desc`;
    }, closeClasses() {
      return `${$}-close`;
    }, iconClasses() {
      return `${$}-icon`;
    }, iconType() {
      let t = "";
      switch (this.type) {
        case "success":
          t = "ios-checkmark-circle";
          break;
        case "info":
          t = "ios-information-circle";
          break;
        case "warning":
          t = "ios-alert";
          break;
        case "error":
          t = "ios-close-circle";
          break;
      }
      return this.desc && (t += "-outline"), t;
    } }, methods: { close(t) {
      this.closed = !0, this.$emit("on-close", t);
    } }, mounted() {
      this.desc = this.$slots.desc !== void 0;
    } };
    function X(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createBlock(e.Transition, { name: o.fade ? "fade" : "" }, { default: e.withCtx(() => [g.closed ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.wrapClasses) }, [o.showIcon ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.iconClasses) }, [e.renderSlot(t.$slots, "icon", {}, () => [e.createVNode(x, { type: a.iconType }, null, 8, ["type"])])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("span", { class: e.normalizeClass(a.messageClasses) }, [e.renderSlot(t.$slots, "default")], 2), e.createElementVNode("span", { class: e.normalizeClass(a.descClasses) }, [e.renderSlot(t.$slots, "desc")], 2), o.closable ? (e.openBlock(), e.createElementBlock("a", { key: 1, class: e.normalizeClass(a.closeClasses), onClick: r[0] || (r[0] = (...O) => a.close && a.close(...O)) }, [e.renderSlot(t.$slots, "close", {}, () => [e.createVNode(x, { type: "ios-close" })])], 2)) : e.createCommentVNode("", !0)], 2))]), _: 3 }, 8, ["name"]);
    }
    var te = f(A, [["render", X]]);
    const J = { name: "Anchor", provide() {
      return { AnchorInstance: this };
    }, emits: ["on-change", "on-select"], props: { affix: { type: Boolean, default: !0 }, offsetTop: { type: Number, default: 0 }, offsetBottom: Number, bounds: { type: Number, default: 5 }, container: null, showInk: { type: Boolean, default: !1 }, scrollOffset: { type: Number, default: 0 } }, data() {
      return { prefix: "ivu-anchor", isAffixed: !1, inkTop: 0, animating: !1, currentLink: "", currentId: "", scrollContainer: null, scrollElement: null, wrapperTop: 0, upperFirstTitle: !0, links: [] };
    }, computed: { wrapperComponent() {
      return this.affix ? "Affix" : "div";
    }, wrapperStyle() {
      return { maxHeight: this.offsetTop ? `calc(100vh - ${this.offsetTop}px)` : "100vh" };
    }, containerIsWindow() {
      return this.scrollContainer === window;
    }, titlesOffsetArr() {
      const t = this.links.map((o) => o.link.href).map((o) => o.split("#")[1]);
      let r = [];
      return h && t.forEach((o) => {
        const C = document.getElementById(o);
        C && r.push({ link: `#${o}`, offset: C.offsetTop - this.scrollElement.offsetTop });
      }), r;
    } }, methods: { handleAffixStateChange(t) {
      this.isAffixed = this.affix && t;
    }, handleScroll(t) {
      if (this.upperFirstTitle = !!this.titlesOffsetArr[0] && t.target.scrollTop < this.titlesOffsetArr[0].offset, this.animating)
        return;
      const r = h ? document.documentElement.scrollTop || document.body.scrollTop || t.target.scrollTop : 0;
      this.getCurrentScrollAtTitleId(r);
    }, handleHashChange() {
      if (!h)
        return;
      const t = window.location.href, r = Le.exec(t);
      !r || (this.currentLink = r[0], this.currentId = r[1]);
    }, handleScrollTo() {
      if (!h)
        return;
      const t = document.getElementById(this.currentId), r = document.querySelector(`a[data-href="${this.currentLink}"]`);
      let o = this.scrollOffset;
      if (r && (o = parseFloat(r.getAttribute("data-scroll-offset"))), !t)
        return;
      const C = t.offsetTop - this.wrapperTop - o;
      this.animating = !0, Y(this.scrollContainer, this.scrollElement.scrollTop, C, 600, () => {
        this.animating = !1;
      }), this.handleSetInkTop();
    }, handleSetInkTop() {
      if (!h)
        return;
      const t = document.querySelector(`a[data-href="${this.currentLink}"]`);
      if (!t)
        return;
      const r = t.offsetTop, o = r < 0 ? this.offsetTop : r;
      this.inkTop = o;
    }, getCurrentScrollAtTitleId(t) {
      let r = -1, o = this.titlesOffsetArr.length, C = { link: "#", offset: 0 };
      for (t += this.bounds; ++r < o; ) {
        let g = this.titlesOffsetArr[r], a = this.titlesOffsetArr[r + 1];
        if (t >= g.offset && t < (a && a.offset || 1 / 0)) {
          C = this.titlesOffsetArr[r];
          break;
        }
      }
      this.currentLink = C.link, this.handleSetInkTop();
    }, getContainer() {
      !h || (this.scrollContainer = this.container ? typeof this.container == "string" ? document.querySelector(this.container) : this.container : window, this.scrollElement = this.container ? this.scrollContainer : document.documentElement || document.body);
    }, removeListener() {
      b(this.scrollContainer, "scroll", this.handleScroll), b(window, "hashchange", this.handleHashChange);
    }, init() {
      this.handleHashChange(), e.nextTick(() => {
        this.removeListener(), this.getContainer(), this.wrapperTop = this.containerIsWindow ? 0 : this.scrollElement.offsetTop, this.handleScrollTo(), this.handleSetInkTop(), this.titlesOffsetArr[0] && (this.upperFirstTitle = this.scrollElement.scrollTop < this.titlesOffsetArr[0].offset), m(this.scrollContainer, "scroll", this.handleScroll), m(window, "hashchange", this.handleHashChange);
      });
    }, addLink(t, r) {
      this.links.push({ id: t, link: r });
    }, removeLink(t) {
      const r = this.links.findIndex((o) => o.id === t);
      this.links.splice(r, 1);
    } }, watch: { $route() {
      this.currentLink = "", this.currentId = "", this.handleHashChange(), e.nextTick(() => {
        this.handleScrollTo();
      });
    }, container() {
      this.init();
    }, currentLink(t, r) {
      this.$emit("on-change", t, r);
    } }, mounted() {
      this.init();
    }, beforeUnmount() {
      this.removeListener();
    } };
    function ae(t, r, o, C, g, a) {
      return e.openBlock(), e.createBlock(e.resolveDynamicComponent(a.wrapperComponent), { "offset-top": o.offsetTop, "offset-bottom": o.offsetBottom, onOnChange: a.handleAffixStateChange }, { default: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass(`${g.prefix}-wrapper`), style: e.normalizeStyle(a.wrapperStyle) }, [e.createElementVNode("div", { class: e.normalizeClass(`${g.prefix}`) }, [e.createElementVNode("div", { class: e.normalizeClass(`${g.prefix}-ink`) }, [e.withDirectives(e.createElementVNode("span", { class: e.normalizeClass(`${g.prefix}-ink-ball`), style: e.normalizeStyle({ top: `${g.inkTop}px` }) }, null, 6), [[e.vShow, o.showInk]])], 2), e.renderSlot(t.$slots, "default")], 2)], 6)]), _: 3 }, 40, ["offset-top", "offset-bottom", "onOnChange"]);
    }
    var ge = f(J, [["render", ae]]);
    function be(t = 32) {
      const r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890", o = r.length;
      let C = "";
      for (let g = 0; g < t; g++)
        C += r.charAt(Math.floor(Math.random() * o));
      return C;
    }
    const ke = { name: "AnchorLink", inject: ["AnchorInstance"], props: { href: String, title: String, scrollOffset: { type: Number, default() {
      return e.inject("AnchorInstance").scrollOffset;
    } } }, data() {
      return { prefix: "ivu-anchor-link", id: be(6) };
    }, computed: { anchorLinkClasses() {
      return [this.prefix, this.AnchorInstance.currentLink === this.href ? `${this.prefix}-active` : ""];
    }, linkTitleClasses() {
      return [`${this.prefix}-title`];
    } }, methods: { goAnchor() {
      this.currentLink = this.href, this.AnchorInstance.handleHashChange(), this.AnchorInstance.handleScrollTo(), this.AnchorInstance.$emit("on-select", this.href), this.$router ? this.$router.push(this.href, () => {
      }) : h && (window.location.href = this.href);
    } }, mounted() {
      this.AnchorInstance.addLink(this.id, this), e.nextTick(() => {
        this.AnchorInstance.init();
      });
    }, beforeUnmount() {
      this.AnchorInstance.removeLink(this.id);
    } }, ne = ["href", "data-scroll-offset", "data-href", "title"];
    function Ve(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.anchorLinkClasses) }, [e.createElementVNode("a", { class: e.normalizeClass(a.linkTitleClasses), href: o.href, "data-scroll-offset": o.scrollOffset, "data-href": o.href, onClick: r[0] || (r[0] = e.withModifiers((...x) => a.goAnchor && a.goAnchor(...x), ["prevent"])), title: o.title }, e.toDisplayString(o.title), 11, ne), e.renderSlot(t.$slots, "default")], 2);
    }
    var Ae = f(ke, [["render", Ve]]), je = { props: { to: { type: [Object, String] }, replace: { type: Boolean, default: !1 }, target: { type: String, validator(t) {
      return z(t, ["_blank", "_self", "_parent", "_top"]);
    }, default: "_self" }, append: { type: Boolean, required: !1, default: !1 } }, computed: { linkUrl() {
      if (typeof this.to != "string")
        return null;
      if (this.to.includes("//"))
        return this.to;
      const t = this.$router;
      if (t) {
        const r = this.$route, o = t.resolve(this.to, r, this.append);
        return o ? o.href : this.to;
      }
      return this.to;
    } }, methods: { handleOpenTo() {
      if (!h)
        return;
      const t = this.$router;
      let r = this.to;
      if (t) {
        const o = this.$route, C = t.resolve(this.to, o, this.append);
        r = C ? C.href : this.to;
      }
      typeof this.to != "string" && window.open(r);
    }, handleClick(t = !1) {
      const r = this.$router;
      !h || (t ? this.handleOpenTo() : r ? typeof this.to == "string" && this.to.includes("//") ? window.location.href = this.to : this.replace ? this.$router.replace(this.to, () => {
      }) : this.$router.push(this.to, () => {
      }) : window.location.href = this.to);
    }, handleCheckClick(t, r = !1) {
      if (this.to) {
        if (this.target === "_blank")
          return this.handleOpenTo(), !1;
        t.preventDefault(), this.handleClick(r);
      }
    } } };
    function rt(t, r) {
      let o = !1;
      return r.forEach((C) => {
        t.includes(C) && (o = !0);
      }), o;
    }
    const st = { name: "Auth", mixins: [je], emits: ["click"], props: { authority: { type: [String, Array, Function, Boolean], default: !0 }, access: { type: [String, Array] }, prevent: { type: Boolean, default: !1 }, message: { type: String, default: "您没有权限进行此操作" }, customTip: { type: Boolean, default: !1 }, display: { type: String } }, computed: { isPermission() {
      let t;
      if (typeof this.authority == "boolean")
        t = this.authority;
      else if (this.authority instanceof Function)
        t = this.authority();
      else {
        const r = typeof this.authority == "string" ? [this.authority] : this.authority, o = typeof this.access == "string" ? [this.access] : this.access;
        t = rt(r, o);
      }
      return t;
    }, options() {
      let t = {};
      return this.display && (t.display = this.display), { class: { "ivu-auth": !0, "ivu-auth-permission": this.isPermission, "ivu-auth-no-math": !this.isPermission, "ivu-auth-redirect": !this.isPermission && this.to, "ivu-auth-prevent": this.prevent }, style: t };
    } }, render() {
      return this.isPermission ? e.h("div", this.options, this.$slots.default()) : this.to ? e.h("div", this.options) : this.prevent ? e.h("div", Object.assign({}, this.options, { onClick: this.handlePreventClick }), [e.h("div", { class: "ivu-auth-prevent-no-match" }, this.$slots.default())]) : e.h("div", this.options, this.$slots.noMatch());
    }, methods: { handlePreventClick(t) {
      this.isPermission || (this.customTip || this.$Message.info({ content: this.message, duration: 3 }), this.$emit("click", t));
    } }, created() {
      !this.isPermission && this.to && this.handleClick(!1);
    } };
    var pt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof jd < "u" ? jd : typeof self < "u" ? self : {};
    function vt(t) {
      throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }
    var Lt = { exports: {} };
    /**!
    * @fileOverview Kickass library to create and place poppers near their reference elements.
    * @version 1.16.1
    * @license
    * Copyright (c) 2016 Federico Zivolo and contributors
    *
    * Permission is hereby granted, free of charge, to any person obtaining a copy
    * of this software and associated documentation files (the "Software"), to deal
    * in the Software without restriction, including without limitation the rights
    * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    * copies of the Software, and to permit persons to whom the Software is
    * furnished to do so, subject to the following conditions:
    *
    * The above copyright notice and this permission notice shall be included in all
    * copies or substantial portions of the Software.
    *
    * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    * SOFTWARE.
    */
    (function(t, r) {
      (function(o, C) {
        t.exports = C();
      })(pt, function() {
        var o = typeof window < "u" && typeof document < "u" && typeof navigator < "u", C = function() {
          for (var F = ["Edge", "Trident", "Firefox"], ie = 0; ie < F.length; ie += 1)
            if (o && navigator.userAgent.indexOf(F[ie]) >= 0)
              return 1;
          return 0;
        }();
        function g(F) {
          var ie = !1;
          return function() {
            ie || (ie = !0, window.Promise.resolve().then(function() {
              ie = !1, F();
            }));
          };
        }
        function a(F) {
          var ie = !1;
          return function() {
            ie || (ie = !0, setTimeout(function() {
              ie = !1, F();
            }, C));
          };
        }
        var x = o && window.Promise, O = x ? g : a;
        function P(F) {
          var ie = {};
          return F && ie.toString.call(F) === "[object Function]";
        }
        function N(F, ie) {
          if (F.nodeType !== 1)
            return [];
          var ce = F.ownerDocument.defaultView, ve = ce.getComputedStyle(F, null);
          return ie ? ve[ie] : ve;
        }
        function B(F) {
          return F.nodeName === "HTML" ? F : F.parentNode || F.host;
        }
        function H(F) {
          if (!F)
            return document.body;
          switch (F.nodeName) {
            case "HTML":
            case "BODY":
              return F.ownerDocument.body;
            case "#document":
              return F.body;
          }
          var ie = N(F), ce = ie.overflow, ve = ie.overflowX, Me = ie.overflowY;
          return /(auto|scroll|overlay)/.test(ce + Me + ve) ? F : H(B(F));
        }
        function oe(F) {
          return F && F.referenceNode ? F.referenceNode : F;
        }
        var se = o && !!(window.MSInputMethodContext && document.documentMode), ee = o && /MSIE 10/.test(navigator.userAgent);
        function j(F) {
          return F === 11 ? se : F === 10 ? ee : se || ee;
        }
        function pe(F) {
          if (!F)
            return document.documentElement;
          for (var ie = j(10) ? document.body : null, ce = F.offsetParent || null; ce === ie && F.nextElementSibling; )
            ce = (F = F.nextElementSibling).offsetParent;
          var ve = ce && ce.nodeName;
          return !ve || ve === "BODY" || ve === "HTML" ? F ? F.ownerDocument.documentElement : document.documentElement : ["TH", "TD", "TABLE"].indexOf(ce.nodeName) !== -1 && N(ce, "position") === "static" ? pe(ce) : ce;
        }
        function at(F) {
          var ie = F.nodeName;
          return ie === "BODY" ? !1 : ie === "HTML" || pe(F.firstElementChild) === F;
        }
        function Qe(F) {
          return F.parentNode !== null ? Qe(F.parentNode) : F;
        }
        function tt(F, ie) {
          if (!F || !F.nodeType || !ie || !ie.nodeType)
            return document.documentElement;
          var ce = F.compareDocumentPosition(ie) & Node.DOCUMENT_POSITION_FOLLOWING, ve = ce ? F : ie, Me = ce ? ie : F, $e = document.createRange();
          $e.setStart(ve, 0), $e.setEnd(Me, 0);
          var Re = $e.commonAncestorContainer;
          if (F !== Re && ie !== Re || ve.contains(Me))
            return at(Re) ? Re : pe(Re);
          var Ge = Qe(F);
          return Ge.host ? tt(Ge.host, ie) : tt(F, Qe(ie).host);
        }
        function Ee(F) {
          var ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top", ce = ie === "top" ? "scrollTop" : "scrollLeft", ve = F.nodeName;
          if (ve === "BODY" || ve === "HTML") {
            var Me = F.ownerDocument.documentElement, $e = F.ownerDocument.scrollingElement || Me;
            return $e[ce];
          }
          return F[ce];
        }
        function ye(F, ie) {
          var ce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, ve = Ee(ie, "top"), Me = Ee(ie, "left"), $e = ce ? -1 : 1;
          return F.top += ve * $e, F.bottom += ve * $e, F.left += Me * $e, F.right += Me * $e, F;
        }
        function ze(F, ie) {
          var ce = ie === "x" ? "Left" : "Top", ve = ce === "Left" ? "Right" : "Bottom";
          return parseFloat(F["border" + ce + "Width"]) + parseFloat(F["border" + ve + "Width"]);
        }
        function Oe(F, ie, ce, ve) {
          return Math.max(ie["offset" + F], ie["scroll" + F], ce["client" + F], ce["offset" + F], ce["scroll" + F], j(10) ? parseInt(ce["offset" + F]) + parseInt(ve["margin" + (F === "Height" ? "Top" : "Left")]) + parseInt(ve["margin" + (F === "Height" ? "Bottom" : "Right")]) : 0);
        }
        function lt(F) {
          var ie = F.body, ce = F.documentElement, ve = j(10) && getComputedStyle(ce);
          return { height: Oe("Height", ie, ce, ve), width: Oe("Width", ie, ce, ve) };
        }
        var it = function(F, ie) {
          if (!(F instanceof ie))
            throw new TypeError("Cannot call a class as a function");
        }, Ze = /* @__PURE__ */ function() {
          function F(ie, ce) {
            for (var ve = 0; ve < ce.length; ve++) {
              var Me = ce[ve];
              Me.enumerable = Me.enumerable || !1, Me.configurable = !0, "value" in Me && (Me.writable = !0), Object.defineProperty(ie, Me.key, Me);
            }
          }
          return function(ie, ce, ve) {
            return ce && F(ie.prototype, ce), ve && F(ie, ve), ie;
          };
        }(), kt = function(F, ie, ce) {
          return ie in F ? Object.defineProperty(F, ie, { value: ce, enumerable: !0, configurable: !0, writable: !0 }) : F[ie] = ce, F;
        }, ot = Object.assign || function(F) {
          for (var ie = 1; ie < arguments.length; ie++) {
            var ce = arguments[ie];
            for (var ve in ce)
              Object.prototype.hasOwnProperty.call(ce, ve) && (F[ve] = ce[ve]);
          }
          return F;
        };
        function Ue(F) {
          return ot({}, F, { right: F.left + F.width, bottom: F.top + F.height });
        }
        function Ke(F) {
          var ie = {};
          try {
            if (j(10)) {
              ie = F.getBoundingClientRect();
              var ce = Ee(F, "top"), ve = Ee(F, "left");
              ie.top += ce, ie.left += ve, ie.bottom += ce, ie.right += ve;
            } else
              ie = F.getBoundingClientRect();
          } catch {
          }
          var Me = { left: ie.left, top: ie.top, width: ie.right - ie.left, height: ie.bottom - ie.top }, $e = F.nodeName === "HTML" ? lt(F.ownerDocument) : {}, Re = $e.width || F.clientWidth || Me.width, Ge = $e.height || F.clientHeight || Me.height, nt = F.offsetWidth - Re, dt = F.offsetHeight - Ge;
          if (nt || dt) {
            var bt = N(F);
            nt -= ze(bt, "x"), dt -= ze(bt, "y"), Me.width -= nt, Me.height -= dt;
          }
          return Ue(Me);
        }
        function qe(F, ie) {
          var ce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, ve = j(10), Me = ie.nodeName === "HTML", $e = Ke(F), Re = Ke(ie), Ge = H(F), nt = N(ie), dt = parseFloat(nt.borderTopWidth), bt = parseFloat(nt.borderLeftWidth);
          ce && Me && (Re.top = Math.max(Re.top, 0), Re.left = Math.max(Re.left, 0));
          var ct = Ue({ top: $e.top - Re.top - dt, left: $e.left - Re.left - bt, width: $e.width, height: $e.height });
          if (ct.marginTop = 0, ct.marginLeft = 0, !ve && Me) {
            var Ct = parseFloat(nt.marginTop), Vt = parseFloat(nt.marginLeft);
            ct.top -= dt - Ct, ct.bottom -= dt - Ct, ct.left -= bt - Vt, ct.right -= bt - Vt, ct.marginTop = Ct, ct.marginLeft = Vt;
          }
          return (ve && !ce ? ie.contains(Ge) : ie === Ge && Ge.nodeName !== "BODY") && (ct = ye(ct, ie)), ct;
        }
        function mt(F) {
          var ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, ce = F.ownerDocument.documentElement, ve = qe(F, ce), Me = Math.max(ce.clientWidth, window.innerWidth || 0), $e = Math.max(ce.clientHeight, window.innerHeight || 0), Re = ie ? 0 : Ee(ce), Ge = ie ? 0 : Ee(ce, "left"), nt = { top: Re - ve.top + ve.marginTop, left: Ge - ve.left + ve.marginLeft, width: Me, height: $e };
          return Ue(nt);
        }
        function et(F) {
          var ie = F.nodeName;
          if (ie === "BODY" || ie === "HTML")
            return !1;
          if (N(F, "position") === "fixed")
            return !0;
          var ce = B(F);
          return ce ? et(ce) : !1;
        }
        function St(F) {
          if (!F || !F.parentElement || j())
            return document.documentElement;
          for (var ie = F.parentElement; ie && N(ie, "transform") === "none"; )
            ie = ie.parentElement;
          return ie || document.documentElement;
        }
        function yt(F, ie, ce, ve) {
          var Me = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, $e = { top: 0, left: 0 }, Re = Me ? St(F) : tt(F, oe(ie));
          if (ve === "viewport")
            $e = mt(Re, Me);
          else {
            var Ge = void 0;
            ve === "scrollParent" ? (Ge = H(B(ie)), Ge.nodeName === "BODY" && (Ge = F.ownerDocument.documentElement)) : ve === "window" ? Ge = F.ownerDocument.documentElement : Ge = ve;
            var nt = qe(Ge, Re, Me);
            if (Ge.nodeName === "HTML" && !et(Re)) {
              var dt = lt(F.ownerDocument), bt = dt.height, ct = dt.width;
              $e.top += nt.top - nt.marginTop, $e.bottom = bt + nt.top, $e.left += nt.left - nt.marginLeft, $e.right = ct + nt.left;
            } else
              $e = nt;
          }
          ce = ce || 0;
          var Ct = typeof ce == "number";
          return $e.left += Ct ? ce : ce.left || 0, $e.top += Ct ? ce : ce.top || 0, $e.right -= Ct ? ce : ce.right || 0, $e.bottom -= Ct ? ce : ce.bottom || 0, $e;
        }
        function ht(F) {
          var ie = F.width, ce = F.height;
          return ie * ce;
        }
        function Rt(F, ie, ce, ve, Me) {
          var $e = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
          if (F.indexOf("auto") === -1)
            return F;
          var Re = yt(ce, ve, $e, Me), Ge = { top: { width: Re.width, height: ie.top - Re.top }, right: { width: Re.right - ie.right, height: Re.height }, bottom: { width: Re.width, height: Re.bottom - ie.bottom }, left: { width: ie.left - Re.left, height: Re.height } }, nt = Object.keys(Ge).map(function(Ct) {
            return ot({ key: Ct }, Ge[Ct], { area: ht(Ge[Ct]) });
          }).sort(function(Ct, Vt) {
            return Vt.area - Ct.area;
          }), dt = nt.filter(function(Ct) {
            var Vt = Ct.width, $t = Ct.height;
            return Vt >= ce.clientWidth && $t >= ce.clientHeight;
          }), bt = dt.length > 0 ? dt[0].key : nt[0].key, ct = F.split("-")[1];
          return bt + (ct ? "-" + ct : "");
        }
        function Tt(F, ie, ce) {
          var ve = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, Me = ve ? St(ie) : tt(ie, oe(ce));
          return qe(ce, Me, ve);
        }
        function qt(F) {
          var ie = F.ownerDocument.defaultView, ce = ie.getComputedStyle(F), ve = parseFloat(ce.marginTop || 0) + parseFloat(ce.marginBottom || 0), Me = parseFloat(ce.marginLeft || 0) + parseFloat(ce.marginRight || 0), $e = { width: F.offsetWidth + Me, height: F.offsetHeight + ve };
          return $e;
        }
        function Tn(F) {
          var ie = { left: "right", right: "left", bottom: "top", top: "bottom" };
          return F.replace(/left|right|bottom|top/g, function(ce) {
            return ie[ce];
          });
        }
        function Wt(F, ie, ce) {
          ce = ce.split("-")[0];
          var ve = qt(F), Me = { width: ve.width, height: ve.height }, $e = ["right", "left"].indexOf(ce) !== -1, Re = $e ? "top" : "left", Ge = $e ? "left" : "top", nt = $e ? "height" : "width", dt = $e ? "width" : "height";
          return Me[Re] = ie[Re] + ie[nt] / 2 - ve[nt] / 2, ce === Ge ? Me[Ge] = ie[Ge] - ve[dt] : Me[Ge] = ie[Tn(Ge)], Me;
        }
        function gn(F, ie) {
          return Array.prototype.find ? F.find(ie) : F.filter(ie)[0];
        }
        function mi(F, ie, ce) {
          if (Array.prototype.findIndex)
            return F.findIndex(function(Me) {
              return Me[ie] === ce;
            });
          var ve = gn(F, function(Me) {
            return Me[ie] === ce;
          });
          return F.indexOf(ve);
        }
        function Hn(F, ie, ce) {
          var ve = ce === void 0 ? F : F.slice(0, mi(F, "name", ce));
          return ve.forEach(function(Me) {
            Me.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
            var $e = Me.function || Me.fn;
            Me.enabled && P($e) && (ie.offsets.popper = Ue(ie.offsets.popper), ie.offsets.reference = Ue(ie.offsets.reference), ie = $e(ie, Me));
          }), ie;
        }
        function We() {
          if (!this.state.isDestroyed) {
            var F = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {} };
            F.offsets.reference = Tt(this.state, this.popper, this.reference, this.options.positionFixed), F.placement = Rt(this.options.placement, F.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), F.originalPlacement = F.placement, F.positionFixed = this.options.positionFixed, F.offsets.popper = Wt(this.popper, F.offsets.reference, F.placement), F.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", F = Hn(this.modifiers, F), this.state.isCreated ? this.options.onUpdate(F) : (this.state.isCreated = !0, this.options.onCreate(F));
          }
        }
        function gt(F, ie) {
          return F.some(function(ce) {
            var ve = ce.name, Me = ce.enabled;
            return Me && ve === ie;
          });
        }
        function It(F) {
          for (var ie = [!1, "ms", "Webkit", "Moz", "O"], ce = F.charAt(0).toUpperCase() + F.slice(1), ve = 0; ve < ie.length; ve++) {
            var Me = ie[ve], $e = Me ? "" + Me + ce : F;
            if (typeof document.body.style[$e] < "u")
              return $e;
          }
          return null;
        }
        function vn() {
          return this.state.isDestroyed = !0, gt(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[It("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
        }
        function U(F) {
          var ie = F.ownerDocument;
          return ie ? ie.defaultView : window;
        }
        function ue(F, ie, ce, ve) {
          var Me = F.nodeName === "BODY", $e = Me ? F.ownerDocument.defaultView : F;
          $e.addEventListener(ie, ce, { passive: !0 }), Me || ue(H($e.parentNode), ie, ce, ve), ve.push($e);
        }
        function q(F, ie, ce, ve) {
          ce.updateBound = ve, U(F).addEventListener("resize", ce.updateBound, { passive: !0 });
          var Me = H(F);
          return ue(Me, "scroll", ce.updateBound, ce.scrollParents), ce.scrollElement = Me, ce.eventsEnabled = !0, ce;
        }
        function Fe() {
          this.state.eventsEnabled || (this.state = q(this.reference, this.options, this.state, this.scheduleUpdate));
        }
        function He(F, ie) {
          return U(F).removeEventListener("resize", ie.updateBound), ie.scrollParents.forEach(function(ce) {
            ce.removeEventListener("scroll", ie.updateBound);
          }), ie.updateBound = null, ie.scrollParents = [], ie.scrollElement = null, ie.eventsEnabled = !1, ie;
        }
        function Xe() {
          this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = He(this.reference, this.state));
        }
        function xt(F) {
          return F !== "" && !isNaN(parseFloat(F)) && isFinite(F);
        }
        function Bt(F, ie) {
          Object.keys(ie).forEach(function(ce) {
            var ve = "";
            ["width", "height", "top", "right", "bottom", "left"].indexOf(ce) !== -1 && xt(ie[ce]) && (ve = "px"), F.style[ce] = ie[ce] + ve;
          });
        }
        function Mt(F, ie) {
          Object.keys(ie).forEach(function(ce) {
            var ve = ie[ce];
            ve !== !1 ? F.setAttribute(ce, ie[ce]) : F.removeAttribute(ce);
          });
        }
        function yn(F) {
          return Bt(F.instance.popper, F.styles), Mt(F.instance.popper, F.attributes), F.arrowElement && Object.keys(F.arrowStyles).length && Bt(F.arrowElement, F.arrowStyles), F;
        }
        function zi(F, ie, ce, ve, Me) {
          var $e = Tt(Me, ie, F, ce.positionFixed), Re = Rt(ce.placement, $e, ie, F, ce.modifiers.flip.boundariesElement, ce.modifiers.flip.padding);
          return ie.setAttribute("x-placement", Re), Bt(ie, { position: ce.positionFixed ? "fixed" : "absolute" }), ce;
        }
        function xn(F, ie) {
          var ce = F.offsets, ve = ce.popper, Me = ce.reference, $e = Math.round, Re = Math.floor, Ge = function(Ri) {
            return Ri;
          }, nt = $e(Me.width), dt = $e(ve.width), bt = ["left", "right"].indexOf(F.placement) !== -1, ct = F.placement.indexOf("-") !== -1, Ct = nt % 2 === dt % 2, Vt = nt % 2 === 1 && dt % 2 === 1, $t = ie ? bt || ct || Ct ? $e : Re : Ge, bn = ie ? $e : Ge;
          return { left: $t(Vt && !ct && ie ? ve.left - 1 : ve.left), top: bn(ve.top), bottom: bn(ve.bottom), right: $t(ve.right) };
        }
        var Ic = o && /Firefox/i.test(navigator.userAgent);
        function Mc(F, ie) {
          var ce = ie.x, ve = ie.y, Me = F.offsets.popper, $e = gn(F.instance.modifiers, function(xs) {
            return xs.name === "applyStyle";
          }).gpuAcceleration;
          $e !== void 0 && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
          var Re = $e !== void 0 ? $e : ie.gpuAcceleration, Ge = pe(F.instance.popper), nt = Ke(Ge), dt = { position: Me.position }, bt = xn(F, window.devicePixelRatio < 2 || !Ic), ct = ce === "bottom" ? "top" : "bottom", Ct = ve === "right" ? "left" : "right", Vt = It("transform"), $t = void 0, bn = void 0;
          if (ct === "bottom" ? Ge.nodeName === "HTML" ? bn = -Ge.clientHeight + bt.bottom : bn = -nt.height + bt.bottom : bn = bt.top, Ct === "right" ? Ge.nodeName === "HTML" ? $t = -Ge.clientWidth + bt.right : $t = -nt.width + bt.right : $t = bt.left, Re && Vt)
            dt[Vt] = "translate3d(" + $t + "px, " + bn + "px, 0)", dt[ct] = 0, dt[Ct] = 0, dt.willChange = "transform";
          else {
            var Ri = ct === "bottom" ? -1 : 1, yo = Ct === "right" ? -1 : 1;
            dt[ct] = bn * Ri, dt[Ct] = $t * yo, dt.willChange = ct + ", " + Ct;
          }
          var gi = { "x-placement": F.placement };
          return F.attributes = ot({}, gi, F.attributes), F.styles = ot({}, dt, F.styles), F.arrowStyles = ot({}, F.offsets.arrow, F.arrowStyles), F;
        }
        function Da(F, ie, ce) {
          var ve = gn(F, function(Ge) {
            var nt = Ge.name;
            return nt === ie;
          }), Me = !!ve && F.some(function(Ge) {
            return Ge.name === ce && Ge.enabled && Ge.order < ve.order;
          });
          if (!Me) {
            var $e = "`" + ie + "`", Re = "`" + ce + "`";
            console.warn(Re + " modifier is required by " + $e + " modifier in order to work, be sure to include it before " + $e + "!");
          }
          return Me;
        }
        function hn(F, ie) {
          var ce;
          if (!Da(F.instance.modifiers, "arrow", "keepTogether"))
            return F;
          var ve = ie.element;
          if (typeof ve == "string") {
            if (ve = F.instance.popper.querySelector(ve), !ve)
              return F;
          } else if (!F.instance.popper.contains(ve))
            return console.warn("WARNING: `arrow.element` must be child of its popper element!"), F;
          var Me = F.placement.split("-")[0], $e = F.offsets, Re = $e.popper, Ge = $e.reference, nt = ["left", "right"].indexOf(Me) !== -1, dt = nt ? "height" : "width", bt = nt ? "Top" : "Left", ct = bt.toLowerCase(), Ct = nt ? "left" : "top", Vt = nt ? "bottom" : "right", $t = qt(ve)[dt];
          Ge[Vt] - $t < Re[ct] && (F.offsets.popper[ct] -= Re[ct] - (Ge[Vt] - $t)), Ge[ct] + $t > Re[Vt] && (F.offsets.popper[ct] += Ge[ct] + $t - Re[Vt]), F.offsets.popper = Ue(F.offsets.popper);
          var bn = Ge[ct] + Ge[dt] / 2 - $t / 2, Ri = N(F.instance.popper), yo = parseFloat(Ri["margin" + bt]), gi = parseFloat(Ri["border" + bt + "Width"]), xs = bn - F.offsets.popper[ct] - yo - gi;
          return xs = Math.max(Math.min(Re[dt] - $t, xs), 0), F.arrowElement = ve, F.offsets.arrow = (ce = {}, kt(ce, ct, Math.round(xs)), kt(ce, Ct, ""), ce), F;
        }
        function xi(F) {
          return F === "end" ? "start" : F === "start" ? "end" : F;
        }
        var ar = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"], _i = ar.slice(3);
        function Ac(F) {
          var ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, ce = _i.indexOf(F), ve = _i.slice(ce + 1).concat(_i.slice(0, ce));
          return ie ? ve.reverse() : ve;
        }
        var Fr = { FLIP: "flip", CLOCKWISE: "clockwise", COUNTERCLOCKWISE: "counterclockwise" };
        function zd(F, ie) {
          if (gt(F.instance.modifiers, "inner") || F.flipped && F.placement === F.originalPlacement)
            return F;
          var ce = yt(F.instance.popper, F.instance.reference, ie.padding, ie.boundariesElement, F.positionFixed), ve = F.placement.split("-")[0], Me = Tn(ve), $e = F.placement.split("-")[1] || "", Re = [];
          switch (ie.behavior) {
            case Fr.FLIP:
              Re = [ve, Me];
              break;
            case Fr.CLOCKWISE:
              Re = Ac(ve);
              break;
            case Fr.COUNTERCLOCKWISE:
              Re = Ac(ve, !0);
              break;
            default:
              Re = ie.behavior;
          }
          return Re.forEach(function(Ge, nt) {
            if (ve !== Ge || Re.length === nt + 1)
              return F;
            ve = F.placement.split("-")[0], Me = Tn(ve);
            var dt = F.offsets.popper, bt = F.offsets.reference, ct = Math.floor, Ct = ve === "left" && ct(dt.right) > ct(bt.left) || ve === "right" && ct(dt.left) < ct(bt.right) || ve === "top" && ct(dt.bottom) > ct(bt.top) || ve === "bottom" && ct(dt.top) < ct(bt.bottom), Vt = ct(dt.left) < ct(ce.left), $t = ct(dt.right) > ct(ce.right), bn = ct(dt.top) < ct(ce.top), Ri = ct(dt.bottom) > ct(ce.bottom), yo = ve === "left" && Vt || ve === "right" && $t || ve === "top" && bn || ve === "bottom" && Ri, gi = ["top", "bottom"].indexOf(ve) !== -1, xs = !!ie.flipVariations && (gi && $e === "start" && Vt || gi && $e === "end" && $t || !gi && $e === "start" && bn || !gi && $e === "end" && Ri), YI = !!ie.flipVariationsByContent && (gi && $e === "start" && $t || gi && $e === "end" && Vt || !gi && $e === "start" && Ri || !gi && $e === "end" && bn), wy = xs || YI;
            (Ct || yo || wy) && (F.flipped = !0, (Ct || yo) && (ve = Re[nt + 1]), wy && ($e = xi($e)), F.placement = ve + ($e ? "-" + $e : ""), F.offsets.popper = ot({}, F.offsets.popper, Wt(F.instance.popper, F.offsets.reference, F.placement)), F = Hn(F.instance.modifiers, F, "flip"));
          }), F;
        }
        function Na(F) {
          var ie = F.offsets, ce = ie.popper, ve = ie.reference, Me = F.placement.split("-")[0], $e = Math.floor, Re = ["top", "bottom"].indexOf(Me) !== -1, Ge = Re ? "right" : "bottom", nt = Re ? "left" : "top", dt = Re ? "width" : "height";
          return ce[Ge] < $e(ve[nt]) && (F.offsets.popper[nt] = $e(ve[nt]) - ce[dt]), ce[nt] > $e(ve[Ge]) && (F.offsets.popper[nt] = $e(ve[Ge])), F;
        }
        function Rd(F, ie, ce, ve) {
          var Me = F.match(/((?:\-|\+)?\d*\.?\d*)(.*)/), $e = +Me[1], Re = Me[2];
          if (!$e)
            return F;
          if (Re.indexOf("%") === 0) {
            var Ge = void 0;
            switch (Re) {
              case "%p":
                Ge = ce;
                break;
              case "%":
              case "%r":
              default:
                Ge = ve;
            }
            var nt = Ue(Ge);
            return nt[ie] / 100 * $e;
          } else if (Re === "vh" || Re === "vw") {
            var dt = void 0;
            return Re === "vh" ? dt = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : dt = Math.max(document.documentElement.clientWidth, window.innerWidth || 0), dt / 100 * $e;
          } else
            return $e;
        }
        function FI(F, ie, ce, ve) {
          var Me = [0, 0], $e = ["right", "left"].indexOf(ve) !== -1, Re = F.split(/(\+|\-)/).map(function(bt) {
            return bt.trim();
          }), Ge = Re.indexOf(gn(Re, function(bt) {
            return bt.search(/,|\s/) !== -1;
          }));
          Re[Ge] && Re[Ge].indexOf(",") === -1 && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
          var nt = /\s*,\s*|\s+/, dt = Ge !== -1 ? [Re.slice(0, Ge).concat([Re[Ge].split(nt)[0]]), [Re[Ge].split(nt)[1]].concat(Re.slice(Ge + 1))] : [Re];
          return dt = dt.map(function(bt, ct) {
            var Ct = (ct === 1 ? !$e : $e) ? "height" : "width", Vt = !1;
            return bt.reduce(function($t, bn) {
              return $t[$t.length - 1] === "" && ["+", "-"].indexOf(bn) !== -1 ? ($t[$t.length - 1] = bn, Vt = !0, $t) : Vt ? ($t[$t.length - 1] += bn, Vt = !1, $t) : $t.concat(bn);
            }, []).map(function($t) {
              return Rd($t, Ct, ie, ce);
            });
          }), dt.forEach(function(bt, ct) {
            bt.forEach(function(Ct, Vt) {
              xt(Ct) && (Me[ct] += Ct * (bt[Vt - 1] === "-" ? -1 : 1));
            });
          }), Me;
        }
        function LI(F, ie) {
          var ce = ie.offset, ve = F.placement, Me = F.offsets, $e = Me.popper, Re = Me.reference, Ge = ve.split("-")[0], nt = void 0;
          return xt(+ce) ? nt = [+ce, 0] : nt = FI(ce, $e, Re, Ge), Ge === "left" ? ($e.top += nt[0], $e.left -= nt[1]) : Ge === "right" ? ($e.top += nt[0], $e.left += nt[1]) : Ge === "top" ? ($e.left += nt[0], $e.top -= nt[1]) : Ge === "bottom" && ($e.left += nt[0], $e.top += nt[1]), F.popper = $e, F;
        }
        function zI(F, ie) {
          var ce = ie.boundariesElement || pe(F.instance.popper);
          F.instance.reference === ce && (ce = pe(ce));
          var ve = It("transform"), Me = F.instance.popper.style, $e = Me.top, Re = Me.left, Ge = Me[ve];
          Me.top = "", Me.left = "", Me[ve] = "";
          var nt = yt(F.instance.popper, F.instance.reference, ie.padding, ce, F.positionFixed);
          Me.top = $e, Me.left = Re, Me[ve] = Ge, ie.boundaries = nt;
          var dt = ie.priority, bt = F.offsets.popper, ct = { primary: function(Ct) {
            var Vt = bt[Ct];
            return bt[Ct] < nt[Ct] && !ie.escapeWithReference && (Vt = Math.max(bt[Ct], nt[Ct])), kt({}, Ct, Vt);
          }, secondary: function(Ct) {
            var Vt = Ct === "right" ? "left" : "top", $t = bt[Vt];
            return bt[Ct] > nt[Ct] && !ie.escapeWithReference && ($t = Math.min(bt[Vt], nt[Ct] - (Ct === "right" ? bt.width : bt.height))), kt({}, Vt, $t);
          } };
          return dt.forEach(function(Ct) {
            var Vt = ["left", "top"].indexOf(Ct) !== -1 ? "primary" : "secondary";
            bt = ot({}, bt, ct[Vt](Ct));
          }), F.offsets.popper = bt, F;
        }
        function RI(F) {
          var ie = F.placement, ce = ie.split("-")[0], ve = ie.split("-")[1];
          if (ve) {
            var Me = F.offsets, $e = Me.reference, Re = Me.popper, Ge = ["bottom", "top"].indexOf(ce) !== -1, nt = Ge ? "left" : "top", dt = Ge ? "width" : "height", bt = { start: kt({}, nt, $e[nt]), end: kt({}, nt, $e[nt] + $e[dt] - Re[dt]) };
            F.offsets.popper = ot({}, Re, bt[ve]);
          }
          return F;
        }
        function jI(F) {
          if (!Da(F.instance.modifiers, "hide", "preventOverflow"))
            return F;
          var ie = F.offsets.reference, ce = gn(F.instance.modifiers, function(ve) {
            return ve.name === "preventOverflow";
          }).boundaries;
          if (ie.bottom < ce.top || ie.left > ce.right || ie.top > ce.bottom || ie.right < ce.left) {
            if (F.hide === !0)
              return F;
            F.hide = !0, F.attributes["x-out-of-boundaries"] = "";
          } else {
            if (F.hide === !1)
              return F;
            F.hide = !1, F.attributes["x-out-of-boundaries"] = !1;
          }
          return F;
        }
        function HI(F) {
          var ie = F.placement, ce = ie.split("-")[0], ve = F.offsets, Me = ve.popper, $e = ve.reference, Re = ["left", "right"].indexOf(ce) !== -1, Ge = ["top", "left"].indexOf(ce) === -1;
          return Me[Re ? "left" : "top"] = $e[ce] - (Ge ? Me[Re ? "width" : "height"] : 0), F.placement = Tn(ie), F.offsets.popper = Ue(Me), F;
        }
        var UI = { shift: { order: 100, enabled: !0, fn: RI }, offset: { order: 200, enabled: !0, fn: LI, offset: 0 }, preventOverflow: { order: 300, enabled: !0, fn: zI, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent" }, keepTogether: { order: 400, enabled: !0, fn: Na }, arrow: { order: 500, enabled: !0, fn: hn, element: "[x-arrow]" }, flip: { order: 600, enabled: !0, fn: zd, behavior: "flip", padding: 5, boundariesElement: "viewport", flipVariations: !1, flipVariationsByContent: !1 }, inner: { order: 700, enabled: !1, fn: HI }, hide: { order: 800, enabled: !0, fn: jI }, computeStyle: { order: 850, enabled: !0, fn: Mc, gpuAcceleration: !0, x: "bottom", y: "right" }, applyStyle: { order: 900, enabled: !0, fn: yn, onLoad: zi, gpuAcceleration: void 0 } }, WI = { placement: "bottom", positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate: function() {
        }, onUpdate: function() {
        }, modifiers: UI }, Fc = function() {
          function F(ie, ce) {
            var ve = this, Me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            it(this, F), this.scheduleUpdate = function() {
              return requestAnimationFrame(ve.update);
            }, this.update = O(this.update.bind(this)), this.options = ot({}, F.Defaults, Me), this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }, this.reference = ie && ie.jquery ? ie[0] : ie, this.popper = ce && ce.jquery ? ce[0] : ce, this.options.modifiers = {}, Object.keys(ot({}, F.Defaults.modifiers, Me.modifiers)).forEach(function(Re) {
              ve.options.modifiers[Re] = ot({}, F.Defaults.modifiers[Re] || {}, Me.modifiers ? Me.modifiers[Re] : {});
            }), this.modifiers = Object.keys(this.options.modifiers).map(function(Re) {
              return ot({ name: Re }, ve.options.modifiers[Re]);
            }).sort(function(Re, Ge) {
              return Re.order - Ge.order;
            }), this.modifiers.forEach(function(Re) {
              Re.enabled && P(Re.onLoad) && Re.onLoad(ve.reference, ve.popper, ve.options, Re, ve.state);
            }), this.update();
            var $e = this.options.eventsEnabled;
            $e && this.enableEventListeners(), this.state.eventsEnabled = $e;
          }
          return Ze(F, [{ key: "update", value: function() {
            return We.call(this);
          } }, { key: "destroy", value: function() {
            return vn.call(this);
          } }, { key: "enableEventListeners", value: function() {
            return Fe.call(this);
          } }, { key: "disableEventListeners", value: function() {
            return Xe.call(this);
          } }]), F;
        }();
        return Fc.Utils = (typeof window < "u" ? window : pt).PopperUtils, Fc.placements = ar, Fc.Defaults = WI, Fc;
      });
    })(Lt);
    var cn = Lt.exports;
    let Ut = 0, Zi = 0;
    function Vn() {
      Ut++;
    }
    function Qs() {
      Zi++;
    }
    const pn = { name: "Drop", emits: ["mouseenter", "mouseleave", "click"], props: { placement: { type: String, default: "bottom-start" }, className: { type: String }, transfer: { type: Boolean }, eventsEnabled: { type: Boolean, default: !1 }, visible: { type: Boolean }, classes: { type: Object, default: () => {
    } }, styles: { type: Object, default: () => {
    } }, transitionName: { type: String, default: "transition-drop" }, boundariesElement: { default: "window" } }, data() {
      return { popper: null, width: "", popperStatus: !1, tIndex: this.handleGetIndex() };
    }, computed: { mergedStyle() {
      let t = {};
      return this.width && (t.minWidth = `${this.width}px`), this.transfer && (t["z-index"] = 1060 + this.tIndex), Object.assign({}, this.styles, t);
    }, mergedClass() {
      return Object.assign({}, this.classes, { [this.className]: this.className });
    } }, methods: { update() {
      e.nextTick(() => {
        this.popper ? (this.popper.update(), this.popperStatus = !0) : this.popper = new cn(this.$parent.$refs.reference, this.$refs.drop, { eventsEnabled: this.eventsEnabled, placement: this.placement, modifiers: { computeStyle: { gpuAcceleration: !1 }, preventOverflow: { boundariesElement: this.boundariesElement } }, onCreate: () => {
          this.resetTransformOrigin(), e.nextTick(this.popper.update());
        }, onUpdate: () => {
          this.resetTransformOrigin();
        } }), this.$parent.$options.name === "iSelect" && (this.width = parseInt(Be(this.$parent.$el, "width"))), this.tIndex = this.handleGetIndex();
      });
    }, destroy() {
      this.popper && setTimeout(() => {
        this.popper && !this.popperStatus && (this.popper.popper.style.display = "none", this.popper.destroy(), this.popper = null), this.popperStatus = !1;
      }, 300);
    }, resetTransformOrigin() {
      if (!this.popper)
        return;
      let t = this.popper.popper.getAttribute("x-placement"), r = t.split("-")[0], o = t.split("-")[1];
      t === "left" || t === "right" || (this.popper.popper.style.transformOrigin = r === "bottom" || r !== "top" && o === "start" ? "center top" : "center bottom");
    }, handleGetIndex() {
      return Vn(), Ut;
    }, handleMouseenter(t) {
      this.$emit("mouseenter", t);
    }, handleMouseleave(t) {
      this.$emit("mouseleave", t);
    }, handleOnUpdatePopper() {
      this.update();
    }, handleOnDestroyPopper() {
      this.destroy();
    }, handleClick(t) {
      this.$emit("click", t);
    } }, beforeUnmount() {
      this.popper && (this.popper.destroy(), this.popper = null);
    } };
    function hi(t, r, o, C, g, a) {
      return e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createVNode(e.Transition, { name: o.transitionName }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", e.mergeProps({ class: ["ivu-select-dropdown", a.mergedClass], ref: "drop", style: a.mergedStyle }, t.$attrs, { onMouseenter: r[0] || (r[0] = (...x) => a.handleMouseenter && a.handleMouseenter(...x)), onMouseleave: r[1] || (r[1] = (...x) => a.handleMouseleave && a.handleMouseleave(...x)), onClick: r[2] || (r[2] = e.withModifiers((...x) => a.handleClick && a.handleClick(...x), ["stop"])) }), [e.renderSlot(t.$slots, "default")], 16), [[e.vShow, o.visible]])]), _: 3 }, 8, ["name"])], 8, ["disabled"]);
    }
    var er = f(pn, [["render", hi]]);
    function pS(t) {
      h && typeof window.viewuiplus < "u" && ("langs" in viewuiplus || (viewuiplus.langs = {}), viewuiplus.langs[t.i.locale] = t);
    }
    const Oh = { i: { locale: "zh-CN", select: { placeholder: "请选择", noMatch: "无匹配数据", loading: "加载中" }, table: { noDataText: "暂无数据", noFilteredDataText: "暂无筛选结果", confirmFilter: "筛选", resetFilter: "重置", clearFilter: "全部", sumText: "合计" }, datepicker: { selectDate: "选择日期", selectTime: "选择时间", startTime: "开始时间", endTime: "结束时间", clear: "清空", ok: "确定", datePanelLabel: "[yyyy年] [m月]", month: "月", month1: "1 月", month2: "2 月", month3: "3 月", month4: "4 月", month5: "5 月", month6: "6 月", month7: "7 月", month8: "8 月", month9: "9 月", month10: "10 月", month11: "11 月", month12: "12 月", year: "年", weekStartDay: "0", weeks: { sun: "日", mon: "一", tue: "二", wed: "三", thu: "四", fri: "五", sat: "六" }, months: { m1: "1月", m2: "2月", m3: "3月", m4: "4月", m5: "5月", m6: "6月", m7: "7月", m8: "8月", m9: "9月", m10: "10月", m11: "11月", m12: "12月" } }, transfer: { titles: { source: "源列表", target: "目的列表" }, filterPlaceholder: "请输入搜索内容", notFoundText: "列表为空" }, modal: { okText: "确定", cancelText: "取消" }, poptip: { okText: "确定", cancelText: "取消" }, page: { prev: "上一页", next: "下一页", total: "共", item: "条", items: "条", prev5: "向前 5 页", next5: "向后 5 页", page: "条/页", goto: "跳至", p: "页" }, rate: { star: "星", stars: "星" }, time: { before: "前", after: "后", just: "刚刚", seconds: "秒", minutes: "分钟", hours: "小时", days: "天" }, tree: { emptyText: "暂无数据" }, image: { zoomIn: "放大", zoomOut: "缩小", rotateLeft: "左旋转", rotateRight: "右旋转", fail: "失败", preview: "预览" } } };
    pS(Oh);
    var mS = function(t) {
      return gS(t) && !vS(t);
    };
    function gS(t) {
      return !!t && typeof t == "object";
    }
    function vS(t) {
      var r = Object.prototype.toString.call(t);
      return r === "[object RegExp]" || r === "[object Date]" || CS(t);
    }
    var yS = typeof Symbol == "function" && Symbol.for, bS = yS ? Symbol.for("react.element") : 60103;
    function CS(t) {
      return t.$$typeof === bS;
    }
    function wS(t) {
      return Array.isArray(t) ? [] : {};
    }
    function Yl(t, r) {
      return r.clone !== !1 && r.isMergeableObject(t) ? Ko(wS(t), t, r) : t;
    }
    function kS(t, r, o) {
      return t.concat(r).map(function(C) {
        return Yl(C, o);
      });
    }
    function SS(t, r, o) {
      var C = {};
      return o.isMergeableObject(t) && Object.keys(t).forEach(function(g) {
        C[g] = Yl(t[g], o);
      }), Object.keys(r).forEach(function(g) {
        !o.isMergeableObject(r[g]) || !t[g] ? C[g] = Yl(r[g], o) : C[g] = Ko(t[g], r[g], o);
      }), C;
    }
    function Ko(t, r, o) {
      o = o || {}, o.arrayMerge = o.arrayMerge || kS, o.isMergeableObject = o.isMergeableObject || mS;
      var C = Array.isArray(r), g = Array.isArray(t), a = C === g;
      return a ? C ? o.arrayMerge(t, r, o) : SS(t, r, o) : Yl(r, o);
    }
    Ko.all = function(t, r) {
      if (!Array.isArray(t))
        throw new Error("first argument should be an array");
      return t.reduce(function(o, C) {
        return Ko(o, C, r);
      }, {});
    };
    var ES = Ko;
    const xS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
    function _S() {
      function t(o, C) {
        return Object.prototype.hasOwnProperty.call(o, C);
      }
      function r(o, ...C) {
        return C.length === 1 && typeof C[0] == "object" && (C = C[0]), (!C || !C.hasOwnProperty) && (C = {}), o === void 0 ? "" : o.replace(xS, (g, a, x, O) => {
          let P;
          return o[O - 1] === "{" && o[O + g.length] === "}" ? x : (P = t(C, x) ? C[x] : null, P ?? "");
        });
      }
      return r;
    }
    const TS = _S();
    let Kl = Oh;
    const OS = { zh: Oh };
    let Im = null, Mm = {}, $n = null, DS = function() {
      if (Reflect.has(this, "$t"))
        return this.$t(...arguments);
      if ($n && $n.global)
        return $n.global.t(...arguments);
      if ($n && $n.locale) {
        if (!Mm[$n.locale] || Im != $n.locale) {
          Mm[$n.locale] = !0;
          let t = $n.getLocaleMessage($n.locale) || {}, r = {};
          ES(r, OS[$n.locale], t), Kl = r, $n.setLocaleMessage($n.locale, r), Im = $n.locale;
        }
        return $n.hlang(...arguments);
      }
    };
    const Am = function(t, r) {
      let o = DS.apply(this, arguments);
      if (o != null)
        return o;
      const C = t.split(".");
      let g = Kl;
      for (let a = 0, x = C.length; a < x; a++) {
        const O = C[a];
        if (o = g[O], a === x - 1)
          return TS(o, r);
        if (!o)
          return "";
        g = o;
      }
      return "";
    };
    var Go = { use: function(t) {
      Kl = t || Kl;
    }, t: Am, i18n: function(t) {
      $n = t;
    } }, Kt = { methods: { t(...t) {
      return Am.apply(this, t);
    } } }, kr = { data() {
      return { globalConfig: {} };
    }, created() {
      const t = e.getCurrentInstance();
      this.globalConfig = t.appContext.config.globalProperties.$VIEWUI;
    } };
    const Xo = "ivu-select", NS = { name: "iSelectHead", mixins: [Kt, kr], components: { Icon: G }, emits: ["on-input-focus", "on-input-blur", "on-keydown", "on-enter", "on-clear", "on-query-change"], inject: ["SelectInstance"], props: { disabled: { type: Boolean, default: !1 }, filterable: { type: Boolean, default: !1 }, multiple: { type: Boolean, default: !1 }, remote: { type: Boolean, default: !1 }, initialLabel: { type: [String, Number, Array] }, values: { type: Array, default: () => [] }, clearable: { type: [Function, Boolean], default: !1 }, inputElementId: { type: String }, placeholder: { type: String }, queryProp: { type: String, default: "" }, prefix: { type: String }, maxTagCount: { type: Number }, maxTagPlaceholder: { type: Function }, allowCreate: { type: Boolean }, showCreateItem: { type: Boolean } }, data() {
      return { prefixCls: Xo, query: "", inputLength: 20, remoteInitialLabel: this.initialLabel, preventRemoteCall: !1 };
    }, computed: { singleDisplayClasses() {
      const { filterable: t, multiple: r, showPlaceholder: o } = this;
      return [{ [Xo + "-head-with-prefix"]: this.showPrefix, [Xo + "-placeholder"]: o && !t, [Xo + "-selected-value"]: !o && !r && !t }];
    }, singleDisplayValue() {
      return this.multiple && this.values.length > 0 || this.filterable ? "" : `${this.selectedSingle}` || this.localePlaceholder;
    }, showPlaceholder() {
      let t = !1;
      if (this.multiple)
        !this.values.length > 0 && (t = !0);
      else {
        const r = this.values[0];
        (typeof r > "u" || String(r).trim() === "") && (t = !this.remoteInitialLabel);
      }
      return t;
    }, resetSelect() {
      return !this.showPlaceholder && this.clearable;
    }, inputStyle() {
      let t = {};
      return this.multiple && (this.showPlaceholder ? t.width = "100%" : t.width = `${this.inputLength}px`), t;
    }, localePlaceholder() {
      return this.placeholder === void 0 ? this.t("i.select.placeholder") : this.placeholder;
    }, selectedSingle() {
      const t = this.values[0];
      return t ? t.label : this.remoteInitialLabel || "";
    }, selectedMultiple() {
      return (this.multiple ? this.values : []).filter((t, r) => this.maxTagCount === void 0 || r < this.maxTagCount);
    }, headCls() {
      return { [`${Xo}-head-flex`]: this.filterable && this.showPrefix };
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-down";
      return t && (t.select.customArrow ? r = "" : t.select.arrow && (r = t.select.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.select.customArrow && (r = t.select.customArrow), r;
    }, showPrefix() {
      const t = this.$slots.prefix && this.$slots.prefix();
      let r = !1;
      return t && (r = t[0].children.length > 0), r || this.prefix;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.select.arrowSize && (r = t.select.arrowSize), r;
    } }, methods: { onInputFocus() {
      this.$emit("on-input-focus");
    }, onInputBlur() {
      this.showCreateItem || (this.values.length || (this.query = ""), this.$emit("on-input-blur"));
    }, removeTag(t) {
      if (this.disabled)
        return !1;
      this.SelectInstance.handleOnSelectSelected(t);
    }, resetInputState() {
      this.inputLength = this.$refs.input.value.length * 12 + 20, this.$emit("on-keydown");
    }, handleInputDelete(t) {
      const r = t.target.value;
      this.multiple && this.selectedMultiple.length && this.query === "" && r === "" && this.removeTag(this.selectedMultiple[this.selectedMultiple.length - 1]);
    }, handleInputEnter(t) {
      this.$emit("on-enter"), this.showCreateItem && t.stopPropagation();
    }, onHeaderClick(t) {
      this.filterable && t.target === this.$el && this.$refs.input.focus();
    }, onClear() {
      this.$emit("on-clear");
    } }, watch: { values([t]) {
      if (this.filterable) {
        if (this.preventRemoteCall = !0, this.multiple) {
          this.query = "", this.preventRemoteCall = !1;
          return;
        }
        typeof t > "u" || t === "" || t === null ? this.query = "" : this.query = t.label, e.nextTick(() => this.preventRemoteCall = !1);
      }
    }, query(t) {
      if (this.preventRemoteCall) {
        this.preventRemoteCall = !1;
        return;
      }
      this.$emit("on-query-change", t);
    }, queryProp(t) {
      t !== this.query && (this.query = t);
    } } }, BS = { key: 1, class: "ivu-tag ivu-tag-checked" }, PS = { class: "ivu-tag-text ivu-select-max-tag" }, VS = ["id", "disabled", "placeholder"];
    function $S(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { onClick: r[6] || (r[6] = (...O) => a.onHeaderClick && a.onHeaderClick(...O)), class: e.normalizeClass(a.headCls) }, [a.showPrefix ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass([g.prefixCls + "-prefix"]) }, [e.renderSlot(t.$slots, "prefix", {}, () => [o.prefix ? (e.openBlock(), e.createBlock(x, { key: 0, type: o.prefix }, null, 8, ["type"])) : e.createCommentVNode("", !0)])], 2)) : e.createCommentVNode("", !0), (e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.selectedMultiple, (O, P) => (e.openBlock(), e.createElementBlock("div", { class: "ivu-tag ivu-tag-checked", key: P }, [e.createElementVNode("span", { class: e.normalizeClass(["ivu-tag-text", { "ivu-select-multiple-tag-hidden": O.disabled }]) }, e.toDisplayString(O.tag !== void 0 ? O.tag : O.label), 3), O.disabled ? e.createCommentVNode("", !0) : (e.openBlock(), e.createBlock(x, { key: 0, type: "ios-close", onClick: e.withModifiers((N) => a.removeTag(O), ["stop"]) }, null, 8, ["onClick"]))]))), 128)), o.maxTagCount !== void 0 && o.values.length > o.maxTagCount ? (e.openBlock(), e.createElementBlock("div", BS, [e.createElementVNode("span", PS, [o.maxTagPlaceholder ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(o.maxTagPlaceholder(o.values.length - o.maxTagCount)), 1)], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode("+ " + e.toDisplayString(o.values.length - o.maxTagCount) + "...", 1)], 64))])])) : e.createCommentVNode("", !0), e.withDirectives(e.createElementVNode("span", { class: e.normalizeClass(a.singleDisplayClasses) }, e.toDisplayString(a.singleDisplayValue), 3), [[e.vShow, a.singleDisplayValue]]), o.filterable ? e.withDirectives((e.openBlock(), e.createElementBlock("input", { key: 2, id: o.inputElementId, type: "text", "onUpdate:modelValue": r[0] || (r[0] = (O) => g.query = O), disabled: o.disabled, class: e.normalizeClass([g.prefixCls + "-input"]), placeholder: a.showPlaceholder ? a.localePlaceholder : "", style: e.normalizeStyle(a.inputStyle), autocomplete: "off", spellcheck: "false", onKeydown: [r[1] || (r[1] = (...O) => a.resetInputState && a.resetInputState(...O)), r[2] || (r[2] = e.withKeys((...O) => a.handleInputDelete && a.handleInputDelete(...O), ["delete"])), r[3] || (r[3] = e.withKeys((...O) => a.handleInputEnter && a.handleInputEnter(...O), ["enter"]))], onFocus: r[4] || (r[4] = (...O) => a.onInputFocus && a.onInputFocus(...O)), onBlur: r[5] || (r[5] = (...O) => a.onInputBlur && a.onInputBlur(...O)), ref: "input" }, null, 46, VS)), [[e.vModelText, g.query]]) : e.createCommentVNode("", !0), a.resetSelect ? (e.openBlock(), e.createBlock(x, { key: 3, type: "ios-close-circle", class: e.normalizeClass([g.prefixCls + "-arrow"]), onClick: e.withModifiers(a.onClear, ["stop"]) }, null, 8, ["class", "onClick"])) : e.createCommentVNode("", !0), !a.resetSelect && !o.remote ? (e.openBlock(), e.createBlock(x, { key: 4, type: a.arrowType, custom: a.customArrowType, size: a.arrowSize, class: e.normalizeClass([g.prefixCls + "-arrow"]) }, null, 8, ["type", "custom", "size", "class"])) : e.createCommentVNode("", !0)], 2);
    }
    var IS = f(NS, [["render", $S]]);
    const MS = "click", qo = /* @__PURE__ */ Object.create(null), Gl = /* @__PURE__ */ Object.create(null), AS = [qo, Gl], Fm = function(t, r, o) {
      const { target: C } = o, g = function(x) {
        const { el: O } = x;
        if (O !== C && !O.contains(C)) {
          const { binding: P } = x;
          P.modifiers.stop && o.stopPropagation(), P.modifiers.prevent && o.preventDefault(), P.value.call(t, o);
        }
      }, a = function(x) {
        return r[x].forEach(g);
      };
      Object.keys(r).forEach(a);
    }, Lm = function(t) {
      Fm(this, qo, t);
    }, zm = function(t) {
      Fm(this, Gl, t);
    }, Rm = function(t) {
      return t ? Lm : zm;
    }, Dh = Object.defineProperties({}, { $_captureInstances: { value: qo }, $_nonCaptureInstances: { value: Gl }, $_onCaptureEvent: { value: Lm }, $_onNonCaptureEvent: { value: zm }, beforeMount: { value: function(t, r) {
      if (typeof r.value != "function")
        throw new TypeError("Binding value must be a function.");
      let o;
      const C = r.modifiers;
      C.click ? o = "click" : C.mousedown ? o = "mousedown" : C.touchstart ? o = "touchstart" : o = MS;
      const g = r.arg, a = v(p({}, r), { modifiers: p({ capture: !1, prevent: !1, stop: !1 }, r.modifiers) }), x = g ? qo : Gl;
      Array.isArray(x[o]) || (x[o] = []), x[o].push({ el: t, binding: a }) === 1 && typeof document == "object" && document && document.addEventListener(o, Rm(g), g);
    } }, unmounted: { value: function(t) {
      const r = function(C) {
        return C.el !== t;
      }, o = function(C) {
        const g = Object.keys(C);
        if (g.length) {
          const a = C === qo, x = function(O) {
            const P = C[O].filter(r);
            P.length ? C[O] = P : (typeof document == "object" && document && document.removeEventListener(O, Rm(a), a), delete C[O]);
          };
          g.forEach(x);
        }
      };
      AS.forEach(o);
    } }, version: { enumerable: !0, value: "3.7.1" } });
    var nn = { inject: { FormInstance: { default: "" }, FormItemInstance: { default: null } }, computed: { itemDisabled() {
      let t = this.disabled;
      return !t && this.FormInstance && (t = this.FormInstance.disabled), t ? !0 : null;
    } }, methods: { handleFormItemChange(t, r) {
      this.FormItemInstance && (t === "blur" ? this.FormItemInstance.formBlur(r) : t === "change" && this.FormItemInstance.formChange(r));
    } } };
    const ki = "ivu-select", FS = (t, r, o) => {
      const C = JSON.stringify(t), g = JSON.stringify(r), a = JSON.stringify(o.map((x) => x.value));
      return C !== g || C !== a || a !== g;
    }, jm = 300, LS = { name: "iSelect", mixins: [Kt, nn], components: { Drop: er, SelectHead: IS, Icon: G }, directives: { clickOutside: Dh }, emits: ["on-set-default-options", "on-clear", "on-clickoutside", "on-select", "on-create", "on-change", "on-query-change", "on-open-change", "update:modelValue"], provide() {
      return { SelectInstance: this };
    }, props: { modelValue: { type: [String, Number, Array], default: "" }, label: { type: [String, Number, Array], default: "" }, defaultLabel: { type: [String, Number, Array], default: "" }, multiple: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !1 }, placeholder: { type: String }, filterable: { type: Boolean, default: !1 }, filterMethod: { type: Function }, remoteMethod: { type: Function }, loading: { type: Boolean, default: !1 }, loadingText: { type: String }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, labelInValue: { type: Boolean, default: !1 }, notFoundText: { type: String }, placement: { validator(t) {
      return z(t, ["top", "bottom", "top-start", "bottom-start", "top-end", "bottom-end"]);
    }, default: "bottom-start" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, autoComplete: { type: Boolean, default: !1 }, name: { type: String }, elementId: { type: String }, transferClassName: { type: String }, prefix: { type: String }, maxTagCount: { type: Number }, maxTagPlaceholder: { type: Function }, allowCreate: { type: Boolean, default: !1 }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, filterByLabel: { type: Boolean, default: !1 }, eventsEnabled: { type: Boolean, default: !1 }, hideNotFound: { type: Boolean, default: !1 } }, mounted() {
      if (!this.remote && this.slotOptions.length > 0 && (this.values = this.getInitialValue().map((t) => typeof t != "number" && !t ? null : this.getOptionData(t)).filter(Boolean)), this.checkUpdateStatus(), this.remote && this.modelValue && this.defaultLabel) {
        if (!this.multiple)
          this.query = this.defaultLabel, this.modelValue && this.defaultLabel && this.values.push({ label: this.defaultLabel, value: this.modelValue });
        else if (this.multiple && this.defaultLabel instanceof Array && this.modelValue.length === this.defaultLabel.length) {
          const t = this.modelValue.map((r, o) => ({ value: r, label: this.defaultLabel[o] }));
          setTimeout(() => {
            this.values = t;
          });
        }
      }
    }, data() {
      return { prefixCls: ki, values: [], dropDownWidth: 0, visible: !1, focusIndex: -1, isFocused: !1, query: "", initialLabel: this.label, hasMouseHoverHead: !1, slotOptions: [], caretPosition: -1, lastRemoteQuery: "", unchangedQuery: !0, hasExpectedValue: !1, isTyping: !1, preventRemoteCall: !1, filterQueryChange: !1, slotOptionsMap: /* @__PURE__ */ new Map(), isLocking: !1 };
    }, computed: { classes() {
      return [`${ki}`, { [`${ki}-visible`]: this.visible, [`${ki}-disabled`]: this.itemDisabled, [`${ki}-multiple`]: this.multiple, [`${ki}-single`]: !this.multiple, [`${ki}-${this.size}`]: !!this.size }];
    }, dropdownCls() {
      return { [ki + "-dropdown-transfer"]: this.transfer, [ki + "-multiple"]: this.multiple && this.transfer, "ivu-auto-complete": this.autoComplete, [this.transferClassName]: this.transferClassName };
    }, selectionCls() {
      return { [`${ki}-selection`]: !this.autoComplete, [`${ki}-selection-focused`]: this.isFocused };
    }, localeNotFoundText() {
      return typeof this.notFoundText > "u" ? this.t("i.select.noMatch") : this.notFoundText;
    }, localeLoadingText() {
      return typeof this.loadingText > "u" ? this.t("i.select.loading") : this.loadingText;
    }, showCreateItem() {
      let t = !1;
      const { allowCreate: r, query: o, slotOptions: C } = this;
      return r && o !== "" && (t = !0, (C || []).find((g) => g.proxy && g.proxy.showLabel === o) && (t = !1)), t;
    }, transitionName() {
      return this.placement === "bottom" ? "slide-up" : "slide-down";
    }, dropVisible() {
      let t = !0;
      const r = this.slotOptions.length === 0;
      return !this.loading && this.remote && this.query === "" && r && (t = !1), this.autoComplete && r && (t = !1), this.visible && t;
    }, showNotFoundLabel() {
      const { loading: t, remote: r, slotOptions: o, hideNotFound: C } = this, g = o || [], a = g.find((x) => x.proxy.isShow);
      return (g.length === 0 || !a) && (!r || r && !t) && !C;
    }, publicValue() {
      return this.multiple ? this.values.map((t) => t.value) : (this.values[0] || {}).value;
    }, canBeCleared() {
      const t = this.hasMouseHoverHead, r = !this.multiple && !this.itemDisabled && this.clearable;
      return t && r && this.reset;
    }, selectTabindex() {
      return this.itemDisabled || this.filterable ? -1 : 0;
    }, remote() {
      return typeof this.remoteMethod == "function";
    } }, methods: { setQuery(t) {
      if (t) {
        this.onQueryChange(t);
        return;
      }
      t === null && (this.onQueryChange(""), this.values = [], this.lastRemoteQuery = "");
    }, clearSingleSelect() {
      this.multiple || this.$emit("update:modelValue", ""), this.$emit("on-clear"), this.hideMenu(), this.clearable && this.reset();
    }, getOptionData(t) {
      const r = this.slotOptions.find(({ props: g }) => g.value === t);
      if (!r)
        return null;
      const { optionLabel: o, disabled: C } = r.proxy || {};
      return { value: t, label: o, disabled: C };
    }, getInitialValue() {
      const { multiple: t, remote: r, modelValue: o } = this;
      let C = Array.isArray(o) ? o : [o];
      if (!t && (typeof C[0] > "u" || String(C[0]).trim() === "" && !Number.isFinite(C[0])) && (C = []), r && !t && o) {
        const g = this.getOptionData(o);
        this.query = g ? g.label : String(o);
      }
      return C.filter((g) => !!g || g === 0);
    }, validateOption({ children: t, elm: r, propsData: o }) {
      const C = o.value, g = o.label || "", a = r && r.textContent || (t || []).reduce((P, N) => {
        const B = N.elm ? N.elm.textContent : N.text;
        return `${P} ${B}`;
      }, "") || "", x = this.filterByLabel ? [g].toString() : [C, g, a].toString(), O = this.query.toLowerCase().trim();
      return x.toLowerCase().includes(O);
    }, toggleMenu(t, r) {
      if (this.itemDisabled)
        return !1;
      this.visible = typeof r < "u" ? r : !this.visible, this.visible && (this.dropDownWidth = this.$el.getBoundingClientRect().width, this.$refs.dropdown.handleOnUpdatePopper());
    }, hideMenu() {
      this.toggleMenu(null, !1), this.isTyping = !1, setTimeout(() => this.unchangedQuery = !0, jm);
    }, onClickOutside(t) {
      if (this.visible) {
        if (t.type === "mousedown") {
          t.preventDefault();
          return;
        }
        if (this.transfer) {
          const r = this.$refs.dropdown.$refs.drop;
          if (r === t.target || r.contains(t.target))
            return;
        }
        if (this.filterable) {
          const r = this.$el.querySelector('input[type="text"]');
          this.caretPosition = r.selectionStart, e.nextTick(() => {
            const o = this.caretPosition === -1 ? r.value.length : this.caretPosition;
            r.setSelectionRange(o, o);
          });
        }
        this.autoComplete || t.stopPropagation(), t.preventDefault(), this.hideMenu(), this.isFocused = !0, this.$emit("on-clickoutside", t);
      } else
        this.caretPosition = -1, this.isFocused = !1;
    }, reset() {
      this.query = "", this.focusIndex = -1, this.unchangedQuery = !0, this.values = [], this.filterQueryChange = !1;
    }, handleKeydown(t) {
      const r = t.key || t.code, o = t.keyCode || t.which;
      if (!(r === "Backspace" || o === 8))
        if (this.visible) {
          if (t.preventDefault(), r === "Tab" && t.stopPropagation(), r === "Escape" && (t.stopPropagation(), this.hideMenu()), r === "ArrowUp" && this.navigateOptions(-1), r === "ArrowDown" && this.navigateOptions(1), r === "Enter") {
            if (this.focusIndex === -1)
              return this.hideMenu();
            const C = this.slotOptions[this.focusIndex];
            if (C) {
              const g = this.getOptionData(C.props.value);
              this.onOptionClick(g);
            } else
              this.hideMenu();
          }
        } else
          ["ArrowUp", "ArrowDown"].includes(t.key) && this.toggleMenu(null, !0);
    }, navigateOptions(t) {
      const r = this.slotOptions, o = r.length - 1;
      if (o < 0)
        return;
      let C = this.focusIndex + t;
      C < 0 && (C = o), C > o && (C = 0);
      let g, a = null;
      if (t > 0) {
        g = -1;
        for (let x = 0; x < r.length; x++) {
          const { proxy: O } = r[x];
          if (!O.disabled && (g = x), O.isShow && a === null)
            a = x;
          else if (!O.isShow) {
            g = x;
            continue;
          }
          if (g >= C)
            break;
        }
      } else {
        g = r.length;
        for (let x = o; x >= 0; x--) {
          const { proxy: O } = r[x];
          if (!O.disabled && (g = x), O.isShow && a === null)
            a = x;
          else if (!O.isShow) {
            g = x;
            continue;
          }
          if (g <= C)
            break;
        }
      }
      C = r[g].proxy.isShow ? g : a, this.focusIndex = C;
    }, onOptionClick(t) {
      if (this.multiple ? (this.remote ? this.lastRemoteQuery = this.lastRemoteQuery || this.query : this.lastRemoteQuery = "", this.values.find(({ value: r }) => r === t.value) ? this.values = this.values.filter(({ value: r }) => r !== t.value) : this.values = this.values.concat(t), this.isFocused = !0) : (this.query = String(t.label).trim(), this.values = [t], this.lastRemoteQuery = "", this.hideMenu()), this.focusIndex = this.slotOptions.findIndex((r) => r ? r.props.value === t.value : !1), this.filterable) {
        const r = this.$el.querySelector('input[type="text"]');
        this.autoComplete || e.nextTick(() => r.focus());
      }
      this.$emit("on-select", t), this.$refs.dropdown.handleOnUpdatePopper(), setTimeout(() => {
        this.filterQueryChange = !1;
      }, jm);
    }, onQueryChange(t) {
      if (this.isTyping = !0, t.length > 0 && t !== this.query)
        if (h && this.autoComplete) {
          let r = document.hasFocus && document.hasFocus() && document.activeElement === this.$el.querySelector("input");
          this.visible = r;
        } else
          this.visible = !0;
      this.query = t, this.unchangedQuery = this.visible, this.filterQueryChange = !0;
    }, toggleHeaderFocus({ type: t }) {
      this.itemDisabled || (this.isFocused = t === "focus");
    }, checkUpdateStatus() {
      this.getInitialValue().length > 0 && this.slotOptions.length === 0 && (this.hasExpectedValue = !0);
    }, handleCreateItem() {
      if (this.allowCreate && this.query !== "" && this.showCreateItem) {
        const t = this.query;
        this.$emit("on-create", t), this.query = "";
        const r = { value: t, label: t, tag: void 0 };
        this.$refs.dropdown.handleOnUpdatePopper(), setTimeout(() => {
          this.onOptionClick(r);
        });
      }
    }, handleOnSelectSelected(t) {
      this.onOptionClick(t);
    }, focus() {
      this.filterable && (this.$refs.selectHead.$refs.input.focus(), this.toggleMenu());
    }, lazyUpdateValue(t) {
      const { getInitialValue: r, isLocking: o, defaultLabel: C, remote: g, modelValue: a, values: x } = this, O = !!(C && C.length);
      (a && a.length || x.length || O) && g && t || o || (this.isLocking = !0, e.nextTick(() => {
        this.values = r().map(this.getOptionData).filter(Boolean), this.isLocking = !1;
      }));
    } }, watch: { modelValue(t) {
      const { publicValue: r, values: o } = this;
      this.checkUpdateStatus(), t === "" ? (this.values = [], this.query = "") : FS(t, r, o) && (this.lazyUpdateValue(), this.multiple || this.handleFormItemChange("change", this.publicValue));
    }, values(t, r) {
      const o = JSON.stringify(t), C = JSON.stringify(r);
      let g = this.publicValue;
      if (o !== C && g !== this.modelValue) {
        let a = this.publicValue;
        this.labelInValue && (this.multiple ? a = this.values : a = this.values[0]), (Array.isArray(g) && !g.length && this.modelValue === null || g === void 0 && this.modelValue === null) && (g = null), this.$emit("update:modelValue", g), this.$emit("on-change", a), this.handleFormItemChange("change", a);
      }
    }, query(t) {
      this.focusIndex = -1, this.$emit("on-query-change", t);
      const { remoteMethod: r, lastRemoteQuery: o } = this, C = r && t !== "" && (t !== o || !o) && !this.preventRemoteCall;
      if (this.preventRemoteCall = !1, C) {
        const g = this.remoteMethod(t);
        this.initialLabel = "", g && g.then && g.then((a) => {
          a && (this.options = a);
        });
      }
      this.visible && this.$refs.dropdown.handleOnUpdatePopper(), t !== "" && this.remote && (this.lastRemoteQuery = t);
    }, isFocused(t) {
      (this.filterable ? this.$el.querySelector('input[type="text"]') : this.$el)[this.isFocused ? "focus" : "blur"]();
      const [r] = this.values;
      if (r && this.filterable && !this.multiple && !t) {
        const o = String(r.label || r.value).trim();
        o && this.query !== o && (this.preventRemoteCall = !0, this.query = o);
      }
    }, focusIndex(t) {
      if (!(t < 0 || this.autoComplete) && this.slotOptions[t]) {
        const r = this.slotOptions[t].proxy.$el, o = this.$refs.dropdown.$refs.drop;
        let C = r.getBoundingClientRect().bottom - o.getBoundingClientRect().bottom, g = r.getBoundingClientRect().top - o.getBoundingClientRect().top;
        C > 0 && (o.scrollTop += C), g < 0 && (o.scrollTop += g);
      }
    }, dropVisible(t) {
      t ? this.$refs.dropdown.handleOnUpdatePopper() : this.$refs.dropdown.handleOnDestroyPopper();
    }, visible(t) {
      this.$emit("on-open-change", t);
    } } }, zS = ["tabindex"], RS = ["name", "value"];
    function jS(t, r, o, C, g, a) {
      const x = e.resolveComponent("select-head"), O = e.resolveComponent("Icon"), P = e.resolveComponent("Drop"), N = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { ref: "reference", class: e.normalizeClass(a.selectionCls), tabindex: a.selectTabindex, onBlur: r[2] || (r[2] = (...B) => a.toggleHeaderFocus && a.toggleHeaderFocus(...B)), onFocus: r[3] || (r[3] = (...B) => a.toggleHeaderFocus && a.toggleHeaderFocus(...B)), onClick: r[4] || (r[4] = (...B) => a.toggleMenu && a.toggleMenu(...B)), onKeydown: [r[5] || (r[5] = e.withKeys((...B) => a.handleKeydown && a.handleKeydown(...B), ["esc"])), r[6] || (r[6] = e.withKeys((...B) => a.handleKeydown && a.handleKeydown(...B), ["enter"])), r[7] || (r[7] = e.withKeys(e.withModifiers((...B) => a.handleKeydown && a.handleKeydown(...B), ["prevent"]), ["up"])), r[8] || (r[8] = e.withKeys(e.withModifiers((...B) => a.handleKeydown && a.handleKeydown(...B), ["prevent"]), ["down"])), r[9] || (r[9] = e.withKeys((...B) => a.handleKeydown && a.handleKeydown(...B), ["tab"])), r[10] || (r[10] = e.withKeys((...B) => a.handleKeydown && a.handleKeydown(...B), ["delete"]))], onMouseenter: r[11] || (r[11] = (B) => g.hasMouseHoverHead = !0), onMouseleave: r[12] || (r[12] = (B) => g.hasMouseHoverHead = !1) }, [e.renderSlot(t.$slots, "input", {}, () => [e.createElementVNode("input", { type: "hidden", name: o.name, value: a.publicValue }, null, 8, RS), e.createVNode(x, { ref: "selectHead", filterable: o.filterable, multiple: o.multiple, values: g.values, clearable: a.canBeCleared, prefix: o.prefix, disabled: t.itemDisabled, remote: a.remote, "input-element-id": o.elementId, "initial-label": g.initialLabel, placeholder: o.placeholder, "query-prop": g.query, "max-tag-count": o.maxTagCount, "max-tag-placeholder": o.maxTagPlaceholder, "allow-create": o.allowCreate, "show-create-item": a.showCreateItem, onOnQueryChange: a.onQueryChange, onOnInputFocus: r[0] || (r[0] = (B) => g.isFocused = !0), onOnInputBlur: r[1] || (r[1] = (B) => g.isFocused = !1), onOnClear: a.clearSingleSelect, onOnEnter: a.handleCreateItem }, { prefix: e.withCtx(() => [e.renderSlot(t.$slots, "prefix")]), _: 3 }, 8, ["filterable", "multiple", "values", "clearable", "prefix", "disabled", "remote", "input-element-id", "initial-label", "placeholder", "query-prop", "max-tag-count", "max-tag-placeholder", "allow-create", "show-create-item", "onOnQueryChange", "onOnClear", "onOnEnter"])])], 42, zS), e.createVNode(P, { ref: "dropdown", classes: a.dropdownCls, visible: a.dropVisible, placement: o.placement, eventsEnabled: o.eventsEnabled, transfer: o.transfer, "transition-name": "transition-drop" }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-not-found"]) }, [e.createElementVNode("li", null, e.toDisplayString(a.localeNotFoundText), 1)], 2), [[e.vShow, a.showNotFoundLabel && !o.allowCreate]]), !a.remote || a.remote && !o.loading ? (e.openBlock(), e.createElementBlock("ul", { key: 0, class: e.normalizeClass(g.prefixCls + "-dropdown-list") }, [a.showCreateItem ? (e.openBlock(), e.createElementBlock("li", { key: 0, class: e.normalizeClass(g.prefixCls + "-item"), onClick: r[13] || (r[13] = (...B) => a.handleCreateItem && a.handleCreateItem(...B)) }, [e.createTextVNode(e.toDisplayString(g.query) + " ", 1), e.createVNode(O, { type: "md-return-left", class: e.normalizeClass(g.prefixCls + "-item-enter") }, null, 8, ["class"])], 2)) : e.createCommentVNode("", !0), e.renderSlot(t.$slots, "default")], 2)) : (e.openBlock(), e.createElementBlock("ul", { key: 1, class: e.normalizeClass(g.prefixCls + "-dropdown-list") }, [a.showCreateItem ? (e.openBlock(), e.createElementBlock("li", { key: 0, class: e.normalizeClass(g.prefixCls + "-item"), onClick: r[14] || (r[14] = (...B) => a.handleCreateItem && a.handleCreateItem(...B)) }, [e.createTextVNode(e.toDisplayString(g.query) + " ", 1), e.createVNode(O, { type: "md-return-left", class: e.normalizeClass(g.prefixCls + "-item-enter") }, null, 8, ["class"])], 2)) : e.createCommentVNode("", !0)], 2)), e.withDirectives(e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-loading"]) }, e.toDisplayString(a.localeLoadingText), 3), [[e.vShow, o.loading]])]), _: 3 }, 8, ["classes", "visible", "placement", "eventsEnabled", "transfer"])], 2)), [[N, a.onClickOutside, o.capture], [N, a.onClickOutside, o.capture, { mousedown: !0 }], [N, a.onClickOutside, o.capture, { touchstart: !0 }]]);
    }
    var ps = f(LS, [["render", jS]]);
    const Xl = "ivu-select-item", HS = { name: "iOption", componentName: "select-item", mixins: [nn], emits: ["on-select-selected"], inject: { SelectInstance: { default: null }, OptionGroupInstance: { default: null } }, props: { value: { type: [String, Number], required: !0 }, label: { type: [String, Number] }, disabled: { type: Boolean, default: !1 }, tag: { type: [String, Number] } }, data() {
      return { searchLabel: "", autoComplete: !1, id: be(6), instance: null };
    }, computed: { classes() {
      return [`${Xl}`, { [`${Xl}-disabled`]: this.itemDisabled, [`${Xl}-selected`]: this.selected && !this.autoComplete, [`${Xl}-focus`]: this.isFocused }];
    }, showLabel() {
      return this.label ? this.label : this.value;
    }, optionLabel() {
      return this.label || this.$el && this.$el.textContent;
    }, isFocused() {
      const t = this.SelectInstance;
      let r = t.slotOptions || [];
      const o = t.focusIndex, C = t.$slots.default;
      if (this.autoComplete && C) {
        r = [];
        let a = C();
        for (; a.length > 0; ) {
          const x = a.shift();
          x.type && typeof x.type == "object" && x.type.name === "iOption" ? r.push(x) : Array.isArray(x.children) && (a = a.concat(x.children));
        }
      }
      const g = r[o];
      return g && g.props && g.props.value === this.value;
    }, isShow() {
      const t = this.SelectInstance, r = t.filterable, o = t.query.toLowerCase().trim(), C = t.filterByLabel, g = t.slotOptionsMap, { props: a } = g.get(this.value) || { props: {} }, x = this.label || this.$el && this.$el.textContent;
      let O = (x || a.value || "").toLowerCase();
      C && (O = (x || "").toLowerCase());
      const P = O.includes(o);
      return !r || r && (P || !t.filterQueryChange) || Z(t.remoteMethod) === "function";
    }, selected() {
      return (this.SelectInstance.values || []).find((t) => t.value === this.value);
    } }, methods: { select() {
      if (this.itemDisabled)
        return !1;
      this.SelectInstance.handleOnSelectSelected({ value: this.value, label: this.optionLabel, tag: this.tag });
    }, addOption() {
      const t = this.SelectInstance, r = this.OptionGroupInstance, { id: o, value: C, instance: g } = this;
      if (r && r.optionList.push(v(p({}, g), { id: o, tag: "option" })), t) {
        t.slotOptions.push(v(p({}, g), { id: o, tag: "option" })), t.slotOptionsMap.set(C, g);
        const { modelValue: a } = t;
        a && a.length && t.lazyUpdateValue(!0);
      }
    }, removeOption() {
      const t = this.OptionGroupInstance, r = this.SelectInstance, { id: o, value: C } = this;
      if (t) {
        const g = t.optionList.findIndex((a) => a.id === o);
        g !== -1 && t.optionList.splice(g, 1);
      }
      if (r) {
        const g = this.SelectInstance, a = g.slotOptions.findIndex((x) => x.id === o);
        a !== -1 && g.slotOptions.splice(a, 1), g.slotOptionsMap.has(C) && g.slotOptionsMap.delete(C);
      }
    } }, created() {
      this.instance = e.getCurrentInstance();
    }, mounted() {
      this.addOption();
      const t = me(this, "iSelect");
      t && (this.autoComplete = t.autoComplete);
    }, beforeUnmount() {
      e.nextTick(() => {
        this.removeOption(), this.instance = null;
      });
    } };
    function US(t, r, o, C, g, a) {
      return e.withDirectives((e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.classes), onClick: r[0] || (r[0] = e.withModifiers((...x) => a.select && a.select(...x), ["stop"])), onMousedown: r[1] || (r[1] = e.withModifiers(() => {
      }, ["prevent"])) }, [e.renderSlot(t.$slots, "default", {}, () => [e.createTextVNode(e.toDisplayString(a.showLabel), 1)])], 34)), [[e.vShow, a.isShow]]);
    }
    var Zs = f(HS, [["render", US]]);
    const WS = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`, YS = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
    let Nh = {}, Vi;
    function KS(t, r = !1) {
      if (!h)
        return;
      const o = t.getAttribute("id") || t.getAttribute("data-reactid") || t.getAttribute("name");
      if (r && Nh[o])
        return Nh[o];
      const C = window.getComputedStyle(t), g = C.getPropertyValue("box-sizing") || C.getPropertyValue("-moz-box-sizing") || C.getPropertyValue("-webkit-box-sizing"), a = parseFloat(C.getPropertyValue("padding-bottom")) + parseFloat(C.getPropertyValue("padding-top")), x = parseFloat(C.getPropertyValue("border-bottom-width")) + parseFloat(C.getPropertyValue("border-top-width")), O = { sizingStyle: YS.map((P) => `${P}:${C.getPropertyValue(P)}`).join(";"), paddingSize: a, borderSize: x, boxSizing: g };
      return r && o && (Nh[o] = O), O;
    }
    function GS(t, r = null, o = null, C = !1) {
      h && !Vi && (Vi = document.createElement("textarea"), document.body.appendChild(Vi)), t.getAttribute("wrap") ? Vi.setAttribute("wrap", t.getAttribute("wrap")) : Vi.removeAttribute("wrap");
      let { paddingSize: g, borderSize: a, boxSizing: x, sizingStyle: O } = KS(t, C);
      Vi.setAttribute("style", `${O};${WS}`), Vi.value = t.value || t.placeholder || "";
      let P = Number.MIN_SAFE_INTEGER, N = Number.MAX_SAFE_INTEGER, B = Vi.scrollHeight, H;
      if (x === "border-box" ? B = B + a : x === "content-box" && (B = B - g), r !== null || o !== null) {
        Vi.value = " ";
        let oe = Vi.scrollHeight - g;
        r !== null && (P = oe * r, x === "border-box" && (P = P + g + a), B = Math.max(P, B)), o !== null && (N = oe * o, x === "border-box" && (N = N + g + a), H = B > N ? "" : "hidden", B = Math.min(N, B));
      }
      return o || (H = "hidden"), { height: `${B}px`, minHeight: `${P}px`, maxHeight: `${N}px`, overflowY: H };
    }
    const un = "ivu-input", XS = { name: "Input", mixins: [nn], emits: ["on-enter", "on-search", "on-keydown", "on-keypress", "on-keyup", "on-click", "on-focus", "on-blur", "on-change", "on-input-change", "on-clear", "update:modelValue"], props: { type: { validator(t) {
      return z(t, ["text", "textarea", "password", "url", "email", "date", "number", "tel"]);
    }, default: "text" }, modelValue: { type: [String, Number], default: "" }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, placeholder: { type: String, default: "" }, maxlength: { type: [String, Number] }, disabled: { type: Boolean, default: !1 }, icon: String, autosize: { type: [Boolean, Object], default: !1 }, rows: { type: Number, default: 2 }, readonly: { type: Boolean, default: !1 }, name: { type: String }, number: { type: Boolean, default: !1 }, autofocus: { type: Boolean, default: !1 }, spellcheck: { type: Boolean, default: !1 }, autocomplete: { type: String, default: "off" }, clearable: { type: Boolean, default: !1 }, elementId: { type: String }, wrap: { validator(t) {
      return z(t, ["hard", "soft"]);
    }, default: "soft" }, prefix: { type: String, default: "" }, suffix: { type: String, default: "" }, search: { type: Boolean, default: !1 }, enterButton: { type: [Boolean, String], default: !1 }, showWordLimit: { type: Boolean, default: !1 }, password: { type: Boolean, default: !1 }, border: { type: Boolean, default: !0 } }, data() {
      return { currentValue: this.modelValue, prefixCls: un, slotReady: !1, textareaStyles: {}, isOnComposition: !1, showPassword: !1, clearableIconOffset: 0 };
    }, computed: { currentType() {
      let t = this.type;
      return t === "password" && this.password && this.showPassword && (t = "text"), t;
    }, prepend() {
      let t = !1;
      return this.type !== "textarea" && (t = this.$slots.prepend !== void 0), t;
    }, append() {
      let t = !1;
      return this.type !== "textarea" && (t = this.$slots.append !== void 0), t;
    }, showPrefix() {
      let t = !1;
      return this.type !== "textarea" && (t = this.prefix !== "" || this.$slots.prefix !== void 0), t;
    }, showSuffix() {
      let t = !1;
      return this.type !== "textarea" && (t = this.suffix !== "" || this.$slots.suffix !== void 0), t;
    }, wrapClasses() {
      return [`${un}-wrapper`, { [`${un}-wrapper-${this.size}`]: !!this.size, [`${un}-type-${this.type}`]: this.type, [`${un}-group`]: this.prepend || this.append || this.search && this.enterButton, [`${un}-group-${this.size}`]: (this.prepend || this.append || this.search && this.enterButton) && !!this.size, [`${un}-group-with-prepend`]: this.prepend, [`${un}-group-with-append`]: this.append || this.search && this.enterButton, [`${un}-hide-icon`]: this.append, [`${un}-with-search`]: this.search && this.enterButton, [`${un}-wrapper-disabled`]: this.itemDisabled }];
    }, inputClasses() {
      return [`${un}`, { [`${un}-${this.size}`]: !!this.size, [`${un}-disabled`]: this.itemDisabled, [`${un}-no-border`]: !this.border, [`${un}-with-prefix`]: this.showPrefix, [`${un}-with-suffix`]: this.showSuffix || this.search && this.enterButton === !1 }];
    }, textareaClasses() {
      return [`${un}`, { [`${un}-disabled`]: this.itemDisabled, [`${un}-no-border`]: !this.border }];
    }, upperLimit() {
      return this.maxlength;
    }, textLength() {
      return typeof this.modelValue == "number" ? String(this.modelValue).length : (this.modelValue || "").length;
    }, clearableStyles() {
      const t = {};
      let r = this.clearableIconOffset;
      return r && (t.transform = `translateX(-${r}px)`), t;
    } }, methods: { handleEnter(t) {
      this.$emit("on-enter", t), this.search && this.$emit("on-search", this.currentValue);
    }, handleKeydown(t) {
      this.$emit("on-keydown", t);
    }, handleKeypress(t) {
      this.$emit("on-keypress", t);
    }, handleKeyup(t) {
      this.$emit("on-keyup", t);
    }, handleIconClick(t) {
      this.$emit("on-click", t);
    }, handleFocus(t) {
      this.$emit("on-focus", t);
    }, handleBlur(t) {
      this.$emit("on-blur", t), me(this, ["DatePicker", "TimePicker", "Cascader", "Search"]) || this.handleFormItemChange("blur", this.currentValue);
    }, handleComposition(t) {
      t.type === "compositionstart" && (this.isOnComposition = !0), t.type === "compositionend" && (this.isOnComposition = !1, this.handleInput(t));
    }, handleInput(t) {
      if (this.isOnComposition)
        return;
      let r = t.target.value;
      this.number && r !== "" && (r = Number.isNaN(Number(r)) ? r : Number(r)), this.$emit("update:modelValue", r), this.setCurrentValue(r), this.$emit("on-change", t);
    }, handleChange(t) {
      this.$emit("on-input-change", t);
    }, setCurrentValue(t) {
      t !== this.currentValue && (e.nextTick(() => {
        this.resizeTextarea();
      }), this.currentValue = t, me(this, ["DatePicker", "TimePicker", "Cascader", "Search"]) || this.handleFormItemChange("change", t));
    }, resizeTextarea() {
      const t = this.autosize;
      if (!t || this.type !== "textarea")
        return !1;
      const r = t.minRows, o = t.maxRows;
      this.textareaStyles = GS(this.$refs.textarea, r, o);
    }, focus(t) {
      const r = this.type === "textarea" ? this.$refs.textarea : this.$refs.input;
      r.focus(t);
      const { cursor: o } = t || {};
      if (o) {
        const C = r.value.length;
        switch (o) {
          case "start":
            r.setSelectionRange(0, 0);
            break;
          case "end":
            r.setSelectionRange(C, C);
            break;
          default:
            r.setSelectionRange(0, C);
        }
      }
    }, blur() {
      this.type === "textarea" ? this.$refs.textarea.blur() : this.$refs.input.blur();
    }, handleClear() {
      const t = { target: { value: "" } };
      this.$emit("update:modelValue", ""), this.setCurrentValue(""), this.$emit("on-change", t), this.$emit("on-clear");
    }, handleSearch() {
      if (this.itemDisabled)
        return !1;
      this.$refs.input.focus(), this.$emit("on-search", this.currentValue);
    }, handleToggleShowPassword() {
      if (this.itemDisabled)
        return !1;
      this.showPassword = !this.showPassword, this.focus();
      const t = this.currentValue.length;
      setTimeout(() => {
        this.$refs.input.setSelectionRange(t, t);
      }, 0);
    }, handleCalcIconOffset() {
      const t = this.$el.querySelectorAll(".ivu-input-group-append")[0];
      t ? this.clearableIconOffset = t.offsetWidth : this.clearableIconOffset = 0;
    } }, watch: { modelValue(t) {
      this.setCurrentValue(t);
    }, type() {
      e.nextTick(this.handleCalcIconOffset);
    } }, mounted() {
      this.slotReady = !0, this.resizeTextarea(), this.handleCalcIconOffset();
    }, updated() {
      e.nextTick(this.handleCalcIconOffset);
    } }, qS = { key: 4, class: "ivu-input-suffix" }, JS = { key: 5, class: "ivu-input-word-count" }, QS = { key: 0, class: "ivu-icon ivu-icon-ios-eye-outline" }, ZS = { key: 1, class: "ivu-icon ivu-icon-ios-eye-off-outline" }, eE = ["id", "autocomplete", "spellcheck", "type", "placeholder", "disabled", "maxlength", "readonly", "name", "value", "number", "autofocus"], tE = { key: 0, class: "ivu-icon ivu-icon-ios-search" }, nE = { key: 9, class: "ivu-input-prefix" }, iE = ["id", "wrap", "autocomplete", "spellcheck", "placeholder", "disabled", "rows", "maxlength", "readonly", "name", "value", "autofocus"], rE = { key: 0, class: "ivu-input-word-count" };
    function sE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [o.type !== "textarea" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [a.prepend ? e.withDirectives((e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-group-prepend"]) }, [e.renderSlot(t.$slots, "prepend")], 2)), [[e.vShow, g.slotReady]]) : e.createCommentVNode("", !0), o.clearable && g.currentValue && !t.itemDisabled ? (e.openBlock(), e.createElementBlock("i", { key: 1, class: e.normalizeClass(["ivu-icon", ["ivu-icon-ios-close-circle", g.prefixCls + "-icon", g.prefixCls + "-icon-clear", g.prefixCls + "-icon-normal"]]), onClick: r[0] || (r[0] = (...x) => a.handleClear && a.handleClear(...x)), style: e.normalizeStyle(a.clearableStyles) }, null, 6)) : o.icon ? (e.openBlock(), e.createElementBlock("i", { key: 2, class: e.normalizeClass(["ivu-icon", ["ivu-icon-" + o.icon, g.prefixCls + "-icon", g.prefixCls + "-icon-normal"]]), onClick: r[1] || (r[1] = (...x) => a.handleIconClick && a.handleIconClick(...x)) }, null, 2)) : o.search && o.enterButton === !1 ? (e.openBlock(), e.createElementBlock("i", { key: 3, class: e.normalizeClass(["ivu-icon ivu-icon-ios-search", [g.prefixCls + "-icon", g.prefixCls + "-icon-normal", g.prefixCls + "-search-icon"]]), onClick: r[2] || (r[2] = (...x) => a.handleSearch && a.handleSearch(...x)) }, null, 2)) : a.showSuffix ? (e.openBlock(), e.createElementBlock("span", qS, [e.renderSlot(t.$slots, "suffix", {}, () => [o.suffix ? (e.openBlock(), e.createElementBlock("i", { key: 0, class: e.normalizeClass(["ivu-icon", ["ivu-icon-" + o.suffix]]) }, null, 2)) : e.createCommentVNode("", !0)])])) : o.showWordLimit ? (e.openBlock(), e.createElementBlock("span", JS, e.toDisplayString(a.textLength) + "/" + e.toDisplayString(a.upperLimit), 1)) : o.password ? (e.openBlock(), e.createElementBlock("span", { key: 6, class: "ivu-input-suffix", onClick: r[3] || (r[3] = (...x) => a.handleToggleShowPassword && a.handleToggleShowPassword(...x)) }, [g.showPassword ? (e.openBlock(), e.createElementBlock("i", QS)) : (e.openBlock(), e.createElementBlock("i", ZS))])) : e.createCommentVNode("", !0), e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [o.icon ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("i", { key: 0, class: e.normalizeClass(["ivu-icon ivu-icon-ios-loading ivu-load-loop", [g.prefixCls + "-icon", g.prefixCls + "-icon-validate"]]) }, null, 2))]), _: 1 }), e.createElementVNode("input", { id: o.elementId, autocomplete: o.autocomplete, spellcheck: o.spellcheck, ref: "input", type: a.currentType, class: e.normalizeClass(a.inputClasses), placeholder: o.placeholder, disabled: t.itemDisabled, maxlength: o.maxlength, readonly: o.readonly, name: o.name, value: g.currentValue, number: o.number, autofocus: o.autofocus, onKeyup: [r[4] || (r[4] = e.withKeys((...x) => a.handleEnter && a.handleEnter(...x), ["enter"])), r[5] || (r[5] = (...x) => a.handleKeyup && a.handleKeyup(...x))], onKeypress: r[6] || (r[6] = (...x) => a.handleKeypress && a.handleKeypress(...x)), onKeydown: r[7] || (r[7] = (...x) => a.handleKeydown && a.handleKeydown(...x)), onFocus: r[8] || (r[8] = (...x) => a.handleFocus && a.handleFocus(...x)), onBlur: r[9] || (r[9] = (...x) => a.handleBlur && a.handleBlur(...x)), onCompositionstart: r[10] || (r[10] = (...x) => a.handleComposition && a.handleComposition(...x)), onCompositionupdate: r[11] || (r[11] = (...x) => a.handleComposition && a.handleComposition(...x)), onCompositionend: r[12] || (r[12] = (...x) => a.handleComposition && a.handleComposition(...x)), onInput: r[13] || (r[13] = (...x) => a.handleInput && a.handleInput(...x)), onChange: r[14] || (r[14] = (...x) => a.handleChange && a.handleChange(...x)) }, null, 42, eE), a.append ? e.withDirectives((e.openBlock(), e.createElementBlock("div", { key: 7, class: e.normalizeClass([g.prefixCls + "-group-append"]) }, [e.renderSlot(t.$slots, "append")], 2)), [[e.vShow, g.slotReady]]) : o.search && o.enterButton ? (e.openBlock(), e.createElementBlock("div", { key: 8, class: e.normalizeClass([g.prefixCls + "-group-append", g.prefixCls + "-search"]), onClick: r[15] || (r[15] = (...x) => a.handleSearch && a.handleSearch(...x)) }, [o.enterButton === !0 ? (e.openBlock(), e.createElementBlock("i", tE)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(o.enterButton), 1)], 64))], 2)) : a.showPrefix ? (e.openBlock(), e.createElementBlock("span", nE, [e.renderSlot(t.$slots, "prefix", {}, () => [o.prefix ? (e.openBlock(), e.createElementBlock("i", { key: 0, class: e.normalizeClass(["ivu-icon", ["ivu-icon-" + o.prefix]]) }, null, 2)) : e.createCommentVNode("", !0)])])) : e.createCommentVNode("", !0)], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createElementVNode("textarea", { id: o.elementId, wrap: o.wrap, autocomplete: o.autocomplete, spellcheck: o.spellcheck, ref: "textarea", class: e.normalizeClass(a.textareaClasses), style: e.normalizeStyle(g.textareaStyles), placeholder: o.placeholder, disabled: t.itemDisabled, rows: o.rows, maxlength: o.maxlength, readonly: o.readonly, name: o.name, value: g.currentValue, autofocus: o.autofocus, onKeyup: [r[16] || (r[16] = e.withKeys((...x) => a.handleEnter && a.handleEnter(...x), ["enter"])), r[17] || (r[17] = (...x) => a.handleKeyup && a.handleKeyup(...x))], onKeypress: r[18] || (r[18] = (...x) => a.handleKeypress && a.handleKeypress(...x)), onKeydown: r[19] || (r[19] = (...x) => a.handleKeydown && a.handleKeydown(...x)), onFocus: r[20] || (r[20] = (...x) => a.handleFocus && a.handleFocus(...x)), onBlur: r[21] || (r[21] = (...x) => a.handleBlur && a.handleBlur(...x)), onCompositionstart: r[22] || (r[22] = (...x) => a.handleComposition && a.handleComposition(...x)), onCompositionupdate: r[23] || (r[23] = (...x) => a.handleComposition && a.handleComposition(...x)), onCompositionend: r[24] || (r[24] = (...x) => a.handleComposition && a.handleComposition(...x)), onInput: r[25] || (r[25] = (...x) => a.handleInput && a.handleInput(...x)) }, `
            `, 46, iE), o.showWordLimit ? (e.openBlock(), e.createElementBlock("span", rE, e.toDisplayString(a.textLength) + "/" + e.toDisplayString(a.upperLimit), 1)) : e.createCommentVNode("", !0)], 64))], 2);
    }
    var di = f(XS, [["render", sE]]);
    const oE = { name: "AutoComplete", mixins: [nn], components: { iSelect: ps, iOption: Zs, iInput: di }, emits: ["update:modelValue", "on-change", "on-search", "on-select", "on-focus", "on-blur", "on-clear"], props: { modelValue: { type: [String, Number], default: "" }, label: { type: [String, Number], default: "" }, data: { type: Array, default: () => [] }, disabled: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !1 }, placeholder: { type: String }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, icon: { type: String }, filterMethod: { type: [Function, Boolean], default: !1 }, placement: { validator(t) {
      return z(t, ["top", "bottom", "top-start", "bottom-start", "top-end", "bottom-end"]);
    }, default: "bottom-start" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, name: { type: String }, elementId: { type: String }, transferClassName: { type: String }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, eventsEnabled: { type: Boolean, default: !1 } }, data() {
      return { currentValue: this.modelValue, disableEmitChange: !1 };
    }, computed: { inputIcon() {
      let t = "";
      return this.clearable && this.currentValue && !this.disabled ? t = "ios-close-circle" : this.icon && (t = this.icon), t;
    }, filteredData() {
      return this.filterMethod ? this.data.filter((t) => this.filterMethod(this.currentValue, t)) : this.data;
    } }, watch: { modelValue(t) {
      this.currentValue !== t && (this.disableEmitChange = !0), this.currentValue = t;
    }, currentValue(t) {
      if (this.$refs.select.setQuery(t), this.$emit("update:modelValue", t), this.disableEmitChange) {
        this.disableEmitChange = !1;
        return;
      }
      this.$emit("on-change", t), this.handleFormItemChange("change", t);
    } }, methods: { remoteMethod(t) {
      this.$emit("on-search", t);
    }, handleSelect(t) {
      const r = t.value;
      r != null && (this.currentValue = r, this.$refs.input.blur(), this.$emit("on-select", r));
    }, handleFocus(t) {
      this.$emit("on-focus", t);
    }, handleBlur(t) {
      this.$emit("on-blur", t);
    }, handleClear() {
      !this.clearable || (this.currentValue = "", this.$refs.select.reset(), this.$emit("on-clear"));
    }, handleClickOutside() {
      e.nextTick(() => {
        this.$refs.input.blur();
      });
    } } };
    function aE(t, r, o, C, g, a) {
      const x = e.resolveComponent("i-input"), O = e.resolveComponent("i-option"), P = e.resolveComponent("i-select");
      return e.openBlock(), e.createBlock(P, { ref: "select", class: "ivu-auto-complete", label: o.label, disabled: t.itemDisabled, clearable: o.clearable, placeholder: o.placeholder, size: o.size, placement: o.placement, "model-value": g.currentValue, "transfer-class-name": o.transferClassName, filterable: "", remote: "", "auto-complete": "", "remote-method": a.remoteMethod, onOnSelect: a.handleSelect, onOnClickoutside: a.handleClickOutside, transfer: o.transfer, capture: o.capture, eventsEnabled: o.eventsEnabled }, { input: e.withCtx(() => [e.renderSlot(t.$slots, "input", {}, () => [e.createVNode(x, { "element-id": o.elementId, ref: "input", modelValue: g.currentValue, "onUpdate:modelValue": r[0] || (r[0] = (N) => g.currentValue = N), name: o.name, placeholder: o.placeholder, disabled: t.itemDisabled, size: o.size, icon: a.inputIcon, onOnClick: a.handleClear, onOnFocus: a.handleFocus, onOnBlur: a.handleBlur }, null, 8, ["element-id", "modelValue", "name", "placeholder", "disabled", "size", "icon", "onOnClick", "onOnFocus", "onOnBlur"])])]), default: e.withCtx(() => [e.renderSlot(t.$slots, "default", {}, () => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.filteredData, (N) => (e.openBlock(), e.createBlock(O, { value: N, key: N }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(N), 1)]), _: 2 }, 1032, ["value"]))), 128))])]), _: 3 }, 8, ["label", "disabled", "clearable", "placeholder", "size", "placement", "model-value", "transfer-class-name", "remote-method", "onOnSelect", "onOnClickoutside", "transfer", "capture", "eventsEnabled"]);
    }
    var Hm = f(oE, [["render", aE]]);
    const eo = "ivu-avatar", Um = ["small", "large", "default"], lE = { name: "Avatar", components: { Icon: G }, emits: ["on-error"], props: { shape: { validator(t) {
      return z(t, ["circle", "square"]);
    }, default: "circle" }, size: { type: [String, Number], default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, src: { type: String }, icon: { type: String }, customIcon: { type: String, default: "" } }, data() {
      return { prefixCls: eo, scale: 1, childrenWidth: 0, isSlotShow: !1, slotTemp: null };
    }, computed: { classes() {
      return [`${eo}`, `${eo}-${this.shape}`, { [`${eo}-image`]: !!this.src, [`${eo}-icon`]: !!this.icon || !!this.customIcon, [`${eo}-${this.size}`]: z(this.size, Um) }];
    }, styles() {
      let t = {};
      return this.size && !z(this.size, Um) && (t.width = `${this.size}px`, t.height = `${this.size}px`, t.lineHeight = `${this.size}px`, t.fontSize = `${this.size / 2}px`), t;
    }, childrenStyle() {
      let t = {};
      return this.isSlotShow && (t = { msTransform: `scale(${this.scale})`, WebkitTransform: `scale(${this.scale})`, transform: `scale(${this.scale})`, position: "absolute", display: "inline-block", left: `calc(50% - ${Math.round(this.childrenWidth / 2)}px)` }), t;
    } }, watch: { size(t, r) {
      t !== r && this.setScale();
    } }, methods: { setScale() {
      if (this.isSlotShow = !this.src && !this.icon, this.$refs.children) {
        this.childrenWidth = this.$refs.children.offsetWidth;
        const t = this.$el.getBoundingClientRect().width;
        t - 8 < this.childrenWidth ? this.scale = (t - 8) / this.childrenWidth : this.scale = 1;
      }
    }, handleError(t) {
      this.$emit("on-error", t);
    } }, beforeCreate() {
      this.slotTemp = this.$slots.default ? this.$slots.default() : null;
    }, mounted() {
      this.setScale();
    }, updated() {
      const t = this.$slots.default ? this.$slots.default() : null;
      t && t !== this.slotTemp && this.setScale();
    } }, cE = ["src"];
    function uE(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("span", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, [o.src ? (e.openBlock(), e.createElementBlock("img", { key: 0, src: o.src, onError: r[0] || (r[0] = (...O) => a.handleError && a.handleError(...O)) }, null, 40, cE)) : o.icon || o.customIcon ? (e.openBlock(), e.createBlock(x, { key: 1, type: o.icon, custom: o.customIcon }, null, 8, ["type", "custom"])) : (e.openBlock(), e.createElementBlock("span", { key: 2, ref: "children", class: e.normalizeClass([g.prefixCls + "-string"]), style: e.normalizeStyle(a.childrenStyle) }, [e.renderSlot(t.$slots, "default")], 6))], 6);
    }
    var Jo = f(lE, [["render", uE]]), Wm = { emits: ["on-popper-show", "on-popper-hide", "created", "update:modelValue"], props: { eventsEnabled: { type: Boolean, default: !1 }, placement: { type: String, default: "bottom" }, boundariesPadding: { type: Number, default: 5 }, reference: Object, popper: Object, offset: { default: 0 }, modelValue: { type: Boolean, default: !1 }, transition: String, options: { type: Object, default() {
      return { modifiers: { computeStyle: { gpuAcceleration: !1 }, preventOverflow: { boundariesElement: "window" } } };
    } } }, data() {
      return { visible: this.modelValue };
    }, watch: { modelValue: { immediate: !0, handler(t) {
      this.visible = t, this.$emit("update:modelValue", t);
    } }, visible(t) {
      t ? (this.handleIndexIncrease && this.handleIndexIncrease(), this.updatePopper(), this.$emit("on-popper-show")) : this.$emit("on-popper-hide"), this.$emit("update:modelValue", t);
    } }, methods: { createPopper() {
      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.placement))
        return;
      const t = this.options, r = this.popper || this.$refs.popper, o = this.reference || this.$refs.reference;
      !r || !o || (this.popperJS && this.popperJS.hasOwnProperty("destroy") && this.popperJS.destroy(), t.eventsEnabled = this.eventsEnabled, t.placement = this.placement, t.modifiers.offset || (t.modifiers.offset = {}), t.modifiers.offset.offset = this.offset, t.onCreate = () => {
        e.nextTick(this.updatePopper), this.$emit("created", this);
      }, this.popperJS = new cn(o, r, t));
    }, updatePopper() {
      this.popperJS ? this.popperJS.update() : this.createPopper();
    }, doDestroy() {
      this.visible || (this.popperJS.destroy(), this.popperJS = null);
    } }, updated() {
      e.nextTick(() => this.updatePopper());
    }, beforeUnmount() {
      this.popperJS && this.popperJS.destroy();
    } };
    const to = "ivu-tooltip", hE = { name: "Tooltip", mixins: [Wm], props: { placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom" }, content: { type: [String, Number], default: "" }, delay: { type: Number, default: 100 }, disabled: { type: Boolean, default: !1 }, controlled: { type: Boolean, default: !1 }, always: { type: Boolean, default: !1 }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, theme: { validator(t) {
      return z(t, ["dark", "light"]);
    }, default: "dark" }, maxWidth: { type: [String, Number] }, transferClassName: { type: String } }, data() {
      return { prefixCls: to, tIndex: this.handleGetIndex() };
    }, computed: { innerStyles() {
      const t = {};
      return this.maxWidth && (t["max-width"] = `${this.maxWidth}px`), t;
    }, innerClasses() {
      return [`${to}-inner`, { [`${to}-inner-with-width`]: !!this.maxWidth }];
    }, dropStyles() {
      let t = {};
      return this.transfer && (t["z-index"] = 1060 + this.tIndex), t;
    }, dropdownCls() {
      return [`${to}-popper`, `${to}-${this.theme}`, { [to + "-transfer"]: this.transfer, [this.transferClassName]: this.transferClassName }];
    } }, watch: { content() {
      this.updatePopper();
    } }, methods: { handleShowPopper() {
      this.timeout && clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.visible = !0;
      }, this.delay), this.tIndex = this.handleGetIndex();
    }, handleClosePopper() {
      this.timeout && (clearTimeout(this.timeout), this.controlled || (this.timeout = setTimeout(() => {
        this.visible = !1;
      }, 100)));
    }, handleGetIndex() {
      return Vn(), Ut;
    } }, mounted() {
      this.always && this.updatePopper();
    } };
    function dE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls]), onMouseenter: r[2] || (r[2] = (...x) => a.handleShowPopper && a.handleShowPopper(...x)), onMouseleave: r[3] || (r[3] = (...x) => a.handleClosePopper && a.handleClosePopper(...x)) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-rel"]), ref: "reference" }, [e.renderSlot(t.$slots, "default")], 2), (e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", { ref: "popper", class: e.normalizeClass(a.dropdownCls), style: e.normalizeStyle(a.dropStyles), onMouseenter: r[0] || (r[0] = (...x) => a.handleShowPopper && a.handleShowPopper(...x)), onMouseleave: r[1] || (r[1] = (...x) => a.handleClosePopper && a.handleClosePopper(...x)) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-arrow"]) }, null, 2), e.createElementVNode("div", { class: e.normalizeClass(a.innerClasses), style: e.normalizeStyle(a.innerStyles) }, [e.renderSlot(t.$slots, "content", {}, () => [e.createTextVNode(e.toDisplayString(o.content), 1)])], 6)], 2)], 38), [[e.vShow, !o.disabled && (t.visible || o.always)]])]), _: 3 })], 8, ["disabled"]))], 34);
    }
    var tr = f(hE, [["render", dE]]);
    const fE = { name: "AvatarList", components: { Avatar: Jo, Tooltip: tr }, props: { list: { type: Array, default() {
      return [];
    } }, shape: { validator(t) {
      return z(t, ["circle", "square"]);
    }, default: "circle" }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default: "default" }, excessStyle: { type: Object, default() {
      return {};
    } }, max: { type: Number }, tooltip: { type: Boolean, default: !0 }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "top" } }, computed: { currentList() {
      const t = this.list.length, r = this.max;
      return t <= r ? [...this.list] : [...this.list].slice(0, r);
    } } }, pE = { key: 0, class: "ivu-avatar-list-item ivu-avatar-list-item-excess" }, mE = { key: 1, class: "ivu-avatar-list-item ivu-avatar-list-item-excess" };
    function gE(t, r, o, C, g, a) {
      const x = e.resolveComponent("Avatar"), O = e.resolveComponent("Tooltip");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-avatar-list", "ivu-avatar-list-" + o.size]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.currentList, (P, N) => (e.openBlock(), e.createElementBlock("div", { class: "ivu-avatar-list-item", key: N }, [o.tooltip && P.tip ? (e.openBlock(), e.createBlock(O, { key: 0, content: P.tip, placement: o.placement }, { default: e.withCtx(() => [e.createVNode(x, { src: P.src, size: o.size, shape: o.shape }, null, 8, ["src", "size", "shape"])]), _: 2 }, 1032, ["content", "placement"])) : (e.openBlock(), e.createBlock(x, { key: 1, src: P.src, size: o.size, shape: o.shape }, null, 8, ["src", "size", "shape"]))]))), 128)), t.$slots.extra ? (e.openBlock(), e.createElementBlock("div", pE, [e.createVNode(x, { size: o.size, shape: o.shape, style: e.normalizeStyle(o.excessStyle) }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "extra")]), _: 3 }, 8, ["size", "shape", "style"])])) : o.list.length > o.max ? (e.openBlock(), e.createElementBlock("div", mE, [e.createVNode(x, { size: o.size, shape: o.shape, style: e.normalizeStyle(o.excessStyle) }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "excess", {}, () => [e.createTextVNode("+" + e.toDisplayString(o.list.length - o.max), 1)])]), _: 3 }, 8, ["size", "shape", "style"])])) : e.createCommentVNode("", !0)], 2);
    }
    var Ym = f(fE, [["render", gE]]);
    const Bh = "ivu-back-top", vE = { name: "BackTop", emits: ["on-click"], props: { height: { type: Number, default: 400 }, bottom: { type: Number, default: 30 }, right: { type: Number, default: 30 }, duration: { type: Number, default: 1e3 } }, data() {
      return { backTop: !1 };
    }, mounted() {
      m(window, "scroll", this.handleScroll), m(window, "resize", this.handleScroll);
    }, beforeUnmount() {
      b(window, "scroll", this.handleScroll), b(window, "resize", this.handleScroll);
    }, computed: { classes() {
      return [`${Bh}`, { [`${Bh}-show`]: this.backTop }];
    }, styles() {
      return { bottom: `${this.bottom}px`, right: `${this.right}px` };
    }, innerClasses() {
      return `${Bh}-inner`;
    } }, methods: { handleScroll() {
      !h || (this.backTop = window.pageYOffset >= this.height);
    }, back() {
      if (!h)
        return;
      const t = document.documentElement.scrollTop || document.body.scrollTop;
      Y(window, t, 0, this.duration), this.$emit("on-click");
    } } }, yE = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-arrow-up" }, null, -1)];
    function bE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles), onClick: r[0] || (r[0] = (...x) => a.back && a.back(...x)) }, [e.renderSlot(t.$slots, "default", {}, () => [e.createElementVNode("div", { class: e.normalizeClass(a.innerClasses) }, yE, 2)])], 6);
    }
    var Km = f(vE, [["render", bE]]);
    const Gm = ["blue", "green", "red", "yellow", "pink", "magenta", "volcano", "orange", "gold", "lime", "cyan", "geekblue", "purple"], $i = "ivu-badge", CE = { name: "Badge", props: { count: Number, dot: { type: Boolean, default: !1 }, overflowCount: { type: [Number, String], default: 99 }, className: String, showZero: { type: Boolean, default: !1 }, text: { type: String, default: "" }, status: { validator(t) {
      return z(t, ["success", "processing", "default", "error", "warning"]);
    } }, type: { validator(t) {
      return z(t, ["success", "primary", "normal", "error", "warning", "info"]);
    } }, offset: { type: Array }, color: { type: String } }, computed: { classes() {
      return `${$i}`;
    }, dotClasses() {
      return `${$i}-dot`;
    }, countClasses() {
      return [`${$i}-count`, { [`${this.className}`]: !!this.className, [`${$i}-count-alone`]: this.alone, [`${$i}-count-${this.type}`]: !!this.type }];
    }, customCountClasses() {
      return [`${$i}-count`, `${$i}-count-custom`, { [`${this.className}`]: !!this.className }];
    }, statusClasses() {
      return [`${$i}-status-dot`, { [`${$i}-status-${this.status}`]: !!this.status, [`${$i}-status-${this.color}`]: !!this.color && z(this.color, Gm) }];
    }, statusStyles() {
      return z(this.color, Gm) ? {} : { backgroundColor: this.color };
    }, styles() {
      const t = {};
      return this.offset && this.offset.length === 2 && (t["margin-top"] = `${this.offset[0]}px`, t["margin-right"] = `${this.offset[1]}px`), t;
    }, finalCount() {
      return this.text !== "" ? this.text : parseInt(this.count) >= parseInt(this.overflowCount) ? `${this.overflowCount}+` : this.count;
    }, badge() {
      let t = !1;
      return this.count && (t = parseInt(this.count) !== 0), this.dot && (t = !0, this.count !== null && parseInt(this.count) === 0 && (t = !1)), this.text !== "" && (t = !0), t || this.showZero;
    }, hasCount() {
      return !!(this.count || this.text !== "" || this.showZero && parseInt(this.count) === 0);
    }, alone() {
      return this.$slots.default === void 0;
    } } }, wE = { class: "ivu-badge-status-text" };
    function kE(t, r, o, C, g, a) {
      return o.dot ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.classes), ref: "badge" }, [e.renderSlot(t.$slots, "default"), e.withDirectives(e.createElementVNode("sup", { class: e.normalizeClass(a.dotClasses), style: e.normalizeStyle(a.styles) }, null, 6), [[e.vShow, a.badge]])], 2)) : o.status || o.color ? (e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass([a.classes, "ivu-badge-status"]), ref: "badge" }, [e.createElementVNode("span", { class: e.normalizeClass(a.statusClasses), style: e.normalizeStyle(a.statusStyles) }, null, 6), e.createElementVNode("span", wE, [e.renderSlot(t.$slots, "text", {}, () => [e.createTextVNode(e.toDisplayString(o.text), 1)])])], 2)) : (e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass(a.classes), ref: "badge" }, [e.renderSlot(t.$slots, "default"), t.$slots.count ? (e.openBlock(), e.createElementBlock("sup", { key: 0, style: e.normalizeStyle(a.styles), class: e.normalizeClass(a.customCountClasses) }, [e.renderSlot(t.$slots, "count")], 6)) : a.hasCount ? e.withDirectives((e.openBlock(), e.createElementBlock("sup", { key: 1, style: e.normalizeStyle(a.styles), class: e.normalizeClass(a.countClasses) }, [e.renderSlot(t.$slots, "text", {}, () => [e.createTextVNode(e.toDisplayString(a.finalCount), 1)])], 6)), [[e.vShow, a.badge]]) : e.createCommentVNode("", !0)], 2));
    }
    var ql = f(CE, [["render", kE]]);
    const SE = { name: "Breadcrumb", provide() {
      return { BreadcrumbInstance: this };
    }, props: { separator: { type: String, default: "/" } } }, EE = { class: "ivu-breadcrumb" };
    function xE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", EE, [e.renderSlot(t.$slots, "default")]);
    }
    var Ph = f(SE, [["render", xE]]);
    const Xm = "ivu-breadcrumb-item", _E = { name: "BreadcrumbItem", mixins: [je], inject: ["BreadcrumbInstance"], props: {}, data() {
      return { showSeparator: !1 };
    }, computed: { linkClasses() {
      return `${Xm}-link`;
    }, separatorClasses() {
      return `${Xm}-separator`;
    }, separator() {
      return this.BreadcrumbInstance.separator;
    } }, mounted() {
      this.showSeparator = this.$slots.separator !== void 0;
    } }, TE = ["href", "target"], OE = ["innerHTML"];
    function DE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", null, [t.to ? (e.openBlock(), e.createElementBlock("a", { key: 0, href: t.linkUrl, target: t.target, class: e.normalizeClass(a.linkClasses), onClick: [r[0] || (r[0] = e.withModifiers((x) => t.handleCheckClick(x, !1), ["exact"])), r[1] || (r[1] = e.withModifiers((x) => t.handleCheckClick(x, !0), ["ctrl"])), r[2] || (r[2] = e.withModifiers((x) => t.handleCheckClick(x, !0), ["meta"]))] }, [e.renderSlot(t.$slots, "default")], 10, TE)) : (e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass(a.linkClasses) }, [e.renderSlot(t.$slots, "default")], 2)), g.showSeparator ? (e.openBlock(), e.createElementBlock("span", { key: 3, class: e.normalizeClass(a.separatorClasses) }, [e.renderSlot(t.$slots, "separator")], 2)) : (e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass(a.separatorClasses), innerHTML: a.separator }, null, 10, OE))]);
    }
    var Vh = f(_E, [["render", DE]]);
    const Sr = "ivu-btn", zn = { name: "Button", mixins: [je, nn], components: { Icon: G }, emits: ["click"], props: { type: { validator(t) {
      return z(t, ["default", "primary", "dashed", "text", "info", "success", "warning", "error"]);
    }, default: "default" }, shape: { validator(t) {
      return z(t, ["circle", "circle-outline"]);
    } }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, loading: Boolean, disabled: Boolean, htmlType: { default: "button", validator(t) {
      return z(t, ["button", "submit", "reset"]);
    } }, icon: { type: String, default: "" }, customIcon: { type: String, default: "" }, long: { type: Boolean, default: !1 }, ghost: { type: Boolean, default: !1 } }, computed: { showSlot() {
      return !!this.$slots.default;
    }, classes() {
      return [`${Sr}`, `${Sr}-${this.type}`, { [`${Sr}-long`]: this.long, [`${Sr}-${this.shape}`]: !!this.shape, [`${Sr}-${this.size}`]: this.size !== "default", [`${Sr}-loading`]: this.loading != null && this.loading, [`${Sr}-icon-only`]: !this.showSlot && (!!this.icon || !!this.customIcon || this.loading), [`${Sr}-ghost`]: this.ghost }];
    }, isHrefPattern() {
      const { to: t } = this;
      return !!t;
    }, tagName() {
      const { isHrefPattern: t } = this;
      return t ? "a" : "button";
    }, tagProps() {
      const { isHrefPattern: t } = this;
      if (t) {
        const { linkUrl: r, target: o } = this;
        return { href: r, target: o };
      } else {
        const { htmlType: r } = this;
        return { type: r };
      }
    } }, methods: { handleClickLink(t) {
      this.$emit("click", t);
      const r = t.ctrlKey || t.metaKey;
      this.handleCheckClick(t, r);
    } }, render() {
      let t;
      this.tagName === "button" ? t = "button" : this.tagName === "a" && (t = "a");
      let r = [];
      return this.loading && r.push(e.h(G, { class: "ivu-load-loop", type: "ios-loading" })), (this.icon || this.customIcon) && !this.loading && r.push(e.h(G, { type: this.icon, custom: this.customIcon })), this.$slots.default && r.push(e.h("span", { ref: "slot" }, this.$slots.default())), e.h(t, p({ class: this.classes, disabled: this.itemDisabled, onClick: this.handleClickLink }, this.tagProps), r);
    } }, Jl = "ivu-btn-group", NE = { name: "ButtonGroup", props: { size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, shape: { validator(t) {
      return z(t, ["circle", "circle-outline"]);
    } }, vertical: { type: Boolean, default: !1 } }, computed: { classes() {
      return [`${Jl}`, { [`${Jl}-${this.size}`]: !!this.size, [`${Jl}-${this.shape}`]: !!this.shape, [`${Jl}-vertical`]: this.vertical }];
    } } };
    function BE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var $h = f(NE, [["render", BE]]);
    const Qo = "ivu-radio-group";
    let PE = 0;
    const VE = Date.now(), $E = { name: "RadioGroup", mixins: [nn], emits: ["update:modelValue", "on-change"], provide() {
      return { RadioGroupInstance: this };
    }, props: { modelValue: { type: [String, Number], default: "" }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, type: { validator(t) {
      return z(t, ["button"]);
    } }, vertical: { type: Boolean, default: !1 }, name: { type: String, default: () => `ivuRadioGroup_${VE}_${PE++}` }, buttonStyle: { validator(t) {
      return z(t, ["default", "solid"]);
    }, default: "default" } }, data() {
      return { currentValue: this.modelValue, children: [] };
    }, computed: { classes() {
      return [`${Qo}`, { [`${Qo}-${this.size}`]: !!this.size, [`ivu-radio-${this.size}`]: !!this.size, [`${Qo}-${this.type}`]: !!this.type, [`${Qo}-button-${this.buttonStyle}`]: this.type === "button" && this.buttonStyle !== "default", [`${Qo}-vertical`]: this.vertical }];
    } }, methods: { change(t) {
      this.currentValue = t.value, this.$emit("update:modelValue", t.value), this.$emit("on-change", t.value), this.handleFormItemChange("change", t.value);
    } }, watch: { modelValue() {
      this.currentValue !== this.modelValue && (this.currentValue = this.modelValue);
    } } }, IE = ["name"];
    function ME(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), name: o.name }, [e.renderSlot(t.$slots, "default")], 10, IE);
    }
    var Ql = f($E, [["render", ME]]);
    const Qn = "ivu-radio", AE = { name: "Radio", mixins: [nn], emits: ["update:modelValue", "on-change"], inject: { RadioGroupInstance: { default: null } }, props: { modelValue: { type: [String, Number, Boolean], default: !1 }, trueValue: { type: [String, Number, Boolean], default: !0 }, falseValue: { type: [String, Number, Boolean], default: !1 }, label: { type: [String, Number] }, disabled: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, name: { type: String }, border: { type: Boolean, default: !1 } }, data() {
      return { groupName: this.name, parent: this.RadioGroupInstance, focusWrapper: !1, focusInner: !1 };
    }, computed: { wrapClasses() {
      return [`${Qn}-wrapper`, { [`${Qn}-group-item`]: this.group, [`${Qn}-wrapper-checked`]: this.currentValue, [`${Qn}-wrapper-disabled`]: this.itemDisabled, [`${Qn}-${this.size}`]: !!this.size, [`${Qn}-focus`]: this.focusWrapper, [`${Qn}-border`]: this.border }];
    }, radioClasses() {
      return [`${Qn}`, { [`${Qn}-checked`]: this.currentValue, [`${Qn}-disabled`]: this.itemDisabled }];
    }, innerClasses() {
      return [`${Qn}-inner`, { [`${Qn}-focus`]: this.focusInner }];
    }, inputClasses() {
      return `${Qn}-input`;
    }, currentValue() {
      return this.RadioGroupInstance ? this.RadioGroupInstance.currentValue === this.label : this.modelValue === this.trueValue;
    }, group() {
      return !!this.RadioGroupInstance;
    } }, mounted() {
      this.parent && (this.name && this.name !== this.parent.name ? console.warn && console.warn("[View UI] Name does not match Radio Group name.") : this.groupName = this.parent.name);
    }, methods: { change(t) {
      if (this.itemDisabled)
        return !1;
      const r = t.target.checked ? this.trueValue : this.falseValue;
      this.$emit("update:modelValue", r), this.group ? this.label !== void 0 && this.parent.change({ value: this.label, checked: this.modelValue }) : (this.$emit("on-change", r), this.handleFormItemChange("change", r));
    }, onBlur() {
      this.focusWrapper = !1, this.focusInner = !1;
    }, onFocus() {
      this.group && this.parent.type === "button" ? this.focusWrapper = !0 : this.focusInner = !0;
    } }, watch: { modelValue(t) {
      if (!(t === this.trueValue || t === this.falseValue))
        throw "Value should be trueValue or falseValue.";
    } } }, FE = ["disabled", "checked", "name"];
    function LE(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("label", { class: e.normalizeClass(a.wrapClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.radioClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.innerClasses) }, null, 2), e.createElementVNode("input", { type: "radio", class: e.normalizeClass(a.inputClasses), disabled: t.itemDisabled, checked: a.currentValue, name: g.groupName, onChange: r[0] || (r[0] = (...x) => a.change && a.change(...x)), onFocus: r[1] || (r[1] = (...x) => a.onFocus && a.onFocus(...x)), onBlur: r[2] || (r[2] = (...x) => a.onBlur && a.onBlur(...x)) }, null, 42, FE)], 2), e.renderSlot(t.$slots, "default", {}, () => [e.createTextVNode(e.toDisplayString(o.label), 1)])], 2);
    }
    var Zl = f(AE, [["render", LE]]), qm = { exports: {} };
    (function(t, r) {
      (function(o, C) {
        t.exports = C();
      })(pt, function() {
        var o = 1e3, C = 6e4, g = 36e5, a = "millisecond", x = "second", O = "minute", P = "hour", N = "day", B = "week", H = "month", oe = "quarter", se = "year", ee = "date", j = "Invalid Date", pe = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, at = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, Qe = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, tt = function(Ue, Ke, qe) {
          var mt = String(Ue);
          return !mt || mt.length >= Ke ? Ue : "" + Array(Ke + 1 - mt.length).join(qe) + Ue;
        }, Ee = { s: tt, z: function(Ue) {
          var Ke = -Ue.utcOffset(), qe = Math.abs(Ke), mt = Math.floor(qe / 60), et = qe % 60;
          return (Ke <= 0 ? "+" : "-") + tt(mt, 2, "0") + ":" + tt(et, 2, "0");
        }, m: function Ue(Ke, qe) {
          if (Ke.date() < qe.date())
            return -Ue(qe, Ke);
          var mt = 12 * (qe.year() - Ke.year()) + (qe.month() - Ke.month()), et = Ke.clone().add(mt, H), St = qe - et < 0, yt = Ke.clone().add(mt + (St ? -1 : 1), H);
          return +(-(mt + (qe - et) / (St ? et - yt : yt - et)) || 0);
        }, a: function(Ue) {
          return Ue < 0 ? Math.ceil(Ue) || 0 : Math.floor(Ue);
        }, p: function(Ue) {
          return { M: H, y: se, w: B, d: N, D: ee, h: P, m: O, s: x, ms: a, Q: oe }[Ue] || String(Ue || "").toLowerCase().replace(/s$/, "");
        }, u: function(Ue) {
          return Ue === void 0;
        } }, ye = "en", ze = {};
        ze[ye] = Qe;
        var Oe = function(Ue) {
          return Ue instanceof kt;
        }, lt = function Ue(Ke, qe, mt) {
          var et;
          if (!Ke)
            return ye;
          if (typeof Ke == "string") {
            var St = Ke.toLowerCase();
            ze[St] && (et = St), qe && (ze[St] = qe, et = St);
            var yt = Ke.split("-");
            if (!et && yt.length > 1)
              return Ue(yt[0]);
          } else {
            var ht = Ke.name;
            ze[ht] = Ke, et = ht;
          }
          return !mt && et && (ye = et), et || !mt && ye;
        }, it = function(Ue, Ke) {
          if (Oe(Ue))
            return Ue.clone();
          var qe = typeof Ke == "object" ? Ke : {};
          return qe.date = Ue, qe.args = arguments, new kt(qe);
        }, Ze = Ee;
        Ze.l = lt, Ze.i = Oe, Ze.w = function(Ue, Ke) {
          return it(Ue, { locale: Ke.$L, utc: Ke.$u, x: Ke.$x, $offset: Ke.$offset });
        };
        var kt = function() {
          function Ue(qe) {
            this.$L = lt(qe.locale, null, !0), this.parse(qe);
          }
          var Ke = Ue.prototype;
          return Ke.parse = function(qe) {
            this.$d = function(mt) {
              var et = mt.date, St = mt.utc;
              if (et === null)
                return /* @__PURE__ */ new Date(NaN);
              if (Ze.u(et))
                return /* @__PURE__ */ new Date();
              if (et instanceof Date)
                return new Date(et);
              if (typeof et == "string" && !/Z$/i.test(et)) {
                var yt = et.match(pe);
                if (yt) {
                  var ht = yt[2] - 1 || 0, Rt = (yt[7] || "0").substring(0, 3);
                  return St ? new Date(Date.UTC(yt[1], ht, yt[3] || 1, yt[4] || 0, yt[5] || 0, yt[6] || 0, Rt)) : new Date(yt[1], ht, yt[3] || 1, yt[4] || 0, yt[5] || 0, yt[6] || 0, Rt);
                }
              }
              return new Date(et);
            }(qe), this.$x = qe.x || {}, this.init();
          }, Ke.init = function() {
            var qe = this.$d;
            this.$y = qe.getFullYear(), this.$M = qe.getMonth(), this.$D = qe.getDate(), this.$W = qe.getDay(), this.$H = qe.getHours(), this.$m = qe.getMinutes(), this.$s = qe.getSeconds(), this.$ms = qe.getMilliseconds();
          }, Ke.$utils = function() {
            return Ze;
          }, Ke.isValid = function() {
            return this.$d.toString() !== j;
          }, Ke.isSame = function(qe, mt) {
            var et = it(qe);
            return this.startOf(mt) <= et && et <= this.endOf(mt);
          }, Ke.isAfter = function(qe, mt) {
            return it(qe) < this.startOf(mt);
          }, Ke.isBefore = function(qe, mt) {
            return this.endOf(mt) < it(qe);
          }, Ke.$g = function(qe, mt, et) {
            return Ze.u(qe) ? this[mt] : this.set(et, qe);
          }, Ke.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, Ke.valueOf = function() {
            return this.$d.getTime();
          }, Ke.startOf = function(qe, mt) {
            var et = this, St = !!Ze.u(mt) || mt, yt = Ze.p(qe), ht = function(Hn, We) {
              var gt = Ze.w(et.$u ? Date.UTC(et.$y, We, Hn) : new Date(et.$y, We, Hn), et);
              return St ? gt : gt.endOf(N);
            }, Rt = function(Hn, We) {
              return Ze.w(et.toDate()[Hn].apply(et.toDate("s"), (St ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(We)), et);
            }, Tt = this.$W, qt = this.$M, Tn = this.$D, Wt = "set" + (this.$u ? "UTC" : "");
            switch (yt) {
              case se:
                return St ? ht(1, 0) : ht(31, 11);
              case H:
                return St ? ht(1, qt) : ht(0, qt + 1);
              case B:
                var gn = this.$locale().weekStart || 0, mi = (Tt < gn ? Tt + 7 : Tt) - gn;
                return ht(St ? Tn - mi : Tn + (6 - mi), qt);
              case N:
              case ee:
                return Rt(Wt + "Hours", 0);
              case P:
                return Rt(Wt + "Minutes", 1);
              case O:
                return Rt(Wt + "Seconds", 2);
              case x:
                return Rt(Wt + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, Ke.endOf = function(qe) {
            return this.startOf(qe, !1);
          }, Ke.$set = function(qe, mt) {
            var et, St = Ze.p(qe), yt = "set" + (this.$u ? "UTC" : ""), ht = (et = {}, et[N] = yt + "Date", et[ee] = yt + "Date", et[H] = yt + "Month", et[se] = yt + "FullYear", et[P] = yt + "Hours", et[O] = yt + "Minutes", et[x] = yt + "Seconds", et[a] = yt + "Milliseconds", et)[St], Rt = St === N ? this.$D + (mt - this.$W) : mt;
            if (St === H || St === se) {
              var Tt = this.clone().set(ee, 1);
              Tt.$d[ht](Rt), Tt.init(), this.$d = Tt.set(ee, Math.min(this.$D, Tt.daysInMonth())).$d;
            } else
              ht && this.$d[ht](Rt);
            return this.init(), this;
          }, Ke.set = function(qe, mt) {
            return this.clone().$set(qe, mt);
          }, Ke.get = function(qe) {
            return this[Ze.p(qe)]();
          }, Ke.add = function(qe, mt) {
            var et, St = this;
            qe = Number(qe);
            var yt = Ze.p(mt), ht = function(qt) {
              var Tn = it(St);
              return Ze.w(Tn.date(Tn.date() + Math.round(qt * qe)), St);
            };
            if (yt === H)
              return this.set(H, this.$M + qe);
            if (yt === se)
              return this.set(se, this.$y + qe);
            if (yt === N)
              return ht(1);
            if (yt === B)
              return ht(7);
            var Rt = (et = {}, et[O] = C, et[P] = g, et[x] = o, et)[yt] || 1, Tt = this.$d.getTime() + qe * Rt;
            return Ze.w(Tt, this);
          }, Ke.subtract = function(qe, mt) {
            return this.add(-1 * qe, mt);
          }, Ke.format = function(qe) {
            var mt = this, et = this.$locale();
            if (!this.isValid())
              return et.invalidDate || j;
            var St = qe || "YYYY-MM-DDTHH:mm:ssZ", yt = Ze.z(this), ht = this.$H, Rt = this.$m, Tt = this.$M, qt = et.weekdays, Tn = et.months, Wt = function(We, gt, It, vn) {
              return We && (We[gt] || We(mt, St)) || It[gt].substr(0, vn);
            }, gn = function(We) {
              return Ze.s(ht % 12 || 12, We, "0");
            }, mi = et.meridiem || function(We, gt, It) {
              var vn = We < 12 ? "AM" : "PM";
              return It ? vn.toLowerCase() : vn;
            }, Hn = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: Tt + 1, MM: Ze.s(Tt + 1, 2, "0"), MMM: Wt(et.monthsShort, Tt, Tn, 3), MMMM: Wt(Tn, Tt), D: this.$D, DD: Ze.s(this.$D, 2, "0"), d: String(this.$W), dd: Wt(et.weekdaysMin, this.$W, qt, 2), ddd: Wt(et.weekdaysShort, this.$W, qt, 3), dddd: qt[this.$W], H: String(ht), HH: Ze.s(ht, 2, "0"), h: gn(1), hh: gn(2), a: mi(ht, Rt, !0), A: mi(ht, Rt, !1), m: String(Rt), mm: Ze.s(Rt, 2, "0"), s: String(this.$s), ss: Ze.s(this.$s, 2, "0"), SSS: Ze.s(this.$ms, 3, "0"), Z: yt };
            return St.replace(at, function(We, gt) {
              return gt || Hn[We] || yt.replace(":", "");
            });
          }, Ke.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, Ke.diff = function(qe, mt, et) {
            var St, yt = Ze.p(mt), ht = it(qe), Rt = (ht.utcOffset() - this.utcOffset()) * C, Tt = this - ht, qt = Ze.m(this, ht);
            return qt = (St = {}, St[se] = qt / 12, St[H] = qt, St[oe] = qt / 3, St[B] = (Tt - Rt) / 6048e5, St[N] = (Tt - Rt) / 864e5, St[P] = Tt / g, St[O] = Tt / C, St[x] = Tt / o, St)[yt] || Tt, et ? qt : Ze.a(qt);
          }, Ke.daysInMonth = function() {
            return this.endOf(H).$D;
          }, Ke.$locale = function() {
            return ze[this.$L];
          }, Ke.locale = function(qe, mt) {
            if (!qe)
              return this.$L;
            var et = this.clone(), St = lt(qe, mt, !0);
            return St && (et.$L = St), et;
          }, Ke.clone = function() {
            return Ze.w(this.$d, this);
          }, Ke.toDate = function() {
            return new Date(this.valueOf());
          }, Ke.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, Ke.toISOString = function() {
            return this.$d.toISOString();
          }, Ke.toString = function() {
            return this.$d.toUTCString();
          }, Ue;
        }(), ot = kt.prototype;
        return it.prototype = ot, [["$ms", a], ["$s", x], ["$m", O], ["$H", P], ["$W", N], ["$M", H], ["$y", se], ["$D", ee]].forEach(function(Ue) {
          ot[Ue[1]] = function(Ke) {
            return this.$g(Ke, Ue[0], Ue[1]);
          };
        }), it.extend = function(Ue, Ke) {
          return Ue.$i || (Ue(Ke, kt, it), Ue.$i = !0), it;
        }, it.locale = lt, it.isDayjs = Oe, it.unix = function(Ue) {
          return it(1e3 * Ue);
        }, it.en = ze[ye], it.Ls = ze, it.p = {}, it;
      });
    })(qm);
    var Zn = qm.exports, Jm = 1 / 0, Qm = 9007199254740991, zE = 17976931348623157e292, Zm = NaN, RE = "[object Function]", jE = "[object GeneratorFunction]", HE = "[object Symbol]", UE = /^\s+|\s+$/g, WE = /^[-+]0x[0-9a-f]+$/i, YE = /^0b[01]+$/i, KE = /^0o[0-7]+$/i, GE = /^(?:0|[1-9]\d*)$/, XE = parseInt, qE = Object.prototype, eg = qE.toString, JE = Math.ceil, QE = Math.max;
    function ZE(t, r, o) {
      var C = -1, g = t.length;
      r < 0 && (r = -r > g ? 0 : g + r), o = o > g ? g : o, o < 0 && (o += g), g = r > o ? 0 : o - r >>> 0, r >>>= 0;
      for (var a = Array(g); ++C < g; )
        a[C] = t[C + r];
      return a;
    }
    function ex(t, r) {
      return r = r ?? Qm, !!r && (typeof t == "number" || GE.test(t)) && t > -1 && t % 1 == 0 && t < r;
    }
    function tx(t, r, o) {
      if (!ec(o))
        return !1;
      var C = typeof r;
      return (C == "number" ? rx(o) && ex(r, o.length) : C == "string" && r in o) ? ix(o[r], t) : !1;
    }
    function nx(t, r, o) {
      (o ? tx(t, r, o) : r === void 0) ? r = 1 : r = QE(ux(r), 0);
      var C = t ? t.length : 0;
      if (!C || r < 1)
        return [];
      for (var g = 0, a = 0, x = Array(JE(C / r)); g < C; )
        x[a++] = ZE(t, g, g += r);
      return x;
    }
    function ix(t, r) {
      return t === r || t !== t && r !== r;
    }
    function rx(t) {
      return t != null && ox(t.length) && !sx(t);
    }
    function sx(t) {
      var r = ec(t) ? eg.call(t) : "";
      return r == RE || r == jE;
    }
    function ox(t) {
      return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Qm;
    }
    function ec(t) {
      var r = typeof t;
      return !!t && (r == "object" || r == "function");
    }
    function ax(t) {
      return !!t && typeof t == "object";
    }
    function lx(t) {
      return typeof t == "symbol" || ax(t) && eg.call(t) == HE;
    }
    function cx(t) {
      if (!t)
        return t === 0 ? t : 0;
      if (t = hx(t), t === Jm || t === -Jm) {
        var r = t < 0 ? -1 : 1;
        return r * zE;
      }
      return t === t ? t : 0;
    }
    function ux(t) {
      var r = cx(t), o = r % 1;
      return r === r ? o ? r - o : r : 0;
    }
    function hx(t) {
      if (typeof t == "number")
        return t;
      if (lx(t))
        return Zm;
      if (ec(t)) {
        var r = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = ec(r) ? r + "" : r;
      }
      if (typeof t != "string")
        return t === 0 ? t : +t;
      t = t.replace(UE, "");
      var o = YE.test(t);
      return o || KE.test(t) ? XE(t.slice(2), o ? 2 : 8) : WE.test(t) ? Zm : +t;
    }
    var tg = nx, ng = { emits: ["on-cell-click", "on-cell-contextmenu"], methods: { handleCellClick(t) {
      this.CalendarInstance.$emit("on-cell-click", t);
    }, handleCellContextmenu(t) {
      this.CalendarInstance.$emit("on-cell-contextmenu", t);
    } } };
    const dx = { name: "CalendarMonth", mixins: [ng], inject: ["CalendarInstance"], props: { date: Object }, data() {
      return { firstDayOfWeek: this.CalendarInstance.firstDayOfWeek, weekDays: this.CalendarInstance.locale.weekDays };
    }, computed: { finalWeekDays() {
      return this.weekDays.slice(this.firstDayOfWeek).concat(this.weekDays.slice(0, this.firstDayOfWeek));
    }, days() {
      let t = [];
      const r = Zn(this.date.format("YYYY-MM-01")), o = r.day(), C = this.firstDayOfWeek, g = C <= o ? o - C : 7 - (C - o);
      for (let P = 0; P < g; P++) {
        const N = r.subtract(g - P, "day"), B = { text: N.format("YYYY-MM-DD"), date: N.format("D"), type: "prev" };
        t.push(B);
      }
      const a = r.daysInMonth();
      for (let P = 0; P < a; P++) {
        const N = r.add(P, "day"), B = { text: N.format("YYYY-MM-DD"), date: N.format("D"), type: "current" };
        t.push(B);
      }
      const x = 42 - t.length, O = r.add(1, "month");
      for (let P = 0; P < x; P++) {
        const N = O.add(P, "day"), B = { text: N.format("YYYY-MM-DD"), date: N.format("D"), type: "next" };
        t.push(B);
      }
      return t;
    }, chunkDays() {
      return tg(this.days, 7);
    }, dayStyles() {
      let t = {};
      return this.CalendarInstance.cellHeight !== 100 && (t.height = `${this.CalendarInstance.cellHeight}px`), t;
    }, currentDate() {
      return this.date.format("YYYY-MM-DD");
    } }, methods: { handleClickDate(t) {
      this.CalendarInstance.handleChangeDate(Zn(t));
    } } }, fx = { class: "ivu-calendar-table", cellspacing: "0", cellpadding: "0" }, px = ["onClick", "onContextmenu"], mx = ["onClick"], gx = { class: "ivu-calendar-table-day-title" }, vx = { class: "ivu-calendar-table-day-slot" };
    function yx(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("table", fx, [e.createElementVNode("thead", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.finalWeekDays, (x) => (e.openBlock(), e.createElementBlock("th", { key: x }, e.toDisplayString(x), 1))), 128))]), e.createElementVNode("tbody", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.chunkDays, (x, O) => (e.openBlock(), e.createElementBlock("tr", { key: O }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(x, (P) => (e.openBlock(), e.createElementBlock("td", { key: P.text, onClick: (N) => t.handleCellClick(P), onContextmenu: e.withModifiers((N) => t.handleCellContextmenu(P), ["prevent"]) }, [e.createElementVNode("div", { class: e.normalizeClass(["ivu-calendar-table-day", { "ivu-calendar-table-day-other": P.type !== "current", "ivu-calendar-table-day-current": P.text === a.currentDate }]), style: e.normalizeStyle(a.dayStyles), onClick: (N) => a.handleClickDate(P.text) }, [e.createElementVNode("div", gx, e.toDisplayString(P.date), 1), e.createElementVNode("div", vx, [e.renderSlot(t.$slots, "month", { date: new Date(P.date), data: { type: P.type + "-month", day: P.text, selected: P.text === a.currentDate } })])], 14, mx)], 40, px))), 128))]))), 128))])]);
    }
    var bx = f(dx, [["render", yx]]);
    const Cx = { name: "CalendarYear", mixins: [ng], inject: ["CalendarInstance"], props: { date: Object }, data() {
      return {};
    }, computed: { months() {
      let t = [];
      const r = Zn(this.date.format("YYYY-01-01"));
      for (let o = 0; o < 12; o++) {
        const C = r.add(o, "month");
        t.push({ text: C.format("YYYY-MM"), month: this.CalendarInstance.locale.months[o], type: "current" });
      }
      return t;
    }, chunkMonths() {
      return tg(this.months, 3);
    }, dayStyles() {
      let t = {};
      return this.CalendarInstance.cellHeight !== 100 && (t.height = `${this.CalendarInstance.cellHeight}px`), t;
    }, currentMonth() {
      return this.date.format("YYYY-MM");
    } }, methods: { handleClickDate(t) {
      this.CalendarInstance.handleChangeDate(Zn(t));
    } } }, wx = { class: "ivu-calendar-table ivu-calendar-table-year", cellspacing: "0", cellpadding: "0" }, kx = ["onClick", "onContextmenu"], Sx = ["onClick"], Ex = { class: "ivu-calendar-table-day-title" }, xx = { class: "ivu-calendar-table-day-slot" };
    function _x(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("table", wx, [e.createElementVNode("tbody", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.chunkMonths, (x, O) => (e.openBlock(), e.createElementBlock("tr", { key: O }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(x, (P) => (e.openBlock(), e.createElementBlock("td", { key: P.text, onClick: (N) => t.handleCellClick(P), onContextmenu: e.withModifiers((N) => t.handleCellContextmenu(P), ["prevent"]) }, [e.createElementVNode("div", { class: e.normalizeClass(["ivu-calendar-table-day", { "ivu-calendar-table-day-current": P.text === a.currentMonth }]), style: e.normalizeStyle(a.dayStyles), onClick: (N) => a.handleClickDate(P.text) }, [e.createElementVNode("div", Ex, e.toDisplayString(P.month), 1), e.createElementVNode("div", xx, [e.renderSlot(t.$slots, "year", { month: new Date(P.month), data: { type: P.type + "-year", month: P.text, selected: P.text === a.currentMonth } })])], 14, Sx)], 40, kx))), 128))]))), 128))])]);
    }
    var Tx = f(Cx, [["render", _x]]);
    const Ox = { name: "Calendar", components: { CalendarMonth: bx, CalendarYear: Tx, ButtonGroup: $h, Button: zn, RadioGroup: Ql, Radio: Zl, Icon: G }, emits: ["on-type-change", "on-prev", "on-next", "on-today", "on-change", "update:modelValue", "on-cell-click", "on-cell-contextmenu"], provide() {
      return { CalendarInstance: this };
    }, props: { modelValue: { type: [Date, String, Number] }, type: { validator(t) {
      return z(t, ["month", "year"]);
    }, default: "month" }, cellHeight: { type: Number, default: 100 }, showHeader: { type: Boolean, default: !0 }, headerType: { validator(t) {
      return z(t, ["simple", "full"]);
    }, default: "simple" }, firstDayOfWeek: { validator(t) {
      return z(t, [1, 2, 3, 4, 5, 6, 7]);
    }, default: 1 }, hideType: { type: Boolean, default: !1 }, locale: { type: Object, default() {
      return { today: "今天", type: { month: "月", year: "年" }, weekDays: ["日", "一", "二", "三", "四", "五", "六"], months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"] };
    } } }, data() {
      const t = this.modelValue ? this.modelValue : /* @__PURE__ */ new Date();
      return { currentValue: Zn(t), mode: this.type };
    }, watch: { modelValue(t) {
      const r = t || /* @__PURE__ */ new Date();
      this.currentValue = Zn(r);
    }, type(t) {
      this.mode = t;
    } }, computed: { headerTitle() {
      if (this.mode === "month")
        return this.currentValue.format("YYYY 年 M 月");
      if (this.mode === "year")
        return this.currentValue.format("YYYY 年");
    } }, methods: { handleChangeType(t) {
      this.$emit("on-type-change", t);
    }, handlePrev() {
      const t = this.currentValue.format("YYYY-MM-01");
      let r;
      this.mode === "month" ? r = Zn(t).subtract(1, "month") : this.mode === "year" && (r = Zn(t).subtract(1, "year")), this.handleChangeDate(r), this.$emit("on-prev");
    }, handleNext() {
      const t = this.currentValue.format("YYYY-MM-01");
      let r;
      this.mode === "month" ? r = Zn(t).add(1, "month") : this.mode === "year" && (r = Zn(t).add(1, "year")), this.handleChangeDate(r), this.$emit("on-next");
    }, handleToday() {
      const t = Zn(/* @__PURE__ */ new Date()), r = t.format("YYYY-MM-DD"), o = this.currentValue.format("YYYY-MM-DD");
      r !== o && this.handleChangeDate(t), this.$emit("on-today");
    }, handleChangeDate(t) {
      this.currentValue = t;
      const r = new Date(t.format("YYYY-MM-DD"));
      this.$emit("update:modelValue", r), this.$emit("on-change", r);
    } } }, Dx = { class: "ivu-calendar" }, Nx = { key: 0, class: "ivu-calendar-header" }, Bx = { class: "ivu-calendar-header-title" }, Px = { class: "ivu-calendar-header-action" }, Vx = { class: "ivu-calendar-body" };
    function $x(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Button"), P = e.resolveComponent("ButtonGroup"), N = e.resolveComponent("Radio"), B = e.resolveComponent("RadioGroup"), H = e.resolveComponent("CalendarMonth"), oe = e.resolveComponent("CalendarYear");
      return e.openBlock(), e.createElementBlock("div", Dx, [o.showHeader ? (e.openBlock(), e.createElementBlock("div", Nx, [e.renderSlot(t.$slots, "header", {}, () => [e.createElementVNode("div", Bx, [e.renderSlot(t.$slots, "headerTitle", {}, () => [e.createTextVNode(e.toDisplayString(a.headerTitle), 1)])]), e.createElementVNode("div", Px, [o.headerType === "simple" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createVNode(P, null, { default: e.withCtx(() => [e.createVNode(O, { onClick: a.handlePrev }, { default: e.withCtx(() => [e.createVNode(x, { type: "ios-arrow-back" })]), _: 1 }, 8, ["onClick"]), e.createVNode(O, { onClick: a.handleToday }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.locale.today), 1)]), _: 1 }, 8, ["onClick"]), e.createVNode(O, { onClick: a.handleNext }, { default: e.withCtx(() => [e.createVNode(x, { type: "ios-arrow-forward" })]), _: 1 }, 8, ["onClick"])]), _: 1 }), o.hideType ? e.createCommentVNode("", !0) : (e.openBlock(), e.createBlock(B, { key: 0, modelValue: g.mode, "onUpdate:modelValue": r[0] || (r[0] = (se) => g.mode = se), type: "button", class: "ivu-ml", onOnChange: a.handleChangeType }, { default: e.withCtx(() => [e.createVNode(N, { label: "month" }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.locale.type.month), 1)]), _: 1 }), e.createVNode(N, { label: "year" }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.locale.type.year), 1)]), _: 1 })]), _: 1 }, 8, ["modelValue", "onOnChange"]))], 64)) : o.headerType === "full" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [], 64)) : e.createCommentVNode("", !0)])])])) : e.createCommentVNode("", !0), e.createElementVNode("div", Vx, [g.mode === "month" ? (e.openBlock(), e.createBlock(H, { key: 0, date: g.currentValue }, { month: e.withCtx(({ date: se, data: ee }) => [e.renderSlot(t.$slots, "month", { date: se, data: ee })]), _: 3 }, 8, ["date"])) : g.mode === "year" ? (e.openBlock(), e.createBlock(oe, { key: 1, date: g.currentValue }, { year: e.withCtx(({ month: se, data: ee }) => [e.renderSlot(t.$slots, "year", { month: se, data: ee })]), _: 3 }, 8, ["date"])) : e.createCommentVNode("", !0)])]);
    }
    var ig = f(Ox, [["render", $x]]);
    const nr = "ivu-col";
    function Ix(t) {
      return typeof t == "number" ? `${t} ${t} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(t) ? `0 0 ${t}` : t;
    }
    const Mx = { name: "iCol", inject: ["RowInstance"], props: { span: [Number, String], order: [Number, String], offset: [Number, String], push: [Number, String], pull: [Number, String], className: String, xs: [Number, Object], sm: [Number, Object], md: [Number, Object], lg: [Number, Object], xl: [Number, Object], xxl: [Number, Object], flex: { type: [Number, String], default: "" } }, computed: { gutter() {
      return this.RowInstance.gutter;
    }, classes() {
      let t = [`${nr}`, { [`${nr}-span-${this.span}`]: this.span, [`${nr}-order-${this.order}`]: this.order, [`${nr}-offset-${this.offset}`]: this.offset, [`${nr}-push-${this.push}`]: this.push, [`${nr}-pull-${this.pull}`]: this.pull, [`${this.className}`]: !!this.className }];
      return ["xs", "sm", "md", "lg", "xl", "xxl"].forEach((r) => {
        if (typeof this[r] == "number")
          t.push(`${nr}-span-${r}-${this[r]}`);
        else if (typeof this[r] == "object") {
          let o = this[r];
          Object.keys(o).forEach((C) => {
            t.push(C !== "span" ? `${nr}-${r}-${C}-${o[C]}` : `${nr}-span-${r}-${o[C]}`);
          });
        }
      }), t;
    }, styles() {
      let t = {};
      return this.gutter !== 0 && (t = { paddingLeft: this.gutter / 2 + "px", paddingRight: this.gutter / 2 + "px" }), this.flex && (t.flex = Ix(this.flex)), t;
    } } };
    function Ax(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, [e.renderSlot(t.$slots, "default")], 6);
    }
    var Ii = f(Mx, [["render", Ax]]);
    const ms = "ivu-row", Fx = { name: "Row", provide() {
      return { RowInstance: this };
    }, props: { type: { validator(t) {
      return z(t, ["flex"]);
    } }, align: { validator(t) {
      return z(t, ["top", "middle", "bottom"]);
    } }, justify: { validator(t) {
      return z(t, ["start", "end", "center", "space-around", "space-between"]);
    } }, gutter: { type: Number, default: 0 }, className: String, wrap: { type: Boolean, default: !0 } }, computed: { classes() {
      return [`${ms}`, { [`${ms}-${this.type}`]: !!this.type, [`${ms}-${this.type}-${this.align}`]: !!this.align && this.type, [`${ms}-${this.type}-${this.justify}`]: !!this.justify && this.type, [`${ms}-${this.align}`]: !!this.align, [`${ms}-${this.justify}`]: !!this.justify, [`${this.className}`]: !!this.className, [`${ms}-no-wrap`]: !this.wrap }];
    }, styles() {
      let t = {};
      return this.gutter !== 0 && (t = { marginLeft: this.gutter / -2 + "px", marginRight: this.gutter / -2 + "px" }), t;
    } } };
    function Lx(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, [e.renderSlot(t.$slots, "default")], 6);
    }
    var Er = f(Fx, [["render", Lx]]);
    function gs() {
      return gs = Object.assign || function(t) {
        for (var r = 1; r < arguments.length; r++) {
          var o = arguments[r];
          for (var C in o)
            Object.prototype.hasOwnProperty.call(o, C) && (t[C] = o[C]);
        }
        return t;
      }, gs.apply(this, arguments);
    }
    function zx(t, r) {
      t.prototype = Object.create(r.prototype), t.prototype.constructor = t, Zo(t, r);
    }
    function Ih(t) {
      return Ih = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r);
      }, Ih(t);
    }
    function Zo(t, r) {
      return Zo = Object.setPrototypeOf || function(o, C) {
        return o.__proto__ = C, o;
      }, Zo(t, r);
    }
    function Rx() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function tc(t, r, o) {
      return Rx() ? tc = Reflect.construct : tc = function(C, g, a) {
        var x = [null];
        x.push.apply(x, g);
        var O = Function.bind.apply(C, x), P = new O();
        return a && Zo(P, a.prototype), P;
      }, tc.apply(null, arguments);
    }
    function jx(t) {
      return Function.toString.call(t).indexOf("[native code]") !== -1;
    }
    function Mh(t) {
      var r = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return Mh = function(o) {
        if (o === null || !jx(o))
          return o;
        if (typeof o != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof r < "u") {
          if (r.has(o))
            return r.get(o);
          r.set(o, C);
        }
        function C() {
          return tc(o, arguments, Ih(this).constructor);
        }
        return C.prototype = Object.create(o.prototype, { constructor: { value: C, enumerable: !1, writable: !0, configurable: !0 } }), Zo(C, o);
      }, Mh(t);
    }
    var Hx = /%[sdj%]/g, Ux = function() {
    };
    typeof process < "u" && process.env;
    function Ah(t) {
      if (!t || !t.length)
        return null;
      var r = {};
      return t.forEach(function(o) {
        var C = o.field;
        r[C] = r[C] || [], r[C].push(o);
      }), r;
    }
    function ei() {
      for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
        r[o] = arguments[o];
      var C = 1, g = r[0], a = r.length;
      if (typeof g == "function")
        return g.apply(null, r.slice(1));
      if (typeof g == "string") {
        var x = String(g).replace(Hx, function(O) {
          if (O === "%%")
            return "%";
          if (C >= a)
            return O;
          switch (O) {
            case "%s":
              return String(r[C++]);
            case "%d":
              return Number(r[C++]);
            case "%j":
              try {
                return JSON.stringify(r[C++]);
              } catch {
                return "[Circular]";
              }
              break;
            default:
              return O;
          }
        });
        return x;
      }
      return g;
    }
    function Wx(t) {
      return t === "string" || t === "url" || t === "hex" || t === "email" || t === "date" || t === "pattern";
    }
    function mn(t, r) {
      return !!(t == null || r === "array" && Array.isArray(t) && !t.length || Wx(r) && typeof t == "string" && !t);
    }
    function Yx(t, r, o) {
      var C = [], g = 0, a = t.length;
      function x(O) {
        C.push.apply(C, O), g++, g === a && o(C);
      }
      t.forEach(function(O) {
        r(O, x);
      });
    }
    function rg(t, r, o) {
      var C = 0, g = t.length;
      function a(x) {
        if (x && x.length) {
          o(x);
          return;
        }
        var O = C;
        C = C + 1, O < g ? r(t[O], a) : o([]);
      }
      a([]);
    }
    function Kx(t) {
      var r = [];
      return Object.keys(t).forEach(function(o) {
        r.push.apply(r, t[o]);
      }), r;
    }
    var sg = function(t) {
      zx(r, t);
      function r(o, C) {
        var g;
        return g = t.call(this, "Async Validation Error") || this, g.errors = o, g.fields = C, g;
      }
      return r;
    }(Mh(Error));
    function Gx(t, r, o, C) {
      if (r.first) {
        var g = new Promise(function(H, oe) {
          var se = function(j) {
            return C(j), j.length ? oe(new sg(j, Ah(j))) : H();
          }, ee = Kx(t);
          rg(ee, o, se);
        });
        return g.catch(function(H) {
          return H;
        }), g;
      }
      var a = r.firstFields || [];
      a === !0 && (a = Object.keys(t));
      var x = Object.keys(t), O = x.length, P = 0, N = [], B = new Promise(function(H, oe) {
        var se = function(ee) {
          if (N.push.apply(N, ee), P++, P === O)
            return C(N), N.length ? oe(new sg(N, Ah(N))) : H();
        };
        x.length || (C(N), H()), x.forEach(function(ee) {
          var j = t[ee];
          a.indexOf(ee) !== -1 ? rg(j, o, se) : Yx(j, o, se);
        });
      });
      return B.catch(function(H) {
        return H;
      }), B;
    }
    function og(t) {
      return function(r) {
        return r && r.message ? (r.field = r.field || t.fullField, r) : { message: typeof r == "function" ? r() : r, field: r.field || t.fullField };
      };
    }
    function ag(t, r) {
      if (r) {
        for (var o in r)
          if (r.hasOwnProperty(o)) {
            var C = r[o];
            typeof C == "object" && typeof t[o] == "object" ? t[o] = gs({}, t[o], C) : t[o] = C;
          }
      }
      return t;
    }
    function lg(t, r, o, C, g, a) {
      t.required && (!o.hasOwnProperty(t.field) || mn(r, a || t.type)) && C.push(ei(g.messages.required, t.fullField));
    }
    function Xx(t, r, o, C, g) {
      (/^\s+$/.test(r) || r === "") && C.push(ei(g.messages.whitespace, t.fullField));
    }
    var Fh = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"), hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, ea = { integer: function(t) {
      return ea.number(t) && parseInt(t, 10) === t;
    }, float: function(t) {
      return ea.number(t) && !ea.integer(t);
    }, array: function(t) {
      return Array.isArray(t);
    }, regexp: function(t) {
      if (t instanceof RegExp)
        return !0;
      try {
        return !!new RegExp(t);
      } catch {
        return !1;
      }
    }, date: function(t) {
      return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
    }, number: function(t) {
      return isNaN(t) ? !1 : typeof t == "number";
    }, object: function(t) {
      return typeof t == "object" && !ea.array(t);
    }, method: function(t) {
      return typeof t == "function";
    }, email: function(t) {
      return typeof t == "string" && !!t.match(Fh.email) && t.length < 255;
    }, url: function(t) {
      return typeof t == "string" && !!t.match(Fh.url);
    }, hex: function(t) {
      return typeof t == "string" && !!t.match(Fh.hex);
    } };
    function qx(t, r, o, C, g) {
      if (t.required && r === void 0) {
        lg(t, r, o, C, g);
        return;
      }
      var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], x = t.type;
      a.indexOf(x) > -1 ? ea[x](r) || C.push(ei(g.messages.types[x], t.fullField, t.type)) : x && typeof r !== t.type && C.push(ei(g.messages.types[x], t.fullField, t.type));
    }
    function Jx(t, r, o, C, g) {
      var a = typeof t.len == "number", x = typeof t.min == "number", O = typeof t.max == "number", P = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, N = r, B = null, H = typeof r == "number", oe = typeof r == "string", se = Array.isArray(r);
      if (H ? B = "number" : oe ? B = "string" : se && (B = "array"), !B)
        return !1;
      se && (N = r.length), oe && (N = r.replace(P, "_").length), a ? N !== t.len && C.push(ei(g.messages[B].len, t.fullField, t.len)) : x && !O && N < t.min ? C.push(ei(g.messages[B].min, t.fullField, t.min)) : O && !x && N > t.max ? C.push(ei(g.messages[B].max, t.fullField, t.max)) : x && O && (N < t.min || N > t.max) && C.push(ei(g.messages[B].range, t.fullField, t.min, t.max));
    }
    var no = "enum";
    function Qx(t, r, o, C, g) {
      t[no] = Array.isArray(t[no]) ? t[no] : [], t[no].indexOf(r) === -1 && C.push(ei(g.messages[no], t.fullField, t[no].join(", ")));
    }
    function Zx(t, r, o, C, g) {
      if (t.pattern) {
        if (t.pattern instanceof RegExp)
          t.pattern.lastIndex = 0, t.pattern.test(r) || C.push(ei(g.messages.pattern.mismatch, t.fullField, r, t.pattern));
        else if (typeof t.pattern == "string") {
          var a = new RegExp(t.pattern);
          a.test(r) || C.push(ei(g.messages.pattern.mismatch, t.fullField, r, t.pattern));
        }
      }
    }
    var Pt = { required: lg, whitespace: Xx, type: qx, range: Jx, enum: Qx, pattern: Zx };
    function e_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r, "string") && !t.required)
          return o();
        Pt.required(t, r, C, a, g, "string"), mn(r, "string") || (Pt.type(t, r, C, a, g), Pt.range(t, r, C, a, g), Pt.pattern(t, r, C, a, g), t.whitespace === !0 && Pt.whitespace(t, r, C, a, g));
      }
      o(a);
    }
    function t_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && Pt.type(t, r, C, a, g);
      }
      o(a);
    }
    function n_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (r === "" && (r = void 0), mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && (Pt.type(t, r, C, a, g), Pt.range(t, r, C, a, g));
      }
      o(a);
    }
    function i_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && Pt.type(t, r, C, a, g);
      }
      o(a);
    }
    function r_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), mn(r) || Pt.type(t, r, C, a, g);
      }
      o(a);
    }
    function s_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && (Pt.type(t, r, C, a, g), Pt.range(t, r, C, a, g));
      }
      o(a);
    }
    function o_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && (Pt.type(t, r, C, a, g), Pt.range(t, r, C, a, g));
      }
      o(a);
    }
    function a_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (r == null && !t.required)
          return o();
        Pt.required(t, r, C, a, g, "array"), r != null && (Pt.type(t, r, C, a, g), Pt.range(t, r, C, a, g));
      }
      o(a);
    }
    function l_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && Pt.type(t, r, C, a, g);
      }
      o(a);
    }
    var c_ = "enum";
    function u_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g), r !== void 0 && Pt[c_](t, r, C, a, g);
      }
      o(a);
    }
    function h_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r, "string") && !t.required)
          return o();
        Pt.required(t, r, C, a, g), mn(r, "string") || Pt.pattern(t, r, C, a, g);
      }
      o(a);
    }
    function d_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r, "date") && !t.required)
          return o();
        if (Pt.required(t, r, C, a, g), !mn(r, "date")) {
          var O;
          r instanceof Date ? O = r : O = new Date(r), Pt.type(t, O, C, a, g), O && Pt.range(t, O.getTime(), C, a, g);
        }
      }
      o(a);
    }
    function f_(t, r, o, C, g) {
      var a = [], x = Array.isArray(r) ? "array" : typeof r;
      Pt.required(t, r, C, a, g, x), o(a);
    }
    function Lh(t, r, o, C, g) {
      var a = t.type, x = [], O = t.required || !t.required && C.hasOwnProperty(t.field);
      if (O) {
        if (mn(r, a) && !t.required)
          return o();
        Pt.required(t, r, C, x, g, a), mn(r, a) || Pt.type(t, r, C, x, g);
      }
      o(x);
    }
    function p_(t, r, o, C, g) {
      var a = [], x = t.required || !t.required && C.hasOwnProperty(t.field);
      if (x) {
        if (mn(r) && !t.required)
          return o();
        Pt.required(t, r, C, a, g);
      }
      o(a);
    }
    var ta = { string: e_, method: t_, number: n_, boolean: i_, regexp: r_, integer: s_, float: o_, array: a_, object: l_, enum: u_, pattern: h_, date: d_, url: Lh, hex: Lh, email: Lh, required: f_, any: p_ };
    function zh() {
      return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
        var t = JSON.parse(JSON.stringify(this));
        return t.clone = this.clone, t;
      } };
    }
    var Rh = zh();
    function xr(t) {
      this.rules = null, this._messages = Rh, this.define(t);
    }
    xr.prototype = { messages: function(t) {
      return t && (this._messages = ag(zh(), t)), this._messages;
    }, define: function(t) {
      if (!t)
        throw new Error("Cannot configure a schema with no rules");
      if (typeof t != "object" || Array.isArray(t))
        throw new Error("Rules must be an object");
      this.rules = {};
      var r, o;
      for (r in t)
        t.hasOwnProperty(r) && (o = t[r], this.rules[r] = Array.isArray(o) ? o : [o]);
    }, validate: function(t, r, o) {
      var C = this;
      r === void 0 && (r = {}), o === void 0 && (o = function() {
      });
      var g = t, a = r, x = o;
      if (typeof a == "function" && (x = a, a = {}), !this.rules || Object.keys(this.rules).length === 0)
        return x && x(), Promise.resolve();
      function O(ee) {
        var j, pe = [], at = {};
        function Qe(tt) {
          if (Array.isArray(tt)) {
            var Ee;
            pe = (Ee = pe).concat.apply(Ee, tt);
          } else
            pe.push(tt);
        }
        for (j = 0; j < ee.length; j++)
          Qe(ee[j]);
        pe.length ? at = Ah(pe) : (pe = null, at = null), x(pe, at);
      }
      if (a.messages) {
        var P = this.messages();
        P === Rh && (P = zh()), ag(P, a.messages), a.messages = P;
      } else
        a.messages = this.messages();
      var N, B, H = {}, oe = a.keys || Object.keys(this.rules);
      oe.forEach(function(ee) {
        N = C.rules[ee], B = g[ee], N.forEach(function(j) {
          var pe = j;
          typeof pe.transform == "function" && (g === t && (g = gs({}, g)), B = g[ee] = pe.transform(B)), typeof pe == "function" ? pe = { validator: pe } : pe = gs({}, pe), pe.validator = C.getValidationMethod(pe), pe.field = ee, pe.fullField = pe.fullField || ee, pe.type = C.getType(pe), pe.validator && (H[ee] = H[ee] || [], H[ee].push({ rule: pe, value: B, source: g, field: ee }));
        });
      });
      var se = {};
      return Gx(H, a, function(ee, j) {
        var pe = ee.rule, at = (pe.type === "object" || pe.type === "array") && (typeof pe.fields == "object" || typeof pe.defaultField == "object");
        at = at && (pe.required || !pe.required && ee.value), pe.field = ee.field;
        function Qe(ye, ze) {
          return gs({}, ze, { fullField: pe.fullField + "." + ye });
        }
        function tt(ye) {
          ye === void 0 && (ye = []);
          var ze = ye;
          if (Array.isArray(ze) || (ze = [ze]), !a.suppressWarning && ze.length && xr.warning("async-validator:", ze), ze.length && pe.message !== void 0 && (ze = [].concat(pe.message)), ze = ze.map(og(pe)), a.first && ze.length)
            return se[pe.field] = 1, j(ze);
          if (!at)
            j(ze);
          else {
            if (pe.required && !ee.value)
              return pe.message !== void 0 ? ze = [].concat(pe.message).map(og(pe)) : a.error && (ze = [a.error(pe, ei(a.messages.required, pe.field))]), j(ze);
            var Oe = {};
            if (pe.defaultField)
              for (var lt in ee.value)
                ee.value.hasOwnProperty(lt) && (Oe[lt] = pe.defaultField);
            Oe = gs({}, Oe, ee.rule.fields);
            for (var it in Oe)
              if (Oe.hasOwnProperty(it)) {
                var Ze = Array.isArray(Oe[it]) ? Oe[it] : [Oe[it]];
                Oe[it] = Ze.map(Qe.bind(null, it));
              }
            var kt = new xr(Oe);
            kt.messages(a.messages), ee.rule.options && (ee.rule.options.messages = a.messages, ee.rule.options.error = a.error), kt.validate(ee.value, ee.rule.options || a, function(ot) {
              var Ue = [];
              ze && ze.length && Ue.push.apply(Ue, ze), ot && ot.length && Ue.push.apply(Ue, ot), j(Ue.length ? Ue : null);
            });
          }
        }
        var Ee;
        pe.asyncValidator ? Ee = pe.asyncValidator(pe, ee.value, tt, ee.source, a) : pe.validator && (Ee = pe.validator(pe, ee.value, tt, ee.source, a), Ee === !0 ? tt() : Ee === !1 ? tt(pe.message || pe.field + " fails") : Ee instanceof Array ? tt(Ee) : Ee instanceof Error && tt(Ee.message)), Ee && Ee.then && Ee.then(function() {
          return tt();
        }, function(ye) {
          return tt(ye);
        });
      }, function(ee) {
        O(ee);
      });
    }, getType: function(t) {
      if (t.type === void 0 && t.pattern instanceof RegExp && (t.type = "pattern"), typeof t.validator != "function" && t.type && !ta.hasOwnProperty(t.type))
        throw new Error(ei("Unknown rule type %s", t.type));
      return t.type || "string";
    }, getValidationMethod: function(t) {
      if (typeof t.validator == "function")
        return t.validator;
      var r = Object.keys(t), o = r.indexOf("message");
      return o !== -1 && r.splice(o, 1), r.length === 1 && r[0] === "required" ? ta.required : ta[this.getType(t)] || !1;
    } }, xr.register = function(t, r) {
      if (typeof r != "function")
        throw new Error("Cannot register a validator by type, validator is not a function");
      ta[t] = r;
    }, xr.warning = Ux, xr.messages = Rh, xr.validators = ta;
    const na = "ivu-form-item";
    function cg(t, r) {
      let o = t;
      r = r.replace(/\[(\w+)\]/g, ".$1"), r = r.replace(/^\./, "");
      let C = r.split("."), g = 0;
      for (let a = C.length; g < a - 1; ++g) {
        let x = C[g];
        if (x in o)
          o = o[x];
        else
          throw new Error("[View UI warn]: please transfer a valid prop path to form item!");
      }
      return { o, k: C[g], v: o[C[g]] };
    }
    const m_ = { name: "FormItem", inject: ["FormInstance"], provide() {
      return { FormItemInstance: this };
    }, props: { label: { type: String, default: "" }, labelWidth: { type: Number }, prop: { type: String }, required: { type: Boolean, default: !1 }, rules: { type: [Object, Array] }, error: { type: String }, validateStatus: { type: Boolean }, showMessage: { type: Boolean, default: !0 }, labelFor: { type: String } }, data() {
      return { prefixCls: na, isRequired: !1, validateState: "", validateMessage: "", validateDisabled: !1, validator: {} };
    }, watch: { error: { handler(t) {
      this.validateMessage = t, this.validateState = t ? "error" : "";
    }, immediate: !0 }, validateStatus(t) {
      this.validateState = t;
    }, rules() {
      this.setRules();
    }, required(t, r) {
      this.isRequired = t, r && !t && this.resetField();
    } }, computed: { classes() {
      return [`${na}`, { [`${na}-required`]: this.required || this.isRequired, [`${na}-error`]: this.validateState === "error", [`${na}-validating`]: this.validateState === "validating" }];
    }, fieldValue() {
      const t = this.FormInstance.model;
      if (!t || !this.prop)
        return;
      let r = this.prop;
      return r.indexOf(":") !== -1 && (r = r.replace(/:/, ".")), cg(t, r).v;
    }, labelStyles() {
      let t = {};
      const r = this.labelWidth === 0 || this.labelWidth ? this.labelWidth : this.FormInstance.labelWidth;
      return (r || r === 0) && (t.width = `${r}px`), t;
    }, contentStyles() {
      let t = {};
      const r = this.labelWidth === 0 || this.labelWidth ? this.labelWidth : this.FormInstance.labelWidth;
      return (r || r === 0) && (t.marginLeft = `${r}px`), t;
    } }, methods: { setRules() {
      let t = this.getRules();
      t.length && this.required || (t.length ? t.every((r) => {
        this.isRequired = r.required;
      }) : this.required && (this.isRequired = this.required));
    }, getRules() {
      let t = this.FormInstance.rules;
      const r = this.rules;
      return t = t ? t[this.prop] : [], [].concat(r || t || []);
    }, getFilteredRule(t) {
      return this.getRules().filter((r) => !r.trigger || r.trigger.indexOf(t) !== -1);
    }, validate(t, r = function() {
    }) {
      let o = this.getFilteredRule(t);
      if (!o || o.length === 0)
        if (this.required)
          o = [{ required: !0 }];
        else
          return r(), !0;
      this.validateState = "validating";
      let C = {};
      C[this.prop] = o;
      const g = new xr(C);
      let a = {};
      a[this.prop] = this.fieldValue, g.validate(a, { firstFields: !0 }, (x) => {
        this.validateState = x ? "error" : "success", this.validateMessage = x ? x[0].message : "", r(this.validateMessage), this.FormInstance && this.FormInstance.$emit("on-validate", this.prop, !x, this.validateMessage || null);
      }), this.validateDisabled = !1;
    }, resetField() {
      this.validateState = "", this.validateMessage = "";
      let t = this.FormInstance.model, r = this.fieldValue, o = this.prop;
      o.indexOf(":") !== -1 && (o = o.replace(/:/, "."));
      let C = cg(t, o);
      Array.isArray(r) && this.initialValue !== null ? (this.validateDisabled = !0, C.o[C.k] = [].concat(this.initialValue)) : (this.validateDisabled = !0, C.o[C.k] = this.initialValue);
    }, onFieldBlur() {
      this.validate("blur");
    }, onFieldChange() {
      if (this.validateDisabled) {
        this.validateDisabled = !1;
        return;
      }
      this.validate("change");
    }, formBlur() {
      this.onFieldBlur();
    }, formChange() {
      this.onFieldChange();
    } }, mounted() {
      this.prop && (this.FormInstance.addField(this), Object.defineProperty(this, "initialValue", { value: this.fieldValue }), this.setRules());
    }, beforeUnmount() {
      this.FormInstance.removeField(this);
    } }, g_ = ["for"];
    function v_(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [o.label || t.$slots.label ? (e.openBlock(), e.createElementBlock("label", { key: 0, class: e.normalizeClass([g.prefixCls + "-label"]), for: o.labelFor, style: e.normalizeStyle(a.labelStyles) }, [e.renderSlot(t.$slots, "label", {}, () => [e.createTextVNode(e.toDisplayString(o.label) + e.toDisplayString(a.FormInstance.colon), 1)])], 14, g_)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]), style: e.normalizeStyle(a.contentStyles) }, [e.renderSlot(t.$slots, "default"), e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [g.validateState === "error" && o.showMessage && a.FormInstance.showMessage ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-error-tip"]) }, e.toDisplayString(g.validateMessage), 3)) : e.createCommentVNode("", !0)]), _: 1 })], 6)], 2);
    }
    var nc = f(m_, [["render", v_]]), jh = { UserName: "请输入用户名！", Password: "请输入密码！", Email: "请输入邮箱！", Mobile: "请输入手机号码！", Captcha: "请输入验证码！" }, ia = { inject: ["LoginInstance"], emits: ["on-change"], props: { rules: { type: [Object, Array], default() {
      const t = e.getCurrentInstance().type.name;
      return [{ required: !0, message: jh[t], trigger: "change" }];
    } }, value: { type: String }, name: { type: String, required: !0 }, enterToSubmit: { type: Boolean, default: !1 } }, data() {
      return { prop: "" };
    }, methods: { handleChange(t) {
      this.LoginInstance.formValidate[this.prop] = t, this.$emit("on-change", t);
    }, handleEnter() {
      this.enterToSubmit && this.LoginInstance.handleSubmit();
    }, handleSetValue() {
      const t = this.$props;
      t.value && (this.LoginInstance.formValidate[this.prop] = t.value);
    }, handleGetProps() {
      let t = this.$props.name;
      const r = { prefix: this.prefix, placeholder: this.placeholder, type: this.type, size: "large", modelValue: this.LoginInstance.formValidate[this.prop] };
      return t && (r.name = t), Object.assign(r, this.$attrs);
    } }, render() {
      const t = this.handleGetProps(), r = e.h(di, v(p({}, t), { "onUpdate:modelValue": this.handleChange, "onOn-enter": this.handleEnter })), o = e.h(nc, { prop: this.prop, rules: this.rules }, () => [r]);
      return e.h("div", { class: this.className }, [o]);
    }, created() {
      const t = this.name, r = Object.assign({}, this.LoginInstance.formValidate);
      r[t] = "", this.LoginInstance.formValidate = r, this.prop = t, this.handleSetValue();
    } };
    const ug = { name: "Captcha", mixins: [ia], emits: ["on-get-captcha"], props: { field: { type: [String, Array] }, countDown: { type: Number, default: 60 }, text: { type: String }, unitText: { type: String, default: "秒" }, beforeClick: Function }, data() {
      return { className: "ivu-login-captcha", prefix: "ios-keypad-outline", placeholder: "请输入验证码", type: "text", buttonDisabled: !1, limitCountDown: 0 };
    }, methods: { handleClickCaptcha() {
      if (this.field) {
        const t = typeof this.field == "string" ? [this.field] : this.field;
        this.LoginInstance.handleValidate(t, (r) => {
          r && this.handleBeforeGetCaptcha();
        });
      } else
        this.handleBeforeGetCaptcha();
    }, handleBeforeGetCaptcha() {
      if (!this.beforeClick)
        return this.handleGetCaptcha();
      const t = this.beforeClick();
      t && t.then ? t.then(() => {
        this.handleGetCaptcha();
      }) : this.handleGetCaptcha();
    }, handleGetCaptcha() {
      this.countDown > 0 && (this.buttonDisabled = !0, this.limitCountDown = this.countDown, this.handleCountDown()), this.$emit("on-get-captcha", this.LoginInstance.formValidate[this.prop], JSON.parse(JSON.stringify(this.LoginInstance.formValidate)));
    }, handleCountDown() {
      this.timer = setTimeout(() => {
        this.limitCountDown--, this.limitCountDown === 0 ? (this.buttonDisabled = !1, clearTimeout(this.timer)) : this.handleCountDown();
      }, 1e3);
    } }, render() {
      const t = this.$attrs, r = this.handleGetProps(), o = { size: "large", type: "default", long: !0, disabled: this.buttonDisabled };
      "size" in t && (o.size = t.size), "button-type" in t && (o.type = t["button-type"]);
      let C;
      this.$slots.text ? C = this.$slots.text : this.limitCountDown !== 0 ? C = () => `${this.limitCountDown} ${this.unitText}` : this.text ? C = () => this.text : C = () => "获取验证码";
      const g = e.h(zn, v(p({}, o), { onClick: this.handleClickCaptcha }), C), a = e.h(di, v(p({}, r), { "onUpdate:modelValue": this.handleChange, "onOn-enter": this.handleEnter })), x = e.h(Ii, { span: 16 }, () => [a]), O = e.h(Ii, { span: 8 }, () => [g]), P = e.h(Er, { gutter: 8 }, () => [x, O]), N = e.h(nc, { prop: this.prop, rules: this.rules }, () => [P]);
      return e.h("div", { class: this.className }, [N]);
    }, beforeUnmount() {
      this.timer && clearTimeout(this.timer);
    } }, vs = "ivu-card", hg = 16, y_ = { name: "Card", mixins: [je], components: { Icon: G }, props: { bordered: { type: Boolean, default: !0 }, disHover: { type: Boolean, default: !1 }, shadow: { type: Boolean, default: !1 }, padding: { type: Number, default: hg }, title: { type: String }, icon: { type: String } }, data() {
      return { showHead: !0, showExtra: !0 };
    }, computed: { classes() {
      return [`${vs}`, { [`${vs}-bordered`]: this.bordered && !this.shadow, [`${vs}-dis-hover`]: this.disHover || this.shadow, [`${vs}-shadow`]: this.shadow }];
    }, headClasses() {
      return `${vs}-head`;
    }, extraClasses() {
      return `${vs}-extra`;
    }, bodyClasses() {
      return `${vs}-body`;
    }, bodyStyles() {
      return this.padding !== hg ? { padding: `${this.padding}px` } : "";
    }, isHrefPattern() {
      const { to: t } = this;
      return !!t;
    }, tagName() {
      const { isHrefPattern: t } = this;
      return t ? "a" : "div";
    }, tagProps() {
      const { isHrefPattern: t } = this;
      if (t) {
        const { linkUrl: r, target: o } = this;
        return { href: r, target: o };
      } else
        return {};
    } }, methods: { handleClickLink(t) {
      if (!this.isHrefPattern)
        return;
      const r = t.ctrlKey || t.metaKey;
      this.handleCheckClick(t, r);
    } }, mounted() {
      this.showHead = this.title || this.$slots.title !== void 0, this.showExtra = this.$slots.extra !== void 0;
    } }, b_ = { key: 0 };
    function C_(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createBlock(e.resolveDynamicComponent(a.tagName), e.mergeProps({ class: a.classes }, a.tagProps, { onClick: a.handleClickLink }), { default: e.withCtx(() => [g.showHead ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.headClasses) }, [e.renderSlot(t.$slots, "title", {}, () => [o.title ? (e.openBlock(), e.createElementBlock("p", b_, [o.icon ? (e.openBlock(), e.createBlock(x, { key: 0, type: o.icon }, null, 8, ["type"])) : e.createCommentVNode("", !0), e.createElementVNode("span", null, e.toDisplayString(o.title), 1)])) : e.createCommentVNode("", !0)])], 2)) : e.createCommentVNode("", !0), g.showExtra ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass(a.extraClasses) }, [e.renderSlot(t.$slots, "extra")], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass(a.bodyClasses), style: e.normalizeStyle(a.bodyStyles) }, [e.renderSlot(t.$slots, "default")], 6)]), _: 3 }, 16, ["class", "onClick"]);
    }
    var dg = f(y_, [["render", C_]]);
    const io = "ivu-carousel", w_ = { name: "Carousel", provide() {
      return { CarouselInstance: this };
    }, components: { Icon: G }, emits: ["on-change", "on-click", "update:modelValue"], props: { arrow: { type: String, default: "hover", validator(t) {
      return z(t, ["hover", "always", "never"]);
    } }, autoplay: { type: Boolean, default: !1 }, autoplaySpeed: { type: Number, default: 2e3 }, loop: { type: Boolean, default: !1 }, easing: { type: String, default: "ease" }, dots: { type: String, default: "inside", validator(t) {
      return z(t, ["inside", "outside", "none"]);
    } }, radiusDot: { type: Boolean, default: !1 }, trigger: { type: String, default: "click", validator(t) {
      return z(t, ["click", "hover"]);
    } }, modelValue: { type: Number, default: 0 }, height: { type: [String, Number], default: "auto", validator(t) {
      return t === "auto" || Object.prototype.toString.call(t) === "[object Number]";
    } } }, data() {
      return { prefixCls: io, listWidth: 0, trackWidth: 0, trackOffset: 0, trackCopyOffset: 0, showCopyTrack: !1, slides: [], slideInstances: [], timer: null, ready: !1, currentIndex: this.modelValue, trackIndex: this.modelValue, copyTrackIndex: this.modelValue, hideTrackPos: -1, carouselItemList: [] };
    }, computed: { classes() {
      return [`${io}`];
    }, trackStyles() {
      const t = this.trackIndex === -1 ? "hidden" : "visible";
      return { width: `${this.trackWidth}px`, transform: `translate3d(${-this.trackOffset}px, 0px, 0px)`, transition: `transform 500ms ${this.easing}`, visibility: t };
    }, copyTrackStyles() {
      return { width: `${this.trackWidth}px`, transform: `translate3d(${-this.trackCopyOffset}px, 0px, 0px)`, transition: `transform 500ms ${this.easing}`, position: "absolute" };
    }, arrowClasses() {
      return [`${io}-arrow`, `${io}-arrow-${this.arrow}`];
    }, dotsClasses() {
      return [`${io}-dots`, `${io}-dots-${this.dots}`];
    } }, methods: { findChild(t) {
      this.carouselItemList.length && this.carouselItemList.forEach((r) => {
        t(r.carouselItem);
      });
    }, initCopyTrackDom() {
      e.nextTick(() => {
        this.$refs.copyTrack.innerHTML = this.$refs.originTrack.innerHTML;
      });
    }, updateSlides(t) {
      let r = [], o = 1;
      this.findChild((C) => {
        r.push({ $el: C.$el }), C.index = o++, t && this.slideInstances.push(C);
      }), this.slides = r, this.updatePos();
    }, updatePos() {
      this.findChild((t) => {
        t.width = this.listWidth, t.height = typeof this.height == "number" ? `${this.height}px` : this.height;
      }), this.trackWidth = (this.slides.length || 0) * this.listWidth;
    }, slotChange() {
      e.nextTick(() => {
        this.slides = [], this.slideInstances = [], this.updateSlides(!0, !0), this.updatePos(), this.updateOffset();
      });
    }, handleResize() {
      this.listWidth = parseInt(Be(this.$el, "width")), this.updatePos(), this.updateOffset();
    }, updateTrackPos(t) {
      this.showCopyTrack ? this.trackIndex = t : this.copyTrackIndex = t;
    }, updateTrackIndex(t) {
      this.showCopyTrack ? this.copyTrackIndex = t : this.trackIndex = t, this.currentIndex = t;
    }, add(t) {
      let r = this.slides.length;
      this.loop && (t > 0 ? this.hideTrackPos = -1 : this.hideTrackPos = r, this.updateTrackPos(this.hideTrackPos));
      const o = this.showCopyTrack ? this.copyTrackIndex : this.trackIndex;
      let C = o + t;
      for (; C < 0; )
        C += r;
      (t > 0 && C === r || t < 0 && C === r - 1) && this.loop ? (this.showCopyTrack = !this.showCopyTrack, this.trackIndex += t, this.copyTrackIndex += t) : (this.loop || (C = C % this.slides.length), this.updateTrackIndex(C)), this.currentIndex = C === this.slides.length ? 0 : C, this.$emit("on-change", o, this.currentIndex), this.$emit("update:modelValue", this.currentIndex);
    }, arrowEvent(t) {
      this.setAutoplay(), this.add(t);
    }, dotsEvent(t, r) {
      let o = this.showCopyTrack ? this.copyTrackIndex : this.trackIndex;
      const C = this.currentIndex;
      t === this.trigger && o !== r && (this.updateTrackIndex(r), this.$emit("on-change", C, this.currentIndex), this.$emit("update:modelValue", r), this.setAutoplay());
    }, setAutoplay() {
      !h || (window.clearInterval(this.timer), this.autoplay && (this.timer = window.setInterval(() => {
        this.add(1);
      }, this.autoplaySpeed)));
    }, updateOffset() {
      e.nextTick(() => {
        let t = this.copyTrackIndex > 0 ? -1 : 1;
        this.trackOffset = this.trackIndex * this.listWidth, this.trackCopyOffset = this.copyTrackIndex * this.listWidth + t;
      });
    }, handleClick(t) {
      this.$emit("on-click", this[t]);
    } }, watch: { autoplay() {
      this.setAutoplay();
    }, autoplaySpeed() {
      this.setAutoplay();
    }, trackIndex() {
      this.updateOffset();
    }, copyTrackIndex() {
      this.updateOffset();
    }, height() {
      this.updatePos();
    }, modelValue(t) {
      this.updateTrackIndex(t), this.setAutoplay();
    } }, mounted() {
      this.updateSlides(!0), this.handleResize(), this.setAutoplay(), m(window, "resize", this.handleResize);
    }, beforeUnmount() {
      b(window, "resize", this.handleResize);
    } }, k_ = ["onClick", "onMouseover"];
    function S_(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("button", { type: "button", class: e.normalizeClass([a.arrowClasses, "left"]), onClick: r[0] || (r[0] = (O) => a.arrowEvent(-1)) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-list"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-track", g.showCopyTrack ? "" : "higher"]), style: e.normalizeStyle(a.trackStyles), ref: "originTrack", onClick: r[1] || (r[1] = (O) => a.handleClick("currentIndex")) }, [e.renderSlot(t.$slots, "default")], 6), o.loop ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-track", g.showCopyTrack ? "higher" : ""]), style: e.normalizeStyle(a.copyTrackStyles), ref: "copyTrack", onClick: r[2] || (r[2] = (O) => a.handleClick("copyTrackIndex")) }, null, 6)) : e.createCommentVNode("", !0)], 2), e.createElementVNode("button", { type: "button", class: e.normalizeClass([a.arrowClasses, "right"]), onClick: r[3] || (r[3] = (O) => a.arrowEvent(1)) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2), e.createElementVNode("ul", { class: e.normalizeClass(a.dotsClasses) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.slides.length, (O) => (e.openBlock(), e.createElementBlock("li", { key: O, class: e.normalizeClass([O - 1 === g.currentIndex ? g.prefixCls + "-active" : ""]), onClick: (P) => a.dotsEvent("click", O - 1), onMouseover: (P) => a.dotsEvent("hover", O - 1) }, [e.createElementVNode("button", { type: "button", class: e.normalizeClass([o.radiusDot ? "radius" : ""]) }, null, 2)], 42, k_))), 128))], 2)], 2);
    }
    var fg = f(w_, [["render", S_]]);
    const E_ = "ivu-carousel-item", x_ = { componentName: "carousel-item", name: "CarouselItem", inject: ["CarouselInstance"], data() {
      return { prefixCls: E_, width: 0, height: "auto", left: 0, id: be(6) };
    }, computed: { styles() {
      return { width: `${this.width}px`, height: `${this.height}`, left: `${this.left}px` };
    } }, watch: { width(t) {
      t && this.CarouselInstance.loop && e.nextTick(() => {
        this.CarouselInstance.initCopyTrackDom();
      });
    }, height(t) {
      t && this.CarouselInstance.loop && e.nextTick(() => {
        this.CarouselInstance.initCopyTrackDom();
      });
    } }, methods: { addInstance() {
      const t = this.CarouselInstance;
      t.carouselItemList || (t.carouselItemList = []), t.carouselItemList.push({ id: this.id, carouselItem: this });
    }, removeInstance() {
      const t = this.CarouselInstance;
      if (!t.carouselItemList)
        return;
      const r = t.carouselItemList.findIndex((o) => o.id === this.id);
      t.carouselItemList.splice(r, 1);
    } }, mounted() {
      this.addInstance(), this.CarouselInstance.slotChange();
    }, beforeUnmount() {
      this.removeInstance(), this.CarouselInstance.slotChange();
    } };
    function __(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(g.prefixCls), style: e.normalizeStyle(a.styles) }, [e.renderSlot(t.$slots, "default")], 6);
    }
    var pg = f(x_, [["render", __]]);
    const T_ = { name: "Casitem", components: { Icon: G }, mixins: [kr], props: { data: Object, prefixCls: String, tmpItem: Object }, computed: { classes() {
      return [`${this.prefixCls}-menu-item`, { [`${this.prefixCls}-menu-item-active`]: this.tmpItem.value === this.data.value, [`${this.prefixCls}-menu-item-disabled`]: this.data.disabled }];
    }, showArrow() {
      return this.data.children && this.data.children.length || "loading" in this.data && !this.data.loading;
    }, showLoading() {
      return "loading" in this.data && this.data.loading;
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-forward";
      return t && (t.cascader.customItemArrow ? r = "" : t.cascader.itemArrow && (r = t.cascader.itemArrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cascader.customItemArrow && (r = t.cascader.customItemArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cascader.itemArrowSize && (r = t.cascader.itemArrowSize), r;
    } } }, O_ = { key: 1, class: "ivu-icon ivu-icon-ios-loading ivu-load-loop ivu-cascader-menu-item-loading" };
    function D_(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.classes) }, [e.createTextVNode(e.toDisplayString(o.data.label) + " ", 1), a.showArrow ? (e.openBlock(), e.createBlock(x, { key: 0, type: a.arrowType, custom: a.customArrowType, size: a.arrowSize }, null, 8, ["type", "custom", "size"])) : e.createCommentVNode("", !0), a.showLoading ? (e.openBlock(), e.createElementBlock("i", O_)) : e.createCommentVNode("", !0)], 2);
    }
    var N_ = f(T_, [["render", D_]]);
    let B_ = 1;
    const P_ = { name: "Caspanel", components: { Casitem: N_ }, inject: ["CascaderInstance"], provide() {
      return { CaspanelInstance: this };
    }, props: { data: { type: Array, default() {
      return [];
    } }, disabled: Boolean, changeOnSelect: Boolean, trigger: String, prefixCls: String }, data() {
      return { tmpItem: {}, result: [], sublist: [], id: be(6), childCaspanelList: [] };
    }, watch: { data() {
      this.sublist = [];
    } }, methods: { handleClickItem(t) {
      this.trigger !== "click" && t.children && t.children.length || this.handleTriggerItem(t, !1, !0);
    }, handleHoverItem(t) {
      this.trigger !== "hover" || !t.children || !t.children.length || this.handleTriggerItem(t, !1, !0);
    }, handleTriggerItem(t, r = !1, o = !1) {
      if (t.disabled)
        return;
      const C = me(this, "Cascader");
      if (t.loading !== void 0 && !t.children.length && C && C.loadData) {
        C.loadData(t, () => {
          o && (C.isLoadedChildren = !0), t.children.length && this.handleTriggerItem(t);
        });
        return;
      }
      const g = this.getBaseItem(t);
      (this.changeOnSelect || g.label !== this.tmpItem.label || g.value !== this.tmpItem.value || g.label === this.tmpItem.label && g.value === this.tmpItem.value) && (this.tmpItem = g, this.emitUpdate([g])), t.children && t.children.length ? (this.sublist = t.children, this.CascaderInstance.handleOnResultChange({ lastValue: !1, changeOnSelect: this.changeOnSelect, fromInit: r }), this.changeOnSelect && this.childCaspanelList.length && this.childCaspanelList[0].caspanel.handleOnClear(!0)) : (this.sublist = [], this.CascaderInstance.handleOnResultChange({ lastValue: !0, changeOnSelect: this.changeOnSelect, fromInit: r })), C && C.$refs.drop.update();
    }, updateResult(t) {
      this.result = [this.tmpItem].concat(t), this.emitUpdate(this.result);
    }, getBaseItem(t) {
      let r = Object.assign({}, t);
      return r.children && delete r.children, r;
    }, emitUpdate(t) {
      this.$parent.$options.name === "Caspanel" ? this.$parent.updateResult(t) : this.CascaderInstance.updateResult(t);
    }, getKey() {
      return B_++;
    }, handleOnFindSelected(t) {
      let r = [...t.value];
      for (let o = 0; o < r.length; o++)
        for (let C = 0; C < this.data.length; C++)
          if (r[o] === this.data[C].value)
            return this.handleTriggerItem(this.data[C], !0), r.splice(0, 1), e.nextTick(() => {
              this.childCaspanelList.length && this.childCaspanelList[0].caspanel.handleOnFindSelected({ value: r });
            }), !1;
    }, handleOnClear(t = !1) {
      this.sublist = [], this.tmpItem = {}, t && this.childCaspanelList.length && this.childCaspanelList[0].caspanel.handleOnClear(!0);
    }, addCaspanel() {
      const t = this.CascaderInstance;
      t.caspanelList || (t.caspanelList = []), t.caspanelList.push({ id: this.id, caspanel: this });
      const r = me(this, "Caspanel");
      r && (r.childCaspanelList || (r.childCaspanelList = []), r.childCaspanelList.push({ id: this.id, caspanel: this }));
    }, removeCaspanel() {
      const t = this.CascaderInstance;
      if (t.caspanelList && t.caspanelList.length) {
        const o = t.caspanelList.findIndex((C) => C.id === this.id);
        t.caspanelList.splice(o, 1);
      }
      const r = me(this, "Caspanel");
      if (r && r.childCaspanelList && r.childCaspanelList.length) {
        const o = r.childCaspanelList.findIndex((C) => C.id === this.id);
        r.childCaspanelList.splice(o, 1);
      }
    } }, mounted() {
      this.addCaspanel();
    }, beforeUnmount() {
      this.removeCaspanel();
    } };
    function V_(t, r, o, C, g, a) {
      const x = e.resolveComponent("Casitem"), O = e.resolveComponent("Caspanel", !0);
      return e.openBlock(), e.createElementBlock("span", null, [o.data && o.data.length ? (e.openBlock(), e.createElementBlock("ul", { key: 0, class: e.normalizeClass([o.prefixCls + "-menu"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.data, (P, N) => (e.openBlock(), e.createBlock(x, { key: N, "prefix-cls": o.prefixCls, data: P, "tmp-item": g.tmpItem, onClick: e.withModifiers((B) => a.handleClickItem(P), ["stop"]), onMouseenter: e.withModifiers((B) => a.handleHoverItem(P), ["stop"]) }, null, 8, ["prefix-cls", "data", "tmp-item", "onClick", "onMouseenter"]))), 128))], 2)) : e.createCommentVNode("", !0), g.sublist && g.sublist.length ? (e.openBlock(), e.createBlock(O, { key: 1, "prefix-cls": o.prefixCls, data: g.sublist, disabled: o.disabled, trigger: o.trigger, "change-on-select": o.changeOnSelect }, null, 8, ["prefix-cls", "data", "disabled", "trigger", "change-on-select"])) : e.createCommentVNode("", !0)]);
    }
    var $_ = f(P_, [["render", V_]]), Hh = { beforeMount(t, r, o) {
      function C(g) {
        if (t.contains(g.target))
          return !1;
        r.value(g);
      }
      t.__vueClickOutside__ = C, h && document.addEventListener("click", C);
    }, unmounted(t, r) {
      h && document.removeEventListener("click", t.__vueClickOutside__), delete t.__vueClickOutside__;
    } };
    const _r = "ivu-cascader", I_ = "ivu-select", M_ = { name: "Cascader", mixins: [Kt, nn, kr], components: { iInput: di, Drop: er, Icon: G, Caspanel: $_ }, directives: { clickOutside: Hh }, emits: ["on-change", "on-visible-change", "update:modelValue"], provide() {
      return { CascaderInstance: this };
    }, props: { data: { type: Array, default() {
      return [];
    } }, modelValue: { type: Array, default() {
      return [];
    } }, disabled: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !0 }, placeholder: { type: String }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, trigger: { validator(t) {
      return z(t, ["click", "hover"]);
    }, default: "click" }, changeOnSelect: { type: Boolean, default: !1 }, renderFormat: { type: Function, default(t) {
      return t.join(" / ");
    } }, loadData: { type: Function }, filterable: { type: Boolean, default: !1 }, notFoundText: { type: String }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, name: { type: String }, elementId: { type: String }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, transferClassName: { type: String }, eventsEnabled: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: _r, selectPrefixCls: I_, visible: !1, selected: [], tmpSelected: [], updatingValue: !1, currentValue: this.modelValue || [], query: "", validDataStr: "", isLoadedChildren: !1, isValueNull: !1, caspanelList: [] };
    }, computed: { classes() {
      return [`${_r}`, { [`${_r}-show-clear`]: this.showCloseIcon, [`${_r}-size-${this.size}`]: !!this.size, [`${_r}-visible`]: this.visible, [`${_r}-disabled`]: this.itemDisabled, [`${_r}-not-found`]: this.filterable && this.query !== "" && !this.querySelections.length }];
    }, showCloseIcon() {
      return this.currentValue && this.currentValue.length && this.clearable && !this.itemDisabled;
    }, displayRender() {
      let t = [];
      for (let r = 0; r < this.selected.length; r++)
        t.push(this.selected[r].label);
      return this.renderFormat(t, this.selected);
    }, displayInputRender() {
      return this.filterable ? "" : this.displayRender;
    }, localePlaceholder() {
      return this.placeholder === void 0 ? this.t("i.select.placeholder") : this.placeholder;
    }, inputPlaceholder() {
      return this.filterable && this.currentValue.length ? null : this.localePlaceholder;
    }, localeNotFoundText() {
      return this.notFoundText === void 0 ? this.t("i.select.noMatch") : this.notFoundText;
    }, querySelections() {
      let t = [];
      function r(o, C, g) {
        const a = W(o);
        for (let x = 0; x < a.length; x++) {
          let O = a[x];
          O.__label = C ? C + " / " + O.label : O.label, O.__value = g ? g + "," + O.value : O.value, O.children && O.children.length ? (r(O.children, O.__label, O.__value), delete O.__label, delete O.__value) : t.push({ label: O.__label, value: O.__value, display: O.__label, item: O, disabled: !!O.disabled });
        }
      }
      return r(this.data), t = t.filter((o) => o.label ? o.label.indexOf(this.query) > -1 : !1).map((o) => (o.display = o.display.replace(new RegExp(this.query, "g"), `<span>${this.query}</span>`), o)), t;
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-down";
      return t && (t.cascader.customArrow ? r = "" : t.cascader.arrow && (r = t.cascader.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cascader.customArrow && (r = t.cascader.customArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cascader.arrowSize && (r = t.cascader.arrowSize), r;
    }, dropdownCls() {
      return { [_r + "-transfer"]: this.transfer, [this.transferClassName]: this.transferClassName };
    } }, methods: { clearSelect() {
      if (this.itemDisabled)
        return !1;
      const t = JSON.stringify(this.currentValue);
      this.currentValue = this.selected = this.tmpSelected = [], this.handleClose(), this.emitValue(this.currentValue, t), this.caspanelList.forEach((r) => {
        r.caspanel.handleOnClear();
      });
    }, handleClose() {
      this.visible = !1;
    }, toggleOpen() {
      if (this.itemDisabled)
        return !1;
      this.visible ? this.filterable || this.handleClose() : this.onFocus();
    }, onFocus() {
      this.visible = !0, this.currentValue.length || this.caspanelList.forEach((t) => {
        t.caspanel.handleOnClear();
      });
    }, updateResult(t) {
      this.tmpSelected = t;
    }, updateSelected(t = !1, r = !1) {
      (!this.changeOnSelect || t || r) && this.caspanelList.forEach((o) => {
        o.caspanel.handleOnFindSelected({ value: this.currentValue });
      });
    }, emitValue(t, r) {
      JSON.stringify(t) !== r && (this.$emit("on-change", this.currentValue, JSON.parse(JSON.stringify(this.selected))), e.nextTick(() => {
        this.handleFormItemChange("change", { value: this.currentValue, selected: JSON.parse(JSON.stringify(this.selected)) });
      }));
    }, handleInput(t) {
      this.query = t.target.value;
    }, handleSelectItem(t) {
      const r = this.querySelections[t];
      if (r.item.disabled)
        return !1;
      this.query = "", this.$refs.input.currentValue = "";
      const o = JSON.stringify(this.currentValue);
      this.currentValue = r.value.split(","), setTimeout(() => {
        this.emitValue(this.currentValue, o), this.handleClose();
      }, 0);
    }, handleFocus() {
      this.$refs.input.focus();
    }, getValidData(t) {
      const r = W(t);
      function o(C) {
        const g = Object.assign({}, C);
        return "loading" in g && delete g.loading, "__value" in g && delete g.__value, "__label" in g && delete g.__label, "children" in g && g.children.length && (g.children = g.children.map((a) => o(a))), g;
      }
      return r.map((C) => o(C));
    }, handleOnResultChange(t) {
      const r = t.lastValue, o = t.changeOnSelect, C = t.fromInit;
      if (r || o) {
        const g = JSON.stringify(this.currentValue);
        this.selected = this.tmpSelected;
        let a = [];
        this.selected.forEach((x) => {
          a.push(x.value);
        }), C || (this.updatingValue = !0, this.currentValue = a, this.emitValue(this.currentValue, g));
      }
      r && !C && this.handleClose();
    } }, created() {
      this.validDataStr = JSON.stringify(this.getValidData(this.data));
    }, mounted() {
      this.updateSelected(!0);
    }, watch: { visible(t) {
      t ? (this.currentValue.length && this.updateSelected(), this.transfer && this.$refs.drop.update(), this.$refs.drop.handleOnUpdatePopper()) : (this.filterable && (this.query = "", this.$refs.input.currentValue = ""), this.transfer && this.$refs.drop.destroy(), this.$refs.drop.handleOnDestroyPopper()), this.$emit("on-visible-change", t);
    }, modelValue(t) {
      t === null && (this.isValueNull = !0), this.currentValue = t || [], (t === null || !t.length) && (this.selected = []);
    }, currentValue() {
      if (this.isValueNull ? (this.isValueNull = !1, this.$emit("update:modelValue", null)) : this.$emit("update:modelValue", this.currentValue), this.updatingValue) {
        this.updatingValue = !1;
        return;
      }
      this.updateSelected(!0);
    }, data: { deep: !0, handler() {
      const t = JSON.stringify(this.getValidData(this.data));
      t !== this.validDataStr && (this.validDataStr = t, this.isLoadedChildren || e.nextTick(() => this.updateSelected(!1, this.changeOnSelect)), this.isLoadedChildren = !1);
    } } } }, A_ = ["name", "value"], F_ = ["onClick", "innerHTML"];
    function L_(t, r, o, C, g, a) {
      const x = e.resolveComponent("i-input"), O = e.resolveComponent("Icon"), P = e.resolveComponent("Caspanel"), N = e.resolveComponent("Drop"), B = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-rel"]), onClick: r[1] || (r[1] = (...H) => a.toggleOpen && a.toggleOpen(...H)), ref: "reference" }, [e.createElementVNode("input", { type: "hidden", name: o.name, value: g.currentValue }, null, 8, A_), e.renderSlot(t.$slots, "default", {}, () => [e.createVNode(x, { "element-id": o.elementId, ref: "input", readonly: !o.filterable, disabled: t.itemDisabled, modelValue: a.displayInputRender, onOnChange: a.handleInput, size: o.size, placeholder: a.inputPlaceholder }, null, 8, ["element-id", "readonly", "disabled", "modelValue", "onOnChange", "size", "placeholder"]), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-label"]), onClick: r[0] || (r[0] = (...H) => a.handleFocus && a.handleFocus(...H)) }, e.toDisplayString(a.displayRender), 3), [[e.vShow, o.filterable && g.query === ""]]), e.withDirectives(e.createVNode(O, { type: "ios-close-circle", class: e.normalizeClass([g.prefixCls + "-arrow"]), onClick: e.withModifiers(a.clearSelect, ["stop"]) }, null, 8, ["class", "onClick"]), [[e.vShow, a.showCloseIcon]]), e.createVNode(O, { type: a.arrowType, custom: a.customArrowType, size: a.arrowSize, class: e.normalizeClass([g.prefixCls + "-arrow"]) }, null, 8, ["type", "custom", "size", "class"])])], 2), e.createVNode(N, { ref: "drop", visible: g.visible, classes: a.dropdownCls, eventsEnabled: o.eventsEnabled, "transition-name": "transition-drop", transfer: o.transfer }, { default: e.withCtx(() => [e.createElementVNode("div", null, [e.withDirectives(e.createVNode(P, { ref: "caspanel", "prefix-cls": g.prefixCls, data: o.data, disabled: t.itemDisabled, "change-on-select": o.changeOnSelect, trigger: o.trigger }, null, 8, ["prefix-cls", "data", "disabled", "change-on-select", "trigger"]), [[e.vShow, !o.filterable || o.filterable && g.query === ""]]), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-dropdown"]) }, [e.createElementVNode("ul", { class: e.normalizeClass([g.selectPrefixCls + "-dropdown-list"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.querySelections, (H, oe) => (e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass([g.selectPrefixCls + "-item", { [g.selectPrefixCls + "-item-disabled"]: H.disabled }]), key: oe, onClick: (se) => a.handleSelectItem(oe), innerHTML: H.display }, null, 10, F_))), 128))], 2)], 2), [[e.vShow, o.filterable && g.query !== "" && a.querySelections.length]]), e.withDirectives(e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-not-found-tip"]) }, [e.createElementVNode("li", null, e.toDisplayString(a.localeNotFoundText), 1)], 2), [[e.vShow, o.filterable && g.query !== "" && !a.querySelections.length || !o.data.length]])])]), _: 1 }, 8, ["visible", "classes", "eventsEnabled", "transfer"])], 2)), [[B, a.handleClose]]);
    }
    var mg = f(M_, [["render", L_]]);
    const z_ = { name: "CellItem", props: { title: { type: String, default: "" }, label: { type: String, default: "" }, extra: { type: String, default: "" } } }, R_ = { class: "ivu-cell-item" }, j_ = { class: "ivu-cell-icon" }, H_ = { class: "ivu-cell-main" }, U_ = { class: "ivu-cell-title" }, W_ = { class: "ivu-cell-label" }, Y_ = { class: "ivu-cell-footer" }, K_ = { class: "ivu-cell-extra" };
    function G_(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", R_, [e.createElementVNode("div", j_, [e.renderSlot(t.$slots, "icon")]), e.createElementVNode("div", H_, [e.createElementVNode("div", U_, [e.renderSlot(t.$slots, "default", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])]), e.createElementVNode("div", W_, [e.renderSlot(t.$slots, "label", {}, () => [e.createTextVNode(e.toDisplayString(o.label), 1)])])]), e.createElementVNode("div", Y_, [e.createElementVNode("span", K_, [e.renderSlot(t.$slots, "extra", {}, () => [e.createTextVNode(e.toDisplayString(o.extra), 1)])])])]);
    }
    var X_ = f(z_, [["render", G_]]);
    const ra = "ivu-cell", q_ = { name: "Cell", inject: ["CellGroupInstance"], mixins: [je, kr], components: { CellItem: X_, Icon: G }, props: { name: { type: [String, Number] }, title: { type: String, default: "" }, label: { type: String, default: "" }, extra: { type: String, default: "" }, disabled: { type: Boolean, default: !1 }, selected: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: ra };
    }, computed: { classes() {
      return [`${ra}`, { [`${ra}-disabled`]: this.disabled, [`${ra}-selected`]: this.selected, [`${ra}-with-link`]: this.to }];
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-forward";
      return t && (t.cell.customArrow ? r = "" : t.cell.arrow && (r = t.cell.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cell.customArrow && (r = t.cell.customArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.cell.arrowSize && (r = t.cell.arrowSize), r;
    } }, methods: { handleClickItem(t, r) {
      this.CellGroupInstance.handleClick(this.name), this.handleCheckClick(t, r);
    } } }, J_ = ["href", "target"], Q_ = { key: 2, class: "ivu-cell-arrow" };
    function Z_(t, r, o, C, g, a) {
      const x = e.resolveComponent("CellItem"), O = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [t.to ? (e.openBlock(), e.createElementBlock("a", { key: 0, href: t.linkUrl, target: t.target, class: "ivu-cell-link", onClick: [r[0] || (r[0] = e.withModifiers((P) => a.handleClickItem(P, !1), ["exact"])), r[1] || (r[1] = e.withModifiers((P) => a.handleClickItem(P, !0), ["ctrl"])), r[2] || (r[2] = e.withModifiers((P) => a.handleClickItem(P, !0), ["meta"]))] }, [e.createVNode(x, { title: o.title, label: o.label, extra: o.extra }, { icon: e.withCtx(() => [e.renderSlot(t.$slots, "icon")]), default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), extra: e.withCtx(() => [e.renderSlot(t.$slots, "extra")]), label: e.withCtx(() => [e.renderSlot(t.$slots, "label")]), _: 3 }, 8, ["title", "label", "extra"])], 8, J_)) : (e.openBlock(), e.createElementBlock("div", { key: 1, class: "ivu-cell-link", onClick: r[3] || (r[3] = (...P) => a.handleClickItem && a.handleClickItem(...P)) }, [e.createVNode(x, { title: o.title, label: o.label, extra: o.extra }, { icon: e.withCtx(() => [e.renderSlot(t.$slots, "icon")]), default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), extra: e.withCtx(() => [e.renderSlot(t.$slots, "extra")]), label: e.withCtx(() => [e.renderSlot(t.$slots, "label")]), _: 3 }, 8, ["title", "label", "extra"])])), t.to ? (e.openBlock(), e.createElementBlock("div", Q_, [e.renderSlot(t.$slots, "arrow", {}, () => [e.createVNode(O, { type: a.arrowType, custom: a.customArrowType, size: a.arrowSize }, null, 8, ["type", "custom", "size"])])])) : e.createCommentVNode("", !0)], 2);
    }
    var gg = f(q_, [["render", Z_]]);
    const e2 = { name: "CellGroup", emits: ["on-click"], provide() {
      return { CellGroupInstance: this };
    }, methods: { handleClick(t) {
      this.$emit("on-click", t);
    } } }, t2 = { class: "ivu-cell-group" };
    function n2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", t2, [e.renderSlot(t.$slots, "default")]);
    }
    var vg = f(e2, [["render", n2]]);
    const ti = "ivu-checkbox", i2 = { name: "Checkbox", mixins: [nn], emits: ["update:modelValue", "on-change"], inject: { CheckboxGroupInstance: { default: null } }, props: { disabled: { type: Boolean, default: !1 }, modelValue: { type: [String, Number, Boolean], default: !1 }, trueValue: { type: [String, Number, Boolean], default: !0 }, falseValue: { type: [String, Number, Boolean], default: !1 }, label: { type: [String, Number, Boolean] }, indeterminate: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, name: { type: String }, border: { type: Boolean, default: !1 } }, data() {
      return { showSlot: !0, focusInner: !1, model: [] };
    }, computed: { wrapClasses() {
      return [`${ti}-wrapper`, { [`${ti}-group-item`]: this.group, [`${ti}-wrapper-checked`]: this.currentValue, [`${ti}-wrapper-disabled`]: this.itemDisabled, [`${ti}-${this.size}`]: !!this.size, [`${ti}-border`]: this.border }];
    }, checkboxClasses() {
      return [`${ti}`, { [`${ti}-checked`]: this.currentValue, [`${ti}-disabled`]: this.itemDisabled, [`${ti}-indeterminate`]: this.indeterminate }];
    }, innerClasses() {
      return [`${ti}-inner`, { [`${ti}-focus`]: this.focusInner }];
    }, inputClasses() {
      return `${ti}-input`;
    }, currentValue() {
      return this.CheckboxGroupInstance ? this.CheckboxGroupInstance.modelValue.indexOf(this.label) >= 0 : this.modelValue === this.trueValue;
    }, group() {
      return !!this.CheckboxGroupInstance;
    } }, mounted() {
      this.CheckboxGroupInstance || (this.showSlot = this.$slots.default !== void 0);
    }, methods: { change(t) {
      if (this.itemDisabled)
        return !1;
      const r = t.target.checked ? this.trueValue : this.falseValue;
      this.$emit("update:modelValue", r), this.group ? this.CheckboxGroupInstance.change(this.model) : (this.$emit("on-change", r), this.handleFormItemChange("change", r));
    }, onBlur() {
      this.focusInner = !1;
    }, onFocus() {
      this.focusInner = !0;
    } }, watch: { modelValue(t) {
      if (!(t === this.trueValue || t === this.falseValue))
        throw "Value should be trueValue or falseValue.";
    }, "CheckboxGroupInstance.modelValue": { handler(t) {
      this.model = t || [];
    }, immediate: !0 } } }, r2 = ["disabled", "value", "name"], s2 = ["disabled", "checked", "name"], o2 = { key: 0, class: "ivu-checkbox-label-text" };
    function a2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("label", { class: e.normalizeClass(a.wrapClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.checkboxClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.innerClasses) }, null, 2), a.group ? e.withDirectives((e.openBlock(), e.createElementBlock("input", { key: 0, type: "checkbox", class: e.normalizeClass(a.inputClasses), disabled: t.itemDisabled, value: o.label, "onUpdate:modelValue": r[0] || (r[0] = (x) => g.model = x), name: o.name, onChange: r[1] || (r[1] = (...x) => a.change && a.change(...x)), onFocus: r[2] || (r[2] = (...x) => a.onFocus && a.onFocus(...x)), onBlur: r[3] || (r[3] = (...x) => a.onBlur && a.onBlur(...x)) }, null, 42, r2)), [[e.vModelCheckbox, g.model]]) : (e.openBlock(), e.createElementBlock("input", { key: 1, type: "checkbox", class: e.normalizeClass(a.inputClasses), disabled: t.itemDisabled, checked: a.currentValue, name: o.name, onChange: r[4] || (r[4] = (...x) => a.change && a.change(...x)), onFocus: r[5] || (r[5] = (...x) => a.onFocus && a.onFocus(...x)), onBlur: r[6] || (r[6] = (...x) => a.onBlur && a.onBlur(...x)) }, null, 42, s2))], 2), g.showSlot ? (e.openBlock(), e.createElementBlock("span", o2, [e.renderSlot(t.$slots, "default", {}, () => [e.createTextVNode(e.toDisplayString(o.label), 1)])])) : e.createCommentVNode("", !0)], 2);
    }
    var ro = f(i2, [["render", a2]]);
    const l2 = "ivu-checkbox-group", c2 = { name: "CheckboxGroup", mixins: [nn], emits: ["update:modelValue", "on-change"], provide() {
      return { CheckboxGroupInstance: this };
    }, props: { modelValue: { type: Array, default() {
      return [];
    } }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } } }, data() {
      return { currentValue: this.modelValue || [], children: [] };
    }, computed: { classes() {
      return [`${l2}`, { [`ivu-checkbox-${this.size}`]: !!this.size }];
    } }, methods: { change(t) {
      this.currentValue = t, this.$emit("update:modelValue", t), this.$emit("on-change", t), this.handleFormItemChange("change", t);
    } } };
    function u2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var Uh = f(c2, [["render", u2]]);
    const yg = "ivu-chart-circle", h2 = { name: "iCircle", props: { percent: { type: Number, default: 0 }, size: { type: Number, default: 120 }, strokeWidth: { type: Number, default: 6 }, strokeColor: { type: [String, Array], default: "#2d8cf0" }, strokeLinecap: { validator(t) {
      return z(t, ["square", "round"]);
    }, default: "round" }, trailWidth: { type: Number, default: 5 }, trailColor: { type: String, default: "#eaeef2" }, dashboard: { type: Boolean, default: !1 } }, data() {
      return { id: `ivu-chart-circle-${be(3)}` };
    }, computed: { circleSize() {
      return { width: `${this.size}px`, height: `${this.size}px` };
    }, computedStrokeWidth() {
      return this.percent === 0 && this.dashboard ? 0 : this.strokeWidth;
    }, radius() {
      return 50 - this.strokeWidth / 2;
    }, pathString() {
      return this.dashboard ? `M 50,50 m 0,${this.radius}
                    a ${this.radius},${this.radius} 0 1 1 0,-${2 * this.radius}
                    a ${this.radius},${this.radius} 0 1 1 0,${2 * this.radius}` : `M 50,50 m 0,-${this.radius}
                    a ${this.radius},${this.radius} 0 1 1 0,${2 * this.radius}
                    a ${this.radius},${this.radius} 0 1 1 0,-${2 * this.radius}`;
    }, len() {
      return Math.PI * 2 * this.radius;
    }, trailStyle() {
      let t = {};
      return this.dashboard && (t = { "stroke-dasharray": `${this.len - 75}px ${this.len}px`, "stroke-dashoffset": `-${75 / 2}px`, transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s" }), t;
    }, pathStyle() {
      let t = {};
      return this.dashboard ? t = { "stroke-dasharray": `${this.percent / 100 * (this.len - 75)}px ${this.len}px`, "stroke-dashoffset": `-${75 / 2}px`, transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .6s ease 0s, stroke .6s, stroke-width .06s ease .6s" } : t = { "stroke-dasharray": `${this.len}px ${this.len}px`, "stroke-dashoffset": `${(100 - this.percent) / 100 * this.len}px`, transition: "stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease" }, t;
    }, wrapClasses() {
      return `${yg}`;
    }, innerClasses() {
      return `${yg}-inner`;
    }, strokeValue() {
      let t = this.strokeColor;
      return typeof this.strokeColor != "string" && (t = `url(#${this.id})`), t;
    }, showDefs() {
      return typeof this.strokeColor != "string";
    } } }, d2 = { viewBox: "0 0 100 100" }, f2 = { key: 0 }, p2 = ["id"], m2 = ["stop-color"], g2 = ["stop-color"], v2 = ["d", "stroke", "stroke-width", "stroke-linecap"], y2 = ["d", "stroke-linecap", "stroke", "stroke-width"];
    function b2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { style: e.normalizeStyle(a.circleSize), class: e.normalizeClass(a.wrapClasses) }, [(e.openBlock(), e.createElementBlock("svg", d2, [a.showDefs ? (e.openBlock(), e.createElementBlock("defs", f2, [e.createElementVNode("linearGradient", { id: g.id, x1: "100%", y1: "0%", x2: "0%", y2: "0%" }, [e.createElementVNode("stop", { offset: "0%", "stop-color": o.strokeColor[0] }, null, 8, m2), e.createElementVNode("stop", { offset: "100%", "stop-color": o.strokeColor[1] }, null, 8, g2)], 8, p2)])) : e.createCommentVNode("", !0), e.createElementVNode("path", { d: a.pathString, stroke: o.trailColor, "stroke-width": o.trailWidth, "fill-opacity": 0, style: e.normalizeStyle(a.trailStyle), "stroke-linecap": o.strokeLinecap }, null, 12, v2), e.createElementVNode("path", { d: a.pathString, "stroke-linecap": o.strokeLinecap, stroke: a.strokeValue, "stroke-width": a.computedStrokeWidth, "fill-opacity": "0", style: e.normalizeStyle(a.pathStyle) }, null, 12, y2)])), e.createElementVNode("div", { class: e.normalizeClass(a.innerClasses) }, [e.renderSlot(t.$slots, "default")], 2)], 6);
    }
    var ic = f(h2, [["render", b2]]);
    const rc = "ivu-dropdown", C2 = { name: "Dropdown", directives: { clickOutside: Hh }, components: { Drop: er }, emits: ["on-visible-change", "on-clickoutside", "on-click", "on-hover-click", "on-haschild-click"], props: { trigger: { validator(t) {
      return z(t, ["click", "hover", "custom", "contextMenu"]);
    }, default: "hover" }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom" }, visible: { type: Boolean, default: !1 }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, transferClassName: { type: String }, stopPropagation: { type: Boolean, default: !1 }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, eventsEnabled: { type: Boolean, default: !1 }, boundariesElement: { default: "window" } }, computed: { transition() {
      return ["bottom-start", "bottom", "bottom-end"].indexOf(this.placement) > -1 ? "slide-up" : "fade";
    }, dropdownCls() {
      return { [rc + "-transfer"]: this.transfer, [this.transferClassName]: this.transferClassName };
    }, relClasses() {
      return [`${rc}-rel`, { [`${rc}-rel-user-select-none`]: this.trigger === "contextMenu" }];
    } }, data() {
      return { prefixCls: rc, currentVisible: this.visible, timeout: null };
    }, watch: { visible(t) {
      this.currentVisible = t;
    }, currentVisible(t) {
      t ? this.$refs.drop.update() : this.$refs.drop.destroy(), this.$emit("on-visible-change", t);
    } }, methods: { handleClick() {
      if (this.trigger === "custom" || this.trigger !== "click")
        return !1;
      this.hasParent() || (this.currentVisible = !this.currentVisible);
    }, handleRightClick() {
      if (this.trigger === "custom" || this.trigger !== "contextMenu")
        return !1;
      this.currentVisible = !this.currentVisible;
    }, handleMouseenter() {
      if (this.trigger === "custom" || this.trigger !== "hover")
        return !1;
      this.timeout && clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.currentVisible = !0;
      }, 250);
    }, handleMouseleave() {
      if (this.trigger === "custom" || this.trigger !== "hover")
        return !1;
      this.timeout && (clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.currentVisible = !1;
      }, 150));
    }, onClickoutside(t) {
      this.handleClose(), this.handleRightClose(), this.currentVisible && this.$emit("on-clickoutside", t);
    }, handleClose() {
      if (this.trigger === "custom" || this.trigger !== "click")
        return !1;
      this.currentVisible = !1;
    }, handleRightClose() {
      if (this.trigger === "custom" || this.trigger !== "contextMenu")
        return !1;
      this.currentVisible = !1;
    }, hasParent() {
      return me(this, "Dropdown") || !1;
    }, handleHaschildClick() {
      e.nextTick(() => {
        if (this.trigger === "custom")
          return !1;
        this.currentVisible = !0;
      });
      const t = this.hasParent();
      t && t.handleHaschildClick();
    }, handleItemClick(t) {
      if (this.stopPropagation)
        return;
      const r = this.hasParent();
      r ? r.handleItemClick(t) : this.$emit("on-click", t);
    }, handleHoverClick() {
      const t = this.hasParent();
      t ? (e.nextTick(() => {
        if (this.trigger === "custom")
          return !1;
        this.currentVisible = !1;
      }), t.handleHoverClick()) : e.nextTick(() => {
        if (this.trigger === "custom")
          return !1;
        this.currentVisible = !1;
      });
    } } };
    function w2(t, r, o, C, g, a) {
      const x = e.resolveComponent("Drop"), O = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls]), onMouseenter: r[2] || (r[2] = (...P) => a.handleMouseenter && a.handleMouseenter(...P)), onMouseleave: r[3] || (r[3] = (...P) => a.handleMouseleave && a.handleMouseleave(...P)) }, [e.createElementVNode("div", { class: e.normalizeClass(a.relClasses), ref: "reference", onClick: r[0] || (r[0] = (...P) => a.handleClick && a.handleClick(...P)), onContextmenu: r[1] || (r[1] = e.withModifiers((...P) => a.handleRightClick && a.handleRightClick(...P), ["prevent"])) }, [e.renderSlot(t.$slots, "default")], 34), e.createVNode(x, { ref: "drop", visible: g.currentVisible, classes: a.dropdownCls, placement: o.placement, eventsEnabled: o.eventsEnabled, boundariesElement: o.boundariesElement, transfer: o.transfer, "transition-name": "transition-drop", onMouseenter: a.handleMouseenter, onMouseleave: a.handleMouseleave }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "list")]), _: 3 }, 8, ["visible", "classes", "placement", "eventsEnabled", "boundariesElement", "transfer", "onMouseenter", "onMouseleave"])], 34)), [[O, a.onClickoutside]]);
    }
    var ys = f(C2, [["render", w2]]);
    const k2 = { name: "DropdownMenu" }, S2 = { class: "ivu-dropdown-menu" };
    function E2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("ul", S2, [e.renderSlot(t.$slots, "default")]);
    }
    var bs = f(k2, [["render", E2]]);
    const fi = "ivu-tag", ir = ["default", "primary", "success", "warning", "error", "blue", "green", "red", "yellow", "pink", "magenta", "volcano", "orange", "gold", "lime", "cyan", "geekblue", "purple"], x2 = ["pink", "magenta", "volcano", "orange", "gold", "lime", "cyan", "geekblue", "purple"], _2 = { name: "Tag", components: { Icon: G }, emits: ["on-change", "on-close"], props: { closable: { type: Boolean, default: !1 }, checkable: { type: Boolean, default: !1 }, checked: { type: Boolean, default: !0 }, color: { type: String, default: "default" }, type: { validator(t) {
      return z(t, ["border", "dot"]);
    } }, name: { type: [String, Number] }, size: { validator(t) {
      return z(t, ["default", "medium", "large"]);
    }, default: "default" } }, data() {
      return { isChecked: this.checked };
    }, computed: { classes() {
      return [`${fi}`, `${fi}-size-${this.size}`, { [`${fi}-${this.color}`]: !!this.color && z(this.color, ir), [`${fi}-${this.type}`]: !!this.type, [`${fi}-closable`]: this.closable, [`${fi}-checked`]: this.isChecked, [`${fi}-checkable`]: this.checkable }];
    }, wraperStyles() {
      return z(this.color, ir) ? {} : { background: this.isChecked ? this.defaultTypeColor : "transparent", borderWidth: "1px", borderStyle: "solid", borderColor: this.type !== "dot" && this.type !== "border" && this.isChecked ? this.borderColor : this.lineColor, color: this.lineColor };
    }, textClasses() {
      return [`${fi}-text`, this.type === "border" && z(this.color, ir) ? `${fi}-color-${this.color}` : "", this.type !== "dot" && this.type !== "border" && this.color !== "default" && this.isChecked && x2.indexOf(this.color) < 0 ? `${fi}-color-white` : ""];
    }, dotClasses() {
      return `${fi}-dot-inner`;
    }, iconClass() {
      return this.type === "dot" ? "" : this.type === "border" ? z(this.color, ir) ? `${fi}-color-${this.color}` : "" : this.color !== void 0 ? this.color === "default" ? "" : "rgb(255, 255, 255)" : "";
    }, showDot() {
      return !!this.type && this.type === "dot";
    }, lineColor() {
      return this.type === "dot" ? "" : this.type === "border" ? this.color !== void 0 ? z(this.color, ir) ? "" : this.color : "" : this.color !== void 0 ? this.color === "default" ? "" : "rgb(255, 255, 255)" : "";
    }, borderColor() {
      return this.color !== void 0 ? this.color === "default" ? "" : this.color : "";
    }, dotColor() {
      return this.color !== void 0 ? z(this.color, ir) ? "" : this.color : "";
    }, textColorStyle() {
      return z(this.color, ir) ? {} : this.type !== "dot" && this.type !== "border" ? this.isChecked ? { color: this.lineColor } : {} : { color: this.lineColor };
    }, bgColorStyle() {
      return z(this.color, ir) ? {} : { background: this.dotColor };
    }, defaultTypeColor() {
      return this.type !== "dot" && this.type !== "border" && this.color !== void 0 ? z(this.color, ir) ? "" : this.color : "";
    } }, methods: { close(t) {
      this.name === void 0 ? this.$emit("on-close", t) : this.$emit("on-close", t, this.name);
    }, check() {
      if (!this.checkable)
        return;
      const t = !this.isChecked;
      this.isChecked = t, this.name === void 0 ? this.$emit("on-change", t) : this.$emit("on-change", t, this.name);
    } }, watch: { checked(t) {
      this.isChecked = t;
    } } };
    function T2(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onClick: r[0] || (r[0] = e.withModifiers((...O) => a.check && a.check(...O), ["stop"])), style: e.normalizeStyle(a.wraperStyles) }, [a.showDot ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.dotClasses), style: e.normalizeStyle(a.bgColorStyle) }, null, 6)) : e.createCommentVNode("", !0), e.createElementVNode("span", { class: e.normalizeClass(a.textClasses), style: e.normalizeStyle(a.textColorStyle) }, [e.renderSlot(t.$slots, "default")], 6), o.closable ? (e.openBlock(), e.createBlock(x, { key: 1, class: e.normalizeClass(a.iconClass), color: a.lineColor, type: "ios-close", onClick: e.withModifiers(a.close, ["stop"]) }, null, 8, ["class", "color", "onClick"])) : e.createCommentVNode("", !0)], 6);
    }
    var so = f(_2, [["render", T2]]), bg = { 11e4: { l: "Z1", n: "北京", c: "110000", p: "86" }, 12e4: { l: "Z1", n: "天津", c: "120000", p: "86" }, 13e4: { l: "H", n: "河北", c: "130000", p: "86" }, 14e4: { l: "S", n: "山西", c: "140000", p: "86" }, 15e4: { l: "N", n: "内蒙古", c: "150000", p: "86" }, 21e4: { l: "L", n: "辽宁", c: "210000", p: "86" }, 22e4: { l: "J", n: "吉林", c: "220000", p: "86" }, 23e4: { l: "H", n: "黑龙江", c: "230000", p: "86" }, 31e4: { l: "Z1", n: "上海", c: "310000", p: "86" }, 32e4: { l: "J", n: "江苏", c: "320000", p: "86" }, 33e4: { l: "Z", n: "浙江", c: "330000", p: "86" }, 34e4: { l: "A", n: "安徽", c: "340000", p: "86" }, 35e4: { l: "F", n: "福建", c: "350000", p: "86" }, 36e4: { l: "J", n: "江西", c: "360000", p: "86" }, 37e4: { l: "S", n: "山东", c: "370000", p: "86" }, 41e4: { l: "H", n: "河南", c: "410000", p: "86" }, 42e4: { l: "H", n: "湖北", c: "420000", p: "86" }, 43e4: { l: "H", n: "湖南", c: "430000", p: "86" }, 44e4: { l: "G", n: "广东", c: "440000", p: "86" }, 45e4: { l: "G", n: "广西", c: "450000", p: "86" }, 46e4: { l: "H", n: "海南", c: "460000", p: "86" }, 5e5: { l: "Z1", n: "重庆", c: "500000", p: "86" }, 51e4: { l: "S", n: "四川", c: "510000", p: "86" }, 52e4: { l: "G", n: "贵州", c: "520000", p: "86" }, 53e4: { l: "Y", n: "云南", c: "530000", p: "86" }, 54e4: { l: "X", n: "西藏", c: "540000", p: "86" }, 61e4: { l: "S", n: "陕西", c: "610000", p: "86" }, 62e4: { l: "G", n: "甘肃", c: "620000", p: "86" }, 63e4: { l: "Q", n: "青海", c: "630000", p: "86" }, 64e4: { l: "N", n: "宁夏", c: "640000", p: "86" }, 65e4: { l: "X", n: "新疆", c: "650000", p: "86" }, 71e4: { l: "T", n: "台湾", c: "710000", p: "86" }, 81e4: { l: "Z2", n: "香港", c: "810000", p: "86" }, 82e4: { l: "Z2", n: "澳门", c: "820000", p: "86" } }, oo = { 11e4: { l: "B", n: "北京市", c: "110000", p: "86" }, 12e4: { l: "T", n: "天津市", c: "120000", p: "86" }, 130100: { l: "S", n: "石家庄市", c: "130100", p: "130000" }, 130200: { l: "T", n: "唐山市", c: "130200", p: "130000" }, 130300: { l: "Q", n: "秦皇岛市", c: "130300", p: "130000" }, 130400: { l: "H", n: "邯郸市", c: "130400", p: "130000" }, 130500: { l: "X", n: "邢台市", c: "130500", p: "130000" }, 130600: { l: "B", n: "保定市", c: "130600", p: "130000" }, 130700: { l: "Z", n: "张家口市", c: "130700", p: "130000" }, 130800: { l: "C", n: "承德市", c: "130800", p: "130000" }, 130900: { l: "C", n: "沧州市", c: "130900", p: "130000" }, 131e3: { l: "L", n: "廊坊市", c: "131000", p: "130000" }, 131100: { l: "H", n: "衡水市", c: "131100", p: "130000" }, 139001: { l: "D", n: "定州市", c: "139001", p: "130000" }, 139002: { l: "X", n: "辛集市", c: "139002", p: "130000" }, 140100: { l: "T", n: "太原市", c: "140100", p: "140000" }, 140200: { l: "D", n: "大同市", c: "140200", p: "140000" }, 140300: { l: "Y", n: "阳泉市", c: "140300", p: "140000" }, 140400: { l: "C", n: "长治市", c: "140400", p: "140000" }, 140500: { l: "J", n: "晋城市", c: "140500", p: "140000" }, 140600: { l: "S", n: "朔州市", c: "140600", p: "140000" }, 140700: { l: "J", n: "晋中市", c: "140700", p: "140000" }, 140800: { l: "Y", n: "运城市", c: "140800", p: "140000" }, 140900: { l: "X", n: "忻州市", c: "140900", p: "140000" }, 141e3: { l: "L", n: "临汾市", c: "141000", p: "140000" }, 141100: { l: "L", n: "吕梁市", c: "141100", p: "140000" }, 150100: { l: "H", n: "呼和浩特市", c: "150100", p: "150000" }, 150200: { l: "B", n: "包头市", c: "150200", p: "150000" }, 150300: { l: "W", n: "乌海市", c: "150300", p: "150000" }, 150400: { l: "C", n: "赤峰市", c: "150400", p: "150000" }, 150500: { l: "T", n: "通辽市", c: "150500", p: "150000" }, 150600: { l: "E", n: "鄂尔多斯市", c: "150600", p: "150000" }, 150700: { l: "H", n: "呼伦贝尔市", c: "150700", p: "150000" }, 150800: { l: "B", n: "巴彦淖尔市", c: "150800", p: "150000" }, 150900: { l: "W", n: "乌兰察布市", c: "150900", p: "150000" }, 152200: { l: "X", n: "兴安盟", c: "152200", p: "150000" }, 152500: { l: "X", n: "锡林郭勒盟", c: "152500", p: "150000" }, 152900: { l: "A", n: "阿拉善盟", c: "152900", p: "150000" }, 210100: { l: "S", n: "沈阳市", c: "210100", p: "210000" }, 210200: { l: "D", n: "大连市", c: "210200", p: "210000" }, 210300: { l: "A", n: "鞍山市", c: "210300", p: "210000" }, 210400: { l: "F", n: "抚顺市", c: "210400", p: "210000" }, 210500: { l: "B", n: "本溪市", c: "210500", p: "210000" }, 210600: { l: "D", n: "丹东市", c: "210600", p: "210000" }, 210700: { l: "J", n: "锦州市", c: "210700", p: "210000" }, 210800: { l: "Y", n: "营口市", c: "210800", p: "210000" }, 210900: { l: "F", n: "阜新市", c: "210900", p: "210000" }, 211e3: { l: "L", n: "辽阳市", c: "211000", p: "210000" }, 211100: { l: "P", n: "盘锦市", c: "211100", p: "210000" }, 211200: { l: "T", n: "铁岭市", c: "211200", p: "210000" }, 211300: { l: "C", n: "朝阳市", c: "211300", p: "210000" }, 211400: { l: "H", n: "葫芦岛市", c: "211400", p: "210000" }, 220100: { l: "C", n: "长春市", c: "220100", p: "220000" }, 220200: { l: "J", n: "吉林市", c: "220200", p: "220000" }, 220300: { l: "S", n: "四平市", c: "220300", p: "220000" }, 220400: { l: "L", n: "辽源市", c: "220400", p: "220000" }, 220500: { l: "T", n: "通化市", c: "220500", p: "220000" }, 220600: { l: "B", n: "白山市", c: "220600", p: "220000" }, 220700: { l: "S", n: "松原市", c: "220700", p: "220000" }, 220800: { l: "B", n: "白城市", c: "220800", p: "220000" }, 222400: { l: "Y", n: "延边朝鲜族自治州", c: "222400", p: "220000" }, 230100: { l: "H", n: "哈尔滨市", c: "230100", p: "230000" }, 230200: { l: "Q", n: "齐齐哈尔市", c: "230200", p: "230000" }, 230300: { l: "J", n: "鸡西市", c: "230300", p: "230000" }, 230400: { l: "H", n: "鹤岗市", c: "230400", p: "230000" }, 230500: { l: "S", n: "双鸭山市", c: "230500", p: "230000" }, 230600: { l: "D", n: "大庆市", c: "230600", p: "230000" }, 230700: { l: "Y", n: "伊春市", c: "230700", p: "230000" }, 230800: { l: "J", n: "佳木斯市", c: "230800", p: "230000" }, 230900: { l: "Q", n: "七台河市", c: "230900", p: "230000" }, 231e3: { l: "M", n: "牡丹江市", c: "231000", p: "230000" }, 231100: { l: "H", n: "黑河市", c: "231100", p: "230000" }, 231200: { l: "S", n: "绥化市", c: "231200", p: "230000" }, 232700: { l: "D", n: "大兴安岭地区", c: "232700", p: "230000" }, 31e4: { l: "S", n: "上海市", c: "310000", p: "86" }, 320100: { l: "N", n: "南京市", c: "320100", p: "320000" }, 320200: { l: "W", n: "无锡市", c: "320200", p: "320000" }, 320300: { l: "X", n: "徐州市", c: "320300", p: "320000" }, 320400: { l: "C", n: "常州市", c: "320400", p: "320000" }, 320500: { l: "S", n: "苏州市", c: "320500", p: "320000" }, 320600: { l: "N", n: "南通市", c: "320600", p: "320000" }, 320700: { l: "L", n: "连云港市", c: "320700", p: "320000" }, 320800: { l: "H", n: "淮安市", c: "320800", p: "320000" }, 320900: { l: "Y", n: "盐城市", c: "320900", p: "320000" }, 321e3: { l: "Y", n: "扬州市", c: "321000", p: "320000" }, 321100: { l: "Z", n: "镇江市", c: "321100", p: "320000" }, 321200: { l: "T", n: "泰州市", c: "321200", p: "320000" }, 321300: { l: "X", n: "宿迁市", c: "321300", p: "320000" }, 330100: { l: "H", n: "杭州市", c: "330100", p: "330000" }, 330200: { l: "N", n: "宁波市", c: "330200", p: "330000" }, 330300: { l: "W", n: "温州市", c: "330300", p: "330000" }, 330400: { l: "J", n: "嘉兴市", c: "330400", p: "330000" }, 330500: { l: "H", n: "湖州市", c: "330500", p: "330000" }, 330600: { l: "S", n: "绍兴市", c: "330600", p: "330000" }, 330700: { l: "J", n: "金华市", c: "330700", p: "330000" }, 330800: { l: "Q", n: "衢州市", c: "330800", p: "330000" }, 330900: { l: "Z", n: "舟山市", c: "330900", p: "330000" }, 331e3: { l: "T", n: "台州市", c: "331000", p: "330000" }, 331100: { l: "L", n: "丽水市", c: "331100", p: "330000" }, 340100: { l: "H", n: "合肥市", c: "340100", p: "340000" }, 340200: { l: "W", n: "芜湖市", c: "340200", p: "340000" }, 340300: { l: "B", n: "蚌埠市", c: "340300", p: "340000" }, 340400: { l: "H", n: "淮南市", c: "340400", p: "340000" }, 340500: { l: "M", n: "马鞍山市", c: "340500", p: "340000" }, 340600: { l: "H", n: "淮北市", c: "340600", p: "340000" }, 340700: { l: "T", n: "铜陵市", c: "340700", p: "340000" }, 340800: { l: "A", n: "安庆市", c: "340800", p: "340000" }, 341e3: { l: "H", n: "黄山市", c: "341000", p: "340000" }, 341100: { l: "C", n: "滁州市", c: "341100", p: "340000" }, 341200: { l: "F", n: "阜阳市", c: "341200", p: "340000" }, 341300: { l: "X", n: "宿州市", c: "341300", p: "340000" }, 341500: { l: "L", n: "六安市", c: "341500", p: "340000" }, 341600: { l: "B", n: "亳州市", c: "341600", p: "340000" }, 341700: { l: "C", n: "池州市", c: "341700", p: "340000" }, 341800: { l: "X", n: "宣城市", c: "341800", p: "340000" }, 350100: { l: "F", n: "福州市", c: "350100", p: "350000" }, 350200: { l: "S", n: "厦门市", c: "350200", p: "350000" }, 350300: { l: "P", n: "莆田市", c: "350300", p: "350000" }, 350400: { l: "S", n: "三明市", c: "350400", p: "350000" }, 350500: { l: "Q", n: "泉州市", c: "350500", p: "350000" }, 350600: { l: "Z", n: "漳州市", c: "350600", p: "350000" }, 350700: { l: "N", n: "南平市", c: "350700", p: "350000" }, 350800: { l: "L", n: "龙岩市", c: "350800", p: "350000" }, 350900: { l: "N", n: "宁德市", c: "350900", p: "350000" }, 360100: { l: "N", n: "南昌市", c: "360100", p: "360000" }, 360200: { l: "J", n: "景德镇市", c: "360200", p: "360000" }, 360300: { l: "P", n: "萍乡市", c: "360300", p: "360000" }, 360400: { l: "J", n: "九江市", c: "360400", p: "360000" }, 360500: { l: "X", n: "新余市", c: "360500", p: "360000" }, 360600: { l: "Y", n: "鹰潭市", c: "360600", p: "360000" }, 360700: { l: "G", n: "赣州市", c: "360700", p: "360000" }, 360800: { l: "J", n: "吉安市", c: "360800", p: "360000" }, 360900: { l: "Y", n: "宜春市", c: "360900", p: "360000" }, 361e3: { l: "F", n: "抚州市", c: "361000", p: "360000" }, 361100: { l: "S", n: "上饶市", c: "361100", p: "360000" }, 370100: { l: "J", n: "济南市", c: "370100", p: "370000" }, 370200: { l: "Q", n: "青岛市", c: "370200", p: "370000" }, 370300: { l: "Z", n: "淄博市", c: "370300", p: "370000" }, 370400: { l: "Z", n: "枣庄市", c: "370400", p: "370000" }, 370500: { l: "D", n: "东营市", c: "370500", p: "370000" }, 370600: { l: "Y", n: "烟台市", c: "370600", p: "370000" }, 370700: { l: "W", n: "潍坊市", c: "370700", p: "370000" }, 370800: { l: "J", n: "济宁市", c: "370800", p: "370000" }, 370900: { l: "T", n: "泰安市", c: "370900", p: "370000" }, 371e3: { l: "W", n: "威海市", c: "371000", p: "370000" }, 371100: { l: "R", n: "日照市", c: "371100", p: "370000" }, 371200: { l: "L", n: "莱芜市", c: "371200", p: "370000" }, 371300: { l: "L", n: "临沂市", c: "371300", p: "370000" }, 371400: { l: "D", n: "德州市", c: "371400", p: "370000" }, 371500: { l: "L", n: "聊城市", c: "371500", p: "370000" }, 371600: { l: "B", n: "滨州市", c: "371600", p: "370000" }, 371700: { l: "H", n: "菏泽市", c: "371700", p: "370000" }, 410100: { l: "Z", n: "郑州市", c: "410100", p: "410000" }, 410200: { l: "K", n: "开封市", c: "410200", p: "410000" }, 410300: { l: "L", n: "洛阳市", c: "410300", p: "410000" }, 410400: { l: "P", n: "平顶山市", c: "410400", p: "410000" }, 410500: { l: "A", n: "安阳市", c: "410500", p: "410000" }, 410600: { l: "H", n: "鹤壁市", c: "410600", p: "410000" }, 410700: { l: "X", n: "新乡市", c: "410700", p: "410000" }, 410800: { l: "J", n: "焦作市", c: "410800", p: "410000" }, 410900: { l: "P", n: "濮阳市", c: "410900", p: "410000" }, 411e3: { l: "X", n: "许昌市", c: "411000", p: "410000" }, 411100: { l: "L", n: "漯河市", c: "411100", p: "410000" }, 411200: { l: "S", n: "三门峡市", c: "411200", p: "410000" }, 411300: { l: "N", n: "南阳市", c: "411300", p: "410000" }, 411400: { l: "S", n: "商丘市", c: "411400", p: "410000" }, 411500: { l: "X", n: "信阳市", c: "411500", p: "410000" }, 411600: { l: "Z", n: "周口市", c: "411600", p: "410000" }, 411700: { l: "Z", n: "驻马店市", c: "411700", p: "410000" }, 419001: { l: "J", n: "济源市", c: "419001", p: "410000" }, 420100: { l: "W", n: "武汉市", c: "420100", p: "420000" }, 420200: { l: "H", n: "黄石市", c: "420200", p: "420000" }, 420300: { l: "S", n: "十堰市", c: "420300", p: "420000" }, 420500: { l: "Y", n: "宜昌市", c: "420500", p: "420000" }, 420600: { l: "X", n: "襄阳市", c: "420600", p: "420000" }, 420700: { l: "E", n: "鄂州市", c: "420700", p: "420000" }, 420800: { l: "J", n: "荆门市", c: "420800", p: "420000" }, 420900: { l: "X", n: "孝感市", c: "420900", p: "420000" }, 421e3: { l: "J", n: "荆州市", c: "421000", p: "420000" }, 421100: { l: "H", n: "黄冈市", c: "421100", p: "420000" }, 421200: { l: "X", n: "咸宁市", c: "421200", p: "420000" }, 421300: { l: "S", n: "随州市", c: "421300", p: "420000" }, 422800: { l: "E", n: "恩施土家族苗族自治州", c: "422800", p: "420000" }, 429004: { l: "X", n: "仙桃市", c: "429004", p: "420000" }, 429005: { l: "Q", n: "潜江市", c: "429005", p: "420000" }, 429006: { l: "T", n: "天门市", c: "429006", p: "420000" }, 429021: { l: "S", n: "神农架林区", c: "429021", p: "420000" }, 430100: { l: "C", n: "长沙市", c: "430100", p: "430000" }, 430200: { l: "Z", n: "株洲市", c: "430200", p: "430000" }, 430300: { l: "X", n: "湘潭市", c: "430300", p: "430000" }, 430400: { l: "H", n: "衡阳市", c: "430400", p: "430000" }, 430500: { l: "S", n: "邵阳市", c: "430500", p: "430000" }, 430600: { l: "Y", n: "岳阳市", c: "430600", p: "430000" }, 430700: { l: "C", n: "常德市", c: "430700", p: "430000" }, 430800: { l: "Z", n: "张家界市", c: "430800", p: "430000" }, 430900: { l: "Y", n: "益阳市", c: "430900", p: "430000" }, 431e3: { l: "C", n: "郴州市", c: "431000", p: "430000" }, 431100: { l: "Y", n: "永州市", c: "431100", p: "430000" }, 431200: { l: "H", n: "怀化市", c: "431200", p: "430000" }, 431300: { l: "L", n: "娄底市", c: "431300", p: "430000" }, 433100: { l: "X", n: "湘西土家族苗族自治州", c: "433100", p: "430000" }, 440100: { l: "G", n: "广州市", c: "440100", p: "440000" }, 440200: { l: "S", n: "韶关市", c: "440200", p: "440000" }, 440300: { l: "S", n: "深圳市", c: "440300", p: "440000" }, 440400: { l: "Z", n: "珠海市", c: "440400", p: "440000" }, 440500: { l: "S", n: "汕头市", c: "440500", p: "440000" }, 440600: { l: "F", n: "佛山市", c: "440600", p: "440000" }, 440700: { l: "J", n: "江门市", c: "440700", p: "440000" }, 440800: { l: "Z", n: "湛江市", c: "440800", p: "440000" }, 440900: { l: "M", n: "茂名市", c: "440900", p: "440000" }, 441200: { l: "Z", n: "肇庆市", c: "441200", p: "440000" }, 441300: { l: "H", n: "惠州市", c: "441300", p: "440000" }, 441400: { l: "M", n: "梅州市", c: "441400", p: "440000" }, 441500: { l: "S", n: "汕尾市", c: "441500", p: "440000" }, 441600: { l: "H", n: "河源市", c: "441600", p: "440000" }, 441700: { l: "Y", n: "阳江市", c: "441700", p: "440000" }, 441800: { l: "Q", n: "清远市", c: "441800", p: "440000" }, 441900: { l: "D", n: "东莞市", c: "441900", p: "440000" }, 442e3: { l: "Z", n: "中山市", c: "442000", p: "440000" }, 445100: { l: "C", n: "潮州市", c: "445100", p: "440000" }, 445200: { l: "J", n: "揭阳市", c: "445200", p: "440000" }, 445300: { l: "Y", n: "云浮市", c: "445300", p: "440000" }, 450100: { l: "N", n: "南宁市", c: "450100", p: "450000" }, 450200: { l: "L", n: "柳州市", c: "450200", p: "450000" }, 450300: { l: "G", n: "桂林市", c: "450300", p: "450000" }, 450400: { l: "W", n: "梧州市", c: "450400", p: "450000" }, 450500: { l: "B", n: "北海市", c: "450500", p: "450000" }, 450600: { l: "F", n: "防城港市", c: "450600", p: "450000" }, 450700: { l: "Q", n: "钦州市", c: "450700", p: "450000" }, 450800: { l: "G", n: "贵港市", c: "450800", p: "450000" }, 450900: { l: "Y", n: "玉林市", c: "450900", p: "450000" }, 451e3: { l: "B", n: "百色市", c: "451000", p: "450000" }, 451100: { l: "H", n: "贺州市", c: "451100", p: "450000" }, 451200: { l: "H", n: "河池市", c: "451200", p: "450000" }, 451300: { l: "L", n: "来宾市", c: "451300", p: "450000" }, 451400: { l: "C", n: "崇左市", c: "451400", p: "450000" }, 460100: { l: "H", n: "海口市", c: "460100", p: "460000" }, 460200: { l: "S", n: "三亚市", c: "460200", p: "460000" }, 460300: { l: "S", n: "三沙市", c: "460300", p: "460000" }, 460400: { l: "D", n: "儋州市", c: "460400", p: "460000" }, 469001: { l: "W", n: "五指山市", c: "469001", p: "460000" }, 469002: { l: "Q", n: "琼海市", c: "469002", p: "460000" }, 469005: { l: "W", n: "文昌市", c: "469005", p: "460000" }, 469006: { l: "W", n: "万宁市", c: "469006", p: "460000" }, 469007: { l: "D", n: "东方市", c: "469007", p: "460000" }, 469021: { l: "D", n: "定安县", c: "469021", p: "460000" }, 469022: { l: "T", n: "屯昌县", c: "469022", p: "460000" }, 469023: { l: "C", n: "澄迈县", c: "469023", p: "460000" }, 469024: { l: "L", n: "临高县", c: "469024", p: "460000" }, 469025: { l: "B", n: "白沙黎族自治县", c: "469025", p: "460000" }, 469026: { l: "C", n: "昌江黎族自治县", c: "469026", p: "460000" }, 469027: { l: "L", n: "乐东黎族自治县", c: "469027", p: "460000" }, 469028: { l: "L", n: "陵水黎族自治县", c: "469028", p: "460000" }, 469029: { l: "B", n: "保亭黎族苗族自治县", c: "469029", p: "460000" }, 469030: { l: "Q", n: "琼中黎族苗族自治县", c: "469030", p: "460000" }, 5e5: { l: "C", n: "重庆市", c: "500000", p: "86" }, 510100: { l: "C", n: "成都市", c: "510100", p: "510000" }, 510300: { l: "Z", n: "自贡市", c: "510300", p: "510000" }, 510400: { l: "P", n: "攀枝花市", c: "510400", p: "510000" }, 510500: { l: "L", n: "泸州市", c: "510500", p: "510000" }, 510600: { l: "D", n: "德阳市", c: "510600", p: "510000" }, 510700: { l: "M", n: "绵阳市", c: "510700", p: "510000" }, 510800: { l: "G", n: "广元市", c: "510800", p: "510000" }, 510900: { l: "S", n: "遂宁市", c: "510900", p: "510000" }, 511e3: { l: "N", n: "内江市", c: "511000", p: "510000" }, 511100: { l: "L", n: "乐山市", c: "511100", p: "510000" }, 511300: { l: "N", n: "南充市", c: "511300", p: "510000" }, 511400: { l: "M", n: "眉山市", c: "511400", p: "510000" }, 511500: { l: "Y", n: "宜宾市", c: "511500", p: "510000" }, 511600: { l: "G", n: "广安市", c: "511600", p: "510000" }, 511700: { l: "D", n: "达州市", c: "511700", p: "510000" }, 511800: { l: "Y", n: "雅安市", c: "511800", p: "510000" }, 511900: { l: "B", n: "巴中市", c: "511900", p: "510000" }, 512e3: { l: "Z", n: "资阳市", c: "512000", p: "510000" }, 513200: { l: "A", n: "阿坝藏族羌族自治州", c: "513200", p: "510000" }, 513300: { l: "G", n: "甘孜藏族自治州", c: "513300", p: "510000" }, 513400: { l: "L", n: "凉山彝族自治州", c: "513400", p: "510000" }, 520100: { l: "G", n: "贵阳市", c: "520100", p: "520000" }, 520200: { l: "L", n: "六盘水市", c: "520200", p: "520000" }, 520300: { l: "Z", n: "遵义市", c: "520300", p: "520000" }, 520400: { l: "A", n: "安顺市", c: "520400", p: "520000" }, 520500: { l: "B", n: "毕节市", c: "520500", p: "520000" }, 520600: { l: "T", n: "铜仁市", c: "520600", p: "520000" }, 522300: { l: "Q", n: "黔西南布依族苗族自治州", c: "522300", p: "520000" }, 522600: { l: "Q", n: "黔东南苗族侗族自治州", c: "522600", p: "520000" }, 522700: { l: "Q", n: "黔南布依族苗族自治州", c: "522700", p: "520000" }, 530100: { l: "K", n: "昆明市", c: "530100", p: "530000" }, 530300: { l: "Q", n: "曲靖市", c: "530300", p: "530000" }, 530400: { l: "Y", n: "玉溪市", c: "530400", p: "530000" }, 530500: { l: "B", n: "保山市", c: "530500", p: "530000" }, 530600: { l: "Z", n: "昭通市", c: "530600", p: "530000" }, 530700: { l: "L", n: "丽江市", c: "530700", p: "530000" }, 530800: { l: "P", n: "普洱市", c: "530800", p: "530000" }, 530900: { l: "L", n: "临沧市", c: "530900", p: "530000" }, 532300: { l: "C", n: "楚雄彝族自治州", c: "532300", p: "530000" }, 532500: { l: "H", n: "红河哈尼族彝族自治州", c: "532500", p: "530000" }, 532600: { l: "W", n: "文山壮族苗族自治州", c: "532600", p: "530000" }, 532800: { l: "X", n: "西双版纳傣族自治州", c: "532800", p: "530000" }, 532900: { l: "D", n: "大理白族自治州", c: "532900", p: "530000" }, 533100: { l: "D", n: "德宏傣族景颇族自治州", c: "533100", p: "530000" }, 533300: { l: "N", n: "怒江傈僳族自治州", c: "533300", p: "530000" }, 533400: { l: "D", n: "迪庆藏族自治州", c: "533400", p: "530000" }, 540100: { l: "L", n: "拉萨市", c: "540100", p: "540000" }, 540200: { l: "R", n: "日喀则市", c: "540200", p: "540000" }, 540300: { l: "C", n: "昌都市", c: "540300", p: "540000" }, 540400: { l: "L", n: "林芝市", c: "540400", p: "540000" }, 540500: { l: "S", n: "山南市", c: "540500", p: "540000" }, 542400: { l: "N", n: "那曲地区", c: "542400", p: "540000" }, 542500: { l: "A", n: "阿里地区", c: "542500", p: "540000" }, 610100: { l: "X", n: "西安市", c: "610100", p: "610000" }, 610200: { l: "T", n: "铜川市", c: "610200", p: "610000" }, 610300: { l: "B", n: "宝鸡市", c: "610300", p: "610000" }, 610400: { l: "X", n: "咸阳市", c: "610400", p: "610000" }, 610500: { l: "W", n: "渭南市", c: "610500", p: "610000" }, 610600: { l: "Y", n: "延安市", c: "610600", p: "610000" }, 610700: { l: "H", n: "汉中市", c: "610700", p: "610000" }, 610800: { l: "Y", n: "榆林市", c: "610800", p: "610000" }, 610900: { l: "A", n: "安康市", c: "610900", p: "610000" }, 611e3: { l: "S", n: "商洛市", c: "611000", p: "610000" }, 620100: { l: "L", n: "兰州市", c: "620100", p: "620000" }, 620200: { l: "J", n: "嘉峪关市", c: "620200", p: "620000" }, 620300: { l: "J", n: "金昌市", c: "620300", p: "620000" }, 620400: { l: "B", n: "白银市", c: "620400", p: "620000" }, 620500: { l: "T", n: "天水市", c: "620500", p: "620000" }, 620600: { l: "W", n: "武威市", c: "620600", p: "620000" }, 620700: { l: "Z", n: "张掖市", c: "620700", p: "620000" }, 620800: { l: "P", n: "平凉市", c: "620800", p: "620000" }, 620900: { l: "J", n: "酒泉市", c: "620900", p: "620000" }, 621e3: { l: "Q", n: "庆阳市", c: "621000", p: "620000" }, 621100: { l: "D", n: "定西市", c: "621100", p: "620000" }, 621200: { l: "L", n: "陇南市", c: "621200", p: "620000" }, 622900: { l: "L", n: "临夏回族自治州", c: "622900", p: "620000" }, 623e3: { l: "G", n: "甘南藏族自治州", c: "623000", p: "620000" }, 630100: { l: "X", n: "西宁市", c: "630100", p: "630000" }, 630200: { l: "H", n: "海东市", c: "630200", p: "630000" }, 632200: { l: "H", n: "海北藏族自治州", c: "632200", p: "630000" }, 632300: { l: "H", n: "黄南藏族自治州", c: "632300", p: "630000" }, 632500: { l: "H", n: "海南藏族自治州", c: "632500", p: "630000" }, 632600: { l: "G", n: "果洛藏族自治州", c: "632600", p: "630000" }, 632700: { l: "Y", n: "玉树藏族自治州", c: "632700", p: "630000" }, 632800: { l: "H", n: "海西蒙古族藏族自治州", c: "632800", p: "630000" }, 640100: { l: "Y", n: "银川市", c: "640100", p: "640000" }, 640200: { l: "S", n: "石嘴山市", c: "640200", p: "640000" }, 640300: { l: "W", n: "吴忠市", c: "640300", p: "640000" }, 640400: { l: "G", n: "固原市", c: "640400", p: "640000" }, 640500: { l: "Z", n: "中卫市", c: "640500", p: "640000" }, 650100: { l: "W", n: "乌鲁木齐市", c: "650100", p: "650000" }, 650200: { l: "K", n: "克拉玛依市", c: "650200", p: "650000" }, 650400: { l: "T", n: "吐鲁番市", c: "650400", p: "650000" }, 650500: { l: "H", n: "哈密市", c: "650500", p: "650000" }, 652300: { l: "C", n: "昌吉回族自治州", c: "652300", p: "650000" }, 652700: { l: "B", n: "博尔塔拉蒙古自治州", c: "652700", p: "650000" }, 652800: { l: "B", n: "巴音郭楞蒙古自治州", c: "652800", p: "650000" }, 652900: { l: "A", n: "阿克苏地区", c: "652900", p: "650000" }, 653e3: { l: "K", n: "克孜勒苏柯尔克孜自治州", c: "653000", p: "650000" }, 653100: { l: "K", n: "喀什地区", c: "653100", p: "650000" }, 653200: { l: "H", n: "和田地区", c: "653200", p: "650000" }, 654e3: { l: "Y", n: "伊犁哈萨克自治州", c: "654000", p: "650000" }, 654200: { l: "T", n: "塔城地区", c: "654200", p: "650000" }, 654300: { l: "A", n: "阿勒泰地区", c: "654300", p: "650000" }, 659001: { l: "S", n: "石河子市", c: "659001", p: "650000" }, 659002: { l: "A", n: "阿拉尔市", c: "659002", p: "650000" }, 659003: { l: "T", n: "图木舒克市", c: "659003", p: "650000" }, 659004: { l: "W", n: "五家渠市", c: "659004", p: "650000" }, 659006: { l: "T", n: "铁门关市", c: "659006", p: "650000" }, 710101: { l: "J", n: "金门", c: "710101", p: "710000" }, 710102: { l: "L", n: "连江", c: "710102", p: "710000" }, 710103: { l: "M", n: "苗栗", c: "710103", p: "710000" }, 710104: { l: "N", n: "南投", c: "710104", p: "710000" }, 710105: { l: "P", n: "澎湖", c: "710105", p: "710000" }, 710106: { l: "P", n: "屏东", c: "710106", p: "710000" }, 710107: { l: "T", n: "台东", c: "710107", p: "710000" }, 710108: { l: "T", n: "台中", c: "710108", p: "710000" }, 710109: { l: "T", n: "台南", c: "710109", p: "710000" }, 710110: { l: "T", n: "台北", c: "710110", p: "710000" }, 710111: { l: "T", n: "桃园", c: "710111", p: "710000" }, 710112: { l: "Y", n: "云林", c: "710112", p: "710000" }, 710113: { l: "X", n: "新北", c: "710113", p: "710000" }, 710114: { l: "Z", n: "彰化", c: "710114", p: "710000" }, 710115: { l: "J", n: "嘉义", c: "710115", p: "710000" }, 710116: { l: "X", n: "新竹", c: "710116", p: "710000" }, 710117: { l: "H", n: "花莲", c: "710117", p: "710000" }, 710118: { l: "Y", n: "宜兰", c: "710118", p: "710000" }, 710119: { l: "G", n: "高雄", c: "710119", p: "710000" }, 710120: { l: "J", n: "基隆", c: "710120", p: "710000" }, 81e4: { l: "X", n: "香港特别行政区", c: "810000", p: "86" }, 82e4: { l: "A", n: "澳门特别行政区", c: "820000", p: "86" } };
    function sa(t) {
      return t.replace("市", "").replace("地区", "").replace("特别行政区", "");
    }
    function O2() {
      const t = W(oo), r = [];
      for (let o in t) {
        const C = t[o];
        C.n = sa(C.n), r.push(C);
      }
      return r;
    }
    function Cg(t, r) {
      if (!r)
        return "";
      const o = t.find((C) => C.n === r);
      return o ? o.c : (console.error("[View UI warn]: City name error."), "");
    }
    function D2(t, r) {
      return t.find((o) => o.c === r).n;
    }
    const N2 = { name: "City", mixins: [nn], components: { Dropdown: ys, DropdownMenu: bs, Select: ps, Option: Zs, Tag: so, Icon: G, RadioGroup: Ql, Radio: Zl }, emits: ["on-change", "update:modelValue"], props: { modelValue: { type: String }, useName: { type: Boolean, default: !1 }, cities: { type: Array, default() {
      return [];
    } }, disabled: { type: Boolean, default: !1 }, clearable: { type: Boolean, default: !1 }, showSuffix: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, name: { type: String }, elementId: { type: String }, placeholder: { type: String, default: "请选择" }, searchPlaceholder: { type: String, default: "输入城市名称搜索" }, transferClassName: { type: String } }, data() {
      const t = O2();
      return { currentValue: this.useName ? Cg(t, this.modelValue) : this.modelValue, visible: !1, provinceList: [], cityListByProvince: [], cityListByLetter: {}, allCities: t, listType: "province", queryCity: "" };
    }, watch: { modelValue(t) {
      const r = this.useName ? Cg(this.allCities, t) : t;
      this.currentValue = r;
    } }, computed: { showCloseIcon() {
      return this.currentValue && this.clearable && !this.itemDisabled;
    }, classes() {
      return [{ "ivu-city-show-clear": this.showCloseIcon, [`ivu-city-size-${this.size}`]: !!this.size, "ivu-city-visible": this.visible, "ivu-city-disabled": this.itemDisabled }];
    }, transferClasses() {
      let t = "ivu-city-transfer";
      return this.transferClassName && (t += ` ${this.transferClassName}`), t;
    }, relCities() {
      const t = [];
      return this.cities.length && this.cities.forEach((r) => {
        const o = oo[r];
        o.n = sa(o.n), t.push(o);
      }), t;
    }, codeToName() {
      if (!this.currentValue)
        return this.placeholder;
      const t = oo[this.currentValue].n;
      return this.showSuffix ? t : sa(t);
    } }, methods: { handleSelect(t) {
      t && (this.handleChangeValue(t), e.nextTick(() => {
        this.queryCity = "";
      }));
    }, handleChangeValue(t) {
      this.currentValue = t, this.visible = !1;
      const r = this.useName ? D2(this.allCities, t) : t;
      this.$emit("update:modelValue", r), this.$emit("on-change", oo[t]), this.handleFormItemChange("change", t);
    }, handleClickLetter(t) {
      let r = t;
      r === "直辖市" ? r = "Z1" : r === "港澳" && (r = "Z2");
      const o = `.ivu-city-${r}`, C = this.$refs.list, g = C.querySelectorAll(o)[0].offsetTop, a = C.offsetTop;
      C.scrollTop = g - a;
    }, clearSelect() {
      if (this.itemDisabled)
        return !1;
    }, handleToggleOpen() {
      if (this.itemDisabled)
        return !1;
      this.visible = !this.visible;
    }, handleVisibleChange(t) {
      this.visible = t;
    }, handleClickOutside(t) {
      this.$refs.city.contains(t.target) || (this.visible = !1);
    }, handleGetProvinceByLetter() {
      const t = { A: { n: "A", p: [], c: [] }, F: { n: "F", p: [], c: [] }, G: { n: "G", p: [], c: [] }, H: { n: "H", p: [], c: [] }, J: { n: "J", p: [], c: [] }, L: { n: "L", p: [], c: [] }, N: { n: "N", p: [], c: [] }, Q: { n: "Q", p: [], c: [] }, S: { n: "S", p: [], c: [] }, T: { n: "T", p: [], c: [] }, X: { n: "X", p: [], c: [] }, Y: { n: "Y", p: [], c: [] }, Z: { n: "Z", p: [], c: [] }, Z1: { n: "直辖市", p: [], c: [] }, Z2: { n: "港澳", p: [], c: [] } };
      for (let r in bg) {
        const o = bg[r];
        t[o.l].p.push(o);
      }
      this.provinceList = t;
    }, handleGetCityByProvince() {
      const t = W(this.provinceList), r = [], o = W(oo), C = [{ p: { n: "直辖市", p: "86", l: "Z1" }, c: [] }, { p: { n: "港澳", p: "86", l: "Z2" }, c: [] }];
      for (let g in t) {
        const a = t[g];
        for (let x = 0; x < a.p.length; x++) {
          const O = a.p[x], P = O.c, N = { p: O, c: [] };
          for (let B in o) {
            const H = o[B];
            H.n = sa(H.n), P === H.p && N.c.push(H);
          }
          g === "Z1" ? C[0].c.push(o[P]) : g === "Z2" ? C[1].c.push(o[P]) : r.push(N);
        }
      }
      this.cityListByProvince = r.concat(C);
    }, handleGetCityByLetter() {
      const t = W(oo), r = { A: [], B: [], C: [], D: [], E: [], F: [], G: [], H: [], J: [], K: [], L: [], M: [], N: [], P: [], Q: [], R: [], S: [], T: [], W: [], X: [], Y: [], Z: [] };
      for (let o in t) {
        const C = t[o];
        C.n = sa(C.n), r[C.l].push(C);
      }
      this.cityListByLetter = r;
    } }, created() {
      this.handleGetProvinceByLetter(), this.handleGetCityByProvince(), this.handleGetCityByLetter();
    } }, B2 = ["name", "value"], P2 = { class: "ivu-city-drop" }, V2 = { key: 0, class: "ivu-city-drop-cities" }, $2 = ["onClick"], I2 = { class: "ivu-city-drop-menu" }, M2 = { class: "ivu-city-drop-type" }, A2 = { class: "ivu-city-drop-search" }, F2 = { key: 1, class: "ivu-city-drop-list" }, L2 = { class: "ivu-city-drop-list-letter" }, z2 = { class: "ivu-city-drop-list-main", ref: "list" }, R2 = ["onClick"], j2 = { key: 2, class: "ivu-city-drop-list" }, H2 = { class: "ivu-city-drop-list-letter" }, U2 = { class: "ivu-city-drop-list-main ivu-city-drop-list-main-city", ref: "list" }, W2 = ["onClick"];
    function Y2(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Radio"), P = e.resolveComponent("RadioGroup"), N = e.resolveComponent("Option"), B = e.resolveComponent("Select"), H = e.resolveComponent("Tag"), oe = e.resolveComponent("DropdownMenu"), se = e.resolveComponent("Dropdown");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-city", a.classes]), ref: "city" }, [e.createVNode(se, { trigger: "custom", visible: g.visible, transfer: o.transfer, placement: "bottom-start", "transfer-class-name": a.transferClasses, onOnVisibleChange: a.handleVisibleChange, onOnClickoutside: a.handleClickOutside }, { list: e.withCtx(() => [e.createVNode(oe, { onClick: r[3] || (r[3] = e.withModifiers(() => {
      }, ["stop"])) }, { default: e.withCtx(() => [e.createElementVNode("div", P2, [o.cities.length ? (e.openBlock(), e.createElementBlock("div", V2, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.relCities, (ee) => (e.openBlock(), e.createElementBlock("span", { key: ee.n, onClick: (j) => a.handleChangeValue(ee.c) }, e.toDisplayString(ee.n), 9, $2))), 128))])) : e.createCommentVNode("", !0), e.createElementVNode("div", I2, [e.createElementVNode("div", M2, [e.createVNode(P, { modelValue: g.listType, "onUpdate:modelValue": r[1] || (r[1] = (ee) => g.listType = ee), type: "button", size: "small" }, { default: e.withCtx(() => [e.createVNode(O, { label: "province" }, { default: e.withCtx(() => [e.createTextVNode("按省份")]), _: 1 }), e.createVNode(O, { label: "city" }, { default: e.withCtx(() => [e.createTextVNode("按城市")]), _: 1 })]), _: 1 }, 8, ["modelValue"])]), e.createElementVNode("div", A2, [e.createVNode(B, { modelValue: g.queryCity, "onUpdate:modelValue": r[2] || (r[2] = (ee) => g.queryCity = ee), filterable: "", size: "small", transfer: "", placeholder: o.searchPlaceholder, onOnChange: a.handleSelect }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.allCities, (ee) => (e.openBlock(), e.createBlock(N, { value: ee.c, key: ee.c }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(ee.n), 1)]), _: 2 }, 1032, ["value"]))), 128))]), _: 1 }, 8, ["modelValue", "placeholder", "onOnChange"])])]), g.listType === "province" ? (e.openBlock(), e.createElementBlock("div", F2, [e.createElementVNode("div", L2, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.provinceList, (ee) => (e.openBlock(), e.createBlock(H, { onClick: (j) => a.handleClickLetter(ee.n), type: "border", fade: !1, key: ee.n }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(ee.n), 1)]), _: 2 }, 1032, ["onClick"]))), 128))]), e.createElementVNode("div", z2, [e.createElementVNode("dl", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.cityListByProvince, (ee) => (e.openBlock(), e.createElementBlock(e.Fragment, { key: ee.p.n }, [e.createElementVNode("dt", { class: e.normalizeClass("ivu-city-" + ee.p.l) }, e.toDisplayString(ee.p.n) + "：", 3), e.createElementVNode("dd", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(ee.c, (j) => (e.openBlock(), e.createElementBlock("li", { key: j.n, onClick: (pe) => a.handleChangeValue(j.c) }, e.toDisplayString(j.n), 9, R2))), 128))])], 64))), 128))])], 512)])) : e.createCommentVNode("", !0), g.listType === "city" ? (e.openBlock(), e.createElementBlock("div", j2, [e.createElementVNode("div", H2, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.cityListByLetter, (ee, j) => (e.openBlock(), e.createBlock(H, { onClick: (pe) => a.handleClickLetter(j), type: "border", fade: !1, key: j }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(j), 1)]), _: 2 }, 1032, ["onClick"]))), 128))]), e.createElementVNode("div", U2, [e.createElementVNode("dl", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.cityListByLetter, (ee, j) => (e.openBlock(), e.createElementBlock(e.Fragment, { key: j }, [e.createElementVNode("dt", { class: e.normalizeClass("ivu-city-" + j) }, e.toDisplayString(j) + "：", 3), e.createElementVNode("dd", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(ee, (pe) => (e.openBlock(), e.createElementBlock("li", { key: pe.n, onClick: (at) => a.handleChangeValue(pe.c) }, e.toDisplayString(pe.n), 9, W2))), 128))])], 64))), 128))])], 512)])) : e.createCommentVNode("", !0)])]), _: 1 })]), default: e.withCtx(() => [e.createElementVNode("div", { class: "ivu-city-rel", onClick: r[0] || (r[0] = e.withModifiers((...ee) => a.handleToggleOpen && a.handleToggleOpen(...ee), ["prevent", "stop"])) }, [e.createElementVNode("input", { type: "hidden", name: o.name, value: g.currentValue }, null, 8, B2), e.renderSlot(t.$slots, "default", {}, () => [e.createElementVNode("span", null, e.toDisplayString(a.codeToName), 1), e.withDirectives(e.createVNode(x, { type: "ios-close-circle", class: "ivu-city-arrow", onClick: e.withModifiers(a.clearSelect, ["stop"]) }, null, 8, ["onClick"]), [[e.vShow, a.showCloseIcon]]), e.createVNode(x, { type: "ios-arrow-down", class: "ivu-city-arrow" })])])]), _: 3 }, 8, ["visible", "transfer", "transfer-class-name", "onOnVisibleChange", "onOnClickoutside"])], 2);
    }
    var wg = f(N2, [["render", Y2]]);
    const kg = "ivu-collapse", K2 = { name: "Collapse", emits: ["on-change", "update:modelValue"], provide() {
      return { CollapseInstance: this };
    }, props: { accordion: { type: Boolean, default: !1 }, modelValue: { type: [Array, String] }, simple: { type: Boolean, default: !1 } }, data() {
      return { currentValue: this.modelValue, panelCount: 0 };
    }, computed: { classes() {
      return [`${kg}`, { [`${kg}-simple`]: this.simple }];
    } }, methods: { getActiveKey() {
      let t = this.currentValue || [];
      const r = this.accordion;
      Array.isArray(t) || (t = [t]), r && t.length > 1 && (t = [t[0]]);
      for (let o = 0; o < t.length; o++)
        t[o] = t[o].toString();
      return t;
    }, toggle(t) {
      const r = t.name.toString();
      let o = [];
      if (this.accordion)
        t.isActive || o.push(r);
      else {
        let C = this.getActiveKey();
        const g = C.indexOf(r);
        t.isActive ? g > -1 && C.splice(g, 1) : g < 0 && C.push(r), o = C;
      }
      this.currentValue = o, this.$emit("update:modelValue", o), this.$emit("on-change", o);
    } }, watch: { modelValue(t) {
      this.currentValue = t;
    } } };
    function G2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var Sg = f(K2, [["render", G2]]), Eg = { exports: {} };
    (function(t) {
      (function(r) {
        var o = /^\s+/, C = /\s+$/, g = 0, a = r.round, x = r.min, O = r.max, P = r.random;
        function N(U, ue) {
          if (U = U || "", ue = ue || {}, U instanceof N)
            return U;
          if (!(this instanceof N))
            return new N(U, ue);
          var q = B(U);
          this._originalInput = U, this._r = q.r, this._g = q.g, this._b = q.b, this._a = q.a, this._roundA = a(100 * this._a) / 100, this._format = ue.format || q.format, this._gradientType = ue.gradientType, this._r < 1 && (this._r = a(this._r)), this._g < 1 && (this._g = a(this._g)), this._b < 1 && (this._b = a(this._b)), this._ok = q.ok, this._tc_id = g++;
        }
        N.prototype = { isDark: function() {
          return this.getBrightness() < 128;
        }, isLight: function() {
          return !this.isDark();
        }, isValid: function() {
          return this._ok;
        }, getOriginalInput: function() {
          return this._originalInput;
        }, getFormat: function() {
          return this._format;
        }, getAlpha: function() {
          return this._a;
        }, getBrightness: function() {
          var U = this.toRgb();
          return (U.r * 299 + U.g * 587 + U.b * 114) / 1e3;
        }, getLuminance: function() {
          var U = this.toRgb(), ue, q, Fe, He, Xe, xt;
          return ue = U.r / 255, q = U.g / 255, Fe = U.b / 255, ue <= 0.03928 ? He = ue / 12.92 : He = r.pow((ue + 0.055) / 1.055, 2.4), q <= 0.03928 ? Xe = q / 12.92 : Xe = r.pow((q + 0.055) / 1.055, 2.4), Fe <= 0.03928 ? xt = Fe / 12.92 : xt = r.pow((Fe + 0.055) / 1.055, 2.4), 0.2126 * He + 0.7152 * Xe + 0.0722 * xt;
        }, setAlpha: function(U) {
          return this._a = yt(U), this._roundA = a(100 * this._a) / 100, this;
        }, toHsv: function() {
          var U = ee(this._r, this._g, this._b);
          return { h: U.h * 360, s: U.s, v: U.v, a: this._a };
        }, toHsvString: function() {
          var U = ee(this._r, this._g, this._b), ue = a(U.h * 360), q = a(U.s * 100), Fe = a(U.v * 100);
          return this._a == 1 ? "hsv(" + ue + ", " + q + "%, " + Fe + "%)" : "hsva(" + ue + ", " + q + "%, " + Fe + "%, " + this._roundA + ")";
        }, toHsl: function() {
          var U = oe(this._r, this._g, this._b);
          return { h: U.h * 360, s: U.s, l: U.l, a: this._a };
        }, toHslString: function() {
          var U = oe(this._r, this._g, this._b), ue = a(U.h * 360), q = a(U.s * 100), Fe = a(U.l * 100);
          return this._a == 1 ? "hsl(" + ue + ", " + q + "%, " + Fe + "%)" : "hsla(" + ue + ", " + q + "%, " + Fe + "%, " + this._roundA + ")";
        }, toHex: function(U) {
          return pe(this._r, this._g, this._b, U);
        }, toHexString: function(U) {
          return "#" + this.toHex(U);
        }, toHex8: function(U) {
          return at(this._r, this._g, this._b, this._a, U);
        }, toHex8String: function(U) {
          return "#" + this.toHex8(U);
        }, toRgb: function() {
          return { r: a(this._r), g: a(this._g), b: a(this._b), a: this._a };
        }, toRgbString: function() {
          return this._a == 1 ? "rgb(" + a(this._r) + ", " + a(this._g) + ", " + a(this._b) + ")" : "rgba(" + a(this._r) + ", " + a(this._g) + ", " + a(this._b) + ", " + this._roundA + ")";
        }, toPercentageRgb: function() {
          return { r: a(ht(this._r, 255) * 100) + "%", g: a(ht(this._g, 255) * 100) + "%", b: a(ht(this._b, 255) * 100) + "%", a: this._a };
        }, toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + a(ht(this._r, 255) * 100) + "%, " + a(ht(this._g, 255) * 100) + "%, " + a(ht(this._b, 255) * 100) + "%)" : "rgba(" + a(ht(this._r, 255) * 100) + "%, " + a(ht(this._g, 255) * 100) + "%, " + a(ht(this._b, 255) * 100) + "%, " + this._roundA + ")";
        }, toName: function() {
          return this._a === 0 ? "transparent" : this._a < 1 ? !1 : et[pe(this._r, this._g, this._b, !0)] || !1;
        }, toFilter: function(U) {
          var ue = "#" + Qe(this._r, this._g, this._b, this._a), q = ue, Fe = this._gradientType ? "GradientType = 1, " : "";
          if (U) {
            var He = N(U);
            q = "#" + Qe(He._r, He._g, He._b, He._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + Fe + "startColorstr=" + ue + ",endColorstr=" + q + ")";
        }, toString: function(U) {
          var ue = !!U;
          U = U || this._format;
          var q = !1, Fe = this._a < 1 && this._a >= 0, He = !ue && Fe && (U === "hex" || U === "hex6" || U === "hex3" || U === "hex4" || U === "hex8" || U === "name");
          return He ? U === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (U === "rgb" && (q = this.toRgbString()), U === "prgb" && (q = this.toPercentageRgbString()), (U === "hex" || U === "hex6") && (q = this.toHexString()), U === "hex3" && (q = this.toHexString(!0)), U === "hex4" && (q = this.toHex8String(!0)), U === "hex8" && (q = this.toHex8String()), U === "name" && (q = this.toName()), U === "hsl" && (q = this.toHslString()), U === "hsv" && (q = this.toHsvString()), q || this.toHexString());
        }, clone: function() {
          return N(this.toString());
        }, _applyModification: function(U, ue) {
          var q = U.apply(null, [this].concat([].slice.call(ue)));
          return this._r = q._r, this._g = q._g, this._b = q._b, this.setAlpha(q._a), this;
        }, lighten: function() {
          return this._applyModification(ze, arguments);
        }, brighten: function() {
          return this._applyModification(Oe, arguments);
        }, darken: function() {
          return this._applyModification(lt, arguments);
        }, desaturate: function() {
          return this._applyModification(tt, arguments);
        }, saturate: function() {
          return this._applyModification(Ee, arguments);
        }, greyscale: function() {
          return this._applyModification(ye, arguments);
        }, spin: function() {
          return this._applyModification(it, arguments);
        }, _applyCombination: function(U, ue) {
          return U.apply(null, [this].concat([].slice.call(ue)));
        }, analogous: function() {
          return this._applyCombination(Ke, arguments);
        }, complement: function() {
          return this._applyCombination(Ze, arguments);
        }, monochromatic: function() {
          return this._applyCombination(qe, arguments);
        }, splitcomplement: function() {
          return this._applyCombination(Ue, arguments);
        }, triad: function() {
          return this._applyCombination(kt, arguments);
        }, tetrad: function() {
          return this._applyCombination(ot, arguments);
        } }, N.fromRatio = function(U, ue) {
          if (typeof U == "object") {
            var q = {};
            for (var Fe in U)
              U.hasOwnProperty(Fe) && (Fe === "a" ? q[Fe] = U[Fe] : q[Fe] = gn(U[Fe]));
            U = q;
          }
          return N(U, ue);
        };
        function B(U) {
          var ue = { r: 0, g: 0, b: 0 }, q = 1, Fe = null, He = null, Xe = null, xt = !1, Bt = !1;
          return typeof U == "string" && (U = It(U)), typeof U == "object" && (gt(U.r) && gt(U.g) && gt(U.b) ? (ue = H(U.r, U.g, U.b), xt = !0, Bt = String(U.r).substr(-1) === "%" ? "prgb" : "rgb") : gt(U.h) && gt(U.s) && gt(U.v) ? (Fe = gn(U.s), He = gn(U.v), ue = j(U.h, Fe, He), xt = !0, Bt = "hsv") : gt(U.h) && gt(U.s) && gt(U.l) && (Fe = gn(U.s), Xe = gn(U.l), ue = se(U.h, Fe, Xe), xt = !0, Bt = "hsl"), U.hasOwnProperty("a") && (q = U.a)), q = yt(q), { ok: xt, format: U.format || Bt, r: x(255, O(ue.r, 0)), g: x(255, O(ue.g, 0)), b: x(255, O(ue.b, 0)), a: q };
        }
        function H(U, ue, q) {
          return { r: ht(U, 255) * 255, g: ht(ue, 255) * 255, b: ht(q, 255) * 255 };
        }
        function oe(U, ue, q) {
          U = ht(U, 255), ue = ht(ue, 255), q = ht(q, 255);
          var Fe = O(U, ue, q), He = x(U, ue, q), Xe, xt, Bt = (Fe + He) / 2;
          if (Fe == He)
            Xe = xt = 0;
          else {
            var Mt = Fe - He;
            switch (xt = Bt > 0.5 ? Mt / (2 - Fe - He) : Mt / (Fe + He), Fe) {
              case U:
                Xe = (ue - q) / Mt + (ue < q ? 6 : 0);
                break;
              case ue:
                Xe = (q - U) / Mt + 2;
                break;
              case q:
                Xe = (U - ue) / Mt + 4;
                break;
            }
            Xe /= 6;
          }
          return { h: Xe, s: xt, l: Bt };
        }
        function se(U, ue, q) {
          var Fe, He, Xe;
          U = ht(U, 360), ue = ht(ue, 100), q = ht(q, 100);
          function xt(yn, zi, xn) {
            return xn < 0 && (xn += 1), xn > 1 && (xn -= 1), xn < 1 / 6 ? yn + (zi - yn) * 6 * xn : xn < 1 / 2 ? zi : xn < 2 / 3 ? yn + (zi - yn) * (2 / 3 - xn) * 6 : yn;
          }
          if (ue === 0)
            Fe = He = Xe = q;
          else {
            var Bt = q < 0.5 ? q * (1 + ue) : q + ue - q * ue, Mt = 2 * q - Bt;
            Fe = xt(Mt, Bt, U + 1 / 3), He = xt(Mt, Bt, U), Xe = xt(Mt, Bt, U - 1 / 3);
          }
          return { r: Fe * 255, g: He * 255, b: Xe * 255 };
        }
        function ee(U, ue, q) {
          U = ht(U, 255), ue = ht(ue, 255), q = ht(q, 255);
          var Fe = O(U, ue, q), He = x(U, ue, q), Xe, xt, Bt = Fe, Mt = Fe - He;
          if (xt = Fe === 0 ? 0 : Mt / Fe, Fe == He)
            Xe = 0;
          else {
            switch (Fe) {
              case U:
                Xe = (ue - q) / Mt + (ue < q ? 6 : 0);
                break;
              case ue:
                Xe = (q - U) / Mt + 2;
                break;
              case q:
                Xe = (U - ue) / Mt + 4;
                break;
            }
            Xe /= 6;
          }
          return { h: Xe, s: xt, v: Bt };
        }
        function j(U, ue, q) {
          U = ht(U, 360) * 6, ue = ht(ue, 100), q = ht(q, 100);
          var Fe = r.floor(U), He = U - Fe, Xe = q * (1 - ue), xt = q * (1 - He * ue), Bt = q * (1 - (1 - He) * ue), Mt = Fe % 6, yn = [q, xt, Xe, Xe, Bt, q][Mt], zi = [Bt, q, q, xt, Xe, Xe][Mt], xn = [Xe, Xe, Bt, q, q, xt][Mt];
          return { r: yn * 255, g: zi * 255, b: xn * 255 };
        }
        function pe(U, ue, q, Fe) {
          var He = [Wt(a(U).toString(16)), Wt(a(ue).toString(16)), Wt(a(q).toString(16))];
          return Fe && He[0].charAt(0) == He[0].charAt(1) && He[1].charAt(0) == He[1].charAt(1) && He[2].charAt(0) == He[2].charAt(1) ? He[0].charAt(0) + He[1].charAt(0) + He[2].charAt(0) : He.join("");
        }
        function at(U, ue, q, Fe, He) {
          var Xe = [Wt(a(U).toString(16)), Wt(a(ue).toString(16)), Wt(a(q).toString(16)), Wt(mi(Fe))];
          return He && Xe[0].charAt(0) == Xe[0].charAt(1) && Xe[1].charAt(0) == Xe[1].charAt(1) && Xe[2].charAt(0) == Xe[2].charAt(1) && Xe[3].charAt(0) == Xe[3].charAt(1) ? Xe[0].charAt(0) + Xe[1].charAt(0) + Xe[2].charAt(0) + Xe[3].charAt(0) : Xe.join("");
        }
        function Qe(U, ue, q, Fe) {
          var He = [Wt(mi(Fe)), Wt(a(U).toString(16)), Wt(a(ue).toString(16)), Wt(a(q).toString(16))];
          return He.join("");
        }
        N.equals = function(U, ue) {
          return !U || !ue ? !1 : N(U).toRgbString() == N(ue).toRgbString();
        }, N.random = function() {
          return N.fromRatio({ r: P(), g: P(), b: P() });
        };
        function tt(U, ue) {
          ue = ue === 0 ? 0 : ue || 10;
          var q = N(U).toHsl();
          return q.s -= ue / 100, q.s = Rt(q.s), N(q);
        }
        function Ee(U, ue) {
          ue = ue === 0 ? 0 : ue || 10;
          var q = N(U).toHsl();
          return q.s += ue / 100, q.s = Rt(q.s), N(q);
        }
        function ye(U) {
          return N(U).desaturate(100);
        }
        function ze(U, ue) {
          ue = ue === 0 ? 0 : ue || 10;
          var q = N(U).toHsl();
          return q.l += ue / 100, q.l = Rt(q.l), N(q);
        }
        function Oe(U, ue) {
          ue = ue === 0 ? 0 : ue || 10;
          var q = N(U).toRgb();
          return q.r = O(0, x(255, q.r - a(255 * -(ue / 100)))), q.g = O(0, x(255, q.g - a(255 * -(ue / 100)))), q.b = O(0, x(255, q.b - a(255 * -(ue / 100)))), N(q);
        }
        function lt(U, ue) {
          ue = ue === 0 ? 0 : ue || 10;
          var q = N(U).toHsl();
          return q.l -= ue / 100, q.l = Rt(q.l), N(q);
        }
        function it(U, ue) {
          var q = N(U).toHsl(), Fe = (q.h + ue) % 360;
          return q.h = Fe < 0 ? 360 + Fe : Fe, N(q);
        }
        function Ze(U) {
          var ue = N(U).toHsl();
          return ue.h = (ue.h + 180) % 360, N(ue);
        }
        function kt(U) {
          var ue = N(U).toHsl(), q = ue.h;
          return [N(U), N({ h: (q + 120) % 360, s: ue.s, l: ue.l }), N({ h: (q + 240) % 360, s: ue.s, l: ue.l })];
        }
        function ot(U) {
          var ue = N(U).toHsl(), q = ue.h;
          return [N(U), N({ h: (q + 90) % 360, s: ue.s, l: ue.l }), N({ h: (q + 180) % 360, s: ue.s, l: ue.l }), N({ h: (q + 270) % 360, s: ue.s, l: ue.l })];
        }
        function Ue(U) {
          var ue = N(U).toHsl(), q = ue.h;
          return [N(U), N({ h: (q + 72) % 360, s: ue.s, l: ue.l }), N({ h: (q + 216) % 360, s: ue.s, l: ue.l })];
        }
        function Ke(U, ue, q) {
          ue = ue || 6, q = q || 30;
          var Fe = N(U).toHsl(), He = 360 / q, Xe = [N(U)];
          for (Fe.h = (Fe.h - (He * ue >> 1) + 720) % 360; --ue; )
            Fe.h = (Fe.h + He) % 360, Xe.push(N(Fe));
          return Xe;
        }
        function qe(U, ue) {
          ue = ue || 6;
          for (var q = N(U).toHsv(), Fe = q.h, He = q.s, Xe = q.v, xt = [], Bt = 1 / ue; ue--; )
            xt.push(N({ h: Fe, s: He, v: Xe })), Xe = (Xe + Bt) % 1;
          return xt;
        }
        N.mix = function(U, ue, q) {
          q = q === 0 ? 0 : q || 50;
          var Fe = N(U).toRgb(), He = N(ue).toRgb(), Xe = q / 100, xt = { r: (He.r - Fe.r) * Xe + Fe.r, g: (He.g - Fe.g) * Xe + Fe.g, b: (He.b - Fe.b) * Xe + Fe.b, a: (He.a - Fe.a) * Xe + Fe.a };
          return N(xt);
        }, N.readability = function(U, ue) {
          var q = N(U), Fe = N(ue);
          return (r.max(q.getLuminance(), Fe.getLuminance()) + 0.05) / (r.min(q.getLuminance(), Fe.getLuminance()) + 0.05);
        }, N.isReadable = function(U, ue, q) {
          var Fe = N.readability(U, ue), He, Xe;
          switch (Xe = !1, He = vn(q), He.level + He.size) {
            case "AAsmall":
            case "AAAlarge":
              Xe = Fe >= 4.5;
              break;
            case "AAlarge":
              Xe = Fe >= 3;
              break;
            case "AAAsmall":
              Xe = Fe >= 7;
              break;
          }
          return Xe;
        }, N.mostReadable = function(U, ue, q) {
          var Fe = null, He = 0, Xe, xt, Bt, Mt;
          q = q || {}, xt = q.includeFallbackColors, Bt = q.level, Mt = q.size;
          for (var yn = 0; yn < ue.length; yn++)
            Xe = N.readability(U, ue[yn]), Xe > He && (He = Xe, Fe = N(ue[yn]));
          return N.isReadable(U, Fe, { level: Bt, size: Mt }) || !xt ? Fe : (q.includeFallbackColors = !1, N.mostReadable(U, ["#fff", "#000"], q));
        };
        var mt = N.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, et = N.hexNames = St(mt);
        function St(U) {
          var ue = {};
          for (var q in U)
            U.hasOwnProperty(q) && (ue[U[q]] = q);
          return ue;
        }
        function yt(U) {
          return U = parseFloat(U), (isNaN(U) || U < 0 || U > 1) && (U = 1), U;
        }
        function ht(U, ue) {
          qt(U) && (U = "100%");
          var q = Tn(U);
          return U = x(ue, O(0, parseFloat(U))), q && (U = parseInt(U * ue, 10) / 100), r.abs(U - ue) < 1e-6 ? 1 : U % ue / parseFloat(ue);
        }
        function Rt(U) {
          return x(1, O(0, U));
        }
        function Tt(U) {
          return parseInt(U, 16);
        }
        function qt(U) {
          return typeof U == "string" && U.indexOf(".") != -1 && parseFloat(U) === 1;
        }
        function Tn(U) {
          return typeof U == "string" && U.indexOf("%") != -1;
        }
        function Wt(U) {
          return U.length == 1 ? "0" + U : "" + U;
        }
        function gn(U) {
          return U <= 1 && (U = U * 100 + "%"), U;
        }
        function mi(U) {
          return r.round(parseFloat(U) * 255).toString(16);
        }
        function Hn(U) {
          return Tt(U) / 255;
        }
        var We = function() {
          var U = "[-\\+]?\\d+%?", ue = "[-\\+]?\\d*\\.\\d+%?", q = "(?:" + ue + ")|(?:" + U + ")", Fe = "[\\s|\\(]+(" + q + ")[,|\\s]+(" + q + ")[,|\\s]+(" + q + ")\\s*\\)?", He = "[\\s|\\(]+(" + q + ")[,|\\s]+(" + q + ")[,|\\s]+(" + q + ")[,|\\s]+(" + q + ")\\s*\\)?";
          return { CSS_UNIT: new RegExp(q), rgb: new RegExp("rgb" + Fe), rgba: new RegExp("rgba" + He), hsl: new RegExp("hsl" + Fe), hsla: new RegExp("hsla" + He), hsv: new RegExp("hsv" + Fe), hsva: new RegExp("hsva" + He), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ };
        }();
        function gt(U) {
          return !!We.CSS_UNIT.exec(U);
        }
        function It(U) {
          U = U.replace(o, "").replace(C, "").toLowerCase();
          var ue = !1;
          if (mt[U])
            U = mt[U], ue = !0;
          else if (U == "transparent")
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          var q;
          return (q = We.rgb.exec(U)) ? { r: q[1], g: q[2], b: q[3] } : (q = We.rgba.exec(U)) ? { r: q[1], g: q[2], b: q[3], a: q[4] } : (q = We.hsl.exec(U)) ? { h: q[1], s: q[2], l: q[3] } : (q = We.hsla.exec(U)) ? { h: q[1], s: q[2], l: q[3], a: q[4] } : (q = We.hsv.exec(U)) ? { h: q[1], s: q[2], v: q[3] } : (q = We.hsva.exec(U)) ? { h: q[1], s: q[2], v: q[3], a: q[4] } : (q = We.hex8.exec(U)) ? { r: Tt(q[1]), g: Tt(q[2]), b: Tt(q[3]), a: Hn(q[4]), format: ue ? "name" : "hex8" } : (q = We.hex6.exec(U)) ? { r: Tt(q[1]), g: Tt(q[2]), b: Tt(q[3]), format: ue ? "name" : "hex" } : (q = We.hex4.exec(U)) ? { r: Tt(q[1] + "" + q[1]), g: Tt(q[2] + "" + q[2]), b: Tt(q[3] + "" + q[3]), a: Hn(q[4] + "" + q[4]), format: ue ? "name" : "hex8" } : (q = We.hex3.exec(U)) ? { r: Tt(q[1] + "" + q[1]), g: Tt(q[2] + "" + q[2]), b: Tt(q[3] + "" + q[3]), format: ue ? "name" : "hex" } : !1;
        }
        function vn(U) {
          var ue, q;
          return U = U || { level: "AA", size: "small" }, ue = (U.level || "AA").toUpperCase(), q = (U.size || "small").toLowerCase(), ue !== "AA" && ue !== "AAA" && (ue = "AA"), q !== "small" && q !== "large" && (q = "small"), { level: ue, size: q };
        }
        t.exports ? t.exports = N : window.tinycolor = N;
      })(Math);
    })(Eg);
    var sc = Eg.exports, xg = { inject: ["ColorPickerInstance"], methods: { handleEscape(t) {
      this.ColorPickerInstance.handleOnEscapeKeydown(t);
    } } }, oa = { data() {
      return { prefixCls: "ivu-color-picker", inputPrefixCls: "ivu-input", iconPrefixCls: "ivu-icon", transferPrefixCls: "ivu-transfer" };
    } };
    function Wh(t, r) {
      const o = sc(t), { _a: C } = o;
      return C == null && o.setAlpha(r || 1), o;
    }
    function X2(t, r) {
      const o = r && r.a;
      if (r) {
        if (r.hsl)
          return Wh(r.hsl, o);
        if (r.hex && r.hex.length > 0)
          return Wh(r.hex, o);
      }
      return Wh(r, o);
    }
    function aa(t, r) {
      const o = t === "" ? "#2d8cf0" : t, C = X2(t, o), g = C.toHsl(), a = C.toHsv();
      return g.s === 0 && (g.h = o.h || o.hsl && o.hsl.h || r || 0, a.h = g.h), a.v < 0.0164 && (a.h = o.h || o.hsv && o.hsv.h || 0, a.s = o.s || o.hsv && o.hsv.s || 0), g.l < 0.01 && (g.h = o.h || o.hsl && o.hsl.h || 0, g.s = o.s || o.hsl && o.hsl.s || 0), { hsl: g, hex: C.toHexString().toUpperCase(), rgba: C.toRgb(), hsv: a, oldHue: o.h || r || g.h, source: o.source, a: o.a || C.getAlpha() };
    }
    function Si(t, r, o) {
      return t < r ? r : t > o ? o : t;
    }
    function _g(t, r, o) {
      return z(t, r) ? o : 0;
    }
    function Tg(t, r) {
      return t.touches ? t.touches[0][r] : 0;
    }
    function la(t) {
      const { r, g: o, b: C, a: g } = t;
      return `rgba(${[r, o, C, g].join(",")})`;
    }
    const q2 = { name: "RecommendedColors", mixins: [xg, oa], emits: ["picker-color", "change"], props: { list: { type: Array, default: void 0 } }, data() {
      const t = Math.ceil(this.list.length / 12), r = 1;
      return { left: -r, right: r, up: -r, down: r, powerKey: "shiftKey", grid: { x: 1, y: 1 }, rows: t, columns: 12 };
    }, computed: { hideClass() {
      return `${this.prefixCls}-hide`;
    }, linearIndex() {
      return this.getLinearIndex(this.grid);
    }, currentCircle() {
      return this.$refs[`color-circle-${this.linearIndex}`][0];
    } }, methods: { getLinearIndex(t) {
      return this.columns * (t.y - 1) + t.x - 1;
    }, getMaxLimit(t) {
      return t === "x" ? this.columns : this.rows;
    }, handleArrow(t, r, o) {
      t.preventDefault(), t.stopPropagation(), this.blurColor();
      const C = p({}, this.grid);
      t[this.powerKey] ? o < 0 ? C[r] = 1 : C[r] = this.getMaxLimit(r) : C[r] += o;
      const g = this.getLinearIndex(C);
      g >= 0 && g < this.list.length && (this.grid[r] = Si(C[r], 1, this.getMaxLimit(r))), this.focusColor();
    }, blurColor() {
      this.currentCircle.classList.add(this.hideClass);
    }, focusColor() {
      this.currentCircle.classList.remove(this.hideClass);
    }, handleEnter(t) {
      this.handleClick(t, this.currentCircle);
    }, handleClick(t, r) {
      t.preventDefault(), t.stopPropagation(), this.$refs.reference.focus();
      const o = r || t.target, C = o.dataset.colorId || o.parentElement.dataset.colorId;
      if (C) {
        this.blurColor();
        const g = Number(C) + 1;
        this.grid.x = g % this.columns || this.columns, this.grid.y = Math.ceil(g / this.columns), this.focusColor(), this.$emit("picker-color", this.list[C]), this.$emit("change", { hex: this.list[C], source: "hex" });
      }
    }, lineBreak(t, r) {
      if (!r)
        return !1;
      const o = r + 1;
      return o < t.length && o % this.columns === 0;
    } } }, J2 = ["data-color-id"], Q2 = { key: 0 };
    function Z2(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { ref: "reference", tabindex: "0", onClick: r[0] || (r[0] = (...x) => a.handleClick && a.handleClick(...x)), onKeydown: [r[1] || (r[1] = e.withKeys((...x) => t.handleEscape && t.handleEscape(...x), ["esc"])), r[2] || (r[2] = e.withKeys((...x) => a.handleEnter && a.handleEnter(...x), ["enter"])), r[3] || (r[3] = e.withKeys((x) => a.handleArrow(x, "x", g.left), ["left"])), r[4] || (r[4] = e.withKeys((x) => a.handleArrow(x, "x", g.right), ["right"])), r[5] || (r[5] = e.withKeys((x) => a.handleArrow(x, "y", g.up), ["up"])), r[6] || (r[6] = e.withKeys((x) => a.handleArrow(x, "y", g.down), ["down"]))], onBlur: r[7] || (r[7] = (...x) => a.blurColor && a.blurColor(...x)), onFocus: r[8] || (r[8] = (...x) => a.focusColor && a.focusColor(...x)) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.list, (x, O) => (e.openBlock(), e.createElementBlock(e.Fragment, { key: x + ":" + O }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-picker-colors-wrapper"]) }, [e.createElementVNode("div", { "data-color-id": O }, [e.createElementVNode("div", { style: e.normalizeStyle({ background: x }), class: e.normalizeClass([t.prefixCls + "-picker-colors-wrapper-color"]) }, null, 6), e.createElementVNode("div", { ref_for: !0, ref: "color-circle-" + O, class: e.normalizeClass([t.prefixCls + "-picker-colors-wrapper-circle", a.hideClass]) }, null, 2)], 8, J2)], 2), a.lineBreak(o.list, O) ? (e.openBlock(), e.createElementBlock("br", Q2)) : e.createCommentVNode("", !0)], 64))), 128))], 544);
    }
    var eT = f(q2, [["render", Z2]]), ca = { mixins: [xg], props: { focused: { type: Boolean, default: !1 }, value: { type: Object, default: void 0 } }, created() {
      this.focused && setTimeout(() => this.$el.focus(), 1);
    }, beforeUnmount() {
      this.unbindEventListeners();
    }, methods: { handleLeft(t) {
      this.handleSlide(t, this.left, "left");
    }, handleRight(t) {
      this.handleSlide(t, this.right, "right");
    }, handleUp(t) {
      this.handleSlide(t, this.up, "up");
    }, handleDown(t) {
      this.handleSlide(t, this.down, "down");
    }, handleMouseDown(t) {
      this.ColorPickerInstance.handleOnDragging(!0), this.handleChange(t, !0), m(window, "mousemove", this.handleChange), m(window, "mouseup", this.handleMouseUp);
    }, handleMouseUp() {
      this.unbindEventListeners();
    }, unbindEventListeners() {
      b(window, "mousemove", this.handleChange), b(window, "mouseup", this.handleMouseUp), setTimeout(() => this.ColorPickerInstance.handleOnDragging(!1), 1);
    }, getLeft(t) {
      if (!h)
        return;
      const { container: r } = this.$refs, o = r.getBoundingClientRect().left + window.pageXOffset;
      return (t.pageX || Tg(t, "PageX")) - o;
    }, getTop(t) {
      if (!h)
        return;
      const { container: r } = this.$refs, o = r.getBoundingClientRect().top + window.pageYOffset;
      return (t.pageY || Tg(t, "PageY")) - o;
    } } };
    const tT = { name: "Saturation", mixins: [ca, oa], emits: ["change"], data() {
      return { left: -0.01, right: 0.01, up: 0.01, down: -0.01, multiplier: 10, powerKey: "shiftKey" };
    }, computed: { bgColorStyle() {
      return { background: `hsl(${this.value.hsv.h}, 100%, 50%)` };
    }, pointerStyle() {
      return { top: `${-(this.value.hsv.v * 100) + 1 + 100}%`, left: `${this.value.hsv.s * 100}%` };
    } }, methods: { change(t, r, o, C) {
      this.$emit("change", { h: t, s: r, v: o, a: C, source: "hsva" });
    }, handleSlide(t, r, o) {
      t.preventDefault(), t.stopPropagation();
      const C = t[this.powerKey] ? r * this.multiplier : r, { h: g, s: a, v: x, a: O } = this.value.hsv, P = Si(a + _g(o, ["left", "right"], C), 0, 1), N = Si(x + _g(o, ["up", "down"], C), 0, 1);
      this.change(g, P, N, O);
    }, handleChange(t) {
      t.preventDefault(), t.stopPropagation();
      const { clientWidth: r, clientHeight: o } = this.$refs.container, C = Si(this.getLeft(t), 0, r), g = Si(this.getTop(t), 0, o), a = C / r, x = Si(1 - g / o, 0, 1);
      this.change(this.value.hsv.h, a, x, this.value.hsv.a);
    }, handleMouseDown(t) {
      ca.methods.handleMouseDown.call(this, t), m(window, "mouseup", this.handleChange);
    }, unbindEventListeners(t) {
      ca.methods.unbindEventListeners.call(this, t), b(window, "mouseup", this.handleChange);
    } } };
    function nT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([t.prefixCls + "-saturation-wrapper"]), tabindex: "0", onKeydown: [r[1] || (r[1] = e.withKeys((...x) => t.handleEscape && t.handleEscape(...x), ["esc"])), r[3] || (r[3] = e.withKeys((...x) => t.handleLeft && t.handleLeft(...x), ["left"])), r[4] || (r[4] = e.withKeys((...x) => t.handleRight && t.handleRight(...x), ["right"])), r[5] || (r[5] = e.withKeys((...x) => t.handleUp && t.handleUp(...x), ["up"])), r[6] || (r[6] = e.withKeys((...x) => t.handleDown && t.handleDown(...x), ["down"]))], onClick: r[2] || (r[2] = (x) => t.$el.focus()) }, [e.createElementVNode("div", { ref: "container", style: e.normalizeStyle(a.bgColorStyle), class: e.normalizeClass([t.prefixCls + "-saturation"]), onMousedown: r[0] || (r[0] = (...x) => a.handleMouseDown && a.handleMouseDown(...x)) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-saturation--white"]) }, null, 2), e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-saturation--black"]) }, null, 2), e.createElementVNode("div", { style: e.normalizeStyle(a.pointerStyle), class: e.normalizeClass([t.prefixCls + "-saturation-pointer"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-saturation-circle"]) }, null, 2)], 6)], 38)], 34);
    }
    var iT = f(tT, [["render", nT]]);
    const rT = { name: "Hue", mixins: [ca, oa], emits: ["change"], data() {
      const t = 0.06944444444444445, r = 20 * t;
      return { left: -t, right: t, up: r, down: -r, powerKey: "shiftKey", percent: Si(this.value.hsl.h * 100 / 360, 0, 100) };
    }, watch: { value() {
      this.percent = Si(this.value.hsl.h * 100 / 360, 0, 100);
    } }, methods: { change(t) {
      this.percent = Si(t, 0, 100);
      const { h: r, s: o, l: C, a: g } = this.value.hsl, a = Si(t / 100 * 360, 0, 360);
      r !== a && this.$emit("change", { h: a, s: o, l: C, a: g, source: "hsl" });
    }, handleSlide(t, r) {
      if (t.preventDefault(), t.stopPropagation(), t[this.powerKey]) {
        this.change(r < 0 ? 0 : 100);
        return;
      }
      this.change(this.percent + r);
    }, handleChange(t) {
      t.preventDefault(), t.stopPropagation();
      const r = this.getLeft(t);
      if (r < 0) {
        this.change(0);
        return;
      }
      const { clientWidth: o } = this.$refs.container;
      if (r > o) {
        this.change(100);
        return;
      }
      this.change(r * 100 / o);
    } } };
    function sT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([t.prefixCls + "-hue"]), tabindex: "0", onClick: r[3] || (r[3] = (x) => t.$el.focus()), onKeydown: [r[4] || (r[4] = e.withKeys((...x) => t.handleEscape && t.handleEscape(...x), ["esc"])), r[5] || (r[5] = e.withKeys((...x) => t.handleLeft && t.handleLeft(...x), ["left"])), r[6] || (r[6] = e.withKeys((...x) => t.handleRight && t.handleRight(...x), ["right"])), r[7] || (r[7] = e.withKeys((...x) => t.handleUp && t.handleUp(...x), ["up"])), r[8] || (r[8] = e.withKeys((...x) => t.handleDown && t.handleDown(...x), ["down"]))] }, [e.createElementVNode("div", { ref: "container", class: e.normalizeClass([t.prefixCls + "-hue-container"]), onMousedown: r[0] || (r[0] = (...x) => t.handleMouseDown && t.handleMouseDown(...x)), onTouchmove: r[1] || (r[1] = (...x) => a.handleChange && a.handleChange(...x)), onTouchstart: r[2] || (r[2] = (...x) => a.handleChange && a.handleChange(...x)) }, [e.createElementVNode("div", { style: e.normalizeStyle({ top: 0, left: `${g.percent}%` }), class: e.normalizeClass([t.prefixCls + "-hue-pointer"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-hue-picker"]) }, null, 2)], 6)], 34)], 34);
    }
    var oT = f(rT, [["render", sT]]);
    const aT = { name: "Alpha", mixins: [ca, oa], emits: ["change"], data() {
      return { left: -1, right: 1, up: 10, down: -10, powerKey: "shiftKey" };
    }, computed: { gradientStyle() {
      const { r: t, g: r, b: o } = this.value.rgba, C = la({ r: t, g: r, b: o, a: 0 }), g = la({ r: t, g: r, b: o, a: 1 });
      return { background: `linear-gradient(to right, ${C} 0%, ${g} 100%)` };
    } }, methods: { change(t) {
      const { h: r, s: o, l: C } = this.value.hsl, { a: g } = this.value;
      g !== t && this.$emit("change", { h: r, s: o, l: C, a: t, source: "rgba" });
    }, handleSlide(t, r) {
      t.preventDefault(), t.stopPropagation(), this.change(Si(t[this.powerKey] ? r : Math.round(this.value.hsl.a * 100 + r) / 100, 0, 1));
    }, handleChange(t) {
      t.preventDefault(), t.stopPropagation();
      const r = this.getLeft(t);
      if (r < 0) {
        this.change(0);
        return;
      }
      const { clientWidth: o } = this.$refs.container;
      if (r > o) {
        this.change(1);
        return;
      }
      this.change(Math.round(r * 100 / o) / 100);
    } } };
    function lT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([t.prefixCls + "-alpha"]), tabindex: "0", onClick: r[3] || (r[3] = (x) => t.$el.focus()), onKeydown: [r[4] || (r[4] = e.withKeys((...x) => t.handleEscape && t.handleEscape(...x), ["esc"])), r[5] || (r[5] = e.withKeys((...x) => t.handleLeft && t.handleLeft(...x), ["left"])), r[6] || (r[6] = e.withKeys((...x) => t.handleRight && t.handleRight(...x), ["right"])), r[7] || (r[7] = e.withKeys((...x) => t.handleUp && t.handleUp(...x), ["up"])), r[8] || (r[8] = e.withKeys((...x) => t.handleDown && t.handleDown(...x), ["down"]))] }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-alpha-checkboard-wrap"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-alpha-checkerboard"]) }, null, 2)], 2), e.createElementVNode("div", { style: e.normalizeStyle(a.gradientStyle), class: e.normalizeClass([t.prefixCls + "-alpha-gradient"]) }, null, 6), e.createElementVNode("div", { ref: "container", class: e.normalizeClass([t.prefixCls + "-alpha-container"]), onMousedown: r[0] || (r[0] = (...x) => t.handleMouseDown && t.handleMouseDown(...x)), onTouchmove: r[1] || (r[1] = (...x) => a.handleChange && a.handleChange(...x)), onTouchstart: r[2] || (r[2] = (...x) => a.handleChange && a.handleChange(...x)) }, [e.createElementVNode("div", { style: e.normalizeStyle({ top: 0, left: `${t.value.a * 100}%` }), class: e.normalizeClass([t.prefixCls + "-alpha-pointer"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-alpha-picker"]) }, null, 2)], 6)], 34)], 34);
    }
    var cT = f(aT, [["render", lT]]);
    const uT = { name: "ColorPicker", components: { Drop: er, RecommendColors: eT, Saturation: iT, Hue: oT, Alpha: cT, iInput: di, iButton: zn, Icon: G }, directives: { clickOutside: Dh }, mixins: [Kt, oa, nn, kr], emits: ["on-active-change", "on-open-change", "on-change", "on-pick-success", "on-pick-clear", "update:modelValue"], provide() {
      return { ColorPickerInstance: this };
    }, props: { modelValue: { type: String, default: void 0 }, hue: { type: Boolean, default: !0 }, alpha: { type: Boolean, default: !1 }, recommend: { type: Boolean, default: !1 }, format: { type: String, validator(t) {
      return z(t, ["hsl", "hsv", "hex", "rgb"]);
    }, default: void 0 }, colors: { type: Array, default() {
      return [];
    } }, disabled: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, hideDropDown: { type: Boolean, default: !1 }, placement: { type: String, validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, name: { type: String, default: void 0 }, editable: { type: Boolean, default: !0 }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, transferClassName: { type: String }, eventsEnabled: { type: Boolean, default: !1 } }, data() {
      return { val: aa(this.modelValue || ""), currentValue: this.modelValue || "", dragging: !1, visible: !1, recommendedColor: ["#2d8cf0", "#19be6b", "#ff9900", "#ed4014", "#00b5ff", "#19c919", "#f9e31c", "#ea1a1a", "#9b1dea", "#00c2b1", "#ac7a33", "#1d35ea", "#8bc34a", "#f16b62", "#ea4ca3", "#0d94aa", "#febd79", "#5d4037", "#00bcd4", "#f06292", "#cddc39", "#607d8b", "#000000", "#ffffff"] };
    }, computed: { arrowClasses() {
      return [`${this.inputPrefixCls}-icon`, `${this.inputPrefixCls}-icon-normal`];
    }, transition() {
      return z(this.placement, ["bottom-start", "bottom", "bottom-end"]) ? "slide-up" : "fade";
    }, saturationColors: { get() {
      return this.val;
    }, set(t) {
      this.val = t, this.$emit("on-active-change", this.formatColor);
    } }, classes() {
      return [`${this.prefixCls}`, { [`${this.prefixCls}-transfer`]: this.transfer }];
    }, wrapClasses() {
      return [`${this.prefixCls}-rel`, `${this.prefixCls}-${this.size}`, `${this.inputPrefixCls}-wrapper`, `${this.inputPrefixCls}-wrapper-${this.size}`, { [`${this.prefixCls}-disabled`]: this.itemDisabled }];
    }, inputClasses() {
      return [`${this.prefixCls}-input`, `${this.inputPrefixCls}`, `${this.inputPrefixCls}-${this.size}`, { [`${this.prefixCls}-focused`]: this.visible, [`${this.prefixCls}-disabled`]: this.itemDisabled }];
    }, dropClasses() {
      return { [`${this.transferPrefixCls}-no-max-height`]: !0, [`${this.prefixCls}-transfer`]: this.transfer, [`${this.prefixCls}-hide-drop`]: this.hideDropDown, [this.transferClassName]: this.transferClassName };
    }, displayedColorStyle() {
      return { backgroundColor: la(this.visible ? this.saturationColors.rgba : sc(this.modelValue).toRgb()) };
    }, formatColor() {
      const { format: t, saturationColors: r } = this;
      if (t) {
        if (t === "hsl")
          return sc(r.hsl).toHslString();
        if (t === "hsv")
          return sc(r.hsv).toHsvString();
        if (t === "hex")
          return r.hex;
        if (t === "rgb")
          return la(r.rgba);
      } else if (this.alpha)
        return la(r.rgba);
      return r.hex;
    }, confirmColorClasses() {
      return [`${this.prefixCls}-confirm-color`, { [`${this.prefixCls}-confirm-color-editable`]: this.editable }];
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-down";
      return t && (t.colorPicker.customArrow ? r = "" : t.colorPicker.arrow && (r = t.colorPicker.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.colorPicker.customArrow && (r = t.colorPicker.customArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.colorPicker.arrowSize && (r = t.colorPicker.arrowSize), r;
    } }, watch: { modelValue(t) {
      this.val = aa(t || "");
    }, visible(t) {
      this.val = aa(this.modelValue || ""), this.$refs.drop[t ? "update" : "destroy"](), this.$emit("on-open-change", !!t);
    } }, methods: { setDragging(t) {
      this.dragging = t;
    }, handleClose(t) {
      if (this.visible) {
        if (this.dragging || t.type === "mousedown") {
          this.$refs.editColorInput && t.target !== this.$refs.editColorInput.$el.querySelector("input") && t.preventDefault();
          return;
        }
        if (this.transfer) {
          const r = this.$refs.drop.$refs.drop;
          if (r === t.target || r.contains(t.target))
            return;
        }
        this.closer(t);
        return;
      }
      this.visible = !1;
    }, toggleVisible() {
      this.itemDisabled || (this.visible = !this.visible, this.$refs.input.focus());
    }, childChange(t) {
      this.colorChange(t);
    }, colorChange(t, r) {
      this.oldHue = this.saturationColors.hsl.h, this.saturationColors = aa(t, r || this.oldHue);
    }, closer(t) {
      t && (t.preventDefault(), t.stopPropagation()), this.visible = !1, this.$refs.input.focus();
    }, handleButtons(t, r) {
      this.currentValue = r, this.$emit("update:modelValue", r), this.$emit("on-change", r), this.handleFormItemChange("change", r), this.closer(t);
    }, handleSuccess(t) {
      this.handleButtons(t, this.formatColor), this.$emit("on-pick-success");
    }, handleClear(t) {
      this.handleButtons(t, ""), this.$emit("on-pick-clear");
    }, handleSelectColor(t) {
      this.val = aa(t), this.$emit("on-active-change", this.formatColor);
    }, handleEditColor(t) {
      const r = t.target.value;
      this.handleSelectColor(r);
    }, handleFirstTab(t) {
      t.shiftKey && (t.preventDefault(), t.stopPropagation(), this.$refs.ok.$el.focus());
    }, handleLastTab(t) {
      t.shiftKey || (t.preventDefault(), t.stopPropagation(), this.$refs.saturation.$el.focus());
    }, onTab(t) {
      this.visible && t.preventDefault();
    }, onEscape(t) {
      this.visible && this.closer(t);
    }, onArrow(t) {
      this.visible || (t.preventDefault(), t.stopPropagation(), this.visible = !0);
    }, handleOnEscapeKeydown(t) {
      this.closer(t);
    }, handleOnDragging(t) {
      this.setDragging(t);
    } } }, hT = ["name", "value"], dT = ["tabindex"];
    function fT(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Saturation"), P = e.resolveComponent("Hue"), N = e.resolveComponent("Alpha"), B = e.resolveComponent("recommend-colors"), H = e.resolveComponent("i-input"), oe = e.resolveComponent("i-button"), se = e.resolveComponent("Drop"), ee = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { ref: "reference", class: e.normalizeClass(a.wrapClasses), onClick: r[4] || (r[4] = (...j) => a.toggleVisible && a.toggleVisible(...j)) }, [e.createElementVNode("input", { name: o.name, value: g.currentValue, type: "hidden" }, null, 8, hT), e.createVNode(x, { type: a.arrowType, custom: a.customArrowType, size: a.arrowSize, class: e.normalizeClass(a.arrowClasses) }, null, 8, ["type", "custom", "size", "class"]), e.createElementVNode("div", { ref: "input", tabindex: t.itemDisabled ? void 0 : 0, class: e.normalizeClass(a.inputClasses), onKeydown: [r[0] || (r[0] = e.withKeys((...j) => a.onTab && a.onTab(...j), ["tab"])), r[1] || (r[1] = e.withKeys((...j) => a.onEscape && a.onEscape(...j), ["esc"])), r[2] || (r[2] = e.withKeys((...j) => a.onArrow && a.onArrow(...j), ["up"])), r[3] || (r[3] = e.withKeys((...j) => a.onArrow && a.onArrow(...j), ["down"]))] }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-color"]) }, [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-color-empty"]) }, [e.createElementVNode("i", { class: e.normalizeClass([t.iconPrefixCls, t.iconPrefixCls + "-ios-close"]) }, null, 2)], 2), [[e.vShow, o.modelValue === "" && !g.visible]]), e.withDirectives(e.createElementVNode("div", { style: e.normalizeStyle(a.displayedColorStyle) }, null, 4), [[e.vShow, o.modelValue || g.visible]])], 2)], 42, dT)], 2), e.createVNode(se, { ref: "drop", visible: g.visible, placement: o.placement, transfer: o.transfer, classes: a.dropClasses, eventsEnabled: o.eventsEnabled, "transition-name": "transition-drop" }, { default: e.withCtx(() => [e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [g.visible ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([t.prefixCls + "-picker"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-picker-wrapper"]) }, [e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-picker-panel"]) }, [e.createVNode(O, { ref: "saturation", value: a.saturationColors, focused: g.visible, onChange: a.childChange, onKeydown: e.withKeys(a.handleFirstTab, ["tab"]) }, null, 8, ["value", "focused", "onChange", "onKeydown"])], 2), o.hue ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([t.prefixCls + "-picker-hue-slider"]) }, [e.createVNode(P, { value: a.saturationColors, onChange: a.childChange }, null, 8, ["value", "onChange"])], 2)) : e.createCommentVNode("", !0), o.alpha ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass([t.prefixCls + "-picker-alpha-slider"]) }, [e.createVNode(N, { value: a.saturationColors, onChange: a.childChange }, null, 8, ["value", "onChange"])], 2)) : e.createCommentVNode("", !0), o.colors.length ? (e.openBlock(), e.createBlock(B, { key: 2, list: o.colors, class: e.normalizeClass([t.prefixCls + "-picker-colors"]), onPickerColor: a.handleSelectColor }, null, 8, ["list", "class", "onPickerColor"])) : e.createCommentVNode("", !0), !o.colors.length && o.recommend ? (e.openBlock(), e.createBlock(B, { key: 3, list: g.recommendedColor, class: e.normalizeClass([t.prefixCls + "-picker-colors"]), onPickerColor: a.handleSelectColor }, null, 8, ["list", "class", "onPickerColor"])) : e.createCommentVNode("", !0)], 2), e.createElementVNode("div", { class: e.normalizeClass([t.prefixCls + "-confirm"]) }, [e.createElementVNode("span", { class: e.normalizeClass(a.confirmColorClasses) }, [o.editable ? (e.openBlock(), e.createBlock(H, { key: 0, ref: "editColorInput", modelValue: a.formatColor, size: "small", onOnEnter: a.handleEditColor, onOnBlur: a.handleEditColor }, null, 8, ["modelValue", "onOnEnter", "onOnBlur"])) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(a.formatColor), 1)], 64))], 2), e.createVNode(oe, { class: e.normalizeClass([t.prefixCls + "-confirm-btn-cancel"]), ref: "clear", tabindex: 0, size: "small", onClick: a.handleClear, onKeydown: [e.withKeys(a.handleClear, ["enter"]), e.withKeys(a.closer, ["esc"])] }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(t.t("i.datepicker.clear")), 1)]), _: 1 }, 8, ["class", "onClick", "onKeydown"]), e.createVNode(oe, { ref: "ok", tabindex: 0, size: "small", type: "primary", onClick: a.handleSuccess, onKeydown: [e.withKeys(a.handleLastTab, ["tab"]), e.withKeys(a.handleSuccess, ["enter"]), e.withKeys(a.closer, ["esc"])] }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(t.t("i.datepicker.ok")), 1)]), _: 1 }, 8, ["onClick", "onKeydown"])], 2)], 2)) : e.createCommentVNode("", !0)]), _: 1 })]), _: 1 }, 8, ["visible", "placement", "transfer", "classes", "eventsEnabled"])], 2)), [[ee, a.handleClose, o.capture]]);
    }
    var Og = f(uT, [["render", fT]]);
    const pT = "ivu-layout", mT = { name: "Content", computed: { wrapClasses() {
      return `${pT}-content`;
    } } };
    function gT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var Yh = f(mT, [["render", gT]]);
    function vT(t) {
      var r;
      if (t.nodeName === "SELECT")
        t.focus(), r = t.value;
      else if (t.nodeName === "INPUT" || t.nodeName === "TEXTAREA") {
        var o = t.hasAttribute("readonly");
        o || t.setAttribute("readonly", ""), t.select(), t.setSelectionRange(0, t.value.length), o || t.removeAttribute("readonly"), r = t.value;
      } else {
        t.hasAttribute("contenteditable") && t.focus();
        var C = window.getSelection(), g = document.createRange();
        g.selectNodeContents(t), C.removeAllRanges(), C.addRange(g), r = C.toString();
      }
      return r;
    }
    var yT = vT, Dg = { name: "RenderCell", props: { render: Function }, render() {
      return this.render(e.h);
    } };
    const bT = { components: { RenderCell: Dg }, props: { prefixCls: { type: String, default: "" }, duration: { type: Number, default: 1.5 }, type: { type: String }, content: { type: String, default: "" }, withIcon: Boolean, render: { type: Function }, hasTitle: Boolean, styles: { type: Object, default: function() {
      return { right: "50%" };
    } }, closable: { type: Boolean, default: !1 }, className: { type: String }, name: { type: String, required: !0 }, onClose: { type: Function }, transitionName: { type: String }, background: { type: Boolean, default: !1 }, msgType: { type: String } }, data() {
      return { withDesc: !1 };
    }, computed: { baseClass() {
      return `${this.prefixCls}-notice`;
    }, renderFunc() {
      return this.render || function() {
      };
    }, classes() {
      return [this.baseClass, { [`${this.className}`]: !!this.className, [`${this.baseClass}-closable`]: this.closable, [`${this.baseClass}-with-desc`]: this.withDesc, [`${this.baseClass}-with-background`]: this.background }];
    }, contentClasses() {
      return [`${this.baseClass}-content`, this.render !== void 0 ? `${this.baseClass}-content-with-render` : ""];
    }, messageContentClasses() {
      return [`${this.baseClass}-content`, { [`${this.baseClass}-content-${this.msgType}`]: this.msgType, [`${this.baseClass}-content-background`]: this.background }];
    }, contentWithIcon() {
      return [this.withIcon ? `${this.prefixCls}-content-with-icon` : "", !this.hasTitle && this.withIcon ? `${this.prefixCls}-content-with-render-notitle` : ""];
    }, messageClasses() {
      return [`${this.baseClass}-content`, this.render !== void 0 ? `${this.baseClass}-content-with-render` : ""];
    } }, methods: { clearCloseTimer() {
      this.closeTimer && (clearTimeout(this.closeTimer), this.closeTimer = null);
    }, close() {
      this.clearCloseTimer(), this.onClose(), this.$parent.$parent.close(this.name);
    }, handleEnter(t) {
      this.type === "message" && (t.style.height = t.scrollHeight + "px");
    }, handleLeave(t) {
      this.type === "message" && h && document.getElementsByClassName("ivu-message-notice").length !== 1 && (t.style.height = 0, t.style.paddingTop = 0, t.style.paddingBottom = 0);
    } }, mounted() {
      if (this.handleEnter(this.$el), this.clearCloseTimer(), this.duration !== 0 && (this.closeTimer = setTimeout(() => {
        this.close();
      }, this.duration * 1e3)), this.prefixCls === "ivu-notice") {
        let t = this.$refs.content.querySelectorAll(`.${this.prefixCls}-desc`)[0];
        this.withDesc = this.render ? !0 : t ? t.innerHTML !== "" : !1;
      }
    }, beforeUnmount() {
      this.handleLeave(this.$el), this.clearCloseTimer();
    } }, CT = ["innerHTML"], wT = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-close" }, null, -1)], kT = ["innerHTML"], ST = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-close" }, null, -1)];
    function ET(t, r, o, C, g, a) {
      const x = e.resolveComponent("render-cell");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(o.styles) }, [o.type === "notice" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses), ref: "content", innerHTML: o.content }, null, 10, CT), e.createElementVNode("div", { class: e.normalizeClass(a.contentWithIcon) }, [e.createVNode(x, { render: a.renderFunc }, null, 8, ["render"])], 2), o.closable ? (e.openBlock(), e.createElementBlock("a", { key: 0, class: e.normalizeClass([a.baseClass + "-close"]), onClick: r[0] || (r[0] = (...O) => a.close && a.close(...O)) }, wT, 2)) : e.createCommentVNode("", !0)], 64)) : e.createCommentVNode("", !0), o.type === "message" ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass(a.messageContentClasses), ref: "content" }, [e.createElementVNode("div", { class: e.normalizeClass([a.baseClass + "-content-text"]), innerHTML: o.content }, null, 10, kT), e.createElementVNode("div", { class: e.normalizeClass([a.baseClass + "-content-text"]) }, [e.createVNode(x, { render: a.renderFunc }, null, 8, ["render"])], 2), o.closable ? (e.openBlock(), e.createElementBlock("a", { key: 0, class: e.normalizeClass([a.baseClass + "-close"]), onClick: r[1] || (r[1] = (...O) => a.close && a.close(...O)) }, ST, 2)) : e.createCommentVNode("", !0)], 2)) : e.createCommentVNode("", !0)], 6);
    }
    var xT = f(bT, [["render", ET]]);
    const _T = "ivu-notification";
    let TT = 0;
    const OT = Date.now();
    function DT() {
      return "ivuNotification_" + OT + "_" + TT++;
    }
    const NT = { components: { Notice: xT }, props: { prefixCls: { type: String, default: _T }, styles: { type: Object, default: function() {
      return { top: "65px", left: "50%" };
    } }, content: { type: String }, className: { type: String }, transitionName: { type: String } }, data() {
      return { notices: [], tIndex: this.handleGetIndex() };
    }, computed: { classes() {
      return [`${this.prefixCls}`, { [`${this.className}`]: !!this.className }];
    }, wrapStyles() {
      let t = Object.assign({}, this.styles);
      return t["z-index"] = 1010 + this.tIndex, t;
    } }, methods: { add(t) {
      const r = t.name || DT();
      let o = Object.assign({ styles: { right: "50%" }, content: "", duration: 1.5, closable: !1, name: r }, t);
      this.notices.push(o), this.tIndex = this.handleGetIndex();
    }, close(t) {
      const r = this.notices;
      for (let o = 0; o < r.length; o++)
        if (r[o].name === t) {
          this.notices.splice(o, 1);
          break;
        }
    }, closeAll() {
      this.notices = [];
    }, handleGetIndex() {
      return Vn(), Ut;
    } } };
    function BT(t, r, o, C, g, a) {
      const x = e.resolveComponent("Notice");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.wrapStyles) }, [e.createVNode(e.TransitionGroup, { name: o.transitionName, appear: "" }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.notices, (O) => (e.openBlock(), e.createBlock(x, { key: O.name, "prefix-cls": o.prefixCls, styles: O.styles, type: O.type, content: O.content, duration: O.duration, render: O.render, "has-title": O.hasTitle, withIcon: O.withIcon, closable: O.closable, name: O.name, "transition-name": O.transitionName, background: O.background, "msg-type": O.msgType, "on-close": O.onClose }, null, 8, ["prefix-cls", "styles", "type", "content", "duration", "render", "has-title", "withIcon", "closable", "name", "transition-name", "background", "msg-type", "on-close"]))), 128))]), _: 1 }, 8, ["name"])], 6);
    }
    var oc = f(NT, [["render", BT]]);
    oc.newInstance = (t) => {
      if (!h)
        return;
      const r = t || {};
      let o = null;
      const C = e.createApp({ render() {
        return e.h(oc, Object.assign({ ref: "notification" }, r));
      }, created() {
        o = e.getCurrentInstance();
      } }), g = document.createElement("div");
      document.body.appendChild(g), C.mount(g);
      const a = o.refs.notification;
      return { notice(x) {
        a.add(x);
      }, remove(x) {
        a.close(x);
      }, component: a, destroy(x) {
        a.closeAll(), h && setTimeout(function() {
          document.body.removeChild(document.getElementsByClassName(x)[0]);
        }, 500);
      } };
    };
    const Kh = "ivu-message", Ng = "ivu-icon", Bg = "ivu_message_key_", ao = { top: 24, duration: 1.5, background: !1 };
    let ac, Pg = 1;
    const PT = { info: "ios-information-circle", success: "ios-checkmark-circle", warning: "ios-alert", error: "ios-close-circle", loading: "ios-loading" }, Vg = "move-up";
    function $g() {
      return ac = ac || oc.newInstance({ prefixCls: Kh, styles: { top: `${ao.top}px` }, transitionName: Vg }), ac;
    }
    function VT(t = "", r = ao.duration, o, C = function() {
    }, g = !1, a = function() {
    }, x = ao.background) {
      const O = PT[o], P = o === "loading" ? " ivu-load-loop" : "";
      let N = $g();
      return N.notice({ name: `${Bg}${Pg}`, duration: r, styles: {}, transitionName: Vg, content: `
            <div class="${Kh}-custom-content ${Kh}-${o}">
                <i class="${Ng} ${Ng}-${O} ${P}"></i>
                <span>${t}</span>
            </div>
        `, render: a, onClose: C, closable: g, type: "message", msgType: o, background: x }), function() {
        let B = Pg++;
        return function() {
          N.remove(`${Bg}${B}`);
        };
      }();
    }
    var ua = { name: "Message", info(t) {
      return this.message("info", t);
    }, success(t) {
      return this.message("success", t);
    }, warning(t) {
      return this.message("warning", t);
    }, error(t) {
      return this.message("error", t);
    }, loading(t) {
      return this.message("loading", t);
    }, message(t, r) {
      return typeof r == "string" && (r = { content: r }), VT(r.content, r.duration, t, r.onClose, r.closable, r.render, r.background);
    }, config(t) {
      (t.top || t.top === 0) && (ao.top = t.top), (t.duration || t.duration === 0) && (ao.duration = t.duration), t.background && (ao.background = t.background);
    }, destroy() {
      let t = $g();
      ac = null, t.destroy("ivu-message");
    } };
    const $T = "复制成功", IT = "复制失败";
    function lc({ text: t = "", successTip: r = $T, errorTip: o = IT, success: C, error: g, showTip: a = !0 }) {
      if (!h)
        return;
      const x = document.documentElement.getAttribute("dir") === "rtl", O = document.createElement("textarea");
      O.style.fontSize = "12pt", O.style.border = "0", O.style.padding = "0", O.style.margin = "0", O.style.position = "absolute", O.style[x ? "right" : "left"] = "-9999px";
      let P = window.pageYOffset || document.documentElement.scrollTop;
      O.style.top = `${P}px`, O.setAttribute("readonly", ""), O.value = t, document.body.appendChild(O), yT(O);
      let N;
      try {
        N = document.execCommand("copy"), a && ua.success({ content: r }), document.body.removeChild(O), C && C.call();
      } catch {
        N = !1, a && ua.error({ content: o }), document.body.removeChild(O), g && g.call();
      }
    }
    function Gh(t) {
      return t * 1 < 10 ? `0${t}` : t;
    }
    const MT = { name: "CountDown", emits: ["on-end"], props: { format: { type: Function }, target: { type: [Date, Number] }, interval: { type: Number, default: 1e3 } }, data() {
      return { lastTime: "" };
    }, methods: { initTime() {
      let t = 0, r = 0;
      try {
        Object.prototype.toString.call(this.target) === "[object Date]" ? r = this.target.getTime() : r = new Date(this.target).getTime();
      } catch (o) {
        throw new Error("invalid target prop", o);
      }
      return t = r - (/* @__PURE__ */ new Date()).getTime(), t < 0 ? 0 : t;
    }, tick() {
      let { lastTime: t } = this;
      this.timer = setTimeout(() => {
        t < this.interval ? (clearTimeout(this.timer), this.lastTime = 0, this.$emit("on-end")) : (t -= this.interval, this.lastTime = t, this.tick());
      }, this.interval);
    }, defaultFormat(t) {
      const r = Math.floor(t / 36e5), o = Math.floor((t - r * 36e5) / 6e4), C = Math.floor((t - r * 36e5 - o * 6e4) / 1e3);
      return `${Gh(r)}:${Gh(o)}:${Gh(C)}`;
    } }, computed: { result() {
      const { format: t = this.defaultFormat } = this;
      return t(this.lastTime);
    } }, watch: { target() {
      this.timer && clearTimeout(this.timer), this.lastTime = this.initTime(), this.tick();
    } }, created() {
      this.lastTime = this.initTime();
    }, mounted() {
      this.tick();
    }, beforeUnmount() {
      this.timer && clearTimeout(this.timer);
    } };
    function AT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", null, e.toDisplayString(a.result), 1);
    }
    var Ig = f(MT, [["render", AT]]), Xh = { exports: {} };
    (function(t, r) {
      (function(o, C) {
        t.exports = C(vt, r, t);
      })(pt, function(o, C, g) {
        var a = function(x, O, P, N, B, H) {
          function oe(Ee) {
            var ye, ze, Oe, lt, it, Ze, kt = Ee < 0;
            if (Ee = Math.abs(Ee).toFixed(j.decimals), Ee += "", ye = Ee.split("."), ze = ye[0], Oe = ye.length > 1 ? j.options.decimal + ye[1] : "", j.options.useGrouping) {
              for (lt = "", it = 0, Ze = ze.length; it < Ze; ++it)
                it !== 0 && it % 3 === 0 && (lt = j.options.separator + lt), lt = ze[Ze - it - 1] + lt;
              ze = lt;
            }
            return j.options.numerals.length && (ze = ze.replace(/[0-9]/g, function(ot) {
              return j.options.numerals[+ot];
            }), Oe = Oe.replace(/[0-9]/g, function(ot) {
              return j.options.numerals[+ot];
            })), (kt ? "-" : "") + j.options.prefix + ze + Oe + j.options.suffix;
          }
          function se(Ee, ye, ze, Oe) {
            return ze * (-Math.pow(2, -10 * Ee / Oe) + 1) * 1024 / 1023 + ye;
          }
          function ee(Ee) {
            return typeof Ee == "number" && !isNaN(Ee);
          }
          var j = this;
          if (j.version = function() {
            return "1.9.3";
          }, j.options = { useEasing: !0, useGrouping: !0, separator: ",", decimal: ".", easingFn: se, formattingFn: oe, prefix: "", suffix: "", numerals: [] }, H && typeof H == "object")
            for (var pe in j.options)
              H.hasOwnProperty(pe) && H[pe] !== null && (j.options[pe] = H[pe]);
          j.options.separator === "" ? j.options.useGrouping = !1 : j.options.separator = "" + j.options.separator;
          for (var at = 0, Qe = ["webkit", "moz", "ms", "o"], tt = 0; tt < Qe.length && !window.requestAnimationFrame; ++tt)
            window.requestAnimationFrame = window[Qe[tt] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[Qe[tt] + "CancelAnimationFrame"] || window[Qe[tt] + "CancelRequestAnimationFrame"];
          window.requestAnimationFrame || (window.requestAnimationFrame = function(Ee, ye) {
            var ze = (/* @__PURE__ */ new Date()).getTime(), Oe = Math.max(0, 16 - (ze - at)), lt = window.setTimeout(function() {
              Ee(ze + Oe);
            }, Oe);
            return at = ze + Oe, lt;
          }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(Ee) {
            clearTimeout(Ee);
          }), j.initialize = function() {
            return !!j.initialized || (j.error = "", j.d = typeof x == "string" ? document.getElementById(x) : x, j.d ? (j.startVal = Number(O), j.endVal = Number(P), ee(j.startVal) && ee(j.endVal) ? (j.decimals = Math.max(0, N || 0), j.dec = Math.pow(10, j.decimals), j.duration = 1e3 * Number(B) || 2e3, j.countDown = j.startVal > j.endVal, j.frameVal = j.startVal, j.initialized = !0, !0) : (j.error = "[CountUp] startVal (" + O + ") or endVal (" + P + ") is not a number", !1)) : (j.error = "[CountUp] target is null or undefined", !1));
          }, j.printValue = function(Ee) {
            var ye = j.options.formattingFn(Ee);
            j.d.tagName === "INPUT" ? this.d.value = ye : j.d.tagName === "text" || j.d.tagName === "tspan" ? this.d.textContent = ye : this.d.innerHTML = ye;
          }, j.count = function(Ee) {
            j.startTime || (j.startTime = Ee), j.timestamp = Ee;
            var ye = Ee - j.startTime;
            j.remaining = j.duration - ye, j.options.useEasing ? j.countDown ? j.frameVal = j.startVal - j.options.easingFn(ye, 0, j.startVal - j.endVal, j.duration) : j.frameVal = j.options.easingFn(ye, j.startVal, j.endVal - j.startVal, j.duration) : j.countDown ? j.frameVal = j.startVal - (j.startVal - j.endVal) * (ye / j.duration) : j.frameVal = j.startVal + (j.endVal - j.startVal) * (ye / j.duration), j.countDown ? j.frameVal = j.frameVal < j.endVal ? j.endVal : j.frameVal : j.frameVal = j.frameVal > j.endVal ? j.endVal : j.frameVal, j.frameVal = Math.round(j.frameVal * j.dec) / j.dec, j.printValue(j.frameVal), ye < j.duration ? j.rAF = requestAnimationFrame(j.count) : j.callback && j.callback();
          }, j.start = function(Ee) {
            j.initialize() && (j.callback = Ee, j.rAF = requestAnimationFrame(j.count));
          }, j.pauseResume = function() {
            j.paused ? (j.paused = !1, delete j.startTime, j.duration = j.remaining, j.startVal = j.frameVal, requestAnimationFrame(j.count)) : (j.paused = !0, cancelAnimationFrame(j.rAF));
          }, j.reset = function() {
            j.paused = !1, delete j.startTime, j.initialized = !1, j.initialize() && (cancelAnimationFrame(j.rAF), j.printValue(j.startVal));
          }, j.update = function(Ee) {
            if (j.initialize()) {
              if (Ee = Number(Ee), !ee(Ee))
                return void (j.error = "[CountUp] update() - new endVal is not a number: " + Ee);
              j.error = "", Ee !== j.frameVal && (cancelAnimationFrame(j.rAF), j.paused = !1, delete j.startTime, j.startVal = j.frameVal, j.endVal = Ee, j.countDown = j.startVal > j.endVal, j.rAF = requestAnimationFrame(j.count));
            }
          }, j.initialize() && j.printValue(j.startVal);
        };
        return a;
      });
    })(Xh, Xh.exports);
    var FT = Xh.exports;
    const LT = { name: "CountUp", props: { start: { type: Number, required: !1, default: 0 }, end: { type: Number, required: !0 }, decimals: { type: Number, required: !1, default: 0 }, duration: { type: Number, required: !1, default: 2 }, options: { type: Object, required: !1, default() {
      return {};
    } }, callback: { type: Function, required: !1, default: () => {
    } } }, data() {
      return { CountUp: null };
    }, watch: { end(t) {
      this.CountUp && this.CountUp.update && this.CountUp.update(t);
    } }, mounted() {
      this.init();
    }, methods: { init() {
      this.CountUp || (this.CountUp = new FT(this.$el, this.start, this.end, this.decimals, this.duration, this.options), this.CountUp.start(() => {
        this.callback(this.CountUp);
      }));
    }, destroy() {
      this.CountUp = null;
    } }, beforeUnmounted() {
      this.destroy();
    }, start(t) {
      this.CountUp && this.CountUp.start && this.CountUp.start(() => {
        t && t(this.CountUp);
      });
    }, pauseResume() {
      this.CountUp && this.CountUp.pauseResume && this.CountUp.pauseResume();
    }, reset() {
      this.CountUp && this.CountUp.reset && this.CountUp.reset();
    }, update(t) {
      this.CountUp && this.CountUp.update && this.CountUp.update(t);
    } }, zT = { class: "ivu-count-up" };
    function RT(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", zT);
    }
    var Mg = f(LT, [["render", RT]]), Ei = {}, Ag = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, Cs = /\d\d?/, jT = /\d{3}/, HT = /\d{4}/, cc = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, Fg = function() {
    };
    function Lg(t, r) {
      for (var o = [], C = 0, g = t.length; C < g; C++)
        o.push(t[C].substr(0, r));
      return o;
    }
    function zg(t) {
      return function(r, o, C) {
        var g = C[t].indexOf(o.charAt(0).toUpperCase() + o.substr(1).toLowerCase());
        ~g && (r.month = g);
      };
    }
    function Mi(t, r) {
      for (t = String(t), r = r || 2; t.length < r; )
        t = "0" + t;
      return t;
    }
    var Rg = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], jg = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], UT = Lg(jg, 3), WT = Lg(Rg, 3);
    Ei.i18n = { dayNamesShort: WT, dayNames: Rg, monthNamesShort: UT, monthNames: jg, amPm: ["am", "pm"], DoFn: function(t) {
      return t + ["th", "st", "nd", "rd"][t % 10 > 3 ? 0 : (t - t % 10 !== 10) * t % 10];
    } };
    var Hg = { D: function(t) {
      return t.getDay();
    }, DD: function(t) {
      return Mi(t.getDay());
    }, Do: function(t, r) {
      return r.DoFn(t.getDate());
    }, d: function(t) {
      return t.getDate();
    }, dd: function(t) {
      return Mi(t.getDate());
    }, ddd: function(t, r) {
      return r.dayNamesShort[t.getDay()];
    }, dddd: function(t, r) {
      return r.dayNames[t.getDay()];
    }, M: function(t) {
      return t.getMonth() + 1;
    }, MM: function(t) {
      return Mi(t.getMonth() + 1);
    }, MMM: function(t, r) {
      return r.monthNamesShort[t.getMonth()];
    }, MMMM: function(t, r) {
      return r.monthNames[t.getMonth()];
    }, yy: function(t) {
      return String(t.getFullYear()).substr(2);
    }, yyyy: function(t) {
      return t.getFullYear();
    }, h: function(t) {
      return t.getHours() % 12 || 12;
    }, hh: function(t) {
      return Mi(t.getHours() % 12 || 12);
    }, H: function(t) {
      return t.getHours();
    }, HH: function(t) {
      return Mi(t.getHours());
    }, m: function(t) {
      return t.getMinutes();
    }, mm: function(t) {
      return Mi(t.getMinutes());
    }, s: function(t) {
      return t.getSeconds();
    }, ss: function(t) {
      return Mi(t.getSeconds());
    }, S: function(t) {
      return Math.round(t.getMilliseconds() / 100);
    }, SS: function(t) {
      return Mi(Math.round(t.getMilliseconds() / 10), 2);
    }, SSS: function(t) {
      return Mi(t.getMilliseconds(), 3);
    }, a: function(t, r) {
      return t.getHours() < 12 ? r.amPm[0] : r.amPm[1];
    }, A: function(t, r) {
      return t.getHours() < 12 ? r.amPm[0].toUpperCase() : r.amPm[1].toUpperCase();
    }, ZZ: function(t) {
      var r = t.getTimezoneOffset();
      return (r > 0 ? "-" : "+") + Mi(Math.floor(Math.abs(r) / 60) * 100 + Math.abs(r) % 60, 4);
    } }, Zt = { d: [Cs, function(t, r) {
      t.day = r;
    }], M: [Cs, function(t, r) {
      t.month = r - 1;
    }], yy: [Cs, function(t, r) {
      var o = /* @__PURE__ */ new Date(), C = +("" + o.getFullYear()).substr(0, 2);
      t.year = "" + (r > 68 ? C - 1 : C) + r;
    }], h: [Cs, function(t, r) {
      t.hour = r;
    }], m: [Cs, function(t, r) {
      t.minute = r;
    }], s: [Cs, function(t, r) {
      t.second = r;
    }], yyyy: [HT, function(t, r) {
      t.year = r;
    }], S: [/\d/, function(t, r) {
      t.millisecond = r * 100;
    }], SS: [/\d{2}/, function(t, r) {
      t.millisecond = r * 10;
    }], SSS: [jT, function(t, r) {
      t.millisecond = r;
    }], D: [Cs, Fg], ddd: [cc, Fg], MMM: [cc, zg("monthNamesShort")], MMMM: [cc, zg("monthNames")], a: [cc, function(t, r, o) {
      var C = r.toLowerCase();
      C === o.amPm[0] ? t.isPm = !1 : C === o.amPm[1] && (t.isPm = !0);
    }], ZZ: [/[\+\-]\d\d:?\d\d/, function(t, r) {
      var o = (r + "").match(/([\+\-]|\d\d)/gi), C;
      o && (C = +(o[1] * 60) + parseInt(o[2], 10), t.timezoneOffset = o[0] === "+" ? C : -C);
    }] };
    Zt.DD = Zt.DD, Zt.dddd = Zt.ddd, Zt.Do = Zt.dd = Zt.d, Zt.mm = Zt.m, Zt.hh = Zt.H = Zt.HH = Zt.h, Zt.MM = Zt.M, Zt.ss = Zt.s, Zt.A = Zt.a, Ei.masks = { default: "ddd MMM dd yyyy HH:mm:ss", shortDate: "M/D/yy", mediumDate: "MMM d, yyyy", longDate: "MMMM d, yyyy", fullDate: "dddd, MMMM d, yyyy", shortTime: "HH:mm", mediumTime: "HH:mm:ss", longTime: "HH:mm:ss.SSS" }, Ei.format = function(t, r, o) {
      var C = o || Ei.i18n;
      if (typeof t == "number" && (t = new Date(t)), Object.prototype.toString.call(t) !== "[object Date]" || isNaN(t.getTime()))
        throw new Error("Invalid Date in fecha.format");
      return r = Ei.masks[r] || r || Ei.masks.default, r.replace(Ag, function(g) {
        return g in Hg ? Hg[g](t, C) : g.slice(1, g.length - 1);
      });
    }, Ei.parse = function(t, r, o) {
      var C = o || Ei.i18n;
      if (typeof r != "string")
        throw new Error("Invalid format in fecha.parse");
      if (r = Ei.masks[r] || r, t.length > 1e3)
        return !1;
      var g = !0, a = {};
      if (r.replace(Ag, function(P) {
        if (Zt[P]) {
          var N = Zt[P], B = t.search(N[0]);
          ~B ? t.replace(N[0], function(H) {
            return N[1](a, H, C), t = t.substr(B + H.length), H;
          }) : g = !1;
        }
        return Zt[P] ? "" : P.slice(1, P.length - 1);
      }), !g)
        return !1;
      var x = /* @__PURE__ */ new Date();
      a.isPm === !0 && a.hour != null && +a.hour != 12 ? a.hour = +a.hour + 12 : a.isPm === !1 && +a.hour == 12 && (a.hour = 0);
      var O;
      return a.timezoneOffset != null ? (a.minute = +(a.minute || 0) - +a.timezoneOffset, O = new Date(Date.UTC(a.year || x.getFullYear(), a.month || 0, a.day || 1, a.hour || 0, a.minute || 0, a.second || 0, a.millisecond || 0))) : O = new Date(a.year || x.getFullYear(), a.month || 0, a.day || 1, a.hour || 0, a.minute || 0, a.second || 0, a.millisecond || 0), O;
    };
    const qh = function(t) {
      let r = new Date(t);
      return isNaN(r.getTime()) && typeof t == "string" && (r = t.split("-").map(Number), r[1] += 1, r = new Date(...r)), isNaN(r.getTime()) ? null : r;
    }, Rn = function(t) {
      const r = new Date(t);
      return r.setHours(0, 0, 0, 0), r.getTime();
    }, YT = (t, r, o) => {
      if (!r || !o)
        return !1;
      const [C, g] = [r, o].sort();
      return t >= C && t <= g;
    }, ha = function(t, r) {
      return t = qh(t), t ? Ei.format(t, r || "yyyy-MM-dd") : "";
    }, uc = function(t, r) {
      return Ei.parse(t, r || "yyyy-MM-dd");
    }, Ug = function(t, r) {
      return new Date(t, r + 1, 0).getDate();
    }, Wg = function(t, r) {
      const o = new Date(t), C = o.getMonth() + r, g = Ug(o.getFullYear(), C);
      return g < o.getDate() && o.setDate(g), o.setMonth(C), o;
    }, Ai = function() {
      const t = /* @__PURE__ */ new Date();
      return t.setHours(0), t.setMinutes(0), t.setSeconds(0), t;
    }, Jh = function() {
      const t = { yyyy: (o) => o.getFullYear(), m: (o) => o.getMonth() + 1, mm: (o) => ("0" + (o.getMonth() + 1)).slice(-2), mmm: (o, C) => o.toLocaleDateString(C, { month: "long" }).slice(0, 3), Mmm: (o, C) => {
        const g = o.toLocaleDateString(C, { month: "long" });
        return (g[0].toUpperCase() + g.slice(1).toLowerCase()).slice(0, 3);
      }, mmmm: (o, C) => o.toLocaleDateString(C, { month: "long" }), Mmmm: (o, C) => {
        const g = o.toLocaleDateString(C, { month: "long" });
        return g[0].toUpperCase() + g.slice(1).toLowerCase();
      } }, r = new RegExp(["yyyy", "Mmmm", "mmmm", "Mmm", "mmm", "mm", "m"].join("|"), "g");
      return function(o, C, g) {
        const a = /(\[[^\]]+\])([^\[\]]+)(\[[^\]]+\])/, x = C.match(a).slice(1), O = x[1], P = [x[0], x[2]].map((N) => ({ label: N.replace(/\[[^\]]+\]/, (B) => B.slice(1, -1).replace(r, (H) => t[H](g, o))), type: N.indexOf("yy") != -1 ? "year" : "month" }));
        return { separator: O, labels: P };
      };
    }(), Yg = { date: "yyyy-MM-dd", month: "yyyy-MM", year: "yyyy", datetime: "yyyy-MM-dd HH:mm:ss", time: "HH:mm:ss", timerange: "HH:mm:ss", daterange: "yyyy-MM-dd", datetimerange: "yyyy-MM-dd HH:mm:ss" }, da = function(t, r) {
      return ha(t, r);
    }, fa = function(t, r) {
      return uc(t, r);
    }, Qh = function(t, r, o) {
      if (Array.isArray(t) && t.length === 2) {
        const C = t[0], g = t[1];
        if (C && g)
          return ha(C, r) + o + ha(g, r);
      } else if (!Array.isArray(t) && t instanceof Date)
        return ha(t, r);
      return "";
    }, Zh = function(t, r, o) {
      const C = Array.isArray(t) ? t : t.split(o);
      if (C.length === 2) {
        const g = C[0], a = C[1];
        return [g instanceof Date ? g : uc(g, r), a instanceof Date ? a : uc(a, r)];
      }
      return [];
    }, lo = { default: { formatter(t) {
      return t ? "" + t : "";
    }, parser(t) {
      return t === void 0 || t === "" ? null : t;
    } }, date: { formatter: da, parser: fa }, datetime: { formatter: da, parser: fa }, daterange: { formatter: Qh, parser: Zh }, datetimerange: { formatter: Qh, parser: Zh }, timerange: { formatter: Qh, parser: Zh }, time: { formatter: da, parser: fa }, month: { formatter: da, parser: fa }, year: { formatter: da, parser: fa }, multiple: { formatter: (t, r) => t.filter(Boolean).map((o) => ha(o, r)).join(","), parser: (t, r) => (typeof t == "string" ? t.split(",") : t).map((o) => o instanceof Date ? o : (typeof o == "string" ? o = o.trim() : typeof o != "number" && !o && (o = ""), uc(o, r))) }, number: { formatter(t) {
      return t ? "" + t : "";
    }, parser(t) {
      let r = Number(t);
      return isNaN(t) ? null : r;
    } } }, hc = "ivu-date-picker", KT = "ivu-picker", GT = (t) => t.reduce((r, o) => r && !o || typeof o == "string" && o.trim() === "", !0), XT = { 40: "up", 39: "right", 38: "down", 37: "left" }, co = (t, r, o) => {
      if (t === "left")
        return r * -1;
      if (t === "right")
        return r * 1;
      if (t === "up")
        return o * 1;
      if (t === "down")
        return o * -1;
    }, qT = (t) => {
      const r = "ivu-date-picker-btn-pulse";
      t.classList.add(r), setTimeout(() => t.classList.remove(r), 200);
    }, ed = (t) => t ? [t.getHours(), t.getMinutes(), t.getSeconds()] : [0, 0, 0], JT = { mixins: [nn, kr], components: { iInput: di, Drop: er, Icon: G }, directives: { clickOutside: Dh }, emits: ["on-clickoutside", "on-clear", "on-change", "on-ok", "on-open-change", "update:modelValue"], provide() {
      return { PickerInstance: this };
    }, props: { format: { type: String }, readonly: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, editable: { type: Boolean, default: !0 }, clearable: { type: Boolean, default: !0 }, confirm: { type: Boolean, default: !1 }, open: { type: Boolean, default: null }, multiple: { type: Boolean, default: !1 }, timePickerOptions: { type: Object, default: () => ({}) }, splitPanels: { type: Boolean, default: !1 }, showWeekNumbers: { type: Boolean, default: !1 }, startDate: { type: Date }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, placeholder: { type: String, default: "" }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom-start" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, name: { type: String }, elementId: { type: String }, steps: { type: Array, default: () => [] }, modelValue: { type: [Date, String, Array] }, options: { type: Object, default: () => ({}) }, separator: { type: String, default: " - " }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !0;
    } }, transferClassName: { type: String }, eventsEnabled: { type: Boolean, default: !1 } }, data() {
      const t = this.type.includes("range"), r = t ? [null, null] : [null], o = GT((t ? this.modelValue : [this.modelValue]) || []) ? r : this.parseDate(this.modelValue), C = o.map(ed);
      return { prefixCls: hc, showClose: !1, visible: !1, internalValue: o, disableClickOutSide: !1, disableCloseUnderTransfer: !1, selectionMode: this.onSelectionModeChange(this.type), forceInputRerender: 1, isFocused: !1, focusedDate: o[0] || this.startDate || /* @__PURE__ */ new Date(), focusedTime: { column: 0, picker: 0, time: C, active: !1 }, internalFocus: !1, isValueNull: !1, timeSpinnerList: [], panelTableList: [] };
    }, computed: { wrapperClasses() {
      return [hc, { [hc + "-focused"]: this.isFocused }];
    }, publicVModelValue() {
      if (this.multiple)
        return this.internalValue.slice();
      {
        const t = this.type.includes("range");
        let r = this.internalValue.map((o) => o instanceof Date ? new Date(o) : o || "");
        return this.type.match(/^time/) && (r = r.map(this.formatDate)), t || this.multiple ? r : r[0];
      }
    }, publicStringValue() {
      const { formatDate: t, publicVModelValue: r, type: o } = this;
      return o.match(/^time/) ? r : this.multiple ? t(r) : Array.isArray(r) ? r.map(t) : t(r);
    }, opened() {
      return this.open === null ? this.visible : this.open;
    }, transition() {
      return this.placement.match(/^bottom/) ? "slide-up" : "slide-down";
    }, visualValue() {
      return this.formatDate(this.internalValue);
    }, isConfirm() {
      return this.confirm || this.type === "datetime" || this.type === "datetimerange" || this.multiple;
    }, arrowType() {
      const t = this.globalConfig;
      let r = "";
      if (this.type === "time" || this.type === "timerange")
        r = "ios-time-outline", t && (t.timePicker.customIcon ? r = "" : t.timePicker.icon && (r = t.timePicker.icon));
      else {
        const o = this.globalConfig;
        r = "ios-calendar-outline", o && (o.datePicker.customIcon ? r = "" : o.datePicker.icon && (r = o.datePicker.icon));
      }
      return this.showClose && (r = "ios-close-circle"), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return this.showClose || (this.type === "time" || this.type === "timerange" ? t && t.timePicker.customIcon && (r = t.timePicker.customIcon) : t && t.datePicker.customIcon && (r = t.datePicker.customIcon)), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return this.showClose || (this.type === "time" || this.type === "timerange" ? t && t.timePicker.iconSize && (r = t.timePicker.iconSize) : t && t.datePicker.iconSize && (r = t.datePicker.iconSize)), r;
    }, dropdownCls() {
      return { [hc + "-transfer"]: this.transfer, [this.transferClassName]: this.transferClassName };
    } }, methods: { onSelectionModeChange(t) {
      return t.match(/^date/) && (t = "date"), this.selectionMode = z(t, ["year", "month", "date", "time"]) && t, this.selectionMode;
    }, handleTransferClick() {
      this.transfer && (this.disableCloseUnderTransfer = !0);
    }, handleClose(t) {
      if (this.disableCloseUnderTransfer)
        return this.disableCloseUnderTransfer = !1, !1;
      if (t && t.type === "mousedown" && this.visible) {
        t.preventDefault(), t.stopPropagation();
        return;
      }
      if (this.visible) {
        const r = this.$refs.pickerPanel && this.$refs.pickerPanel.$el;
        if (t && r && r.contains(t.target))
          return;
        this.visible = !1, t && t.preventDefault(), t && t.stopPropagation(), this.$emit("on-clickoutside", t);
        return;
      }
      this.isFocused = !1, this.disableClickOutSide = !1;
    }, handleFocus(t) {
      this.readonly || (this.isFocused = !0, !(t && t.type === "focus") && (this.itemDisabled || (this.visible = !0)));
    }, handleBlur(t) {
      if (this.internalFocus) {
        this.internalFocus = !1;
        return;
      }
      if (this.visible) {
        t.preventDefault();
        return;
      }
      this.isFocused = !1, this.onSelectionModeChange(this.type), this.internalValue = this.internalValue.slice(), this.reset(), this.$refs.pickerPanel.onToggleVisibility(!1);
    }, handleKeydown(t) {
      const r = t.keyCode;
      if (r === 9)
        if (this.visible)
          if (t.stopPropagation(), t.preventDefault(), this.isConfirm) {
            const C = `.${KT}-confirm > *`, g = this.$refs.drop.$el.querySelectorAll(C);
            this.internalFocus = !0, [...g][t.shiftKey ? "pop" : "shift"]().focus();
          } else
            this.handleClose();
        else
          this.focused = !1;
      const o = [37, 38, 39, 40];
      if (!this.visible && o.includes(r)) {
        this.visible = !0;
        return;
      }
      if (r === 27 && this.visible && (t.stopPropagation(), this.handleClose()), r === 13) {
        const C = this.timeSpinnerList.map((g) => g.timeSpinner);
        if (C.length > 0) {
          const g = C[0].showSeconds ? 3 : 2, a = Math.floor(this.focusedTime.column / g), x = this.focusedTime.time[a];
          C[a].chooseValue(x);
          return;
        }
        if (this.type.match(/range/))
          this.$refs.pickerPanel.handleRangePick(this.focusedDate, "date");
        else {
          const g = this.panelTableList.map((x) => x.panelTable), a = (x) => {
            const O = ["year", "month", "date"].indexOf(this.type) + 1;
            return [x.getFullYear(), x.getMonth(), x.getDate()].slice(0, O).join("-");
          };
          g.find(({ cells: x }) => x.find(({ date: O, disabled: P }) => a(O) === a(this.focusedDate) && !P)) && this.onPick(this.focusedDate, !1, "date");
        }
      }
      !o.includes(r) || (this.focusedTime.active && t.preventDefault(), this.navigateDatePanel(XT[r], t.shiftKey));
    }, reset() {
      this.$refs.pickerPanel.reset && this.$refs.pickerPanel.reset();
    }, navigateTimePanel(t) {
      this.focusedTime.active = !0;
      const r = t.match(/left|right/), o = t.match(/up|down/), C = this.timeSpinnerList.map((N) => N.timeSpinner), g = (C[0].showSeconds ? 3 : 2) * C.length, a = ((N) => (N + (r ? t === "left" ? -1 : 1 : 0) + g) % g)(this.focusedTime.column), x = g / C.length, O = Math.floor(a / x), P = a % x;
      if (r) {
        const N = this.internalValue.map(ed);
        this.focusedTime = v(p({}, this.focusedTime), { column: a, time: N }), C.forEach((B, H) => {
          H === O ? B.updateFocusedTime(P, N[O]) : B.updateFocusedTime(-1, B.focusedTime);
        });
      }
      if (o) {
        const N = t === "up" ? 1 : -1, B = ["hours", "minutes", "seconds"], H = C[O][`${B[P]}List`], oe = (H.findIndex(({ text: j }) => this.focusedTime.time[O][P] === j) + N + H.length) % H.length, se = H[oe].text, ee = this.focusedTime.time.map((j, pe) => (pe !== O || (j[P] = se), j));
        this.focusedTime = v(p({}, this.focusedTime), { time: ee }), C.forEach((j, pe) => {
          pe === O ? j.updateFocusedTime(P, ee[pe]) : j.updateFocusedTime(-1, j.focusedTime);
        });
      }
    }, navigateDatePanel(t, r) {
      const o = this.timeSpinnerList.map((a) => a.timeSpinner);
      if (o.length > 0) {
        this.navigateTimePanel(t, r, o);
        return;
      }
      if (r) {
        this.type === "year" ? this.focusedDate = new Date(this.focusedDate.getFullYear() + co(t, 0, 10), this.focusedDate.getMonth(), this.focusedDate.getDate()) : this.focusedDate = new Date(this.focusedDate.getFullYear() + co(t, 0, 1), this.focusedDate.getMonth() + co(t, 1, 0), this.focusedDate.getDate());
        const a = t.match(/left|down/) ? "prev" : "next", x = t.match(/up|down/) ? "-double" : "", O = this.$refs.drop.$el.querySelector(`.ivu-date-picker-${a}-btn-arrow${x}`);
        O && qT(O);
        return;
      }
      const C = this.focusedDate || this.internalValue && this.internalValue[0] || /* @__PURE__ */ new Date(), g = new Date(C);
      if (this.type.match(/^date/)) {
        const a = Ug(C.getFullYear(), C.getMonth()), x = C.getDate(), O = g.getDate() + co(t, 1, 7);
        O < 1 ? t.match(/left|right/) ? (g.setMonth(g.getMonth() + 1), g.setDate(O)) : g.setDate(x + Math.floor((a - x) / 7) * 7) : O > a ? t.match(/left|right/) ? (g.setMonth(g.getMonth() - 1), g.setDate(O)) : g.setDate(x % 7) : g.setDate(O);
      }
      this.type.match(/^month/) && g.setMonth(g.getMonth() + co(t, 1, 3)), this.type.match(/^year/) && g.setFullYear(g.getFullYear() + co(t, 1, 3)), this.focusedDate = g;
    }, handleInputChange(t) {
      const r = this.type.includes("range") || this.multiple, o = this.visualValue, C = t.target.value, g = this.parseDate(C), a = this.options && typeof this.options.disabledDate == "function" && this.options.disabledDate, x = r ? g : g[0], O = a && a(x), P = g.reduce((N, B) => N && B instanceof Date, !0);
      C !== o && !O && P ? (this.emitChange(this.type), this.internalValue = g) : this.forceInputRerender++;
    }, handleInputMouseenter() {
      this.readonly || this.itemDisabled || this.visualValue && this.clearable && (this.showClose = !0);
    }, handleInputMouseleave() {
      this.showClose = !1;
    }, handleIconClick(t) {
      this.showClose ? (t && t.stopPropagation(), this.handleClear()) : this.itemDisabled || this.handleFocus();
    }, handleClear() {
      this.visible = !1, this.internalValue = this.internalValue.map(() => null), this.$emit("on-clear"), this.handleFormItemChange("change", ""), this.emitChange(this.type), this.reset(), setTimeout(() => this.onSelectionModeChange(this.type), 500);
    }, emitChange(t) {
      e.nextTick(() => {
        this.$emit("on-change", this.publicStringValue, t), this.handleFormItemChange("change", this.publicStringValue);
      });
    }, parseDate(t) {
      const r = this.type.includes("range"), o = this.type, C = (lo[o] || lo.default).parser, g = this.format || Yg[o], a = lo.multiple.parser;
      if (t && o === "time" && !(t instanceof Date))
        t = C(t, g, this.separator);
      else if (this.multiple && t)
        t = a(t, g, this.separator);
      else if (r)
        if (!t)
          t = [null, null];
        else if (typeof t == "string")
          t = C(t, g, this.separator);
        else if (o === "timerange")
          t = C(t, g, this.separator).map((x) => x || "");
        else {
          const [x, O] = t;
          x instanceof Date && O instanceof Date ? t = t.map((P) => new Date(P)) : typeof x == "string" && typeof O == "string" ? t = C(t.join(this.separator), g, this.separator) : (!x || !O) && (t = [null, null]);
        }
      else
        typeof t == "string" && o.indexOf("time") !== 0 && (t = C(t, g) || null);
      return r || this.multiple ? t || [] : [t];
    }, formatDate(t) {
      const r = Yg[this.type];
      if (this.multiple)
        return lo.multiple.formatter(t, this.format || r, this.separator);
      {
        const { formatter: o } = lo[this.type] || lo.default;
        return o(t, this.format || r, this.separator);
      }
    }, onPick(t, r = !1, o) {
      if (this.multiple) {
        const C = t.getTime(), g = this.internalValue.findIndex((x) => x && x.getTime() === C), a = [...this.internalValue, t].filter(Boolean).map((x) => x.getTime()).filter((x, O, P) => P.indexOf(x) === O && O !== g);
        this.internalValue = a.map((x) => new Date(x));
      } else
        t = this.parseDate(t), this.internalValue = Array.isArray(t) ? t : [t];
      this.internalValue[0] && (this.focusedDate = this.internalValue[0]), this.focusedTime = v(p({}, this.focusedTime), { time: this.internalValue.map(ed) }), this.isConfirm || this.onSelectionModeChange(this.type), this.isConfirm || (this.visible = !!r), this.emitChange(o);
    }, onPickSuccess() {
      this.visible = !1, this.$emit("on-ok"), this.focus(), this.reset();
    }, focus() {
      this.$refs.input && this.$refs.input.focus();
    }, updatePopper() {
      this.$refs.drop.update();
    }, handleOnFocusInput() {
      this.focus();
    }, handleOnUpdatePopper() {
      this.updatePopper();
    } }, watch: { visible(t) {
      t === !1 && this.$refs.drop.destroy(), t && this.$refs.drop.update(), this.$emit("on-open-change", t);
    }, modelValue(t) {
      t === null && (this.isValueNull = !0), this.internalValue = this.parseDate(t);
    }, open(t) {
      this.visible = t === !0;
    }, type(t) {
      this.onSelectionModeChange(t);
    }, publicVModelValue(t, r) {
      const o = JSON.stringify(t), C = JSON.stringify(r);
      (o !== C || typeof t != typeof r) && (this.isValueNull ? (this.isValueNull = !1, this.$emit("update:modelValue", null)) : this.$emit("update:modelValue", t));
    } }, mounted() {
      this.open !== null && (this.visible = this.open);
    } };
    function QT(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("i-input"), P = e.resolveComponent("Drop"), N = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapperClasses) }, [e.createElementVNode("div", { ref: "reference", class: e.normalizeClass([g.prefixCls + "-rel"]) }, [e.renderSlot(t.$slots, "default", {}, () => [(e.openBlock(), e.createBlock(O, { key: g.forceInputRerender, "element-id": o.elementId, class: e.normalizeClass([g.prefixCls + "-editor"]), readonly: !o.editable || o.readonly, disabled: t.itemDisabled, size: o.size, placeholder: o.placeholder, "model-value": a.visualValue, name: o.name, ref: "input", onOnInputChange: a.handleInputChange, onOnFocus: a.handleFocus, onOnBlur: a.handleBlur, onClick: a.handleFocus, onKeydown: a.handleKeydown, onMouseenter: a.handleInputMouseenter, onMouseleave: a.handleInputMouseleave }, { suffix: e.withCtx(() => [e.createVNode(x, { onClick: a.handleIconClick, type: a.arrowType, custom: a.customArrowType, size: a.arrowSize }, null, 8, ["onClick", "type", "custom", "size"])]), _: 1 }, 8, ["element-id", "class", "readonly", "disabled", "size", "placeholder", "model-value", "name", "onOnInputChange", "onOnFocus", "onOnBlur", "onClick", "onKeydown", "onMouseenter", "onMouseleave"]))])], 2), e.createVNode(P, { ref: "drop", visible: a.opened, classes: a.dropdownCls, placement: o.placement, eventsEnabled: o.eventsEnabled, transfer: o.transfer, "transition-name": "transition-drop", onClick: a.handleTransferClick }, { default: e.withCtx(() => [e.createElementVNode("div", null, [(e.openBlock(), e.createBlock(e.resolveDynamicComponent(t.panel), e.mergeProps({ ref: "pickerPanel", visible: g.visible, showTime: t.type === "datetime" || t.type === "datetimerange", confirm: a.isConfirm, selectionMode: g.selectionMode, steps: o.steps, format: o.format, "model-value": g.internalValue, "start-date": o.startDate, "split-panels": o.splitPanels, "show-week-numbers": o.showWeekNumbers, "picker-type": t.type, multiple: o.multiple, "focused-date": g.focusedDate, "time-picker-options": o.timePickerOptions }, t.ownPickerProps, { onOnPick: a.onPick, onOnPickClear: a.handleClear, onOnPickSuccess: a.onPickSuccess, onOnPickClick: r[0] || (r[0] = (B) => g.disableClickOutSide = !0), onOnSelectionModeChange: a.onSelectionModeChange }), null, 16, ["visible", "showTime", "confirm", "selectionMode", "steps", "format", "model-value", "start-date", "split-panels", "show-week-numbers", "picker-type", "multiple", "focused-date", "time-picker-options", "onOnPick", "onOnPickClear", "onOnPickSuccess", "onOnSelectionModeChange"]))])]), _: 1 }, 8, ["visible", "classes", "placement", "eventsEnabled", "transfer", "onClick"])], 2)), [[N, a.handleClose, o.capture, { mousedown: !0 }], [N, a.handleClose, o.capture, { touchstart: !0 }], [N, a.handleClose, o.capture]]);
    }
    var Kg = f(JT, [["render", QT]]), Gg = 1e3 * 60 * 60 * 24;
    function Xg(t, r) {
      return new Date(t, r + 1, 0).getDate();
    }
    function qg(t, r, o) {
      return r === 0 && o > 50 ? t - 1 : r === 11 && o < 10 ? t + 1 : t;
    }
    function Jg(t, r, o, C) {
      r > 11 && (r = 0, t++);
      var g = new Date(t, r, o);
      C && g.setDate(g.getDate() + 4 - (g.getDay() || 7));
      var a = C ? g.getFullYear() : t, x = new Date(a, 0, 1), O = 1 + Math.round((g - x) / Gg);
      C || (O += x.getDay());
      var P = Math.ceil(O / 7);
      if (!C) {
        var N = new Date(t, r, o), B = new Date(t + 1, 0, 1), H = B.getDay();
        N.getTime() >= B.getTime() - Gg * H && (P = 1);
      }
      return P;
    }
    function ZT(t, r, o) {
      for (var C = this.lang || "en", g = this.onlyDays, a = typeof this.weekStart > "u" ? 1 : this.weekStart, x = a === 1, O = [], P = new Date(t, r, 1), N = P.getDay() || (x ? 7 : 0), B = a - N, H = Jg(t, r, 1, x), oe = Xg(t, r), se = Xg(t, r - 1), ee, j, pe, at = qg(t, r, H), Qe = { month: r, year: t, daysInMonth: oe }, tt = 0; tt < 7; tt++) {
        pe = B;
        for (var Ee = 0; Ee < 8; Ee++) {
          tt > 0 && Ee > 0 && B++, B > oe || B < 1 ? (j = B > oe ? B - oe : se + B, ee = B > oe ? r + 1 : r - 1) : (j = B, ee = r);
          var ye = function() {
            return Ee === 0 ? "weekLabel" : tt === 0 ? "dayLabel" : B < 1 ? "prevMonth" : B > oe ? "nextMonth" : "monthDay";
          }(), ze = pe !== B && tt > 0, Oe = { desc: ze ? j : H, week: H, type: ye, format: x ? "ISO 8601" : "US", date: ze ? new Date(Date.UTC(t, ee, j)) : !1, year: at, index: O.length };
          o && (typeof o == "function" ? Oe = o.call(Qe, Oe, C) : o.forEach(function(lt) {
            Oe = lt.call(Qe, Oe, C);
          })), g && ze ? O.push(Oe) : g || O.push(Oe);
        }
        tt > 0 && (H = Jg(t, ee, j + 1, x)), at = qg(t, r, H);
      }
      return Qe.cells = O, Qe;
    }
    var eO = function(t) {
      return ZT.bind(t);
    }, tO = { weekPlaceholder: "", columnNames: { en: { 0: "w", 1: "monday", 2: "tuesday", 3: "wednesday", 4: "thursday", 5: "friday", 6: "saturday", 7: "sunday" }, sv: { 0: "v", 1: "måndag", 2: "tisdag", 3: "onsdag", 4: "torsdag", 5: "fredag", 6: "lördag", 7: "söndag" }, pt: { 0: "s", 1: "segunda", 2: "terça", 3: "quarta", 4: "quinta", 5: "sexta", 6: "sábado", 7: "domingo" } }, monthNames: { en: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], sv: ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"], pt: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"] }, classes: { dayLabel: "day-of-week", weekLabel: "week-number", prevMonth: "inactive", nextMonth: "inactive", monthDay: "day-in-month" } }, Fi = tO;
    function nO(t) {
      return t == null ? !1 : t.constructor === Array || t.constructor === Object;
    }
    function Qg(t, r) {
      for (var o in t)
        r[o] ? nO(t[o]) && Qg(t[o], r[o]) : r[o] = t[o];
    }
    function Zg(t, r) {
      var o = [Fi.classes[t.type]];
      return t.class ? t.class = (typeof t.class == "string" ? [t.class] : t.class).concat(o) : t.class = o, t.type.indexOf("Label") > 0 && (t.index == 0 && Fi.weekPlaceholder ? t.desc = Fi.weekPlaceholder : t.index < 8 ? t.desc = Fi.columnNames[r][t.index] : t.index % 8 == 0 && (t.desc = t.week)), t.date && (t.monthName = Fi.monthNames[r][t.date.getMonth()]), this.monthName || (this.monthName = Fi.monthNames[r][this.month]), this.labels || (this.labels = { monthNames: Fi.monthNames[r], columnNames: Fi.columnNames[r], classes: Fi.classes }), t;
    }
    Zg.setLabels = function(t) {
      Qg(t, Fi);
    };
    var iO = Zg, rO = { Generator: eO, addLabels: iO }, td = { name: "PanelTable", emits: ["on-pick", "on-pick-click", "on-change-range"], inject: ["PickerInstance"], props: { tableDate: { type: Date, required: !0 }, disabledDate: { type: Function }, selectionMode: { type: String, required: !0 }, modelValue: { type: Array, required: !0 }, rangeState: { type: Object, default: () => ({ from: null, to: null, selecting: !1 }) }, focusedDate: { type: Date, required: !0 } }, data() {
      return { id: be(6) };
    }, computed: { dates() {
      const { selectionMode: t, modelValue: r, rangeState: o } = this;
      return t === "range" && o.selecting ? [o.from] : r;
    } }, methods: { handleClick(t, r) {
      if (r.stopPropagation(), t.disabled || t.type === "weekLabel")
        return;
      const o = new Date(Rn(t.date));
      this.$emit("on-pick", o), this.$emit("on-pick-click");
    }, handleMouseMove(t) {
      if (!this.rangeState.selecting || t.disabled)
        return;
      const r = t.date;
      this.$emit("on-change-range", r);
    }, addPanelTable() {
      const t = this.PickerInstance;
      t.panelTableList || (t.panelTableList = []), t.panelTableList.push({ id: this.id, panelTable: this });
    }, removePanelTable() {
      const t = this.PickerInstance;
      if (t.panelTableList && t.panelTableList.length) {
        const r = t.panelTableList.findIndex((o) => o.id === this.id);
        t.panelTableList.splice(r, 1);
      }
    } }, mounted() {
      this.addPanelTable();
    }, beforeUnmount() {
      this.removePanelTable();
    } }, Gt = "ivu-date-picker-cells";
    const sO = { mixins: [Kt, td], props: { showWeekNumbers: { type: Boolean, default: !1 } }, computed: { classes() {
      return [`${Gt}`, { [`${Gt}-show-week-numbers`]: this.showWeekNumbers }];
    }, calendar() {
      const t = Number(this.t("i.datepicker.weekStartDay"));
      return new rO.Generator({ onlyDays: !this.showWeekNumbers, weekStart: t });
    }, headerDays() {
      const t = Number(this.t("i.datepicker.weekStartDay")), r = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"].map((C) => this.t("i.datepicker.weeks." + C)), o = r.splice(t, 7 - t).concat(r.splice(0, t));
      return this.showWeekNumbers ? [""].concat(o) : o;
    }, cells() {
      const t = this.tableDate.getFullYear(), r = this.tableDate.getMonth(), o = Rn(/* @__PURE__ */ new Date()), C = this.dates.filter(Boolean).map(Rn), [g, a] = this.dates.map(Rn), x = this.rangeState.from && Rn(this.rangeState.from), O = this.rangeState.to && Rn(this.rangeState.to), P = this.selectionMode === "range", N = typeof this.disabledDate == "function" && this.disabledDate;
      return this.calendar(t, r, (B) => {
        B.date instanceof Date && B.date.setTime(B.date.getTime() + B.date.getTimezoneOffset() * 6e4 + 480 * 60 * 1e3);
        const H = B.date && Rn(B.date), oe = B.date && r === B.date.getMonth();
        return v(p({}, B), { type: H === o ? "today" : B.type, selected: oe && C.includes(H), disabled: B.date && N && N(new Date(H)), range: oe && P && YT(H, x, O), start: oe && P && H === g, end: oe && P && H === a });
      }).cells.slice(this.showWeekNumbers ? 8 : 0);
    } }, methods: { getCellCls(t) {
      return [`${Gt}-cell`, { [`${Gt}-cell-selected`]: t.selected || t.start || t.end, [`${Gt}-cell-disabled`]: t.disabled, [`${Gt}-cell-today`]: t.type === "today", [`${Gt}-cell-prev-month`]: t.type === "prevMonth", [`${Gt}-cell-next-month`]: t.type === "nextMonth", [`${Gt}-cell-week-label`]: t.type === "weekLabel", [`${Gt}-cell-range`]: t.range && !t.start && !t.end, [`${Gt}-focused`]: Rn(t.date) === Rn(this.focusedDate) }];
    } } }, oO = { class: "ivu-date-picker-cells-header" }, aO = ["onClick", "onMouseenter"];
    function lO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", oO, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.headerDays, (x) => (e.openBlock(), e.createElementBlock("span", { key: x }, e.toDisplayString(x), 1))), 128))]), (e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.cells, (x, O) => (e.openBlock(), e.createElementBlock("span", { key: String(x.date) + O, class: e.normalizeClass(a.getCellCls(x)), onClick: (P) => t.handleClick(x, P), onMouseenter: (P) => t.handleMouseMove(x) }, [e.createElementVNode("em", null, e.toDisplayString(x.desc), 1)], 42, aO))), 128))], 2);
    }
    var e0 = f(sO, [["render", lO]]);
    const cO = { mixins: [td], props: {}, computed: { classes() {
      return [`${Gt}`, `${Gt}-year`];
    }, startYear() {
      return Math.floor(this.tableDate.getFullYear() / 10) * 10;
    }, cells() {
      let t = [];
      const r = { text: "", selected: !1, disabled: !1 }, o = this.dates.filter(Boolean).map((g) => Rn(new Date(g.getFullYear(), 0, 1))), C = Rn(new Date(this.focusedDate.getFullYear(), 0, 1));
      for (let g = 0; g < 10; g++) {
        const a = W(r);
        a.date = new Date(this.startYear + g, 0, 1), a.disabled = typeof this.disabledDate == "function" && this.disabledDate(a.date) && this.selectionMode === "year";
        const x = Rn(a.date);
        a.selected = o.includes(x), a.focused = x === C, t.push(a);
      }
      return t;
    } }, methods: { getCellCls(t) {
      return [`${Gt}-cell`, { [`${Gt}-cell-selected`]: t.selected, [`${Gt}-cell-disabled`]: t.disabled, [`${Gt}-cell-focused`]: t.focused, [`${Gt}-cell-range`]: t.range && !t.start && !t.end }];
    } } }, uO = ["onClick", "onMouseenter"];
    function hO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.cells, (x) => (e.openBlock(), e.createElementBlock("span", { class: e.normalizeClass(a.getCellCls(x)), key: x.date, onClick: (O) => t.handleClick(x, O), onMouseenter: (O) => t.handleMouseMove(x) }, [e.createElementVNode("em", null, e.toDisplayString(x.date.getFullYear()), 1)], 42, uO))), 128))], 2);
    }
    var t0 = f(cO, [["render", hO]]);
    const dO = { mixins: [Kt, td], props: {}, computed: { classes() {
      return [`${Gt}`, `${Gt}-month`];
    }, cells() {
      let t = [];
      const r = { text: "", selected: !1, disabled: !1 }, o = this.tableDate.getFullYear(), C = this.dates.filter(Boolean).map((a) => Rn(new Date(a.getFullYear(), a.getMonth(), 1))), g = Rn(new Date(this.focusedDate.getFullYear(), this.focusedDate.getMonth(), 1));
      for (let a = 0; a < 12; a++) {
        const x = W(r);
        x.date = new Date(o, a, 1), x.text = this.tCell(a + 1);
        const O = Rn(x.date);
        x.disabled = typeof this.disabledDate == "function" && this.disabledDate(x.date) && this.selectionMode === "month", x.selected = C.includes(O), x.focused = O === g, t.push(x);
      }
      return t;
    } }, methods: { getCellCls(t) {
      return [`${Gt}-cell`, { [`${Gt}-cell-selected`]: t.selected, [`${Gt}-cell-disabled`]: t.disabled, [`${Gt}-cell-focused`]: t.focused, [`${Gt}-cell-range`]: t.range && !t.start && !t.end }];
    }, tCell(t) {
      return this.t(`i.datepicker.months.m${t}`);
    } } }, fO = ["onClick", "onMouseenter"];
    function pO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.cells, (x) => (e.openBlock(), e.createElementBlock("span", { class: e.normalizeClass(a.getCellCls(x)), key: x.text, onClick: (O) => t.handleClick(x, O), onMouseenter: (O) => t.handleMouseMove(x) }, [e.createElementVNode("em", null, e.toDisplayString(x.text), 1)], 42, fO))), 128))], 2);
    }
    var n0 = f(dO, [["render", pO]]), dc = { props: { disabledHours: { type: Array, default() {
      return [];
    } }, disabledMinutes: { type: Array, default() {
      return [];
    } }, disabledSeconds: { type: Array, default() {
      return [];
    } }, hideDisabledOptions: { type: Boolean, default: !1 } } };
    const ws = "ivu-time-picker-cells", nd = ["hours", "minutes", "seconds"], mO = { name: "TimeSpinner", mixins: [dc], emits: ["on-change", "on-pick-click"], inject: ["PickerInstance"], props: { hours: { type: [Number, String], default: NaN }, minutes: { type: [Number, String], default: NaN }, seconds: { type: [Number, String], default: NaN }, showSeconds: { type: Boolean, default: !0 }, steps: { type: Array, default: () => [] } }, data() {
      return { spinerSteps: [1, 1, 1].map((t, r) => Math.abs(this.steps[r]) || t), prefixCls: ws, compiled: !1, focusedColumn: -1, focusedTime: [0, 0, 0], id: be(6) };
    }, computed: { classes() {
      return [`${ws}`, { [`${ws}-with-seconds`]: this.showSeconds }];
    }, hoursList() {
      let t = [];
      const r = this.spinerSteps[0], o = this.focusedColumn === 0 && this.focusedTime[0], C = { text: 0, selected: !1, disabled: !1, hide: !1 };
      for (let g = 0; g < 24; g += r) {
        const a = W(C);
        a.text = g, a.focused = g === o, this.disabledHours.length && this.disabledHours.indexOf(g) > -1 && (a.disabled = !0, this.hideDisabledOptions && (a.hide = !0)), this.hours === g && (a.selected = !0), t.push(a);
      }
      return t;
    }, minutesList() {
      let t = [];
      const r = this.spinerSteps[1], o = this.focusedColumn === 1 && this.focusedTime[1], C = { text: 0, selected: !1, disabled: !1, hide: !1 };
      for (let g = 0; g < 60; g += r) {
        const a = W(C);
        a.text = g, a.focused = g === o, this.disabledMinutes.length && this.disabledMinutes.indexOf(g) > -1 && (a.disabled = !0, this.hideDisabledOptions && (a.hide = !0)), this.minutes === g && (a.selected = !0), t.push(a);
      }
      return t;
    }, secondsList() {
      let t = [];
      const r = this.spinerSteps[2], o = this.focusedColumn === 2 && this.focusedTime[2], C = { text: 0, selected: !1, disabled: !1, hide: !1 };
      for (let g = 0; g < 60; g += r) {
        const a = W(C);
        a.text = g, a.focused = g === o, this.disabledSeconds.length && this.disabledSeconds.indexOf(g) > -1 && (a.disabled = !0, this.hideDisabledOptions && (a.hide = !0)), this.seconds === g && (a.selected = !0), t.push(a);
      }
      return t;
    } }, methods: { getCellCls(t) {
      return [`${ws}-cell`, { [`${ws}-cell-selected`]: t.selected, [`${ws}-cell-focused`]: t.focused, [`${ws}-cell-disabled`]: t.disabled }];
    }, chooseValue(t) {
      const r = nd.reduce((o, C, g) => {
        const a = t[g];
        return this[C] === a ? o : v(p({}, o), { [C]: a });
      }, {});
      Object.keys(r).length > 0 && this.emitChange(r);
    }, handleClick(t, r) {
      if (r.disabled)
        return;
      const o = { [t]: r.text };
      this.emitChange(o);
    }, emitChange(t) {
      this.$emit("on-change", t), this.$emit("on-pick-click");
    }, scroll(t, r) {
      const o = this.$refs[t].scrollTop, C = 24 * this.getScrollIndex(t, r);
      Y(this.$refs[t], o, C, 500);
    }, getScrollIndex(t, r) {
      const o = L(t), C = this[`disabled${o}`];
      if (C.length && this.hideDisabledOptions) {
        let g = 0;
        C.forEach((a) => a <= r ? g++ : ""), r -= g;
      }
      return r;
    }, updateScroll() {
      e.nextTick(() => {
        nd.forEach((t) => {
          this.$refs[t].scrollTop = 24 * this[`${t}List`].findIndex((r) => r.text == this[t]);
        });
      });
    }, formatTime(t) {
      return t < 10 ? "0" + t : t;
    }, updateFocusedTime(t, r) {
      this.focusedColumn = t, this.focusedTime = r.slice();
    }, addTimeSpinner() {
      const t = this.PickerInstance;
      t.timeSpinnerList || (t.timeSpinnerList = []), t.timeSpinnerList.push({ id: this.id, timeSpinner: this });
    }, removeTimeSpinner() {
      const t = this.PickerInstance;
      if (t.timeSpinnerList && t.timeSpinnerList.length) {
        const r = t.timeSpinnerList.findIndex((o) => o.id === this.id);
        t.timeSpinnerList.splice(r, 1);
      }
    } }, watch: { hours(t) {
      !this.compiled || this.scroll("hours", this.hoursList.findIndex((r) => r.text == t));
    }, minutes(t) {
      !this.compiled || this.scroll("minutes", this.minutesList.findIndex((r) => r.text == t));
    }, seconds(t) {
      !this.compiled || this.scroll("seconds", this.secondsList.findIndex((r) => r.text == t));
    }, focusedTime(t, r) {
      nd.forEach((o, C) => {
        if (t[C] === r[C] || typeof t[C] > "u")
          return;
        const g = this[`${o}List`].findIndex((a) => a.text === t[C]);
        this.scroll(o, g);
      });
    } }, mounted() {
      this.addTimeSpinner(), e.nextTick(() => this.compiled = !0);
    }, beforeUnmount() {
      this.removeTimeSpinner();
    } }, gO = ["onClick"], vO = ["onClick"], yO = ["onClick"];
    function bO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-list"]), ref: "hours" }, [e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-ul"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.hoursList, (x) => e.withDirectives((e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.getCellCls(x)), key: x.text, onClick: (O) => a.handleClick("hours", x) }, e.toDisplayString(a.formatTime(x.text)), 11, gO)), [[e.vShow, !x.hide]])), 128))], 2)], 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-list"]), ref: "minutes" }, [e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-ul"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.minutesList, (x) => e.withDirectives((e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.getCellCls(x)), key: x.text, onClick: (O) => a.handleClick("minutes", x) }, e.toDisplayString(a.formatTime(x.text)), 11, vO)), [[e.vShow, !x.hide]])), 128))], 2)], 2), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-list"]), ref: "seconds" }, [e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-ul"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.secondsList, (x) => e.withDirectives((e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.getCellCls(x)), key: x.text, onClick: (O) => a.handleClick("seconds", x) }, e.toDisplayString(a.formatTime(x.text)), 11, yO)), [[e.vShow, !x.hide]])), 128))], 2)], 2), [[e.vShow, o.showSeconds]])], 2);
    }
    var i0 = f(mO, [["render", bO]]);
    const r0 = "ivu-picker", CO = { mixins: [Kt], components: { iButton: zn }, emits: ["on-pick-clear", "on-pick-success", "on-pick-toggle-time"], inject: ["PickerInstance"], props: { showTime: { type: Boolean, default: !1 }, isTime: { type: Boolean, default: !1 }, timeDisabled: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: r0 };
    }, computed: { timeClasses() {
      return `${r0}-confirm-time`;
    }, labels() {
      const t = ["time", "clear", "ok"], r = [this.isTime ? "selectDate" : "selectTime", "clear", "ok"];
      return t.reduce((o, C, g) => (o[C] = this.t("i.datepicker." + r[g]), o), {});
    } }, methods: { handleClear() {
      this.$emit("on-pick-clear");
    }, handleSuccess() {
      this.$emit("on-pick-success");
    }, handleToggleTime() {
      this.timeDisabled || (this.$emit("on-pick-toggle-time"), this.PickerInstance.handleOnFocusInput(), this.PickerInstance.handleOnUpdatePopper());
    }, handleTab(t) {
      const r = [...this.$el.children][t.shiftKey ? "shift" : "pop"]();
      h && document.activeElement === r && (t.preventDefault(), t.stopPropagation(), this.PickerInstance.handleOnFocusInput());
    } } };
    function wO(t, r, o, C, g, a) {
      const x = e.resolveComponent("i-button");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls + "-confirm"]), onKeydownCapture: r[0] || (r[0] = e.withKeys((...O) => a.handleTab && a.handleTab(...O), ["tab"])) }, [o.showTime ? (e.openBlock(), e.createBlock(x, { key: 0, class: e.normalizeClass(a.timeClasses), size: "small", type: "text", disabled: o.timeDisabled, onClick: a.handleToggleTime }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.labels.time), 1)]), _: 1 }, 8, ["class", "disabled", "onClick"])) : e.createCommentVNode("", !0), e.createVNode(x, { size: "small", class: "ivu-picker-confirm-btn-cancel", onClick: a.handleClear, onKeydown: e.withKeys(a.handleClear, ["enter"]) }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.labels.clear), 1)]), _: 1 }, 8, ["onClick", "onKeydown"]), e.createVNode(x, { size: "small", type: "primary", onClick: a.handleSuccess, onKeydown: e.withKeys(a.handleSuccess, ["enter"]) }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.labels.ok), 1)]), _: 1 }, 8, ["onClick", "onKeydown"])], 34);
    }
    var fc = f(CO, [["render", wO]]);
    const kO = "ivu-picker-panel", s0 = "ivu-date-picker";
    var pc = { emits: ["on-pick-clear", "on-pick-success", "on-pick-click", "on-pick"], props: { confirm: { type: Boolean, default: !1 } }, methods: { iconBtnCls(t, r = "") {
      return [`${kO}-icon-btn`, `${s0}-${t}-btn`, `${s0}-${t}-btn-arrow${r}`];
    }, handleShortcutClick(t) {
      t.value && this.$emit("on-pick", t.value()), t.onClick && t.onClick(this);
    }, handlePickClear() {
      this.resetView(), this.$emit("on-pick-clear");
    }, handlePickSuccess() {
      this.resetView(), this.$emit("on-pick-success");
    }, handlePickClick() {
      this.$emit("on-pick-click");
    }, resetView() {
      setTimeout(() => this.currentView = this.selectionMode, 500);
    }, handleClear() {
      this.dates = this.dates.map(() => null), this.rangeState = {}, this.$emit("on-pick", this.dates), this.handleConfirm();
    }, handleConfirm(t, r) {
      this.$emit("on-pick", this.dates, t, r || this.type);
    }, onToggleVisibility(t) {
      const { timeSpinner: r, timeSpinnerEnd: o } = this.$refs;
      t && r && r.updateScroll(), t && o && o.updateScroll();
    } } };
    const SO = "ivu-picker-panel", EO = "ivu-time-picker", xO = (t) => t[0].toUpperCase() + t.slice(1), _O = (t, r, o, C) => {
      const g = new Date(t.getTime());
      return g.setHours(r), g.setMinutes(o), g.setSeconds(C), g;
    }, TO = (t, r, o) => o.indexOf(t) === r, o0 = () => !1, OO = { name: "TimePickerPanel", mixins: [pc, Kt, dc], components: { TimeSpinner: i0, Confirm: fc }, emits: ["on-pick"], props: { disabledDate: { type: Function, default: o0 }, steps: { type: Array, default: () => [] }, format: { type: String, default: "HH:mm:ss" }, modelValue: { type: Array, required: !0 } }, data() {
      return { prefixCls: SO, timePrefixCls: EO, date: this.modelValue[0] || Ai(), showDate: !1 };
    }, computed: { showSeconds() {
      return !!(this.format || "").match(/ss/);
    }, visibleDate() {
      const t = this.date, r = t.getMonth() + 1, o = this.t("i.datepicker.year"), C = this.t(`i.datepicker.month${r}`);
      return `${t.getFullYear()}${o} ${C}`;
    }, timeSlots() {
      return this.modelValue[0] ? ["getHours", "getMinutes", "getSeconds"].map((t) => this.date[t]()) : [];
    }, disabledHMS() {
      const t = ["disabledHours", "disabledMinutes", "disabledSeconds"];
      if (this.disabledDate === o0 || !this.modelValue[0])
        return t.reduce((r, o) => (r[o] = this[o], r), {});
      {
        const r = [24, 60, 60], o = ["Hours", "Minutes", "Seconds"].map((C) => this[`disabled${C}`]).map((C, g) => {
          const a = r[g], x = C;
          for (let O = 0; O < a; O += this.steps[g] || 1) {
            const P = this.timeSlots.map((B, H) => H === g ? O : B), N = _O(this.date, ...P);
            this.disabledDate(N, !0) && x.push(O);
          }
          return x.filter(TO);
        });
        return t.reduce((C, g, a) => (C[g] = o[a], C), {});
      }
    } }, watch: { modelValue(t) {
      let r = t[0] || Ai();
      r = new Date(r), this.date = r;
    } }, methods: { handleChange(t, r = !0) {
      const o = new Date(this.date);
      Object.keys(t).forEach((C) => o[`set${xO(C)}`](t[C])), r && this.$emit("on-pick", o, "time");
    } }, mounted() {
      this.$parent && this.$parent.$options.name === "DatePicker" && (this.showDate = !0);
    } };
    function DO(t, r, o, C, g, a) {
      const x = e.resolveComponent("time-spinner"), O = e.resolveComponent("Confirm");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls + "-body-wrapper"]), onMousedown: r[0] || (r[0] = e.withModifiers(() => {
      }, ["prevent"])) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]) }, [g.showDate ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.timePrefixCls + "-header"]) }, e.toDisplayString(a.visibleDate), 3)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [e.createVNode(x, { ref: "timeSpinner", "show-seconds": a.showSeconds, steps: o.steps, hours: a.timeSlots[0], minutes: a.timeSlots[1], seconds: a.timeSlots[2], "disabled-hours": a.disabledHMS.disabledHours, "disabled-minutes": a.disabledHMS.disabledMinutes, "disabled-seconds": a.disabledHMS.disabledSeconds, "hide-disabled-options": t.hideDisabledOptions, onOnChange: a.handleChange, onOnPickClick: t.handlePickClick }, null, 8, ["show-seconds", "steps", "hours", "minutes", "seconds", "disabled-hours", "disabled-minutes", "disabled-seconds", "hide-disabled-options", "onOnChange", "onOnPickClick"])], 2), t.confirm ? (e.openBlock(), e.createBlock(O, { key: 1, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess }, null, 8, ["onOnPickClear", "onOnPickSuccess"])) : e.createCommentVNode("", !0)], 2)], 34);
    }
    var a0 = f(OO, [["render", DO]]);
    const NO = { props: { datePanelLabel: Object, currentView: String, datePrefixCls: String } };
    function BO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", null, [o.datePanelLabel ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass([o.datePrefixCls + "-header-label"]), onClick: r[0] || (r[0] = (...x) => o.datePanelLabel.labels[0].handler && o.datePanelLabel.labels[0].handler(...x)) }, e.toDisplayString(o.datePanelLabel.labels[0].label), 3)), [[e.vShow, o.datePanelLabel.labels[0].type === "year" || o.currentView === "date"]]) : e.createCommentVNode("", !0), o.datePanelLabel && o.currentView === "date" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(o.datePanelLabel.separator), 1)], 64)) : e.createCommentVNode("", !0), o.datePanelLabel ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass([o.datePrefixCls + "-header-label"]), onClick: r[1] || (r[1] = (...x) => o.datePanelLabel.labels[1].handler && o.datePanelLabel.labels[1].handler(...x)) }, e.toDisplayString(o.datePanelLabel.labels[1].label), 3)), [[e.vShow, o.datePanelLabel.labels[1].type === "year" || o.currentView === "date"]]) : e.createCommentVNode("", !0)]);
    }
    var l0 = f(NO, [["render", BO]]), c0 = { props: { showTime: { type: Boolean, default: !1 }, format: { type: String, default: "yyyy-MM-dd" }, selectionMode: { type: String, validator(t) {
      return z(t, ["year", "month", "date", "time"]);
    }, default: "date" }, shortcuts: { type: Array, default: () => [] }, disabledDate: { type: Function, default: () => !1 }, modelValue: { type: Array, default: () => [Ai(), Ai()] }, timePickerOptions: { default: () => ({}), type: Object }, showWeekNumbers: { type: Boolean, default: !1 }, startDate: { type: Date }, pickerType: { type: String, require: !0 }, focusedDate: { type: Date, required: !0 } }, computed: { isTime() {
      return this.currentView === "time";
    } }, methods: { handleToggleTime() {
      this.currentView = this.currentView === "time" ? "date" : "time";
    } } };
    const id = "ivu-picker-panel", PO = "ivu-date-picker", VO = { name: "DatePickerPanel", mixins: [pc, Kt, c0], components: { Icon: G, DateTable: e0, YearTable: t0, MonthTable: n0, TimePicker: a0, Confirm: fc, datePanelLabel: l0 }, emits: ["on-selection-mode-change", "on-pick"], props: { multiple: { type: Boolean, default: !1 } }, data() {
      const { selectionMode: t, modelValue: r } = this, o = r.slice().sort();
      return { prefixCls: id, datePrefixCls: PO, currentView: t || "date", pickerTable: this.getTableType(t), dates: o, panelDate: this.startDate || o[0] || /* @__PURE__ */ new Date() };
    }, computed: { classes() {
      return [`${id}-body-wrapper`, { [`${id}-with-sidebar`]: this.shortcuts.length }];
    }, panelPickerHandlers() {
      return this.pickerTable === `${this.currentView}-table` ? this.handlePick : this.handlePreSelection;
    }, datePanelLabel() {
      const t = this.t("i.locale"), r = this.t("i.datepicker.datePanelLabel"), o = this.panelDate, { labels: C, separator: g } = Jh(t, r, o), a = (x) => () => this.pickerTable = this.getTableType(x);
      return { separator: g, labels: C.map((x) => (x.handler = a(x.type), x)) };
    }, timeDisabled() {
      return !this.dates[0];
    } }, watch: { modelValue(t) {
      this.dates = t;
      const r = this.multiple ? this.dates[this.dates.length - 1] : this.startDate || this.dates[0];
      this.panelDate = r || /* @__PURE__ */ new Date();
    }, currentView(t) {
      this.$emit("on-selection-mode-change", t), this.currentView === "time" && e.nextTick(() => {
        this.$refs.timePicker.$refs.timeSpinner.updateScroll();
      });
    }, selectionMode(t) {
      this.currentView = t, this.pickerTable = this.getTableType(t);
    }, focusedDate(t) {
      const r = t.getFullYear() !== this.panelDate.getFullYear(), o = r || t.getMonth() !== this.panelDate.getMonth();
      (r || o) && (this.multiple || (this.panelDate = t));
    } }, methods: { reset() {
      this.currentView = this.selectionMode, this.pickerTable = this.getTableType(this.currentView);
    }, changeYear(t) {
      this.selectionMode === "year" || this.pickerTable === "year-table" ? this.panelDate = new Date(this.panelDate.getFullYear() + t * 10, 0, 1) : this.panelDate = Wg(this.panelDate, t * 12);
    }, getTableType(t) {
      return t.match(/^time/) ? "time-picker" : `${t}-table`;
    }, changeMonth(t) {
      this.panelDate = Wg(this.panelDate, t);
    }, handlePreSelection(t) {
      this.panelDate = t, this.pickerTable === "year-table" ? this.pickerTable = "month-table" : this.pickerTable = this.getTableType(this.currentView);
    }, handlePick(t, r) {
      const { selectionMode: o, panelDate: C } = this;
      o === "year" ? t = new Date(t.getFullYear(), 0, 1) : o === "month" ? t = new Date(C.getFullYear(), t.getMonth(), 1) : t = new Date(t), this.dates = [t], this.$emit("on-pick", t, !1, r || o);
    } } }, $O = ["onClick"];
    function IO(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("date-panel-label"), P = e.resolveComponent("time-picker"), N = e.resolveComponent("Confirm");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onMousedown: r[4] || (r[4] = e.withModifiers(() => {
      }, ["prevent"])) }, [t.shortcuts.length ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-sidebar"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(t.shortcuts, (B) => (e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls + "-shortcut"]), key: B.text, onClick: (H) => t.handleShortcutClick(B) }, e.toDisplayString(B.text), 11, $O))), 128))], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]) }, [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.datePrefixCls + "-header"]) }, [e.createElementVNode("span", { class: e.normalizeClass(t.iconBtnCls("prev", "-double")), onClick: r[0] || (r[0] = (B) => a.changeYear(-1)) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2), g.pickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(t.iconBtnCls("prev")), onClick: r[1] || (r[1] = (B) => a.changeMonth(-1)) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0), e.createVNode(O, { "date-panel-label": a.datePanelLabel, "current-view": g.pickerTable.split("-").shift(), "date-prefix-cls": g.datePrefixCls }, null, 8, ["date-panel-label", "current-view", "date-prefix-cls"]), e.createElementVNode("span", { class: e.normalizeClass(t.iconBtnCls("next", "-double")), onClick: r[2] || (r[2] = (B) => a.changeYear(1)) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2), g.pickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass(t.iconBtnCls("next")), onClick: r[3] || (r[3] = (B) => a.changeMonth(1)) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0)], 2), [[e.vShow, g.currentView !== "time"]]), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [g.currentView !== "time" ? (e.openBlock(), e.createBlock(e.resolveDynamicComponent(g.pickerTable), { key: 0, ref: "pickerTable", "table-date": g.panelDate, "show-week-numbers": t.showWeekNumbers, "model-value": g.dates, "selection-mode": t.selectionMode, "disabled-date": t.disabledDate, "focused-date": t.focusedDate, onOnPick: a.panelPickerHandlers, onOnPickClick: t.handlePickClick }, null, 40, ["table-date", "show-week-numbers", "model-value", "selection-mode", "disabled-date", "focused-date", "onOnPick", "onOnPickClick"])) : e.createCommentVNode("", !0)], 2), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [g.currentView === "time" ? (e.openBlock(), e.createBlock(P, e.mergeProps({ key: 0, ref: "timePicker", "model-value": g.dates, format: t.format, "time-disabled": a.timeDisabled, "disabled-date": t.disabledDate, "focused-date": t.focusedDate }, t.timePickerOptions, { onOnPick: a.handlePick, onOnPickClick: t.handlePickClick, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess, onOnPickToggleTime: t.handleToggleTime }), null, 16, ["model-value", "format", "time-disabled", "disabled-date", "focused-date", "onOnPick", "onOnPickClick", "onOnPickClear", "onOnPickSuccess", "onOnPickToggleTime"])) : e.createCommentVNode("", !0)], 2), [[e.vShow, t.isTime]]), t.confirm ? (e.openBlock(), e.createBlock(N, { key: 0, "show-time": t.showTime, "is-time": t.isTime, onOnPickToggleTime: t.handleToggleTime, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess }, null, 8, ["show-time", "is-time", "onOnPickToggleTime", "onOnPickClear", "onOnPickSuccess"])) : e.createCommentVNode("", !0)], 2)], 34);
    }
    var MO = f(VO, [["render", IO]]);
    const u0 = "ivu-picker-panel", rd = "ivu-time-picker", h0 = (t) => t[0].toUpperCase() + t.slice(1), AO = { name: "RangeTimePickerPanel", mixins: [pc, Kt, dc], components: { TimeSpinner: i0, Confirm: fc }, emits: ["on-pick"], props: { steps: { type: Array, default: () => [] }, format: { type: String, default: "HH:mm:ss" }, modelValue: { type: Array, required: !0 } }, data() {
      const [t, r] = this.modelValue.slice();
      return { prefixCls: u0, timePrefixCls: rd, showDate: !1, dateStart: t || Ai(), dateEnd: r || Ai() };
    }, computed: { classes() {
      return [`${u0}-body-wrapper`, `${rd}-with-range`, { [`${rd}-with-seconds`]: this.showSeconds }];
    }, showSeconds() {
      return !!(this.format || "").match(/ss/);
    }, leftDatePanelLabel() {
      return this.panelLabelConfig(this.date);
    }, rightDatePanelLabel() {
      return this.panelLabelConfig(this.dateEnd);
    } }, watch: { modelValue(t) {
      const [r, o] = t.slice();
      this.dateStart = r || Ai(), this.dateEnd = o || Ai();
    } }, methods: { panelLabelConfig(t) {
      const r = this.t("i.locale"), o = this.t("i.datepicker.datePanelLabel"), { labels: C, separator: g } = Jh(r, o, t || Ai());
      return [C[0].label, g, C[1].label].join("");
    }, handleChange(t, r, o = !0) {
      const C = new Date(this.dateStart);
      let g = new Date(this.dateEnd);
      Object.keys(t).forEach((a) => {
        C[`set${h0(a)}`](t[a]);
      }), Object.keys(r).forEach((a) => {
        g[`set${h0(a)}`](r[a]);
      }), g < C && (g = C), o && this.$emit("on-pick", [C, g], "time");
    }, handleStartChange(t) {
      this.handleChange(t, {});
    }, handleEndChange(t) {
      this.handleChange({}, t);
    }, updateScroll() {
      this.$refs.timeSpinner.updateScroll(), this.$refs.timeSpinnerEnd.updateScroll();
    } }, mounted() {
      this.$parent && this.$parent.$options.name === "DatePicker" && (this.showDate = !0);
    } };
    function FO(t, r, o, C, g, a) {
      const x = e.resolveComponent("time-spinner"), O = e.resolveComponent("Confirm");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onMousedown: r[0] || (r[0] = e.withModifiers(() => {
      }, ["prevent"])) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content", g.prefixCls + "-content-left"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.timePrefixCls + "-header"]) }, [g.showDate ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(a.leftDatePanelLabel), 1)], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(t.t("i.datepicker.startTime")), 1)], 64))], 2), e.createVNode(x, { ref: "timeSpinner", steps: o.steps, "show-seconds": a.showSeconds, hours: o.modelValue[0] && g.dateStart.getHours(), minutes: o.modelValue[0] && g.dateStart.getMinutes(), seconds: o.modelValue[0] && g.dateStart.getSeconds(), "disabled-hours": t.disabledHours, "disabled-minutes": t.disabledMinutes, "disabled-seconds": t.disabledSeconds, "hide-disabled-options": t.hideDisabledOptions, onOnChange: a.handleStartChange, onOnPickClick: t.handlePickClick }, null, 8, ["steps", "show-seconds", "hours", "minutes", "seconds", "disabled-hours", "disabled-minutes", "disabled-seconds", "hide-disabled-options", "onOnChange", "onOnPickClick"])], 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content", g.prefixCls + "-content-right"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.timePrefixCls + "-header"]) }, [g.showDate ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(a.rightDatePanelLabel), 1)], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(t.t("i.datepicker.endTime")), 1)], 64))], 2), e.createVNode(x, { ref: "timeSpinnerEnd", steps: o.steps, "show-seconds": a.showSeconds, hours: o.modelValue[1] && g.dateEnd.getHours(), minutes: o.modelValue[1] && g.dateEnd.getMinutes(), seconds: o.modelValue[1] && g.dateEnd.getSeconds(), "disabled-hours": t.disabledHours, "disabled-minutes": t.disabledMinutes, "disabled-seconds": t.disabledSeconds, "hide-disabled-options": t.hideDisabledOptions, onOnChange: a.handleEndChange, onOnPickClick: t.handlePickClick }, null, 8, ["steps", "show-seconds", "hours", "minutes", "seconds", "disabled-hours", "disabled-minutes", "disabled-seconds", "hide-disabled-options", "onOnChange", "onOnPickClick"])], 2), t.confirm ? (e.openBlock(), e.createBlock(O, { key: 0, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess }, null, 8, ["onOnPickClear", "onOnPickSuccess"])) : e.createCommentVNode("", !0)], 2)], 34);
    }
    var d0 = f(AO, [["render", FO]]);
    const uo = "ivu-picker-panel", sd = "ivu-date-picker", f0 = (t, r) => !t || !r ? 0 : t.getTime() - r.getTime(), LO = { name: "RangeDatePickerPanel", mixins: [pc, Kt, c0], components: { Icon: G, DateTable: e0, YearTable: t0, MonthTable: n0, TimePicker: d0, Confirm: fc, datePanelLabel: l0 }, props: { splitPanels: { type: Boolean, default: !1 } }, data() {
      const [t, r] = this.modelValue.map((C) => C || Ai()), o = this.startDate ? this.startDate : t;
      return { prefixCls: uo, datePrefixCls: sd, dates: this.modelValue, rangeState: { from: this.modelValue[0], to: this.modelValue[1], selecting: t && !r }, currentView: this.selectionMode || "range", leftPickerTable: `${this.selectionMode}-table`, rightPickerTable: `${this.selectionMode}-table`, leftPanelDate: o, rightPanelDate: new Date(o.getFullYear(), o.getMonth() + 1, 1) };
    }, computed: { classes() {
      return [`${uo}-body-wrapper`, `${sd}-with-range`, { [`${uo}-with-sidebar`]: this.shortcuts.length, [`${sd}-with-week-numbers`]: this.showWeekNumbers }];
    }, panelBodyClasses() {
      return [uo + "-body", { [uo + "-body-time"]: this.showTime, [uo + "-body-date"]: !this.showTime }];
    }, leftDatePanelLabel() {
      return this.panelLabelConfig("left");
    }, rightDatePanelLabel() {
      return this.panelLabelConfig("right");
    }, leftDatePanelView() {
      return this.leftPickerTable.split("-").shift();
    }, rightDatePanelView() {
      return this.rightPickerTable.split("-").shift();
    }, timeDisabled() {
      return !(this.dates[0] && this.dates[1]);
    }, preSelecting() {
      const t = `${this.currentView}-table`;
      return { left: this.leftPickerTable !== t, right: this.rightPickerTable !== t };
    }, panelPickerHandlers() {
      return { left: this.preSelecting.left ? this.handlePreSelection.bind(this, "left") : this.handleRangePick, right: this.preSelecting.right ? this.handlePreSelection.bind(this, "right") : this.handleRangePick };
    } }, watch: { modelValue(t) {
      const r = t[0] ? qh(t[0]) : null, o = t[1] ? qh(t[1]) : null;
      this.dates = [r, o].sort(f0), this.rangeState = { from: this.dates[0], to: this.dates[1], selecting: !1 }, this.setPanelDates(this.startDate || this.dates[0] || /* @__PURE__ */ new Date());
    }, currentView(t) {
      const r = this.leftPanelDate.getMonth(), o = this.rightPanelDate.getMonth(), C = this.leftPanelDate.getFullYear() === this.rightPanelDate.getFullYear();
      t === "date" && C && r === o && this.changePanelDate("right", "Month", 1), t === "month" && C && this.changePanelDate("right", "FullYear", 1), t === "year" && C && this.changePanelDate("right", "FullYear", 10);
    }, selectionMode(t) {
      this.currentView = t || "range";
    }, focusedDate(t) {
      this.setPanelDates(t || /* @__PURE__ */ new Date());
    } }, methods: { reset() {
      this.currentView = this.selectionMode, this.leftPickerTable = `${this.currentView}-table`, this.rightPickerTable = `${this.currentView}-table`;
    }, setPanelDates(t) {
      this.leftPanelDate = t;
      const r = new Date(t.getFullYear(), t.getMonth() + 1, 1), o = this.dates[1] ? this.dates[1].getTime() : this.dates[1];
      this.rightPanelDate = this.splitPanels ? new Date(Math.max(o, r.getTime())) : r;
    }, panelLabelConfig(t) {
      const r = this.t("i.locale"), o = this.t("i.datepicker.datePanelLabel"), C = (O) => {
        const P = O == "month" ? this.showMonthPicker : this.showYearPicker;
        return () => P(t);
      }, g = this[`${t}PanelDate`], { labels: a, separator: x } = Jh(r, o, g);
      return { separator: x, labels: a.map((O) => (O.handler = C(O.type), O)) };
    }, prevYear(t) {
      const r = this.currentView === "year" ? -10 : -1;
      this.changePanelDate(t, "FullYear", r);
    }, nextYear(t) {
      const r = this.currentView === "year" ? 10 : 1;
      this.changePanelDate(t, "FullYear", r);
    }, prevMonth(t) {
      this.changePanelDate(t, "Month", -1);
    }, nextMonth(t) {
      this.changePanelDate(t, "Month", 1);
    }, changePanelDate(t, r, o, C = !0) {
      const g = new Date(this[`${t}PanelDate`]);
      if (r === "FullYear" ? g[`set${r}`](g[`get${r}`]() + o) : g[`set${r}`](g[`get${r}`]() + o, 1), this[`${t}PanelDate`] = g, !!C)
        if (this.splitPanels) {
          const a = t === "left" ? "right" : "left";
          t === "left" && this.leftPanelDate >= this.rightPanelDate && this.changePanelDate(a, r, 1), t === "right" && this.rightPanelDate <= this.leftPanelDate && this.changePanelDate(a, r, -1);
        } else {
          const a = t === "left" ? "right" : "left", x = this[`${a}PanelDate`], O = new Date(x);
          if (r === "Month") {
            const P = new Date(O.getFullYear(), O.getMonth() + o + 1, 0).getDate();
            O.setDate(Math.min(P, O.getDate()));
          }
          O[`set${r}`](O[`get${r}`]() + o), this[`${a}PanelDate`] = O;
        }
    }, showYearPicker(t) {
      this[`${t}PickerTable`] = "year-table";
    }, showMonthPicker(t) {
      this[`${t}PickerTable`] = "month-table";
    }, handlePreSelection(t, r) {
      if (this[`${t}PanelDate`] = r, this[`${t}PickerTable`] === "year-table" ? this[`${t}PickerTable`] = "month-table" : this[`${t}PickerTable`] = `${this.currentView}-table`, !this.splitPanels) {
        const o = t === "left" ? "right" : "left";
        this[`${o}PanelDate`] = r;
        const C = o === "left" ? -1 : 1;
        this.changePanelDate(o, "Month", C, !1);
      }
    }, handleRangePick(t, r) {
      if (this.rangeState.selecting || this.currentView === "time") {
        if (this.currentView === "time")
          this.dates = t;
        else {
          const [o, C] = [this.rangeState.from, t].sort(f0);
          this.dates = [o, C], this.rangeState = { from: o, to: C, selecting: !1 };
        }
        this.handleConfirm(!1, r || "date");
      } else
        this.rangeState = { from: t, to: null, selecting: !0 };
    }, handleChangeRange(t) {
      this.rangeState.to = t;
    } } }, zO = ["onClick"];
    function RO(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("date-panel-label"), P = e.resolveComponent("time-picker"), N = e.resolveComponent("Confirm");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onMousedown: r[8] || (r[8] = e.withModifiers(() => {
      }, ["prevent"])) }, [t.shortcuts.length ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-sidebar"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(t.shortcuts, (B) => (e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls + "-shortcut"]), key: B.text, onClick: (H) => t.handleShortcutClick(B) }, e.toDisplayString(B.text), 11, zO))), 128))], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass(a.panelBodyClasses) }, [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content", g.prefixCls + "-content-left"]) }, [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.datePrefixCls + "-header"]) }, [e.createElementVNode("span", { class: e.normalizeClass(t.iconBtnCls("prev", "-double")), onClick: r[0] || (r[0] = (B) => a.prevYear("left")) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2), g.leftPickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(t.iconBtnCls("prev")), onClick: r[1] || (r[1] = (B) => a.prevMonth("left")) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0), e.createVNode(O, { "date-panel-label": a.leftDatePanelLabel, "current-view": a.leftDatePanelView, "date-prefix-cls": g.datePrefixCls }, null, 8, ["date-panel-label", "current-view", "date-prefix-cls"]), o.splitPanels || g.leftPickerTable !== "date-table" ? (e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass(t.iconBtnCls("next", "-double")), onClick: r[2] || (r[2] = (B) => a.nextYear("left")) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2)) : e.createCommentVNode("", !0), o.splitPanels && g.leftPickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass(t.iconBtnCls("next")), onClick: r[3] || (r[3] = (B) => a.nextMonth("left")) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0)], 2), [[e.vShow, g.currentView !== "time"]]), g.currentView !== "time" ? (e.openBlock(), e.createBlock(e.resolveDynamicComponent(g.leftPickerTable), { key: 0, ref: "leftYearTable", "table-date": g.leftPanelDate, "selection-mode": "range", "disabled-date": t.disabledDate, "range-state": g.rangeState, "show-week-numbers": t.showWeekNumbers, "model-value": a.preSelecting.left ? [g.dates[0]] : g.dates, "focused-date": t.focusedDate, onOnChangeRange: a.handleChangeRange, onOnPick: a.panelPickerHandlers.left, onOnPickClick: t.handlePickClick }, null, 40, ["table-date", "disabled-date", "range-state", "show-week-numbers", "model-value", "focused-date", "onOnChangeRange", "onOnPick", "onOnPickClick"])) : e.createCommentVNode("", !0)], 2), [[e.vShow, !t.isTime]]), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content", g.prefixCls + "-content-right"]) }, [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.datePrefixCls + "-header"]) }, [o.splitPanels || g.rightPickerTable !== "date-table" ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(t.iconBtnCls("prev", "-double")), onClick: r[4] || (r[4] = (B) => a.prevYear("right")) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2)) : e.createCommentVNode("", !0), o.splitPanels && g.rightPickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass(t.iconBtnCls("prev")), onClick: r[5] || (r[5] = (B) => a.prevMonth("right")) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0), e.createVNode(O, { "date-panel-label": a.rightDatePanelLabel, "current-view": a.rightDatePanelView, "date-prefix-cls": g.datePrefixCls }, null, 8, ["date-panel-label", "current-view", "date-prefix-cls"]), e.createElementVNode("span", { class: e.normalizeClass(t.iconBtnCls("next", "-double")), onClick: r[6] || (r[6] = (B) => a.nextYear("right")) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2), g.rightPickerTable === "date-table" ? e.withDirectives((e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass(t.iconBtnCls("next")), onClick: r[7] || (r[7] = (B) => a.nextMonth("right")) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2)), [[e.vShow, g.currentView === "date"]]) : e.createCommentVNode("", !0)], 2), [[e.vShow, g.currentView !== "time"]]), g.currentView !== "time" ? (e.openBlock(), e.createBlock(e.resolveDynamicComponent(g.rightPickerTable), { key: 0, ref: "rightYearTable", "table-date": g.rightPanelDate, "selection-mode": "range", "range-state": g.rangeState, "disabled-date": t.disabledDate, "show-week-numbers": t.showWeekNumbers, "model-value": a.preSelecting.right ? [g.dates[g.dates.length - 1]] : g.dates, "focused-date": t.focusedDate, onOnChangeRange: a.handleChangeRange, onOnPick: a.panelPickerHandlers.right, onOnPickClick: t.handlePickClick }, null, 40, ["table-date", "range-state", "disabled-date", "show-week-numbers", "model-value", "focused-date", "onOnChangeRange", "onOnPick", "onOnPickClick"])) : e.createCommentVNode("", !0)], 2), [[e.vShow, !t.isTime]]), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [g.currentView === "time" ? (e.openBlock(), e.createBlock(P, e.mergeProps({ key: 0, ref: "timePicker", "model-value": g.dates, format: t.format, "time-disabled": a.timeDisabled }, t.timePickerOptions, { onOnPick: a.handleRangePick, onOnPickClick: t.handlePickClick, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess, onOnPickToggleTime: t.handleToggleTime }), null, 16, ["model-value", "format", "time-disabled", "onOnPick", "onOnPickClick", "onOnPickClear", "onOnPickSuccess", "onOnPickToggleTime"])) : e.createCommentVNode("", !0)], 2), [[e.vShow, t.isTime]]), t.confirm ? (e.openBlock(), e.createBlock(N, { key: 0, "show-time": t.showTime, "is-time": t.isTime, "time-disabled": a.timeDisabled, onOnPickToggleTime: t.handleToggleTime, onOnPickClear: t.handlePickClear, onOnPickSuccess: t.handlePickSuccess }, null, 8, ["show-time", "is-time", "time-disabled", "onOnPickToggleTime", "onOnPickClear", "onOnPickSuccess"])) : e.createCommentVNode("", !0)], 2)], 34);
    }
    var jO = f(LO, [["render", RO]]), p0 = { name: "CalendarPicker", mixins: [Kg], props: { type: { validator(t) {
      return z(t, ["year", "month", "date", "daterange", "datetime", "datetimerange"]);
    }, default: "date" } }, components: { DatePickerPanel: MO, RangeDatePickerPanel: jO }, computed: { panel() {
      return this.type === "daterange" || this.type === "datetimerange" ? "RangeDatePickerPanel" : "DatePickerPanel";
    }, ownPickerProps() {
      return this.options;
    } } }, HO = { 1: { xs: 24 }, 2: { xs: 24, sm: 12 }, 3: { xs: 24, sm: 12, md: 8 }, 4: { xs: 24, sm: 12, md: 6 } };
    const m0 = { name: "Description", inject: ["DescriptionListInstance"], props: { term: { type: String } }, computed: { styles() {
      let t = {};
      return this.DescriptionListInstance.gutter !== 0 && (t = { paddingLeft: this.DescriptionListInstance.gutter / 2 + "px", paddingRight: this.DescriptionListInstance.gutter / 2 + "px" }), t;
    } }, render() {
      let t;
      (this.term || this.$slots.term) && (this.$slots.term ? t = e.h("div", { class: "ivu-description-term" }, this.$slots.term()) : t = e.h("div", { class: "ivu-description-term" }, this.term));
      const r = e.h("div", { class: "ivu-description-detail" }, this.$slots.default()), o = t ? [t, r] : [r];
      return e.h(Ii, v(p({}, HO[this.DescriptionListInstance.col]), { style: this.styles }), () => o);
    } }, UO = { name: "DescriptionList", components: { Row: Er }, provide() {
      return { DescriptionListInstance: this };
    }, props: { layout: { validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "horizontal" }, title: { type: String }, gutter: { type: Number, default: 32 }, col: { validator(t) {
      return z(t, [1, 2, 3, 4]);
    }, default: 3 } } }, WO = { key: 0, class: "ivu-description-list-title" };
    function YO(t, r, o, C, g, a) {
      const x = e.resolveComponent("Row");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-description-list", { "ivu-description-list-vertical": o.layout === "vertical" }]) }, [o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("div", WO, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0), e.createVNode(x, { gutter: o.gutter }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), _: 3 }, 8, ["gutter"])], 2);
    }
    var g0 = f(UO, [["render", YO]]);
    const Tr = "ivu-divider", KO = { name: "Divider", props: { type: { type: String, default: "horizontal", validator(t) {
      return z(t, ["horizontal", "vertical"]);
    } }, orientation: { type: String, default: "center", validator(t) {
      return z(t, ["left", "right", "center"]);
    } }, dashed: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "default"]);
    }, default: "default" }, plain: { type: Boolean, default: !1 } }, computed: { hasSlot() {
      return !!this.$slots.default;
    }, classes() {
      return [`${Tr}`, `${Tr}-${this.type}`, `${Tr}-${this.size}`, { [`${Tr}-with-text`]: this.hasSlot && this.orientation === "center", [`${Tr}-with-text-${this.orientation}`]: this.hasSlot, [`${Tr}-dashed`]: !!this.dashed, [`${Tr}-plain`]: this.plain }];
    }, slotClasses() {
      return [`${Tr}-inner-text`];
    } } };
    function GO(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [a.hasSlot ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.slotClasses) }, [e.renderSlot(t.$slots, "default")], 2)) : e.createCommentVNode("", !0)], 2);
    }
    var mc = f(KO, [["render", GO]]), od = { props: { lockScroll: { type: Boolean, default: !0 } }, methods: { checkScrollBar() {
      if (!h)
        return;
      let t = window.innerWidth;
      if (!t) {
        const r = document.documentElement.getBoundingClientRect();
        t = r.right - Math.abs(r.left);
      }
      this.bodyIsOverflowing = document.body.clientWidth < t, this.bodyIsOverflowing && (this.scrollBarWidth = he());
    }, checkMaskInVisible() {
      let t = h ? document.getElementsByClassName("ivu-modal-mask") || [] : [];
      return Array.from(t).every((r) => r.style.display === "none" || r.classList.contains("fade-leave-to"));
    }, setScrollBar() {
      h && this.bodyIsOverflowing && this.scrollBarWidth !== void 0 && (document.body.style.paddingRight = `${this.scrollBarWidth}px`);
    }, resetScrollBar() {
      h && (document.body.style.paddingRight = "");
    }, addScrollEffect() {
      !this.lockScroll || (this.checkScrollBar(), this.setScrollBar(), h && (document.body.style.overflow = "hidden"));
    }, removeScrollEffect() {
      !this.lockScroll || h && this.checkMaskInVisible() && (document.body.style.overflow = "", this.resetScrollBar());
    } } };
    const jn = "ivu-drawer", XO = { name: "Drawer", mixins: [od], components: { Icon: G }, emits: ["on-close", "on-resize-width", "on-visible-change", "update:modelValue", "on-drag"], provide() {
      return { DrawerInstance: this };
    }, props: { modelValue: { type: Boolean, default: !1 }, title: { type: String }, width: { type: [Number, String], default: 256 }, height: { type: [Number, String], default: 256 }, closable: { type: Boolean, default: !0 }, maskClosable: { type: Boolean, default: !0 }, mask: { type: Boolean, default: !0 }, maskStyle: { type: Object }, styles: { type: Object }, scrollable: { type: Boolean, default: !1 }, placement: { validator(t) {
      return z(t, ["left", "right", "top", "bottom"]);
    }, default: "right" }, zIndex: { type: Number, default: 1e3 }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !0 : t.$VIEWUI.transfer;
    } }, className: { type: String }, inner: { type: Boolean, default: !1 }, draggable: { type: Boolean, default: !1 }, beforeClose: Function }, data() {
      return { prefixCls: jn, visible: this.modelValue, wrapShow: !1, showHead: !0, canMove: !1, dragWidth: this.width, dragHeight: this.height, wrapperWidth: this.width, wrapperHeight: this.height, wrapperLeft: 0, minWidth: 256, minHeight: 256, id: be(6), tableList: [], sliderList: [] };
    }, computed: { wrapClasses() {
      return [`${jn}-wrap`, { [`${jn}-hidden`]: !this.wrapShow, [`${this.className}`]: !!this.className, [`${jn}-no-mask`]: !this.mask, [`${jn}-wrap-inner`]: this.inner, [`${jn}-wrap-dragging`]: this.canMove }];
    }, mainStyles() {
      let t = {};
      if (this.placement === "left" || this.placement === "right") {
        const r = parseInt(this.dragWidth), o = { width: r <= 100 ? `${r}%` : `${r}px` };
        Object.assign(t, o);
      } else {
        const r = parseInt(this.dragHeight), o = { height: r <= 100 ? `${r}%` : `${r}px` };
        Object.assign(t, o);
      }
      return t;
    }, contentClasses() {
      return [`${jn}-content`, { [`${jn}-content-no-mask`]: !this.mask }];
    }, classes() {
      return [`${jn}`, `${jn}-${this.placement}`, { [`${jn}-no-header`]: !this.showHead, [`${jn}-inner`]: this.inner }];
    }, maskClasses() {
      return [`${jn}-mask`, { [`${jn}-mask-inner`]: this.inner }];
    }, transitionName() {
      return this.placement === "left" || this.placement === "right" ? `move-${this.placement}` : this.placement === "top" ? "move-up" : "move-down";
    } }, methods: { close() {
      if (!this.beforeClose)
        return this.handleClose();
      const t = this.beforeClose();
      t && t.then ? t.then(() => {
        this.handleClose();
      }) : this.handleClose();
    }, handleClose() {
      this.visible = !1, this.$emit("update:modelValue", !1), this.$emit("on-close");
    }, handleMask() {
      this.maskClosable && this.mask && this.close();
    }, handleWrapClick(t) {
      const r = t.target.getAttribute("class");
      r && r.indexOf(`${jn}-wrap`) > -1 && this.handleMask();
    }, handleMousemove(t) {
      if (!this.canMove || !this.draggable)
        return;
      this.handleSetWrapperWidth();
      const r = t.pageX - this.wrapperLeft;
      let o = this.placement === "right" ? this.wrapperWidth - r : r;
      o = Math.max(o, parseFloat(this.minWidth)), t.atMin = o === parseFloat(this.minWidth), o <= 100 && (o = o / this.wrapperWidth * 100), this.dragWidth = o, this.$emit("on-resize-width", parseInt(this.dragWidth)), this.$emit("on-drag", "dragging", parseInt(this.dragWidth));
    }, handleSetWrapperWidth() {
      const { width: t, left: r } = this.$refs.drawer.getBoundingClientRect();
      this.wrapperWidth = t, this.wrapperLeft = r;
    }, handleMouseup() {
      !this.draggable || (this.canMove = !1, this.$emit("on-drag", "end"));
    }, handleTriggerMousedown() {
      this.canMove = !0, window.getSelection().removeAllRanges(), this.$emit("on-drag", "start");
    }, addDrawer() {
      const t = this.$root;
      t.drawerList || (t.drawerList = []), t.drawerList.push({ id: this.id, drawer: this });
    }, removeDrawer() {
      const t = this.$root;
      if (!t.drawerList)
        return;
      const r = t.drawerList.findIndex((o) => o.id === this.id);
      t.drawerList.splice(r, 1);
    } }, mounted() {
      this.visible && (this.wrapShow = !0);
      let t = !0;
      this.$slots.header === void 0 && !this.title && (t = !1), this.showHead = t, this.addDrawer(), m(document, "mousemove", this.handleMousemove), m(document, "mouseup", this.handleMouseup), this.handleSetWrapperWidth();
    }, beforeUnmount() {
      this.removeDrawer(), b(document, "mousemove", this.handleMousemove), b(document, "mouseup", this.handleMouseup), this.removeScrollEffect();
    }, watch: { modelValue(t) {
      this.visible = t;
    }, visible(t) {
      t === !1 ? this.timer = setTimeout(() => {
        this.wrapShow = !1, this.$root.drawerList.map((r) => r.drawer).filter((r) => r.id !== this.id).some((r) => r.visible && !r.scrollable) || this.removeScrollEffect();
      }, 300) : (this.timer && clearTimeout(this.timer), this.wrapShow = !0, this.scrollable || this.addScrollEffect()), this.tableList.forEach((r) => {
        r.table.handleOnVisibleChange(t);
      }), this.sliderList.forEach((r) => {
        r.slider.handleOnVisibleChange(t);
      }), this.$emit("on-visible-change", t);
    }, scrollable(t) {
      t ? this.removeScrollEffect() : this.addScrollEffect();
    }, title(t) {
      this.$slots.header === void 0 && (this.showHead = !!t);
    }, width(t) {
      this.dragWidth = t;
    }, height(t) {
      this.dragHeight = t;
    } } }, qO = { ref: "drawer" }, JO = e.createElementVNode("div", { class: "ivu-drawer-drag-move-trigger" }, [e.createElementVNode("div", { class: "ivu-drawer-drag-move-trigger-point" }, [e.createElementVNode("i"), e.createElementVNode("i"), e.createElementVNode("i"), e.createElementVNode("i"), e.createElementVNode("i")])], -1);
    function QO(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createElementVNode("div", qO, [e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [o.mask ? e.withDirectives((e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.maskClasses), style: e.normalizeStyle(o.maskStyle), onClick: r[0] || (r[0] = (...O) => a.handleMask && a.handleMask(...O)) }, null, 6)), [[e.vShow, g.visible]]) : e.createCommentVNode("", !0)]), _: 1 }), e.createElementVNode("div", { class: e.normalizeClass(a.wrapClasses), onClick: r[3] || (r[3] = (...O) => a.handleWrapClick && a.handleWrapClick(...O)) }, [e.createVNode(e.Transition, { name: a.transitionName }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.mainStyles) }, [e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses), ref: "content" }, [o.closable ? (e.openBlock(), e.createElementBlock("a", { key: 0, class: "ivu-drawer-close", onClick: r[1] || (r[1] = (...O) => a.close && a.close(...O)) }, [e.renderSlot(t.$slots, "close", {}, () => [e.createVNode(x, { type: "ios-close" })])])) : e.createCommentVNode("", !0), g.showHead ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass([g.prefixCls + "-header"]) }, [e.renderSlot(t.$slots, "header", {}, () => [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-header-inner"]) }, e.toDisplayString(o.title), 3)])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]), style: e.normalizeStyle(o.styles) }, [e.renderSlot(t.$slots, "default")], 6)], 2), o.draggable && (o.placement === "left" || o.placement === "right") ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(["ivu-drawer-drag", "ivu-drawer-drag-" + o.placement]), onMousedown: r[2] || (r[2] = (...O) => a.handleTriggerMousedown && a.handleTriggerMousedown(...O)) }, [e.renderSlot(t.$slots, "trigger", {}, () => [JO])], 34)) : e.createCommentVNode("", !0)], 6), [[e.vShow, g.visible]])]), _: 3 }, 8, ["name"])], 2)], 512)], 8, ["disabled"]);
    }
    var v0 = f(XO, [["render", QO]]);
    const gc = "ivu-dropdown-item", ZO = { name: "DropdownItem", props: { name: { type: [String, Number] }, disabled: { type: Boolean, default: !1 }, selected: { type: Boolean, default: !1 }, divided: { type: Boolean, default: !1 } }, computed: { classes() {
      return [`${gc}`, { [`${gc}-disabled`]: this.disabled, [`${gc}-selected`]: this.selected, [`${gc}-divided`]: this.divided }];
    } }, methods: { handleClick() {
      if (this.disabled)
        return;
      const t = me(this, "Dropdown");
      this.$parent && this.$parent.$options.name === "Dropdown" ? this.$parent.handleHaschildClick() : t && t.$options.name === "Dropdown" && t.handleHoverClick(), t.handleItemClick(this.name);
    } } };
    function eD(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.classes), onClick: r[0] || (r[0] = (...x) => a.handleClick && a.handleClick(...x)) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var y0 = f(ZO, [["render", eD]]);
    const tD = (t = "") => t.split("").reduce((r, o) => {
      const C = o.charCodeAt(0);
      return C >= 0 && C <= 128 ? r + 1 : r + 2;
    }, 0), nD = (t = "", r) => {
      let o = 0;
      return t.split("").reduce((C, g) => {
        const a = g.charCodeAt(0);
        return a >= 0 && a <= 128 ? o += 1 : o += 2, o <= r ? C + g : C;
      }, "");
    }, iD = { name: "Ellipsis", components: { Tooltip: tr }, emits: ["on-show", "on-hide"], props: { text: { type: String }, height: { type: Number }, lines: { type: Number }, length: { type: Number }, fullWidthRecognition: { type: Boolean, default: !1 }, autoResize: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, tooltip: { type: Boolean, default: !1 }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, theme: { validator(t) {
      return z(t, ["dark", "light"]);
    }, default: "dark" }, maxWidth: { type: [String, Number], default: 250 }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom" } }, data() {
      return { oversize: !1, computedReady: !1, computedText: "" };
    }, watch: { disabled() {
      this.init();
    }, text() {
      this.init();
    }, height() {
      this.init();
    } }, mounted() {
      this.init();
    }, methods: { init() {
      this.disabled || (this.computeText(), this.limitShow());
    }, computeText() {
      this.oversize = !1, this.computedReady = !1, e.nextTick(() => {
        let t = this.$refs.text, r = this.$el, o = this.$refs.more, C = 1e3, g = this.text, a = this.height;
        if (!a && this.lines && (a = parseInt(Be(r, "lineHeight"), 10) * this.lines), t) {
          if (this.length)
            (this.fullWidthRecognition ? tD(g) : g.length) > this.length && (this.oversize = !0, o.style.display = "inline-block", g = this.fullWidthRecognition ? nD(g, this.length) : g.slice(0, this.length));
          else if (r.offsetHeight > a)
            for (this.oversize = !0, o.style.display = "inline-block"; r.offsetHeight > a && C > 0; )
              r.offsetHeight > a * 3 ? t.innerText = g = g.substring(0, Math.floor(g.length / 2)) : t.innerText = g = g.substring(0, g.length - 1), C--;
        }
        this.computedText = g;
      });
    }, limitShow() {
      this.computedReady = !0, e.nextTick(() => {
        let t = this.$refs.text, r = this.$el;
        t && (t.innerText = this.computedText, r.offsetHeight > this.height ? this.$emit("on-hide") : this.$emit("on-show"));
      });
    } } }, rD = { class: "ivu-ellipsis" }, sD = { class: "ivu-ellipsis-more", ref: "more" }, oD = { class: "ivu-ellipsis-more", ref: "more" }, aD = { key: 1, class: "ivu-ellipsis-hidden" }, lD = { class: "ivu-ellipsis-more", ref: "more" };
    function cD(t, r, o, C, g, a) {
      const x = e.resolveComponent("Tooltip");
      return e.openBlock(), e.createElementBlock("div", rD, [e.renderSlot(t.$slots, "prefix", { class: "ivu-ellipsis-prefix" }), g.computedReady ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [o.tooltip ? (e.openBlock(), e.createBlock(x, { key: 0, content: o.text, theme: o.theme, "max-width": o.maxWidth, placement: o.placement, transfer: o.transfer }, { default: e.withCtx(() => [e.createElementVNode("span", { class: "ivu-ellipsis-text", ref: "text" }, e.toDisplayString(o.text), 513), e.withDirectives(e.createElementVNode("span", sD, [e.renderSlot(t.$slots, "more", {}, () => [e.createTextVNode("...")])], 512), [[e.vShow, g.oversize]]), e.renderSlot(t.$slots, "suffix", { class: "ivu-ellipsis-suffix" })]), _: 3 }, 8, ["content", "theme", "max-width", "placement", "transfer"])) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createElementVNode("span", { class: "ivu-ellipsis-text", ref: "text" }, e.toDisplayString(o.text), 513), e.withDirectives(e.createElementVNode("span", oD, [e.renderSlot(t.$slots, "more", {}, () => [e.createTextVNode("...")])], 512), [[e.vShow, g.oversize]]), e.renderSlot(t.$slots, "suffix", { class: "ivu-ellipsis-suffix" })], 64))], 64)) : (e.openBlock(), e.createElementBlock("div", aD, [e.createElementVNode("span", { class: "ivu-ellipsis-text", ref: "text" }, e.toDisplayString(o.text), 513), e.withDirectives(e.createElementVNode("span", lD, [e.renderSlot(t.$slots, "more", {}, () => [e.createTextVNode("...")])], 512), [[e.vShow, g.oversize]]), e.renderSlot(t.$slots, "suffix", { class: "ivu-ellipsis-suffix" })]))]);
    }
    var b0 = f(iD, [["render", cD]]);
    const C0 = { name: "Email", mixins: [ia], data() {
      return { className: "ivu-login-mail", prefix: "ios-mail-outline", placeholder: "请输入邮箱", type: "email" };
    }, props: { rules: { type: [Object, Array], default() {
      return [{ required: !0, message: jh.Email, trigger: "change" }, { type: "email", message: "输入的邮箱格式不正确！", trigger: "change" }];
    } } } };
    var vc = { 403: { img: "https://file.iviewui.com/iview-pro/icon-403.svg", imgColor: "https://file.iviewui.com/iview-pro/icon-403-color.svg", title: "403", desc: "抱歉，你无权访问该页面" }, 404: { img: "https://file.iviewui.com/iview-pro/icon-404.svg", imgColor: "https://file.iviewui.com/iview-pro/icon-404-color.svg", title: "404", desc: "抱歉，你访问的页面不存在" }, 500: { img: "https://file.iviewui.com/iview-pro/icon-500.svg", imgColor: "https://file.iviewui.com/iview-pro/icon-500-color.svg", title: "500", desc: "抱歉，服务器出错了" } };
    const uD = { name: "Exception", components: { Button: zn }, props: { type: { validator(t) {
      return z(t, ["403", "404", "500", 403, 404, 500]);
    }, default: "404" }, title: { type: String }, desc: { type: String }, img: { type: String }, imgColor: { type: Boolean, default: !1 }, backText: { type: String, default: "返回首页" }, redirect: { type: String, default: "/" } }, computed: { imgPath() {
      return this.img ? this.img : this.imgColor ? vc[this.type].imgColor : vc[this.type].img;
    }, titleText() {
      return this.title ? this.title : vc[this.type].title;
    }, descText() {
      return this.desc ? this.desc : vc[this.type].desc;
    } } }, hD = { class: "ivu-exception" }, dD = { class: "ivu-exception-img" }, fD = { class: "ivu-exception-content" }, pD = { class: "ivu-exception-content-desc" }, mD = { class: "ivu-exception-content-actions" };
    function gD(t, r, o, C, g, a) {
      const x = e.resolveComponent("Button");
      return e.openBlock(), e.createElementBlock("div", hD, [e.createElementVNode("div", dD, [e.createElementVNode("div", { class: "ivu-exception-img-element", style: e.normalizeStyle({ "background-image": "url(" + a.imgPath + ")" }) }, null, 4)]), e.createElementVNode("div", fD, [e.createElementVNode("h1", null, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(a.titleText), 1)])]), e.createElementVNode("div", pD, [e.renderSlot(t.$slots, "desc", {}, () => [e.createTextVNode(e.toDisplayString(a.descText), 1)])]), e.createElementVNode("div", mD, [e.renderSlot(t.$slots, "actions", {}, () => [e.createVNode(x, { to: o.redirect, type: "primary", size: "large" }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.backText), 1)]), _: 1 }, 8, ["to"])])])])]);
    }
    var w0 = f(uD, [["render", gD]]);
    const vD = "ivu-layout", yD = { name: "Footer", computed: { wrapClasses() {
      return `${vD}-footer`;
    } } };
    function bD(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var ad = f(yD, [["render", bD]]);
    const CD = { name: "FooterToolbar", props: { extra: { type: String } } }, wD = { class: "ivu-footer-toolbar" }, kD = { key: 0, class: "ivu-footer-toolbar-left" }, SD = { class: "ivu-footer-toolbar-right" };
    function ED(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", wD, [o.extra || t.$slots.extra ? (e.openBlock(), e.createElementBlock("div", kD, [e.renderSlot(t.$slots, "extra", {}, () => [e.createTextVNode(e.toDisplayString(o.extra), 1)])])) : e.createCommentVNode("", !0), e.createElementVNode("div", SD, [e.renderSlot(t.$slots, "default")])]);
    }
    var k0 = f(CD, [["render", ED]]);
    const yc = "ivu-form", xD = { name: "iForm", emits: ["on-validate"], provide() {
      return { FormInstance: this };
    }, props: { model: { type: Object }, rules: { type: Object }, labelWidth: { type: Number }, labelPosition: { validator(t) {
      return z(t, ["left", "right", "top"]);
    }, default: "right" }, inline: { type: Boolean, default: !1 }, showMessage: { type: Boolean, default: !0 }, autocomplete: { validator(t) {
      return z(t, ["on", "off"]);
    }, default: "off" }, hideRequiredMark: { type: Boolean, default: !1 }, labelColon: { type: [Boolean, String], default: !1 }, disabled: { type: Boolean, default: !1 } }, data() {
      return { fields: [] };
    }, computed: { classes() {
      return [`${yc}`, `${yc}-label-${this.labelPosition}`, { [`${yc}-inline`]: this.inline, [`${yc}-hide-required-mark`]: this.hideRequiredMark }];
    }, colon() {
      let t = "";
      return this.labelColon && (t = typeof this.labelColon == "boolean" ? ":" : this.labelColon), t;
    } }, methods: { resetFields() {
      this.fields.forEach((t) => {
        t.resetField();
      });
    }, validate(t) {
      return new Promise((r) => {
        let o = !0, C = 0;
        this.fields.length === 0 && (r(o), typeof t == "function" && t(o)), this.fields.forEach((g) => {
          g.validate("", (a) => {
            a && (o = !1), ++C === this.fields.length && (r(o), typeof t == "function" && t(o));
          });
        });
      });
    }, validateField(t, r) {
      const o = this.fields.filter((C) => C.prop === t)[0];
      if (!o)
        throw new Error("[View UI warn]: must call validateField with valid prop string!");
      o.validate("", r);
    }, addField(t) {
      t && this.fields.push(t);
    }, removeField(t) {
      t.prop && this.fields.splice(this.fields.indexOf(t), 1);
    } }, watch: { rules() {
      this.validate();
    } } }, _D = ["autocomplete"];
    function TD(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("form", { class: e.normalizeClass(a.classes), autocomplete: o.autocomplete }, [e.renderSlot(t.$slots, "default")], 10, _D);
    }
    var bc = f(xD, [["render", TD]]);
    const OD = { name: "GlobalFooter", components: { Icon: G }, props: { links: { type: Array, default() {
      return [];
    } }, copyright: { type: String } } }, DD = { class: "ivu-global-footer" }, ND = { key: 0, class: "ivu-global-footer-links" }, BD = ["href", "target", "title"], PD = { key: 1, class: "ivu-global-footer-copyright" };
    function VD(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("footer", DD, [o.links.length || t.$slots.links ? (e.openBlock(), e.createElementBlock("div", ND, [e.renderSlot(t.$slots, "links", {}, () => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.links, (O) => (e.openBlock(), e.createElementBlock("a", { href: O.href, target: O.blankTarget ? "_blank" : "_self", key: O.key, title: O.title }, [O.icon ? (e.openBlock(), e.createBlock(x, { key: 0, type: O.icon }, null, 8, ["type"])) : O.customIcon ? (e.openBlock(), e.createBlock(x, { key: 1, custom: O.customIcon }, null, 8, ["custom"])) : e.createCommentVNode("", !0), e.createTextVNode(" " + e.toDisplayString(O.title), 1)], 8, BD))), 128))])])) : e.createCommentVNode("", !0), o.copyright || t.$slots.copyright ? (e.openBlock(), e.createElementBlock("div", PD, [e.renderSlot(t.$slots, "copyright", {}, () => [e.createTextVNode(e.toDisplayString(o.copyright), 1)])])) : e.createCommentVNode("", !0)]);
    }
    var S0 = f(OD, [["render", VD]]), ld = { exports: {} }, $D = ld.exports = {};
    $D.forEach = function(t, r) {
      for (var o = 0; o < t.length; o++) {
        var C = r(t[o]);
        if (C)
          return C;
      }
    };
    var ID = function(t) {
      var r = t.stateHandler.getState;
      function o(x) {
        var O = r(x);
        return O && !!O.isDetectable;
      }
      function C(x) {
        r(x).isDetectable = !0;
      }
      function g(x) {
        return !!r(x).busy;
      }
      function a(x, O) {
        r(x).busy = !!O;
      }
      return { isDetectable: o, markAsDetectable: C, isBusy: g, markBusy: a };
    }, MD = function(t) {
      var r = {};
      function o(x) {
        var O = t.get(x);
        return O === void 0 ? [] : r[O] || [];
      }
      function C(x, O) {
        var P = t.get(x);
        r[P] || (r[P] = []), r[P].push(O);
      }
      function g(x, O) {
        for (var P = o(x), N = 0, B = P.length; N < B; ++N)
          if (P[N] === O) {
            P.splice(N, 1);
            break;
          }
      }
      function a(x) {
        var O = o(x);
        !O || (O.length = 0);
      }
      return { get: o, add: C, removeListener: g, removeAllListeners: a };
    }, AD = function() {
      var t = 1;
      function r() {
        return t++;
      }
      return { generate: r };
    }, FD = function(t) {
      var r = t.idGenerator, o = t.stateHandler.getState;
      function C(a) {
        var x = o(a);
        return x && x.id !== void 0 ? x.id : null;
      }
      function g(a) {
        var x = o(a);
        if (!x)
          throw new Error("setId required the element to have a resize detection state.");
        var O = r.generate();
        return x.id = O, O;
      }
      return { get: C, set: g };
    }, LD = function(t) {
      function r() {
      }
      var o = { log: r, warn: r, error: r };
      if (!t && window.console) {
        var C = function(g, a) {
          g[a] = function() {
            var x = console[a];
            if (x.apply)
              x.apply(console, arguments);
            else
              for (var O = 0; O < arguments.length; O++)
                x(arguments[O]);
          };
        };
        C(o, "log"), C(o, "warn"), C(o, "error");
      }
      return o;
    }, cd = { exports: {} }, E0 = cd.exports = {};
    E0.isIE = function(t) {
      function r() {
        var C = navigator.userAgent.toLowerCase();
        return C.indexOf("msie") !== -1 || C.indexOf("trident") !== -1 || C.indexOf(" edge/") !== -1;
      }
      if (!r())
        return !1;
      if (!t)
        return !0;
      var o = function() {
        var C, g = 3, a = document.createElement("div"), x = a.getElementsByTagName("i");
        do
          a.innerHTML = "<!--[if gt IE " + ++g + "]><i></i><![endif]-->";
        while (x[0]);
        return g > 4 ? g : C;
      }();
      return t === o;
    }, E0.isLegacyOpera = function() {
      return !!window.opera;
    };
    var x0 = { exports: {} }, zD = x0.exports = {};
    zD.getOption = RD;
    function RD(t, r, o) {
      var C = t[r];
      return C == null && o !== void 0 ? o : C;
    }
    var _0 = x0.exports, jD = function(t) {
      t = t || {};
      var r = t.reporter, o = _0.getOption(t, "async", !0), C = _0.getOption(t, "auto", !0);
      C && !o && (r && r.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true."), o = !0);
      var g = T0(), a, x = !1;
      function O(se, ee) {
        !x && C && o && g.size() === 0 && B(), g.add(se, ee);
      }
      function P() {
        for (x = !0; g.size(); ) {
          var se = g;
          g = T0(), se.process();
        }
        x = !1;
      }
      function N(se) {
        x || (se === void 0 && (se = o), a && (H(a), a = null), se ? B() : P());
      }
      function B() {
        a = oe(P);
      }
      function H(se) {
        var ee = clearTimeout;
        return ee(se);
      }
      function oe(se) {
        var ee = function(j) {
          return setTimeout(j, 0);
        };
        return ee(se);
      }
      return { add: O, force: N };
    };
    function T0() {
      var t = {}, r = 0, o = 0, C = 0;
      function g(O, P) {
        P || (P = O, O = 0), O > o ? o = O : O < C && (C = O), t[O] || (t[O] = []), t[O].push(P), r++;
      }
      function a() {
        for (var O = C; O <= o; O++)
          for (var P = t[O], N = 0; N < P.length; N++) {
            var B = P[N];
            B();
          }
      }
      function x() {
        return r;
      }
      return { add: g, process: a, size: x };
    }
    var ud = "_erd";
    function HD(t) {
      return t[ud] = {}, O0(t);
    }
    function O0(t) {
      return t[ud];
    }
    function UD(t) {
      delete t[ud];
    }
    var WD = { initState: HD, getState: O0, cleanState: UD }, pa = cd.exports, YD = function(t) {
      t = t || {};
      var r = t.reporter, o = t.batchProcessor, C = t.stateHandler.getState;
      if (!r)
        throw new Error("Missing required dependency: reporter.");
      function g(N, B) {
        function H() {
          B(N);
        }
        if (pa.isIE(8))
          C(N).object = { proxy: H }, N.attachEvent("onresize", H);
        else {
          var oe = O(N);
          if (!oe)
            throw new Error("Element is not detectable by this strategy.");
          oe.contentDocument.defaultView.addEventListener("resize", H);
        }
      }
      function a(N) {
        var B = t.important ? " !important; " : "; ";
        return (N.join(B) + B).trim();
      }
      function x(N, B, H) {
        H || (H = B, B = N, N = null), N = N || {}, N.debug;
        function oe(se, ee) {
          var j = a(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]), pe = !1, at = window.getComputedStyle(se), Qe = se.offsetWidth, tt = se.offsetHeight;
          C(se).startSize = { width: Qe, height: tt };
          function Ee() {
            function ye() {
              if (at.position === "static") {
                se.style.setProperty("position", "relative", N.important ? "important" : "");
                var lt = function(it, Ze, kt, ot) {
                  function Ue(qe) {
                    return qe.replace(/[^-\d\.]/g, "");
                  }
                  var Ke = kt[ot];
                  Ke !== "auto" && Ue(Ke) !== "0" && (it.warn("An element that is positioned static has style." + ot + "=" + Ke + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + ot + " will be set to 0. Element: ", Ze), Ze.style.setProperty(ot, "0", N.important ? "important" : ""));
                };
                lt(r, se, at, "top"), lt(r, se, at, "right"), lt(r, se, at, "bottom"), lt(r, se, at, "left");
              }
            }
            function ze() {
              pe || ye();
              function lt(Ze, kt) {
                if (!Ze.contentDocument) {
                  var ot = C(Ze);
                  ot.checkForObjectDocumentTimeoutId && window.clearTimeout(ot.checkForObjectDocumentTimeoutId), ot.checkForObjectDocumentTimeoutId = setTimeout(function() {
                    ot.checkForObjectDocumentTimeoutId = 0, lt(Ze, kt);
                  }, 100);
                  return;
                }
                kt(Ze.contentDocument);
              }
              var it = this;
              lt(it, function(Ze) {
                ee(se);
              });
            }
            at.position !== "" && (ye(), pe = !0);
            var Oe = document.createElement("object");
            Oe.style.cssText = j, Oe.tabIndex = -1, Oe.type = "text/html", Oe.setAttribute("aria-hidden", "true"), Oe.onload = ze, pa.isIE() || (Oe.data = "about:blank"), C(se) && (se.appendChild(Oe), C(se).object = Oe, pa.isIE() && (Oe.data = "about:blank"));
          }
          o ? o.add(Ee) : Ee();
        }
        pa.isIE(8) ? H(B) : oe(B, H);
      }
      function O(N) {
        return C(N).object;
      }
      function P(N) {
        if (C(N)) {
          var B = O(N);
          !B || (pa.isIE(8) ? N.detachEvent("onresize", B.proxy) : N.removeChild(B), C(N).checkForObjectDocumentTimeoutId && window.clearTimeout(C(N).checkForObjectDocumentTimeoutId), delete C(N).object);
        }
      }
      return { makeDetectable: x, addListener: g, uninstall: P };
    }, KD = ld.exports.forEach, GD = function(t) {
      t = t || {};
      var r = t.reporter, o = t.batchProcessor, C = t.stateHandler.getState;
      t.stateHandler.hasState;
      var g = t.idHandler;
      if (!o)
        throw new Error("Missing required dependency: batchProcessor");
      if (!r)
        throw new Error("Missing required dependency: reporter.");
      var a = B(), x = "erd_scroll_detection_scrollbar_style", O = "erd_scroll_detection_container";
      function P(Ee) {
        H(Ee, x, O);
      }
      P(window.document);
      function N(Ee) {
        var ye = t.important ? " !important; " : "; ";
        return (Ee.join(ye) + ye).trim();
      }
      function B() {
        var Ee = 500, ye = 500, ze = document.createElement("div");
        ze.style.cssText = N(["position: absolute", "width: " + Ee * 2 + "px", "height: " + ye * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
        var Oe = document.createElement("div");
        Oe.style.cssText = N(["position: absolute", "width: " + Ee + "px", "height: " + ye + "px", "overflow: scroll", "visibility: none", "top: " + -Ee * 3 + "px", "left: " + -ye * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]), Oe.appendChild(ze), document.body.insertBefore(Oe, document.body.firstChild);
        var lt = Ee - Oe.clientWidth, it = ye - Oe.clientHeight;
        return document.body.removeChild(Oe), { width: lt, height: it };
      }
      function H(Ee, ye, ze) {
        function Oe(kt, ot) {
          ot = ot || function(Ke) {
            Ee.head.appendChild(Ke);
          };
          var Ue = Ee.createElement("style");
          return Ue.innerHTML = kt, Ue.id = ye, ot(Ue), Ue;
        }
        if (!Ee.getElementById(ye)) {
          var lt = ze + "_animation", it = ze + "_animation_active", Ze = `/* Created by the element-resize-detector library. */
`;
          Ze += "." + ze + " > div::-webkit-scrollbar { " + N(["display: none"]) + ` }

`, Ze += "." + it + " { " + N(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + lt, "animation-name: " + lt]) + ` }
`, Ze += "@-webkit-keyframes " + lt + ` { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
`, Ze += "@keyframes " + lt + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }", Oe(Ze);
        }
      }
      function oe(Ee) {
        Ee.className += " " + O + "_animation_active";
      }
      function se(Ee, ye, ze) {
        if (Ee.addEventListener)
          Ee.addEventListener(ye, ze);
        else if (Ee.attachEvent)
          Ee.attachEvent("on" + ye, ze);
        else
          return r.error("[scroll] Don't know how to add event listeners.");
      }
      function ee(Ee, ye, ze) {
        if (Ee.removeEventListener)
          Ee.removeEventListener(ye, ze);
        else if (Ee.detachEvent)
          Ee.detachEvent("on" + ye, ze);
        else
          return r.error("[scroll] Don't know how to remove event listeners.");
      }
      function j(Ee) {
        return C(Ee).container.childNodes[0].childNodes[0].childNodes[0];
      }
      function pe(Ee) {
        return C(Ee).container.childNodes[0].childNodes[0].childNodes[1];
      }
      function at(Ee, ye) {
        var ze = C(Ee).listeners;
        if (!ze.push)
          throw new Error("Cannot add listener to an element that is not detectable.");
        C(Ee).listeners.push(ye);
      }
      function Qe(Ee, ye, ze) {
        ze || (ze = ye, ye = Ee, Ee = null), Ee = Ee || {};
        function Oe() {
          if (Ee.debug) {
            var We = Array.prototype.slice.call(arguments);
            if (We.unshift(g.get(ye), "Scroll: "), r.log.apply)
              r.log.apply(null, We);
            else
              for (var gt = 0; gt < We.length; gt++)
                r.log(We[gt]);
          }
        }
        function lt(We) {
          function gt(It) {
            var vn = It.getRootNode && It.getRootNode().contains(It);
            return It === It.ownerDocument.body || It.ownerDocument.body.contains(It) || vn;
          }
          return !gt(We) || window.getComputedStyle(We) === null;
        }
        function it(We) {
          var gt = C(We).container.childNodes[0], It = window.getComputedStyle(gt);
          return !It.width || It.width.indexOf("px") === -1;
        }
        function Ze() {
          var We = window.getComputedStyle(ye), gt = {};
          return gt.position = We.position, gt.width = ye.offsetWidth, gt.height = ye.offsetHeight, gt.top = We.top, gt.right = We.right, gt.bottom = We.bottom, gt.left = We.left, gt.widthCSS = We.width, gt.heightCSS = We.height, gt;
        }
        function kt() {
          var We = Ze();
          C(ye).startSize = { width: We.width, height: We.height }, Oe("Element start size", C(ye).startSize);
        }
        function ot() {
          C(ye).listeners = [];
        }
        function Ue() {
          if (Oe("storeStyle invoked."), !C(ye)) {
            Oe("Aborting because element has been uninstalled");
            return;
          }
          var We = Ze();
          C(ye).style = We;
        }
        function Ke(We, gt, It) {
          C(We).lastWidth = gt, C(We).lastHeight = It;
        }
        function qe(We) {
          return j(We).childNodes[0];
        }
        function mt() {
          return 2 * a.width + 1;
        }
        function et() {
          return 2 * a.height + 1;
        }
        function St(We) {
          return We + 10 + mt();
        }
        function yt(We) {
          return We + 10 + et();
        }
        function ht(We) {
          return We * 2 + mt();
        }
        function Rt(We) {
          return We * 2 + et();
        }
        function Tt(We, gt, It) {
          var vn = j(We), U = pe(We), ue = St(gt), q = yt(It), Fe = ht(gt), He = Rt(It);
          vn.scrollLeft = ue, vn.scrollTop = q, U.scrollLeft = Fe, U.scrollTop = He;
        }
        function qt() {
          var We = C(ye).container;
          if (!We) {
            We = document.createElement("div"), We.className = O, We.style.cssText = N(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]), C(ye).container = We, oe(We), ye.appendChild(We);
            var gt = function() {
              C(ye).onRendered && C(ye).onRendered();
            };
            se(We, "animationstart", gt), C(ye).onAnimationStart = gt;
          }
          return We;
        }
        function Tn() {
          function We() {
            var hn = C(ye).style;
            if (hn.position === "static") {
              ye.style.setProperty("position", "relative", Ee.important ? "important" : "");
              var xi = function(ar, _i, Ac, Fr) {
                function zd(Rd) {
                  return Rd.replace(/[^-\d\.]/g, "");
                }
                var Na = Ac[Fr];
                Na !== "auto" && zd(Na) !== "0" && (ar.warn("An element that is positioned static has style." + Fr + "=" + Na + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + Fr + " will be set to 0. Element: ", _i), _i.style[Fr] = 0);
              };
              xi(r, ye, hn, "top"), xi(r, ye, hn, "right"), xi(r, ye, hn, "bottom"), xi(r, ye, hn, "left");
            }
          }
          function gt(hn, xi, ar, _i) {
            return hn = hn ? hn + "px" : "0", xi = xi ? xi + "px" : "0", ar = ar ? ar + "px" : "0", _i = _i ? _i + "px" : "0", ["left: " + hn, "top: " + xi, "right: " + _i, "bottom: " + ar];
          }
          if (Oe("Injecting elements"), !C(ye)) {
            Oe("Aborting because element has been uninstalled");
            return;
          }
          We();
          var It = C(ye).container;
          It || (It = qt());
          var vn = a.width, U = a.height, ue = N(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]), q = N(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(gt(-(1 + vn), -(1 + U), -U, -vn))), Fe = N(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), He = N(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), Xe = N(["position: absolute", "left: 0", "top: 0"]), xt = N(["position: absolute", "width: 200%", "height: 200%"]), Bt = document.createElement("div"), Mt = document.createElement("div"), yn = document.createElement("div"), zi = document.createElement("div"), xn = document.createElement("div"), Ic = document.createElement("div");
          Bt.dir = "ltr", Bt.style.cssText = ue, Bt.className = O, Mt.className = O, Mt.style.cssText = q, yn.style.cssText = Fe, zi.style.cssText = Xe, xn.style.cssText = He, Ic.style.cssText = xt, yn.appendChild(zi), xn.appendChild(Ic), Mt.appendChild(yn), Mt.appendChild(xn), Bt.appendChild(Mt), It.appendChild(Bt);
          function Mc() {
            var hn = C(ye);
            hn && hn.onExpand ? hn.onExpand() : Oe("Aborting expand scroll handler: element has been uninstalled");
          }
          function Da() {
            var hn = C(ye);
            hn && hn.onShrink ? hn.onShrink() : Oe("Aborting shrink scroll handler: element has been uninstalled");
          }
          se(yn, "scroll", Mc), se(xn, "scroll", Da), C(ye).onExpandScroll = Mc, C(ye).onShrinkScroll = Da;
        }
        function Wt() {
          function We(Fe, He, Xe) {
            var xt = qe(Fe), Bt = St(He), Mt = yt(Xe);
            xt.style.setProperty("width", Bt + "px", Ee.important ? "important" : ""), xt.style.setProperty("height", Mt + "px", Ee.important ? "important" : "");
          }
          function gt(Fe) {
            var He = ye.offsetWidth, Xe = ye.offsetHeight, xt = He !== C(ye).lastWidth || Xe !== C(ye).lastHeight;
            Oe("Storing current size", He, Xe), Ke(ye, He, Xe), o.add(0, function() {
              if (xt) {
                if (!C(ye)) {
                  Oe("Aborting because element has been uninstalled");
                  return;
                }
                if (!It()) {
                  Oe("Aborting because element container has not been initialized");
                  return;
                }
                if (Ee.debug) {
                  var Bt = ye.offsetWidth, Mt = ye.offsetHeight;
                  (Bt !== He || Mt !== Xe) && r.warn(g.get(ye), "Scroll: Size changed before updating detector elements.");
                }
                We(ye, He, Xe);
              }
            }), o.add(1, function() {
              if (!C(ye)) {
                Oe("Aborting because element has been uninstalled");
                return;
              }
              if (!It()) {
                Oe("Aborting because element container has not been initialized");
                return;
              }
              Tt(ye, He, Xe);
            }), xt && Fe && o.add(2, function() {
              if (!C(ye)) {
                Oe("Aborting because element has been uninstalled");
                return;
              }
              if (!It()) {
                Oe("Aborting because element container has not been initialized");
                return;
              }
              Fe();
            });
          }
          function It() {
            return !!C(ye).container;
          }
          function vn() {
            function Fe() {
              return C(ye).lastNotifiedWidth === void 0;
            }
            Oe("notifyListenersIfNeeded invoked");
            var He = C(ye);
            if (Fe() && He.lastWidth === He.startSize.width && He.lastHeight === He.startSize.height)
              return Oe("Not notifying: Size is the same as the start size, and there has been no notification yet.");
            if (He.lastWidth === He.lastNotifiedWidth && He.lastHeight === He.lastNotifiedHeight)
              return Oe("Not notifying: Size already notified");
            Oe("Current size not notified, notifying..."), He.lastNotifiedWidth = He.lastWidth, He.lastNotifiedHeight = He.lastHeight, KD(C(ye).listeners, function(Xe) {
              Xe(ye);
            });
          }
          function U() {
            if (Oe("startanimation triggered."), it(ye)) {
              Oe("Ignoring since element is still unrendered...");
              return;
            }
            Oe("Element rendered.");
            var Fe = j(ye), He = pe(ye);
            (Fe.scrollLeft === 0 || Fe.scrollTop === 0 || He.scrollLeft === 0 || He.scrollTop === 0) && (Oe("Scrollbars out of sync. Updating detector elements..."), gt(vn));
          }
          function ue() {
            if (Oe("Scroll detected."), it(ye)) {
              Oe("Scroll event fired while unrendered. Ignoring...");
              return;
            }
            gt(vn);
          }
          if (Oe("registerListenersAndPositionElements invoked."), !C(ye)) {
            Oe("Aborting because element has been uninstalled");
            return;
          }
          C(ye).onRendered = U, C(ye).onExpand = ue, C(ye).onShrink = ue;
          var q = C(ye).style;
          We(ye, q.width, q.height);
        }
        function gn() {
          if (Oe("finalizeDomMutation invoked."), !C(ye)) {
            Oe("Aborting because element has been uninstalled");
            return;
          }
          var We = C(ye).style;
          Ke(ye, We.width, We.height), Tt(ye, We.width, We.height);
        }
        function mi() {
          ze(ye);
        }
        function Hn() {
          Oe("Installing..."), ot(), kt(), o.add(0, Ue), o.add(1, Tn), o.add(2, Wt), o.add(3, gn), o.add(4, mi);
        }
        Oe("Making detectable..."), lt(ye) ? (Oe("Element is detached"), qt(), Oe("Waiting until element is attached..."), C(ye).onRendered = function() {
          Oe("Element is now attached"), Hn();
        }) : Hn();
      }
      function tt(Ee) {
        var ye = C(Ee);
        !ye || (ye.onExpandScroll && ee(j(Ee), "scroll", ye.onExpandScroll), ye.onShrinkScroll && ee(pe(Ee), "scroll", ye.onShrinkScroll), ye.onAnimationStart && ee(ye.container, "animationstart", ye.onAnimationStart), ye.container && Ee.removeChild(ye.container));
      }
      return { makeDetectable: Qe, addListener: at, uninstall: tt, initDocument: P };
    }, ma = ld.exports.forEach, XD = ID, qD = MD, JD = AD, QD = FD, ZD = LD, D0 = cd.exports, eN = jD, Or = WD, tN = YD, nN = GD;
    function N0(t) {
      return Array.isArray(t) || t.length !== void 0;
    }
    function B0(t) {
      if (Array.isArray(t))
        return t;
      var r = [];
      return ma(t, function(o) {
        r.push(o);
      }), r;
    }
    function P0(t) {
      return t && t.nodeType === 1;
    }
    var ho = function(t) {
      t = t || {};
      var r;
      if (t.idHandler)
        r = { get: function(Qe) {
          return t.idHandler.get(Qe, !0);
        }, set: t.idHandler.set };
      else {
        var o = JD(), C = QD({ idGenerator: o, stateHandler: Or });
        r = C;
      }
      var g = t.reporter;
      if (!g) {
        var a = g === !1;
        g = ZD(a);
      }
      var x = Dr(t, "batchProcessor", eN({ reporter: g })), O = {};
      O.callOnAdd = !!Dr(t, "callOnAdd", !0), O.debug = !!Dr(t, "debug", !1);
      var P = qD(r), N = XD({ stateHandler: Or }), B, H = Dr(t, "strategy", "object"), oe = Dr(t, "important", !1), se = { reporter: g, batchProcessor: x, stateHandler: Or, idHandler: r, important: oe };
      if (H === "scroll" && (D0.isLegacyOpera() ? (g.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy."), H = "object") : D0.isIE(9) && (g.warn("Scroll strategy is not supported on IE9. Changing to object strategy."), H = "object")), H === "scroll")
        B = nN(se);
      else if (H === "object")
        B = tN(se);
      else
        throw new Error("Invalid strategy name: " + H);
      var ee = {};
      function j(Qe, tt, Ee) {
        function ye(kt) {
          var ot = P.get(kt);
          ma(ot, function(Ue) {
            Ue(kt);
          });
        }
        function ze(kt, ot, Ue) {
          P.add(ot, Ue), kt && Ue(ot);
        }
        if (Ee || (Ee = tt, tt = Qe, Qe = {}), !tt)
          throw new Error("At least one element required.");
        if (!Ee)
          throw new Error("Listener required.");
        if (P0(tt))
          tt = [tt];
        else if (N0(tt))
          tt = B0(tt);
        else
          return g.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        var Oe = 0, lt = Dr(Qe, "callOnAdd", O.callOnAdd), it = Dr(Qe, "onReady", function() {
        }), Ze = Dr(Qe, "debug", O.debug);
        ma(tt, function(kt) {
          Or.getState(kt) || (Or.initState(kt), r.set(kt));
          var ot = r.get(kt);
          if (Ze && g.log("Attaching listener to element", ot, kt), !N.isDetectable(kt)) {
            if (Ze && g.log(ot, "Not detectable."), N.isBusy(kt)) {
              Ze && g.log(ot, "System busy making it detectable"), ze(lt, kt, Ee), ee[ot] = ee[ot] || [], ee[ot].push(function() {
                Oe++, Oe === tt.length && it();
              });
              return;
            }
            return Ze && g.log(ot, "Making detectable..."), N.markBusy(kt, !0), B.makeDetectable({ debug: Ze, important: oe }, kt, function(Ue) {
              if (Ze && g.log(ot, "onElementDetectable"), Or.getState(Ue)) {
                N.markAsDetectable(Ue), N.markBusy(Ue, !1), B.addListener(Ue, ye), ze(lt, Ue, Ee);
                var Ke = Or.getState(Ue);
                if (Ke && Ke.startSize) {
                  var qe = Ue.offsetWidth, mt = Ue.offsetHeight;
                  (Ke.startSize.width !== qe || Ke.startSize.height !== mt) && ye(Ue);
                }
                ee[ot] && ma(ee[ot], function(et) {
                  et();
                });
              } else
                Ze && g.log(ot, "Element uninstalled before being detectable.");
              delete ee[ot], Oe++, Oe === tt.length && it();
            });
          }
          Ze && g.log(ot, "Already detecable, adding listener."), ze(lt, kt, Ee), Oe++;
        }), Oe === tt.length && it();
      }
      function pe(Qe) {
        if (!Qe)
          return g.error("At least one element is required.");
        if (P0(Qe))
          Qe = [Qe];
        else if (N0(Qe))
          Qe = B0(Qe);
        else
          return g.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        ma(Qe, function(tt) {
          P.removeAllListeners(tt), B.uninstall(tt), Or.cleanState(tt);
        });
      }
      function at(Qe) {
        B.initDocument && B.initDocument(Qe);
      }
      return { listenTo: j, removeListener: P.removeListener, removeAllListeners: P.removeAllListeners, uninstall: pe, initDocument: at };
    };
    function Dr(t, r, o) {
      var C = t[r];
      return C == null && o !== void 0 ? o : C;
    }
    var V0 = "Expected a function", $0 = NaN, iN = "[object Symbol]", rN = /^\s+|\s+$/g, sN = /^[-+]0x[0-9a-f]+$/i, oN = /^0b[01]+$/i, aN = /^0o[0-7]+$/i, lN = parseInt, cN = typeof pt == "object" && pt && pt.Object === Object && pt, uN = typeof self == "object" && self && self.Object === Object && self, hN = cN || uN || Function("return this")(), dN = Object.prototype, fN = dN.toString, pN = Math.max, mN = Math.min, hd = function() {
      return hN.Date.now();
    };
    function gN(t, r, o) {
      var C, g, a, x, O, P, N = 0, B = !1, H = !1, oe = !0;
      if (typeof t != "function")
        throw new TypeError(V0);
      r = I0(r) || 0, Cc(o) && (B = !!o.leading, H = "maxWait" in o, a = H ? pN(I0(o.maxWait) || 0, r) : a, oe = "trailing" in o ? !!o.trailing : oe);
      function se(ze) {
        var Oe = C, lt = g;
        return C = g = void 0, N = ze, x = t.apply(lt, Oe), x;
      }
      function ee(ze) {
        return N = ze, O = setTimeout(at, r), B ? se(ze) : x;
      }
      function j(ze) {
        var Oe = ze - P, lt = ze - N, it = r - Oe;
        return H ? mN(it, a - lt) : it;
      }
      function pe(ze) {
        var Oe = ze - P, lt = ze - N;
        return P === void 0 || Oe >= r || Oe < 0 || H && lt >= a;
      }
      function at() {
        var ze = hd();
        if (pe(ze))
          return Qe(ze);
        O = setTimeout(at, j(ze));
      }
      function Qe(ze) {
        return O = void 0, oe && C ? se(ze) : (C = g = void 0, x);
      }
      function tt() {
        O !== void 0 && clearTimeout(O), N = 0, C = P = g = O = void 0;
      }
      function Ee() {
        return O === void 0 ? x : Qe(hd());
      }
      function ye() {
        var ze = hd(), Oe = pe(ze);
        if (C = arguments, g = this, P = ze, Oe) {
          if (O === void 0)
            return ee(P);
          if (H)
            return O = setTimeout(at, r), se(P);
        }
        return O === void 0 && (O = setTimeout(at, r)), x;
      }
      return ye.cancel = tt, ye.flush = Ee, ye;
    }
    function vN(t, r, o) {
      var C = !0, g = !0;
      if (typeof t != "function")
        throw new TypeError(V0);
      return Cc(o) && (C = "leading" in o ? !!o.leading : C, g = "trailing" in o ? !!o.trailing : g), gN(t, r, { leading: C, maxWait: r, trailing: g });
    }
    function Cc(t) {
      var r = typeof t;
      return !!t && (r == "object" || r == "function");
    }
    function yN(t) {
      return !!t && typeof t == "object";
    }
    function bN(t) {
      return typeof t == "symbol" || yN(t) && fN.call(t) == iN;
    }
    function I0(t) {
      if (typeof t == "number")
        return t;
      if (bN(t))
        return $0;
      if (Cc(t)) {
        var r = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = Cc(r) ? r + "" : r;
      }
      if (typeof t != "string")
        return t === 0 ? t : +t;
      t = t.replace(rN, "");
      var o = oN.test(t);
      return o || aN.test(t) ? lN(t.slice(2), o ? 2 : 8) : sN.test(t) ? $0 : +t;
    }
    var wc = vN;
    const CN = { name: "Grid", provide() {
      return { GridInstance: this };
    }, props: { col: { type: Number, default: 3 }, square: { type: Boolean, default: !1 }, padding: { type: String, default: "24px" }, center: { type: Boolean, default: !1 }, border: { type: Boolean, default: !0 }, hover: { type: Boolean, default: !1 } }, data() {
      return { resizeCount: 0, handleResize: () => {
      } };
    }, computed: { classes() {
      return { "ivu-grid-center": this.center, "ivu-grid-border": this.border, "ivu-grid-hover": this.hover };
    } }, methods: { onResize() {
      this.resizeCount++;
    } }, mounted() {
      this.handleResize = wc(this.onResize, 150, { leading: !1 }), this.observer = ho(), this.observer.listenTo(this.$refs.grid, this.handleResize);
    }, beforeUnmount() {
      this.observer.removeListener(this.$refs.grid, this.handleResize);
    } };
    function wN(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-grid", a.classes]), ref: "grid" }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var M0 = f(CN, [["render", wN]]);
    const kN = { name: "GridItem", inject: ["GridInstance"], data() {
      return { height: 0 };
    }, computed: { col() {
      return this.GridInstance.col;
    }, square() {
      return this.GridInstance.square;
    }, styles() {
      const t = { width: `${100 / this.col}%` };
      return this.height && this.square && (t.height = `${this.height}px`), t;
    }, mainStyles() {
      return { padding: this.GridInstance.padding };
    } }, watch: { col() {
      e.nextTick(() => {
        this.handleChangeHeight();
      });
    }, square() {
      this.handleChangeHeight();
    }, "GridInstance.resizeCount"() {
      this.handleChangeHeight();
    } }, methods: { handleChangeHeight() {
      if (this.square) {
        const t = this.$refs.col;
        this.height = parseFloat(Be(t, "width"));
      }
    } }, mounted() {
      this.handleChangeHeight();
    } };
    function SN(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: "ivu-grid-item", style: e.normalizeStyle(a.styles), ref: "col" }, [e.createElementVNode("div", { class: "ivu-grid-item-main", style: e.normalizeStyle(a.mainStyles) }, [e.renderSlot(t.$slots, "default")], 4)], 4);
    }
    var A0 = f(kN, [["render", SN]]);
    const EN = "ivu-layout", xN = { name: "Header", computed: { wrapClasses() {
      return `${EN}-header`;
    } } };
    function _N(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var dd = f(xN, [["render", _N]]);
    const ut = { MAC_ENTER: 3, BACKSPACE: 8, TAB: 9, NUM_CENTER: 12, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 44, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, QUESTION_MARK: 63, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, META: 91, WIN_KEY_RIGHT: 92, CONTEXT_MENU: 93, NUM_ZERO: 96, NUM_ONE: 97, NUM_TWO: 98, NUM_THREE: 99, NUM_FOUR: 100, NUM_FIVE: 101, NUM_SIX: 102, NUM_SEVEN: 103, NUM_EIGHT: 104, NUM_NINE: 105, NUM_MULTIPLY: 106, NUM_PLUS: 107, NUM_MINUS: 109, NUM_PERIOD: 110, NUM_DIVISION: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, NUMLOCK: 144, SEMICOLON: 186, DASH: 189, EQUALS: 187, COMMA: 188, PERIOD: 190, SLASH: 191, APOSTROPHE: 192, SINGLE_QUOTE: 222, OPEN_SQUARE_BRACKET: 219, BACKSLASH: 220, CLOSE_SQUARE_BRACKET: 221, WIN_KEY: 224, MAC_FF_META: 224, WIN_IME: 229, isTextModifyingKeyEvent(t) {
      const { keyCode: r } = t;
      if (t.altKey && !t.ctrlKey || t.metaKey || r >= ut.F1 && r <= ut.F12)
        return !1;
      switch (r) {
        case ut.ALT:
        case ut.CAPS_LOCK:
        case ut.CONTEXT_MENU:
        case ut.CTRL:
        case ut.DOWN:
        case ut.END:
        case ut.ESC:
        case ut.HOME:
        case ut.INSERT:
        case ut.LEFT:
        case ut.MAC_FF_META:
        case ut.META:
        case ut.NUMLOCK:
        case ut.NUM_CENTER:
        case ut.PAGE_DOWN:
        case ut.PAGE_UP:
        case ut.PAUSE:
        case ut.PRINT_SCREEN:
        case ut.RIGHT:
        case ut.SHIFT:
        case ut.UP:
        case ut.WIN_KEY:
        case ut.WIN_KEY_RIGHT:
          return !1;
        default:
          return !0;
      }
    }, isCharacterKey(t) {
      if (t >= ut.ZERO && t <= ut.NINE || t >= ut.NUM_ZERO && t <= ut.NUM_MULTIPLY || t >= ut.A && t <= ut.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
        return !0;
      switch (t) {
        case ut.SPACE:
        case ut.QUESTION_MARK:
        case ut.NUM_PLUS:
        case ut.NUM_MINUS:
        case ut.NUM_PERIOD:
        case ut.NUM_DIVISION:
        case ut.SEMICOLON:
        case ut.DASH:
        case ut.EQUALS:
        case ut.COMMA:
        case ut.PERIOD:
        case ut.SLASH:
        case ut.APOSTROPHE:
        case ut.SINGLE_QUOTE:
        case ut.OPEN_SQUARE_BRACKET:
        case ut.BACKSLASH:
        case ut.CLOSE_SQUARE_BRACKET:
          return !0;
        default:
          return !1;
      }
    } }, Nr = "ivu-spin", TN = { name: "Spin", mixins: [od], props: { size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, fix: { type: Boolean, default: !1 }, fullscreen: { type: Boolean, default: !1 }, show: { type: Boolean, default: !0 } }, data() {
      return { showText: !1, visible: !1 };
    }, computed: { classes() {
      return [`${Nr}`, { [`${Nr}-${this.size}`]: !!this.size, [`${Nr}-fix`]: this.fix, [`${Nr}-show-text`]: this.showText, [`${Nr}-fullscreen`]: this.fullscreen }];
    }, mainClasses() {
      return `${Nr}-main`;
    }, dotClasses() {
      return `${Nr}-dot`;
    }, textClasses() {
      return `${Nr}-text`;
    }, fullscreenVisible() {
      return this.fullscreen ? this.visible : !0;
    } }, watch: { visible(t) {
      t ? this.addScrollEffect() : this.removeScrollEffect();
    } }, mounted() {
      this.showText = !!this.$slots.default && this.$slots.default().some((t) => t.children && t.children.length);
    } };
    function ON(t, r, o, C, g, a) {
      return e.openBlock(), e.createBlock(e.Transition, { name: "fade" }, { default: e.withCtx(() => [a.fullscreenVisible && o.show ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { class: e.normalizeClass(a.mainClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.dotClasses) }, null, 2), e.createElementVNode("div", { class: e.normalizeClass(a.textClasses) }, [e.renderSlot(t.$slots, "default")], 2)], 2)], 2)) : e.createCommentVNode("", !0)]), _: 3 });
    }
    var ni = f(TN, [["render", ON]]);
    const DN = { name: "ImagePreview", mixins: [Kt], components: { Icon: G, Spin: ni, Row: Er, Col: Ii }, inheritAttrs: !1, emits: ["update:modelValue", "on-close", "on-switch"], props: { modelValue: { type: Boolean, default: !1 }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, maskClosable: { type: Boolean, default: !0 }, previewList: { type: Array, default() {
      return [];
    } }, initialIndex: { type: Number, default: 0 }, infinite: { type: Boolean, default: !0 }, toolbar: { type: Array, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || !t.$VIEWUI.image || t.$VIEWUI.image.toolbar === "" ? ["zoomIn", "zoomOut", "original", "rotateLeft", "rotateRight", "download"] : t.$VIEWUI.image.toolbar;
    } } }, data() {
      return { currentIndex: 0, scale: 1, degree: 0, translate: { x: 0, y: 0 }, startX: 0, startY: 0, transition: !0, original: !1, prevOverflow: "", status: "loading", zIndex: 1e3, maskIndex: this.getMaskIndex(), downloading: !1 };
    }, computed: { imgClasses() {
      return ["ivu-image-preview-image", { "ivu-image-preview-grabbing": !this.transition, "ivu-image-preview-hidden": this.status === "failed", "ivu-image-preview-transition": this.transition, "ivu-image-preview-limit": !this.original }];
    }, imageStyle() {
      let t = this.translate.x / this.scale, r = this.translate.y / this.scale;
      const o = this.degree % 360;
      return [90, -270].includes(o) && ([t, r] = [r, -t]), [180, -180].includes(o) && ([t, r] = [-t, -r]), [270, -90].includes(o) && ([t, r] = [-r, t]), { transform: `
                        scale(${this.scale})
                        rotate(${this.degree}deg)
                        translate(${t}px, ${r}px)
                    ` };
    }, maskStyle() {
      return { zIndex: this.maskIndex + this.zIndex };
    }, leftClasses() {
      return ["ivu-image-preview-arrow-left", { "ivu-image-preview-arrow-disabled": this.hasLeftSwitchEnd }];
    }, rightClasses() {
      return ["ivu-image-preview-arrow-right", { "ivu-image-preview-arrow-disabled": this.hasRightSwitchEnd }];
    }, hasRightSwitchEnd() {
      const { currentIndex: t, infinite: r, previewList: o } = this, C = o.length;
      return r ? !1 : t >= C - 1;
    }, hasLeftSwitchEnd() {
      const { currentIndex: t, infinite: r } = this;
      return r ? !1 : t === 0;
    }, currentSrc() {
      return this.previewList[this.currentIndex];
    }, failLang() {
      return this.t("i.image.fail");
    } }, methods: { resetStyle() {
      this.scale = 1, this.degree = 0, this.translate.x = 0, this.translate.y = 0;
    }, handleClose() {
      this.$emit("update:modelValue", !1), this.$emit("on-close");
    }, handleClickMask() {
      !this.maskClosable || this.handleClose();
    }, handleSwitch(t) {
      t ? this.currentIndex + 1 === this.previewList.length ? this.infinite && (this.resetStyle(), this.currentIndex = 0) : (this.resetStyle(), this.currentIndex += 1) : this.currentIndex === 0 ? this.infinite && (this.resetStyle(), this.currentIndex = this.previewList.length - 1) : (this.resetStyle(), this.currentIndex -= 1), this.$emit("on-switch", { currentIndex: this.currentIndex });
    }, handleOperation(t) {
      t === "zoomIn" && this.scale < 6 && (this.scale += 0.25), t === "zoomOut" && this.scale > 0.25 && (this.scale -= 0.25), t === "rotateLeft" && (this.degree -= 90), t === "rotateRight" && (this.degree += 90), t === "original" && (this.original = !this.original, this.transition = !1, this.resetStyle(), setTimeout(() => {
        this.transition = !0;
      }, 0)), t === "download" && (this.downloading = !0, Ye(this.previewList[this.currentIndex]).then(() => {
        this.downloading = !1;
      }).catch(() => {
        this.downloading = !1;
      }));
    }, handleKeydown(t) {
      if (!this.modelValue)
        return;
      const { keyCode: r } = t;
      r === ut.LEFT && this.handleSwitch(!1), r === ut.RIGHT && this.handleSwitch(!0), r === ut.UP && this.handleOperation("zoomIn"), r === ut.DOWN && this.handleOperation("zoomOut"), r === ut.SPACE && (t.preventDefault(), this.original = !this.original);
    }, handleKeyup(t) {
      if (!this.modelValue)
        return;
      const { keyCode: r } = t;
      r === ut.ESC && this.handleClose();
    }, handleWheel(t) {
      if (!this.modelValue)
        return;
      const { deltaY: r } = t;
      this.handleOperation(r < 0 ? "zoomIn" : "zoomOut");
    }, handleMousedown(t) {
      const { pageX: r, pageY: o, which: C } = t;
      C === 1 && (this.startX = r, this.startY = o, this.transition = !1, m(document, "mousemove", this.handleMousemove), m(document, "mouseup", this.handleMouseup));
    }, handleMousemove: wc(function(t) {
      t.stopPropagation();
      const { pageX: r, pageY: o } = t;
      this.translate.x += r - this.startX, this.translate.y += o - this.startY, this.startX = r, this.startY = o;
    }), handleMouseup() {
      this.transition = !0, b(document, "mousemove", this.handleMousemove), b(document, "mouseup", this.handleMouseup);
    }, getBodyOverflow() {
      return h ? document.body.style.overflow : "";
    }, setBodyOverflow(t) {
      !h || (document.body.style.overflow = t);
    }, handleImageLoad() {
      this.status = "loaded";
    }, handleImageError() {
      this.status = "failed";
    }, getMaskIndex() {
      return Vn(), Ut;
    } }, watch: { modelValue(t) {
      t ? (this.currentIndex = this.initialIndex, this.resetStyle(), this.original = !1, this.prevOverflow = this.getBodyOverflow(), this.setBodyOverflow("hidden"), this.maskIndex = this.getMaskIndex()) : this.setBodyOverflow(this.prevOverflow);
    }, currentIndex() {
      this.status = "loading";
    } }, mounted() {
      m(document, "keydown", this.handleKeydown), m(document, "keyup", this.handleKeyup), m(document, "wheel", this.handleWheel);
    }, beforeUnmount() {
      b(document, "keydown", this.handleKeydown), b(document, "keyup", this.handleKeyup), b(document, "wheel", this.handleWheel);
    } }, NN = { key: 1, class: "ivu-image-preview-fail" }, BN = ["src"], PN = [e.createElementVNode("path", { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z", "p-id": "7198", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M921 867L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z", "p-id": "7199", fill: "#ffffff" }, null, -1)], VN = [e.createElementVNode("path", { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z", "p-id": "7413", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M921 867L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z", "p-id": "7414", fill: "#ffffff" }, null, -1)], $N = [e.createElementVNode("path", { d: "M358.058667 128H156.970667A28.970667 28.970667 0 0 0 128 157.013333v202.837334c0 7.978667 6.528 14.506667 14.506667 14.506666h43.434666a14.506667 14.506667 0 0 0 14.506667-14.506666V200.448h157.610667a14.506667 14.506667 0 0 0 14.506666-14.506667V142.506667a14.506667 14.506667 0 0 0-14.506666-14.506667zM881.493333 649.642667h-43.434666a14.506667 14.506667 0 0 0-14.506667 14.506666v159.402667h-157.610667a14.506667 14.506667 0 0 0-14.506666 14.506667v43.434666c0 7.978667 6.570667 14.506667 14.506666 14.506667h201.088c16 0 28.970667-12.928 28.970667-29.013333v-202.837334a14.506667 14.506667 0 0 0-14.506667-14.506666zM358.058667 823.552H200.448v-159.402667a14.506667 14.506667 0 0 0-14.506667-14.506666H142.506667a14.506667 14.506667 0 0 0-14.506667 14.506666v202.88c0 16 12.970667 28.970667 29.013333 28.970667h201.045334a14.506667 14.506667 0 0 0 14.506666-14.506667v-43.434666a14.506667 14.506667 0 0 0-14.506666-14.506667zM866.986667 128h-201.088a14.506667 14.506667 0 0 0-14.506667 14.506667v43.434666c0 7.978667 6.570667 14.506667 14.506667 14.506667h157.610666v159.402667c0 7.978667 6.528 14.506667 14.506667 14.506666h43.434667a14.506667 14.506667 0 0 0 14.506666-14.506666V156.970667A28.928 28.928 0 0 0 866.986667 128z", "p-id": "26673", fill: "#ffffff" }, null, -1)], IN = [e.createElementVNode("path", { d: "M864 128H160c-19.2 0-32 12.8-32 32v704c0 19.2 12.8 32 32 32h704c19.2 0 32-12.8 32-32V160c0-19.2-12.8-32-32-32z m-32 704H192V192h640v640z", "p-id": "1977", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M320 384v288c0 19.2 12.8 32 32 32s32-12.8 32-32V352c0-19.2-12.8-32-32-32h-32c-19.2 0-32 12.8-32 32s12.8 32 32 32zM640 384v288c0 19.2 12.8 32 32 32s32-12.8 32-32V352c0-19.2-12.8-32-32-32h-32c-19.2 0-32 12.8-32 32s12.8 32 32 32z", "p-id": "1978", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M512 384m-32 0a32 32 0 1 0 64 0 32 32 0 1 0-64 0Z", "p-id": "1979", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M512 640m-32 0a32 32 0 1 0 64 0 32 32 0 1 0-64 0Z", "p-id": "1980", fill: "#ffffff" }, null, -1)], MN = [e.createElementVNode("path", { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32z m-44 402H188V494h440v326z m191.3-491.5c-78.8-100.7-196-153.6-314.6-154.2l-0.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7 0.4 12.6-6.1v-63.9c12.9 0.1 25.9 0.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8 11 40.7 14 82.7 8.9 124.8-0.7 5.4-1.4 10.8-2.4 16.1h74.9c14.8-103.6-11.3-213-81-302.3z", "p-id": "13309", fill: "#ffffff" }, null, -1)], AN = [e.createElementVNode("path", { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-0.4-12.6 6.1l-0.2 64c-118.6 0.5-235.8 53.4-314.6 154.2-69.6 89.2-95.7 198.6-81.1 302.4h74.9c-0.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8zM880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32z m-44 402H396V494h440v326z", "p-id": "13522", fill: "#ffffff" }, null, -1)], FN = [e.createElementVNode("path", { d: "M505.7 621c3.2 4.1 9.4 4.1 12.6 0l112-141.7c4.1-5.2 0.4-12.9-6.3-12.9h-72.1V120c0-4.4-3.6-8-8-8h-64c-4.4 0-8 3.6-8 8v346.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8z", "p-id": "8826", fill: "#ffffff" }, null, -1), e.createElementVNode("path", { d: "M903 516h-64c-4.4 0-8 3.6-8 8v300c0 4.4-3.6 8-8 8H199c-4.4 0-8-3.6-8-8V524c0-4.4-3.6-8-8-8h-64c-4.4 0-8 3.6-8 8v372c0 8.8 7.2 16 16 16h768c8.8 0 16-7.2 16-16V524c0-4.4-3.6-8-8-8z", "p-id": "8827", fill: "#ffffff" }, null, -1)], LN = { class: "ivu-image-preview-operations-item ivu-image-preview-operations-wait ivu-anim-loop", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "7816", width: "200", height: "200" }, zN = [e.createElementVNode("path", { d: "M512 64c247.2 0 448 200.8 448 448h-64c0-212-172-384-384-384V64z m0 832c-212 0-384-172-384-384H64c0 247.2 200.8 448 448 448v-64z", "p-id": "7817", fill: "#ffffff" }, null, -1)];
    function RN(t, r, o, C, g, a) {
      const x = e.resolveComponent("Spin"), O = e.resolveComponent("Col"), P = e.resolveComponent("Row"), N = e.resolveComponent("Icon");
      return e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [o.modelValue ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-image-preview-mask", style: e.normalizeStyle(a.maskStyle) }, null, 4)) : e.createCommentVNode("", !0)]), _: 1 }), e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [o.modelValue ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-image-preview-wrap", style: e.normalizeStyle(a.maskStyle) }, [e.createElementVNode("div", e.mergeProps({ class: "ivu-image-preview" }, t.$attrs, { onClick: r[14] || (r[14] = e.withModifiers((...B) => a.handleClickMask && a.handleClickMask(...B), ["stop"])) }), [g.status === "loading" ? (e.openBlock(), e.createBlock(x, { key: 0, size: "large", class: "ivu-image-preview-loading" })) : g.status === "failed" ? (e.openBlock(), e.createElementBlock("div", NN, [e.createElementVNode("span", null, e.toDisplayString(a.failLang), 1)])) : e.createCommentVNode("", !0), (e.openBlock(), e.createElementBlock("img", { class: e.normalizeClass(a.imgClasses), style: e.normalizeStyle(a.imageStyle), src: a.currentSrc, key: g.currentIndex.toString(), onClick: r[0] || (r[0] = e.withModifiers(() => {
      }, ["stop"])), onMousedown: r[1] || (r[1] = e.withModifiers((...B) => a.handleMousedown && a.handleMousedown(...B), ["stop", "prevent"])), onLoad: r[2] || (r[2] = (...B) => a.handleImageLoad && a.handleImageLoad(...B)), onError: r[3] || (r[3] = (...B) => a.handleImageError && a.handleImageError(...B)) }, null, 46, BN)), o.toolbar && o.toolbar.length > 0 ? (e.openBlock(), e.createBlock(P, { key: 2, "class-name": "ivu-image-preview-operations", wrap: !1, onClick: r[11] || (r[11] = e.withModifiers(() => {
      }, ["stop"])) }, { default: e.withCtx(() => [o.toolbar.indexOf("zoomIn") > -1 ? (e.openBlock(), e.createBlock(O, { key: 0, flex: "1", order: o.toolbar.indexOf("zoomIn") + 1 }, { default: e.withCtx(() => [(e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[4] || (r[4] = e.withModifiers((B) => a.handleOperation("zoomIn"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "7197", width: "200", height: "200" }, PN))]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0), o.toolbar.indexOf("zoomOut") > -1 ? (e.openBlock(), e.createBlock(O, { key: 1, flex: "1", order: o.toolbar.indexOf("zoomOut") + 1 }, { default: e.withCtx(() => [(e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[5] || (r[5] = e.withModifiers((B) => a.handleOperation("zoomOut"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "7412", width: "200", height: "200" }, VN))]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0), o.toolbar.indexOf("original") > -1 ? (e.openBlock(), e.createBlock(O, { key: 2, flex: "1", order: o.toolbar.indexOf("original") + 1 }, { default: e.withCtx(() => [e.withDirectives((e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[6] || (r[6] = e.withModifiers((B) => a.handleOperation("original"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "26672", width: "200", height: "200" }, $N, 512)), [[e.vShow, !this.original]]), e.withDirectives((e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[7] || (r[7] = e.withModifiers((B) => a.handleOperation("original"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "1976", width: "200", height: "200" }, IN, 512)), [[e.vShow, this.original]])]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0), o.toolbar.indexOf("rotateLeft") > -1 ? (e.openBlock(), e.createBlock(O, { key: 3, flex: "1", order: o.toolbar.indexOf("rotateLeft") + 1 }, { default: e.withCtx(() => [(e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[8] || (r[8] = e.withModifiers((B) => a.handleOperation("rotateLeft"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "13308", width: "200", height: "200" }, MN))]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0), o.toolbar.indexOf("rotateRight") > -1 ? (e.openBlock(), e.createBlock(O, { key: 4, flex: "1", order: o.toolbar.indexOf("rotateRight") + 1 }, { default: e.withCtx(() => [(e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[9] || (r[9] = e.withModifiers((B) => a.handleOperation("rotateRight"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "13521", width: "200", height: "200" }, AN))]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0), o.toolbar.indexOf("download") > -1 ? (e.openBlock(), e.createBlock(O, { key: 5, flex: "1", order: o.toolbar.indexOf("download") + 1 }, { default: e.withCtx(() => [e.withDirectives((e.openBlock(), e.createElementBlock("svg", { class: "ivu-image-preview-operations-item", onClick: r[10] || (r[10] = e.withModifiers((B) => a.handleOperation("download"), ["stop"])), viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "8825", width: "200", height: "200" }, FN, 512)), [[e.vShow, !g.downloading]]), e.withDirectives((e.openBlock(), e.createElementBlock("svg", LN, zN, 512)), [[e.vShow, g.downloading]])]), _: 1 }, 8, ["order"])) : e.createCommentVNode("", !0)]), _: 1 })) : e.createCommentVNode("", !0), o.previewList.length > 1 ? (e.openBlock(), e.createBlock(N, { key: 3, class: e.normalizeClass(a.leftClasses), type: "ios-arrow-back", onClick: r[12] || (r[12] = e.withModifiers((B) => a.handleSwitch(!1), ["stop"])) }, null, 8, ["class"])) : e.createCommentVNode("", !0), o.previewList.length > 1 ? (e.openBlock(), e.createBlock(N, { key: 4, class: e.normalizeClass(a.rightClasses), type: "ios-arrow-forward", onClick: r[13] || (r[13] = e.withModifiers((B) => a.handleSwitch(!0), ["stop"])) }, null, 8, ["class"])) : e.createCommentVNode("", !0), e.createVNode(N, { class: "ivu-image-preview-arrow-close", type: "md-close", onClick: e.withModifiers(a.handleClose, ["stop"]) }, null, 8, ["onClick"])], 16)], 4)) : e.createCommentVNode("", !0)]), _: 1 })], 8, ["disabled"]);
    }
    var Br = f(DN, [["render", RN]]);
    const jN = (t) => typeof HTMLElement == "object" && t instanceof HTMLElement, HN = { name: "Image", mixins: [Kt], components: { ImagePreview: Br }, emits: ["on-load", "on-error", "on-switch", "on-close", "on-click"], props: { src: { type: String, default: "" }, alt: { type: String, default: "" }, preview: { type: Boolean, default: !1 }, referrerPolicy: { type: String, default: "" }, width: { type: [String, Number], default: "" }, height: { type: [String, Number], default: "" }, fit: { type: String, default: "" }, lazy: { type: Boolean, default: !1 }, scrollContainer: { type: [String], default: "" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, maskClosable: { type: Boolean, default: !0 }, previewList: { type: Array }, infinite: { type: Boolean, default: !0 }, initialIndex: { type: Number, default: 0 }, previewTip: { type: Boolean, default: !0 }, toolbar: { type: Array, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || !t.$VIEWUI.image || t.$VIEWUI.image.toolbar === "" ? ["zoomIn", "zoomOut", "original", "rotateLeft", "rotateRight", "download"] : t.$VIEWUI.image.toolbar;
    } } }, data() {
      return { loadingImage: !1, loading: !1, imageError: !1, scrollElement: null, observer: null, imagePreviewModal: !1 };
    }, watch: { src() {
      this.loadImage();
    } }, computed: { innerClasses() {
      return ["ivu-image-inner", { "ivu-image-cursor": this.preview }];
    }, imgClasses() {
      return ["ivu-image-img", { "ivu-image-img-hidden": this.loading || this.imageError }];
    }, fitStyle() {
      const t = ["fill", "contain", "cover", "none", "scale-down"], { fit: r } = this;
      return t.includes(r) ? `object-fit:${r};` : "";
    }, imageStyles() {
      return { width: typeof this.width == "number" ? `${this.width}px` : this.width, height: typeof this.height == "number" ? `${this.height}px` : this.height };
    }, loadingLang() {
      return this.t("i.select.loading");
    }, failLang() {
      return this.t("i.image.fail");
    }, previewLang() {
      return this.t("i.image.preview");
    }, loadingType() {
      return this.lazy ? "lazy" : "eager";
    } }, mounted() {
      h && this.handleImageEvent();
    }, methods: { handleLazy() {
      const t = this.$refs.image;
      (this.observer = new IntersectionObserver(this.handlerObserveImage, { root: this.scrollElement, rootMargin: "0px", threshold: 0 })).observe(t);
    }, handlerObserveImage(t) {
      for (let r of t)
        r.isIntersecting && (this.offObserver(), this.loadImage());
    }, addLazyImageListener() {
      const { scrollContainer: t } = this;
      this.scrollElement = null, jN(t) ? this.scrollElement = t : t && typeof t == "string" && (this.scrollElement = document.querySelector(t)), this.handleLazy();
    }, handleImageLoad() {
      this.loading = !1, this.imageError = !1, this.$emit("on-load");
    }, handleImageError() {
      this.loading = !1, this.imageError = !0, this.loadingImage = !1, this.$emit("on-error");
    }, loadImage() {
      this.loading = !0, this.imageError = !1, this.loadingImage = !0;
    }, handleImageEvent() {
      const { lazy: t } = this;
      t ? this.addLazyImageListener() : this.loadImage();
    }, offObserver() {
      const { observer: t } = this;
      t && t.disconnect();
    }, handlePreview() {
      const { preview: t, initialIndex: r } = this;
      t && (this.imagePreviewModal = !0, this.$emit("on-click", { initialIndex: r }));
    }, handleClose() {
      this.$emit("on-close");
    }, handleSwitch(t) {
      this.$emit("on-switch", t);
    } }, beforeUnmount() {
      this.offObserver();
    } }, UN = { key: 0, class: "ivu-image-placeholder" }, WN = { key: 1, class: "ivu-image-error" }, YN = ["alt", "src", "loading", "referrerPolicy"], KN = { class: "ivu-image-mark" };
    function GN(t, r, o, C, g, a) {
      const x = e.resolveComponent("ImagePreview");
      return e.openBlock(), e.createElementBlock("div", { class: "ivu-image", ref: "image", style: e.normalizeStyle(a.imageStyles) }, [g.loading ? (e.openBlock(), e.createElementBlock("div", UN, [e.renderSlot(t.$slots, "placeholder", {}, () => [e.createElementVNode("span", null, e.toDisplayString(a.loadingLang), 1)])])) : g.imageError ? (e.openBlock(), e.createElementBlock("div", WN, [e.renderSlot(t.$slots, "error", {}, () => [e.createElementVNode("span", null, e.toDisplayString(a.failLang), 1)])])) : e.createCommentVNode("", !0), g.loadingImage ? (e.openBlock(), e.createElementBlock("div", { key: 2, class: e.normalizeClass(a.innerClasses), onClick: r[2] || (r[2] = (...O) => a.handlePreview && a.handlePreview(...O)) }, [e.createElementVNode("img", { class: e.normalizeClass(a.imgClasses), style: e.normalizeStyle([a.fitStyle]), alt: o.alt, src: o.src, loading: a.loadingType, referrerPolicy: o.referrerPolicy, onLoad: r[0] || (r[0] = (...O) => a.handleImageLoad && a.handleImageLoad(...O)), onError: r[1] || (r[1] = (...O) => a.handleImageError && a.handleImageError(...O)) }, null, 46, YN), o.preview && o.previewTip ? e.renderSlot(t.$slots, "preview", { key: 0 }, () => [e.createElementVNode("div", KN, [e.createElementVNode("span", null, e.toDisplayString(a.previewLang), 1)])]) : e.createCommentVNode("", !0)], 2)) : e.createCommentVNode("", !0), o.preview ? (e.openBlock(), e.createBlock(x, { key: 3, modelValue: g.imagePreviewModal, "onUpdate:modelValue": r[3] || (r[3] = (O) => g.imagePreviewModal = O), "preview-list": o.previewList, "initial-index": o.initialIndex, infinite: o.infinite, "mask-closable": o.maskClosable, transfer: o.transfer, toolbar: o.toolbar, onOnClose: a.handleClose, onOnSwitch: a.handleSwitch }, null, 8, ["modelValue", "preview-list", "initial-index", "infinite", "mask-closable", "transfer", "toolbar", "onOnClose", "onOnSwitch"])) : e.createCommentVNode("", !0)], 4);
    }
    var F0 = f(HN, [["render", GN]]);
    Br.newInstance = (t) => {
      if (!h)
        return;
      const r = t || {};
      let o = null;
      const C = e.createApp({ data() {
        return Object.assign({}, r, { visible: !1, previewList: [], initialIndex: 0, toolbar: ["zoomIn", "zoomOut", "original", "rotateLeft", "rotateRight", "download"], infinite: !0, maskClosable: !0, transfer: !0 });
      }, render() {
        return e.h(Br, Object.assign({}, r, { ref: "imagePreview", modelValue: this.visible, previewList: this.previewList, initialIndex: this.initialIndex, toolbar: this.toolbar, infinite: this.infinite, maskClosable: this.maskClosable, transfer: this.transfer, "onOn-close": this.close }));
      }, methods: { close() {
        this.visible = !1, setTimeout(() => {
          this.destroy(), this.onRemove();
        }, 300);
      }, destroy() {
        C.unmount(), document.body.removeChild(g);
      }, onRemove() {
      } }, created() {
        o = e.getCurrentInstance();
      } }), g = document.createElement("div");
      document.body.appendChild(g), C.mount(g);
      const a = o.refs.imagePreview;
      return { show(x) {
        Object.keys(x).forEach((O) => {
          a.$parent[O] = x[O];
        }), a.$parent.visible = !0;
      }, component: a };
    };
    let kc;
    function XN() {
      return kc = kc || Br.newInstance(), kc;
    }
    Br.show = function(t = {}) {
      const r = XN();
      t.onRemove = function() {
        kc = null;
      }, r.show(t);
    };
    const In = "ivu-input-number", Sc = "ivu-icon";
    function Ec(t, r) {
      let o, C, g;
      try {
        o = t.toString().split(".")[1].length;
      } catch {
        o = 0;
      }
      try {
        C = r.toString().split(".")[1].length;
      } catch {
        C = 0;
      }
      return g = Math.pow(10, Math.max(o, C)), (Math.round(t * g) + Math.round(r * g)) / g;
    }
    const qN = { name: "InputNumber", mixins: [nn], emits: ["on-change", "on-focus", "on-blur", "update:modelValue"], props: { max: { type: Number, default: 1 / 0 }, min: { type: Number, default: -1 / 0 }, step: { type: Number, default: 1 }, activeChange: { type: Boolean, default: !0 }, modelValue: { type: Number, default: 1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, disabled: { type: Boolean, default: !1 }, autofocus: { type: Boolean, default: !1 }, readonly: { type: Boolean, default: !1 }, editable: { type: Boolean, default: !0 }, name: { type: String }, precision: { type: Number }, elementId: { type: String }, formatter: { type: Function }, parser: { type: Function }, placeholder: { type: String, default: "" }, controlsOutside: { type: Boolean, default: !1 } }, data() {
      return { focused: !1, upDisabled: !1, downDisabled: !1, currentValue: this.modelValue };
    }, computed: { wrapClasses() {
      return [`${In}`, { [`${In}-${this.size}`]: !!this.size, [`${In}-disabled`]: this.itemDisabled, [`${In}-focused`]: this.focused, [`${In}-controls-outside`]: this.controlsOutside }];
    }, handlerClasses() {
      return `${In}-handler-wrap`;
    }, upClasses() {
      return [`${In}-handler`, `${In}-handler-up`, { [`${In}-handler-up-disabled`]: this.upDisabled }];
    }, innerUpClasses() {
      return `${In}-handler-up-inner ${Sc} ${Sc}-ios-arrow-up`;
    }, downClasses() {
      return [`${In}-handler`, `${In}-handler-down`, { [`${In}-handler-down-disabled`]: this.downDisabled }];
    }, innerDownClasses() {
      return `${In}-handler-down-inner ${Sc} ${Sc}-ios-arrow-down`;
    }, inputWrapClasses() {
      return `${In}-input-wrap`;
    }, inputClasses() {
      return `${In}-input`;
    }, precisionValue() {
      return this.currentValue ? this.precision ? this.currentValue.toFixed(this.precision) : this.currentValue : this.currentValue;
    }, formatterValue() {
      return this.formatter && this.precisionValue !== null ? this.formatter(this.precisionValue) : this.precisionValue;
    } }, methods: { preventDefault(t) {
      t.preventDefault();
    }, up(t) {
      const r = Number(t.target.value);
      if (this.upDisabled && isNaN(r))
        return !1;
      this.changeStep("up", t);
    }, down(t) {
      const r = Number(t.target.value);
      if (this.downDisabled && isNaN(r))
        return !1;
      this.changeStep("down", t);
    }, changeStep(t, r) {
      if (this.itemDisabled || this.readonly)
        return !1;
      const o = Number(r.target.value);
      let C = Number(this.currentValue);
      const g = Number(this.step);
      if (isNaN(C))
        return !1;
      if (!isNaN(o)) {
        if (t === "up")
          if (Ec(o, g) <= this.max)
            C = o;
          else
            return !1;
        else if (t === "down")
          if (Ec(o, -g) >= this.min)
            C = o;
          else
            return !1;
      }
      t === "up" ? C = Ec(C, g) : t === "down" && (C = Ec(C, -g)), this.setValue(C);
    }, setValue(t) {
      t && !isNaN(this.precision) && (t = Number(Number(t).toFixed(this.precision)));
      const { min: r, max: o } = this;
      t !== null && (t > o ? t = o : t < r && (t = r)), e.nextTick(() => {
        this.currentValue = t, this.$emit("update:modelValue", t), this.$emit("on-change", t), this.handleFormItemChange("change", t);
      });
    }, focus(t) {
      this.focused = !0, this.$emit("on-focus", t);
    }, blur() {
      this.focused = !1, this.$emit("on-blur"), me(this, ["DatePicker", "TimePicker", "Cascader", "Search"]) || this.handleFormItemChange("blur", this.currentValue);
    }, keyDown(t) {
      t.keyCode === 38 ? (t.preventDefault(), this.up(t)) : t.keyCode === 40 && (t.preventDefault(), this.down(t));
    }, change(t) {
      if (t.type === "change" && this.activeChange || t.type === "input" && !this.activeChange)
        return;
      let r = t.target.value.trim();
      if (this.parser && (r = this.parser(r)), r.length === 0) {
        this.setValue(null);
        return;
      }
      t.type === "input" && r.match(/^\-?\.?$|\.$/) || (r = Number(r), isNaN(r) ? t.target.value = this.currentValue : (this.currentValue = r, this.setValue(r)));
    }, changeVal(t) {
      if (t = Number(t), isNaN(t))
        this.upDisabled = !0, this.downDisabled = !0;
      else {
        const r = this.step;
        this.upDisabled = t + r > this.max, this.downDisabled = t - r < this.min;
      }
    } }, mounted() {
      this.changeVal(this.currentValue);
    }, watch: { modelValue(t) {
      this.currentValue = t;
    }, currentValue(t) {
      this.changeVal(t);
    }, min() {
      this.changeVal(this.currentValue);
    }, max() {
      this.changeVal(this.currentValue);
    } } }, JN = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-remove" }, null, -1)], QN = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-add" }, null, -1)], ZN = ["id", "disabled", "autofocus", "readonly", "name", "value", "placeholder"];
    function eB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [o.controlsOutside ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.handlerClasses) }, [e.createElementVNode("a", { onClick: r[1] || (r[1] = (...x) => a.up && a.up(...x)), class: e.normalizeClass(a.upClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.innerUpClasses), onClick: r[0] || (r[0] = (...x) => a.preventDefault && a.preventDefault(...x)) }, null, 2)], 2), e.createElementVNode("a", { onClick: r[3] || (r[3] = (...x) => a.down && a.down(...x)), class: e.normalizeClass(a.downClasses) }, [e.createElementVNode("span", { class: e.normalizeClass(a.innerDownClasses), onClick: r[2] || (r[2] = (...x) => a.preventDefault && a.preventDefault(...x)) }, null, 2)], 2)], 2)), o.controlsOutside ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass(["ivu-input-number-controls-outside-btn ivu-input-number-controls-outside-down", { "ivu-input-number-controls-outside-btn-disabled": g.downDisabled }]), onClick: r[4] || (r[4] = (...x) => a.down && a.down(...x)) }, JN, 2)) : e.createCommentVNode("", !0), o.controlsOutside ? (e.openBlock(), e.createElementBlock("div", { key: 2, class: e.normalizeClass(["ivu-input-number-controls-outside-btn ivu-input-number-controls-outside-up", { "ivu-input-number-controls-outside-btn-disabled": g.upDisabled }]), onClick: r[5] || (r[5] = (...x) => a.up && a.up(...x)) }, QN, 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass(a.inputWrapClasses) }, [e.createElementVNode("input", { id: o.elementId, class: e.normalizeClass(a.inputClasses), disabled: t.itemDisabled, autocomplete: "off", spellcheck: "false", autofocus: o.autofocus, onFocus: r[6] || (r[6] = (...x) => a.focus && a.focus(...x)), onBlur: r[7] || (r[7] = (...x) => a.blur && a.blur(...x)), onKeydown: r[8] || (r[8] = e.withModifiers((...x) => a.keyDown && a.keyDown(...x), ["stop"])), onInput: r[9] || (r[9] = (...x) => a.change && a.change(...x)), onMouseup: r[10] || (r[10] = (...x) => a.preventDefault && a.preventDefault(...x)), onChange: r[11] || (r[11] = (...x) => a.change && a.change(...x)), readonly: o.readonly || !o.editable, name: o.name, value: a.formatterValue, placeholder: o.placeholder }, null, 42, ZN)], 2)], 2);
    }
    var fd = f(qN, [["render", eB]]);
    const L0 = "ivu-layout", tB = { name: "Layout", data() {
      return { hasSider: !1 };
    }, computed: { wrapClasses() {
      return [`${L0}`, { [`${L0}-has-sider`]: this.hasSider }];
    } }, methods: { findSider() {
      return this.$slots.default().some((t) => t.type.name === "Sider");
    } }, mounted() {
      this.hasSider = this.findSider();
    } };
    function nB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var z0 = f(tB, [["render", nB]]);
    const R0 = { tooltips: ["复制", "复制成功"], showTip: !1, successTip: "复制成功", errorTip: "复制失败" }, j0 = { tooltip: "编辑", editing: !1, maxlength: "", autosize: !0, triggerType: "icon" }, H0 = { rows: 1, tooltip: !1, suffix: !1, expandable: !1, symbol: "展开" };
    var ga = { emits: ["update:modelValue"], mixins: [je], props: { type: { validator(t) {
      return z(t, ["secondary", "success", "warning", "danger", ""]);
    }, default: "" }, copyable: { type: Boolean, default: !1 }, copyText: { type: String, default: "" }, copyConfig: { type: Object, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.typography.copyConfig === "" ? R0 : t.$VIEWUI.typography.copyConfig;
    } }, editable: { type: Boolean, default: !1 }, editConfig: { type: Object, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.typography.editConfig === "" ? j0 : t.$VIEWUI.typography.editConfig;
    } }, ellipsis: { type: Boolean, default: !1 }, ellipsisConfig: { type: Object, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.typography.ellipsisConfig === "" ? H0 : t.$VIEWUI.typography.ellipsisConfig;
    } }, disabled: { type: Boolean, default: !1 }, code: { type: Boolean, default: !1 }, delete: { type: Boolean, default: !1 }, keyboard: { type: Boolean, default: !1 }, mark: { type: Boolean, default: !1 }, strong: { type: Boolean, default: !1 }, underline: { type: Boolean, default: !1 }, italic: { type: Boolean, default: !1 }, modelValue: { type: String, default: "" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, theme: { validator(t) {
      return z(t, ["dark", "light"]);
    }, default: "dark" }, maxWidth: { type: [String, Number], default: 250 }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "top" } }, computed: { isHrefPattern() {
      const { to: t } = this;
      return !!t;
    }, linkProps() {
      if (this.isHrefPattern) {
        const { linkUrl: t, target: r } = this;
        return { href: t, target: r };
      } else
        return {};
    }, mergedCopyConfig() {
      return Object.assign({}, R0, this.copyConfig);
    }, mergedEditConfig() {
      return Object.assign({}, j0, this.editConfig);
    }, mergedEllipsisConfig() {
      return Object.assign({}, H0, this.ellipsisConfig);
    } }, methods: { commonSlots() {
      const t = {};
      return this.$slots.default && (t.default = () => this.$slots.default()), this.$slots.copyIcon && (t.copyIcon = (r) => this.$slots.copyIcon(r)), this.$slots.editIcon && (t.editIcon = (r) => this.$slots.editIcon(r)), this.$slots.enterIcon && (t.enterIcon = (r) => this.$slots.enterIcon(r)), t;
    }, commonEvents() {
      return { "onUpdate:modelValue": this.handleOnUpdateModelValue };
    }, handleOnUpdateModelValue(t) {
      this.$emit("update:modelValue", t);
    } } };
    const xc = { name: "TypographyBase", mixins: [ga], emits: ["on-copy-success", "on-copy-error", "on-edit-start", "on-edit-end", "on-edit-change", "on-edit-cancel"], props: { component: { type: String, default: "div" }, level: { type: Number, default: 0 } }, data() {
      return { currentContent: this.modelValue, copied: !1, copyTimeout: null, editing: !1, editContent: "", lastKeyCode: "", isEditESC: !1, ellipsisText: "", ellipsisContent: "", isEllipsis: !1, ellipsisExpanded: !1, observer: null };
    }, created() {
      this.editing = this.mergedEditConfig.editing || !1, this.editing && (this.editContent = this.currentContent ? this.currentContent : this.handleGetContent());
    }, watch: { modelValue(t) {
      this.currentContent = t;
    }, editing(t) {
      t || e.nextTick(() => {
        this.handleRemoveObserver(), this.handleCreateObserver();
      });
    }, isEllipsis() {
      e.nextTick(() => {
        this.handleRemoveObserver(), this.handleCreateObserver();
      });
    }, ellipsis: { handler(t) {
      t ? e.nextTick(() => {
        this.handleUpdateEllipsisStatus(), this.handleCreateObserver();
      }) : this.handleRemoveObserver();
    }, immediate: !0 } }, computed: { classes() {
      return ["ivu-typography", { [`ivu-typography-${this.type}`]: this.type, "ivu-typography-disabled": this.disabled, "ivu-typography-ellipsis-line-clamp": this.ellipsis && !this.ellipsisExpanded, "ivu-typography-ellipsis-single-line": this.ellipsis && !this.ellipsisExpanded && this.mergedEllipsisConfig.rows === 1 }];
    } }, methods: { wrapperDecorations() {
      let t = this.currentContent ? this.currentContent : this.$slots.default ? this.$slots.default() : "";
      function r(o, C) {
        !o || (t = e.h(C, t));
      }
      return r(this.strong, "strong"), r(this.underline, "u"), r(this.delete, "del"), r(this.code, "code"), r(this.mark, "mark"), r(this.keyboard, "kbd"), r(this.italic, "i"), t;
    }, handleClickContent(t) {
      if (!this.isHrefPattern && this.component !== "a") {
        const r = this.mergedEditConfig.triggerType;
        this.editable && (r === "text" || r === "both") && this.handleEdit();
      } else {
        const r = t.ctrlKey || t.metaKey;
        this.handleCheckClick(t, r);
      }
    }, handleGetContent() {
      const t = document.createElement("div");
      document.body.appendChild(t);
      let r = null, o = null, C = "";
      const g = this.wrapperDecorations();
      return r = e.createApp({ render() {
        return e.h("div", { ref: "text", style: { display: "none" } }, g);
      }, created() {
        o = e.getCurrentInstance();
      } }), r.mount(t), C = o.refs.text.innerText, r.unmount(), document.body.removeChild(t), C;
    }, handleCopy() {
      let t = "";
      this.copyText ? t = this.copyText : this.currentContent ? t = this.currentContent : this.$slots.default && (t = this.handleGetContent()), lc({ text: this.copyText ? this.copyText : t, showTip: this.mergedCopyConfig.showTip, successTip: this.mergedCopyConfig.successTip, errorTip: this.mergedCopyConfig.errorTip, success: () => {
        this.$emit("on-copy-success"), this.copied = !0, this.copyTimeout && clearTimeout(this.copyTimeout), this.copyTimeout = setTimeout(() => {
          this.copied = !1;
        }, 3e3);
      }, error: () => {
        this.$emit("on-copy-error");
      } });
    }, handleEdit() {
      this.editContent = this.currentContent ? this.currentContent : this.handleGetContent(), e.nextTick(() => {
        this.editing = !0, this.$emit("on-edit-start"), e.nextTick(() => {
          this.$refs.edit.focus({ cursor: "end" });
        });
      });
    }, handleEditBlur() {
      if (this.isEditESC) {
        this.isEditESC = !1;
        return;
      }
      this.handleEditSave(), this.$emit("on-edit-end", this.editContent);
    }, handleEditChange(t) {
      const r = t.target.value;
      this.editContent = r, this.$emit("on-edit-change", r);
    }, handleEditSave() {
      this.$emit("update:modelValue", this.editContent), this.editing = !1;
    }, handleEditKeydown(t) {
      const { keyCode: r } = t;
      r === ut.ENTER && t.preventDefault(), this.lastKeyCode = r;
    }, handleEditKeyup(t) {
      const { keyCode: r, ctrlKey: o, altKey: C, metaKey: g, shiftKey: a } = t;
      this.lastKeyCode === r && !o && !C && !g && !a && (r === ut.ENTER ? (this.handleEditSave(), this.$emit("on-edit-end", this.editContent)) : r === ut.ESC && (this.isEditESC = !0, this.$emit("on-edit-cancel"), this.editing = !1));
    }, handleUpdateEllipsisStatus() {
      if (this.ellipsis && !this.ellipsisExpanded) {
        const t = this.$refs.typography;
        this.isEllipsis = t.scrollHeight > t.clientHeight;
      } else
        this.isEllipsis = !1;
    }, handleCreateObserver() {
      this.ellipsis && !this.ellipsisExpanded && (this.observer = ho(), this.observer.listenTo(this.$refs.typography, this.handleUpdateEllipsisStatus));
    }, handleRemoveObserver() {
      this.observer && (this.observer.removeListener(this.$refs.typography, this.handleUpdateEllipsisStatus), this.observer = null);
    } }, render() {
      let t = [];
      const r = this.wrapperDecorations();
      if (t.push(r), this.editable) {
        const o = this.mergedEditConfig.triggerType;
        if (o === "icon" || o === "both") {
          const C = this.$slots.editIcon ? this.$slots.editIcon() : e.h(G, { type: "md-create" }), g = e.h("div", { class: "ivu-typography-edit", onClick: this.handleEdit }, C);
          if (this.mergedEditConfig.tooltip) {
            const a = e.h(tr, { content: this.mergedEditConfig.tooltip, placement: "top" }, () => g);
            t.push(a);
          } else
            t.push(g);
        }
      }
      if (this.copyable) {
        const o = this.$slots.copyIcon ? this.$slots.copyIcon({ copied: this.copied }) : e.h(G, { type: this.copied ? "md-checkmark" : "md-copy" }), C = e.h("div", { class: ["ivu-typography-copy", { "ivu-typography-copy-success": this.copied }], onClick: this.handleCopy }, o);
        if (this.mergedCopyConfig.tooltips instanceof Array && this.mergedCopyConfig.tooltips.length === 2) {
          const g = e.h(tr, { content: this.copied ? this.mergedCopyConfig.tooltips[1] : this.mergedCopyConfig.tooltips[0], placement: "top" }, () => C);
          t.push(g);
        } else
          t.push(C);
      }
      if (this.editing) {
        const o = e.h(di, { ref: "edit", modelValue: this.editContent, type: "textarea", autosize: this.mergedEditConfig.autosize, maxlength: this.mergedEditConfig.maxlength, "onOn-blur": this.handleEditBlur, "onOn-keydown": this.handleEditKeydown, "onOn-keyup": this.handleEditKeyup, "onOn-change": this.handleEditChange }), C = this.$slots.enterIcon ? this.$slots.enterIcon() : e.h(G, { type: "md-return-left" }), g = e.h("span", { class: "ivu-typography-edit-content-confirm" }, C);
        return e.h("div", { class: ["ivu-typography", "ivu-typography-edit-content", { [`ivu-typography-h${this.level}`]: this.level, "ivu-typography-div": !this.level }] }, [o, g]);
      } else {
        const o = {};
        this.ellipsis && !this.ellipsisExpanded && (o["-webkit-line-clamp"] = this.mergedEllipsisConfig.rows);
        const g = e.h(this.component, v(p({ ref: "typography", class: this.classes }, this.linkProps), { style: o, onClick: this.handleClickContent }), [t, null]);
        return this.ellipsis && !this.ellipsisExpanded && this.isEllipsis && this.mergedEllipsisConfig.tooltip ? e.h(tr, { content: this.mergedEllipsisConfig.tooltip === !0 ? this.handleGetContent() : this.mergedEllipsisConfig.tooltip, placement: this.placement, transfer: this.transfer, theme: this.theme, maxWidth: this.maxWidth }, () => g) : g;
      }
    }, beforeUnmount() {
      this.handleRemoveObserver();
    } }, U0 = { name: "Link", mixins: [ga], render() {
      return e.h(xc, p(v(p({}, this.$props), { component: "a" }), this.commonEvents()), this.commonSlots());
    } };
    function W0() {
      return Vn(), Ut;
    }
    let Y0 = W0();
    ni.newInstance = (t) => {
      if (!h)
        return;
      const r = t || {};
      let o = null;
      const C = e.createApp({ data() {
        return Object.assign({}, r, {});
      }, render() {
        let x = "";
        return this.render ? x = e.h(ni, { fix: !0, fullscreen: !0, ref: "spin" }, [this.render(e.h)]) : x = e.h(ni, { size: "large", fix: !0, fullscreen: !0, ref: "spin" }), e.h("div", { class: "ivu-spin-fullscreen ivu-spin-fullscreen-wrapper", style: { "z-index": 2010 + Y0 } }, [x]);
      }, created() {
        o = e.getCurrentInstance();
      } }), g = document.createElement("div");
      document.body.appendChild(g), C.mount(g);
      const a = o.refs.spin;
      return { show() {
        e.nextTick(() => {
          o.refs.spin.visible = !0, Y0 = W0();
        });
      }, remove(x) {
        a.visible = !1, setTimeout(function() {
          C.unmount(), document.body.removeChild(g), x();
        }, 500);
      }, component: a };
    };
    let va;
    function K0(t = void 0) {
      return va = va || ni.newInstance({ render: t }), va;
    }
    function iB(t) {
      const r = "render" in t ? t.render : void 0;
      K0(r).show(t);
    }
    ni.show = function(t = {}) {
      return iB(t);
    }, ni.hide = function() {
      if (!va)
        return !1;
      K0().remove(() => {
        va = null;
      });
    };
    const ya = "ivu-list", rB = { name: "List", provide() {
      return { ListInstance: this };
    }, components: { Spin: ni }, props: { border: { type: Boolean, default: !1 }, itemLayout: { validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "horizontal" }, header: { type: String, default: "" }, footer: { type: String, default: "" }, loading: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, split: { type: Boolean, default: !0 } }, data() {
      return {};
    }, computed: { classes() {
      return [`${ya}`, `${ya}-${this.size}`, `${ya}-${this.itemLayout}`, { [`${ya}-bordered`]: this.border, [`${ya}-split`]: this.split }];
    } }, methods: {} }, sB = { key: 0, class: "ivu-list-header" }, oB = { class: "ivu-list-container" }, aB = { class: "ivu-list-items" }, lB = { key: 2, class: "ivu-list-footer" };
    function cB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Spin");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [o.header || t.$slots.header ? (e.openBlock(), e.createElementBlock("div", sB, [e.renderSlot(t.$slots, "header", {}, () => [e.createTextVNode(e.toDisplayString(o.header), 1)])])) : e.createCommentVNode("", !0), e.createElementVNode("div", oB, [e.createElementVNode("ul", aB, [e.renderSlot(t.$slots, "default")])]), o.loading ? (e.openBlock(), e.createBlock(x, { key: 1, fix: "", size: "large" }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "spin")]), _: 3 })) : e.createCommentVNode("", !0), o.footer || t.$slots.footer ? (e.openBlock(), e.createElementBlock("div", lB, [e.renderSlot(t.$slots, "footer", {}, () => [e.createTextVNode(e.toDisplayString(o.footer), 1)])])) : e.createCommentVNode("", !0)], 2);
    }
    var G0 = f(rB, [["render", cB]]);
    const uB = { name: "ListItem", inject: ["ListInstance"], props: {}, computed: { itemLayout() {
      return this.ListInstance.itemLayout;
    }, isItemContainsTextNode() {
      let t;
      return this.$slots.default().forEach((r) => {
        typeof r == "string" && (t = !0);
      }), t;
    }, isFlexMode() {
      const t = this.$slots.extra;
      return this.itemLayout === "vertical" ? !!t : !this.isItemContainsTextNode;
    }, classes() {
      return [{ "ivu-list-item-no-flex": !this.isFlexMode }];
    } } }, hB = { class: "ivu-list-item-main" }, dB = { key: 0, class: "ivu-list-item-action" }, fB = { class: "ivu-list-item-extra" }, pB = { key: 0, class: "ivu-list-item-action" }, mB = { class: "ivu-list-item-extra" };
    function gB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(["ivu-list-item", a.classes]) }, [a.itemLayout === "vertical" && t.$slots.extra ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createElementVNode("div", hB, [e.renderSlot(t.$slots, "default"), t.$slots.action ? (e.openBlock(), e.createElementBlock("ul", dB, [e.renderSlot(t.$slots, "action")])) : e.createCommentVNode("", !0)]), e.createElementVNode("div", fB, [e.renderSlot(t.$slots, "extra")])], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.renderSlot(t.$slots, "default"), t.$slots.action ? (e.openBlock(), e.createElementBlock("ul", pB, [e.renderSlot(t.$slots, "action")])) : e.createCommentVNode("", !0), e.createElementVNode("div", mB, [e.renderSlot(t.$slots, "extra")])], 64))], 2);
    }
    var X0 = f(uB, [["render", gB]]);
    const vB = { name: "ListItemMeta", components: { Avatar: Jo }, props: { avatar: { type: String, default: "" }, title: { type: String, default: "" }, description: { type: String, default: "" } } }, yB = { class: "ivu-list-item-meta" }, bB = { key: 0, class: "ivu-list-item-meta-avatar" }, CB = { class: "ivu-list-item-meta-content" }, wB = { key: 0, class: "ivu-list-item-meta-title" }, kB = { key: 1, class: "ivu-list-item-meta-description" };
    function SB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Avatar");
      return e.openBlock(), e.createElementBlock("div", yB, [o.avatar || t.$slots.avatar ? (e.openBlock(), e.createElementBlock("div", bB, [e.renderSlot(t.$slots, "avatar", {}, () => [e.createVNode(x, { src: o.avatar }, null, 8, ["src"])])])) : e.createCommentVNode("", !0), e.createElementVNode("div", CB, [o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("div", wB, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0), o.description || t.$slots.description ? (e.openBlock(), e.createElementBlock("div", kB, [e.renderSlot(t.$slots, "description", {}, () => [e.createTextVNode(e.toDisplayString(o.description), 1)])])) : e.createCommentVNode("", !0)])]);
    }
    var q0 = f(vB, [["render", SB]]);
    const _c = "ivu-loading-bar", EB = { name: "LoadingBar", props: { color: { type: String, default: "primary" }, failedColor: { type: String, default: "error" }, height: { type: Number, default: 2 } }, data() {
      return { percent: 0, status: "success", show: !1 };
    }, computed: { classes() {
      return `${_c}`;
    }, innerClasses() {
      return [`${_c}-inner`, { [`${_c}-inner-color-primary`]: this.color === "primary" && this.status === "success", [`${_c}-inner-failed-color-error`]: this.failedColor === "error" && this.status === "error" }];
    }, outerStyles() {
      return { height: `${this.height}px` };
    }, styles() {
      let t = { width: `${this.percent}%`, height: `${this.height}px` };
      return this.color !== "primary" && this.status === "success" && (t.backgroundColor = this.color), this.failedColor !== "error" && this.status === "error" && (t.backgroundColor = this.failedColor), t;
    } } };
    function xB(t, r, o, C, g, a) {
      return e.openBlock(), e.createBlock(e.Transition, { name: "fade" }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.outerStyles) }, [e.createElementVNode("div", { class: e.normalizeClass(a.innerClasses), style: e.normalizeStyle(a.styles) }, null, 6)], 6), [[e.vShow, g.show]])]), _: 1 });
    }
    var pd = f(EB, [["render", xB]]);
    pd.newInstance = (t) => {
      if (!h)
        return;
      const r = t || {};
      let o = null;
      const C = e.createApp({ data() {
        return r;
      }, render() {
        return e.h(pd, Object.assign({ ref: "loadingBar" }, r));
      }, created() {
        o = e.getCurrentInstance();
      } }), g = document.createElement("div");
      document.body.appendChild(g), C.mount(g);
      const a = o.refs.loadingBar;
      return { update(x) {
        "percent" in x && (a.percent = x.percent), x.status && (a.status = x.status), "show" in x && (a.show = x.show);
      }, component: a, destroy() {
        C.unmount(), document.body.removeChild(g);
      } };
    };
    let Tc, J0 = "primary", Q0 = 800, Z0 = "error", ev = 2, ba;
    function tv() {
      return Tc = Tc || pd.newInstance({ color: J0, failedColor: Z0, height: ev }), Tc;
    }
    function ks(t) {
      tv().update(t);
    }
    function nv() {
      setTimeout(() => {
        ks({ show: !1 }), setTimeout(() => {
          ks({ percent: 0 });
        }, 200);
      }, Q0);
    }
    function Ca() {
      ba && (clearInterval(ba), ba = null);
    }
    var md = { start() {
      if (ba)
        return;
      let t = 0;
      ks({ percent: t, status: "success", show: !0 }), ba = setInterval(() => {
        t += Math.floor(Math.random() * 3 + 1), t > 95 && Ca(), ks({ percent: t, status: "success", show: !0 });
      }, 200);
    }, update(t) {
      Ca(), ks({ percent: t, status: "success", show: !0 });
    }, finish() {
      Ca(), ks({ percent: 100, status: "success", show: !0 }), nv();
    }, error() {
      Ca(), ks({ percent: 100, status: "error", show: !0 }), nv();
    }, config(t) {
      t.color && (J0 = t.color), t.duration && (Q0 = t.duration), t.failedColor && (Z0 = t.failedColor), t.height && (ev = t.height);
    }, destroy() {
      Ca();
      let t = tv();
      Tc = null, t.destroy();
    } };
    const _B = { name: "Login", components: { Form: bc }, emits: ["on-submit"], provide() {
      return { LoginInstance: this };
    }, props: {}, data() {
      return { formValidate: {} };
    }, methods: { handleSubmit() {
      this.$refs.form.validate((t) => {
        this.$emit("on-submit", t, JSON.parse(JSON.stringify(this.formValidate)));
      });
    }, handleValidate(t, r) {
      let o = !0;
      t.forEach((C) => {
        this.$refs.form.validateField(C, (g) => {
          g && (o = !1);
        });
      }), r(o);
    } } }, TB = { class: "ivu-login" };
    function OB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Form");
      return e.openBlock(), e.createElementBlock("div", TB, [e.createVNode(x, { ref: "form", model: g.formValidate, onSubmit: r[0] || (r[0] = e.withModifiers(() => {
      }, ["prevent"])) }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), _: 3 }, 8, ["model"])]);
    }
    var iv = f(_B, [["render", OB]]);
    const gd = "ivu-menu", DB = { name: "Menu", emits: ["on-select", "on-open-change"], provide() {
      return { MenuInstance: this };
    }, props: { mode: { validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "vertical" }, theme: { validator(t) {
      return z(t, ["light", "dark", "primary"]);
    }, default: "light" }, activeName: { type: [String, Number] }, openNames: { type: Array, default() {
      return [];
    } }, accordion: { type: Boolean, default: !1 }, width: { type: String, default: "240px" } }, data() {
      return { currentActiveName: this.activeName, openedNames: [], submenuList: [], menuItemList: [], ready: !1 };
    }, computed: { classes() {
      let t = this.theme;
      return this.mode === "vertical" && this.theme === "primary" && (t = "light"), [`${gd}`, `${gd}-${t}`, { [`${gd}-${this.mode}`]: this.mode }];
    }, styles() {
      let t = {};
      return this.mode === "vertical" && (t.width = this.width), t;
    } }, methods: { updateActiveName() {
      this.currentActiveName === void 0 && (this.currentActiveName = -1), this.submenuList.map((t) => t.submenu).forEach((t) => {
        t.handleUpdateActiveName(!1);
      }), this.menuItemList.map((t) => t.menuitem).forEach((t) => {
        t.handleUpdateActiveName(this.currentActiveName);
      });
    }, updateOpenKeys(t) {
      const r = [...this.openedNames].indexOf(t), o = this.submenuList.map((g) => g.submenu);
      if (this.accordion && o.forEach((g) => {
        g.opened = !1;
      }), r >= 0) {
        let g = null;
        o.forEach((a) => {
          a.name === t && (g = a, a.opened = !1);
        }), K(g, "Submenu").forEach((a) => {
          a.opened = !0;
        }), g.childSubmenuList.map((a) => a.submenu).forEach((a) => {
          a.opened = !1;
        });
      } else if (this.accordion) {
        let g = null;
        o.forEach((a) => {
          a.name === t && (g = a, a.opened = !0);
        }), K(g, "Submenu").forEach((a) => {
          a.opened = !0;
        });
      } else
        this.submenuList.map((g) => g.submenu).forEach((g) => {
          g.name === t && (g.opened = !0);
        });
      let C = o.filter((g) => g.opened).map((g) => g.name);
      this.openedNames = [...C], this.$emit("on-open-change", C);
    }, updateOpened() {
      const t = (this.submenuList || []).map((r) => r.submenu);
      t.length && t.forEach((r) => {
        this.openedNames.indexOf(r.name) > -1 ? r.opened = !0 : r.opened = !1;
      });
    }, handleEmitSelectEvent(t) {
      this.$emit("on-select", t);
    }, handleMenuItemSelect(t) {
      this.currentActiveName = t, this.$emit("on-select", t);
    } }, mounted() {
      this.openedNames = [...this.openNames], this.updateOpened(), e.nextTick(() => {
        this.updateActiveName(), this.ready = !0;
      });
    }, watch: { openNames(t) {
      this.openedNames = t;
    }, activeName(t) {
      this.currentActiveName = t;
    }, currentActiveName() {
      this.updateActiveName();
    } } };
    function NB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("ul", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, [e.renderSlot(t.$slots, "default")], 6);
    }
    var vd = f(DB, [["render", NB]]), yd = { inject: { MenuInstance: { default: null }, SubmenuInstance: { default: null } }, data() {
      return { menu: this.MenuInstance };
    }, computed: { hasParentSubmenu() {
      return !!this.SubmenuInstance;
    }, parentSubmenuNum() {
      return K(this, "Submenu").length;
    }, mode() {
      return this.MenuInstance.mode;
    } } };
    const BB = "ivu-menu", PB = { name: "MenuGroup", mixins: [yd], props: { title: { type: String, default: "" } }, data() {
      return { prefixCls: BB };
    }, computed: { groupStyle() {
      return this.hasParentSubmenu && this.mode !== "horizontal" ? { paddingLeft: 43 + (this.parentSubmenuNum - 1) * 28 + "px" } : {};
    } } };
    function VB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass([g.prefixCls + "-item-group"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-item-group-title"]), style: e.normalizeStyle(a.groupStyle) }, e.toDisplayString(o.title), 7), e.createElementVNode("ul", null, [e.renderSlot(t.$slots, "default")])], 2);
    }
    var rv = f(PB, [["render", VB]]);
    const Oc = "ivu-menu", $B = { name: "MenuItem", mixins: [yd, je], props: { name: { type: [String, Number], required: !0 }, disabled: { type: Boolean, default: !1 } }, data() {
      return { active: !1, id: be(6) };
    }, computed: { classes() {
      return [`${Oc}-item`, { [`${Oc}-item-active`]: this.active, [`${Oc}-item-selected`]: this.active, [`${Oc}-item-disabled`]: this.disabled }];
    }, itemStyle() {
      return this.hasParentSubmenu && this.mode !== "horizontal" ? { paddingLeft: 43 + (this.parentSubmenuNum - 1) * 24 + "px" } : {};
    } }, methods: { handleClickItem(t, r = !1) {
      if (!this.disabled)
        if (r || this.target === "_blank") {
          this.handleCheckClick(t, r);
          let o = me(this, "Menu");
          o && o.handleEmitSelectEvent(this.name);
        } else
          me(this, "Submenu") ? this.SubmenuInstance.handleMenuItemSelect(this.name) : this.MenuInstance.handleMenuItemSelect(this.name), this.handleCheckClick(t, r);
    }, handleUpdateActiveName(t) {
      this.name === t ? (this.active = !0, this.SubmenuInstance && this.SubmenuInstance.handleUpdateActiveName(t)) : this.active = !1;
    }, addMenuItem() {
      const t = this.MenuInstance;
      t.menuItemList || (t.menuItemList = []), t.menuItemList.push({ id: this.id, menuitem: this });
    }, removeMenuItem() {
      const t = this.MenuInstance;
      if (t.menuItemList && t.menuItemList.length) {
        const r = t.menuItemList.findIndex((o) => o.id === this.id);
        t.menuItemList.splice(r, 1);
      }
    } }, mounted() {
      this.addMenuItem();
    }, beforeUnmount() {
      this.removeMenuItem();
    } }, IB = ["href", "target"];
    function MB(t, r, o, C, g, a) {
      return t.to ? (e.openBlock(), e.createElementBlock("a", { key: 0, href: t.linkUrl, target: t.target, class: e.normalizeClass(a.classes), onClick: [r[0] || (r[0] = e.withModifiers((x) => a.handleClickItem(x, !1), ["exact"])), r[1] || (r[1] = e.withModifiers((x) => a.handleClickItem(x, !0), ["ctrl"])), r[2] || (r[2] = e.withModifiers((x) => a.handleClickItem(x, !0), ["meta"]))], style: e.normalizeStyle(a.itemStyle) }, [e.renderSlot(t.$slots, "default")], 14, IB)) : (e.openBlock(), e.createElementBlock("li", { key: 1, class: e.normalizeClass(a.classes), onClick: r[3] || (r[3] = e.withModifiers((...x) => a.handleClickItem && a.handleClickItem(...x), ["stop"])), style: e.normalizeStyle(a.itemStyle) }, [e.renderSlot(t.$slots, "default")], 6));
    }
    var sv = f($B, [["render", MB]]);
    const ov = { name: "Mobile", mixins: [ia], data() {
      return { className: "ivu-login-mobile", prefix: "ios-phone-portrait", placeholder: "请输入手机号码", type: "text" };
    }, props: { rules: { type: [Object, Array], default() {
      return [{ required: !0, message: jh.Mobile, trigger: "change" }, { pattern: /^1\d{10}$/, message: "输入的手机号码格式不正确！", trigger: "change" }];
    } } } }, Kn = "ivu-modal", av = { x: null, y: null, dragX: null, dragY: null, dragging: !1, rect: null }, AB = { inheritAttrs: !1, name: "Modal", mixins: [Kt, od], components: { Icon: G, iButton: zn }, emits: ["on-cancel", "on-ok", "on-hidden", "on-visible-change", "update:modelValue"], provide() {
      return { ModalInstance: this };
    }, props: { modelValue: { type: Boolean, default: !1 }, closable: { type: Boolean, default: !0 }, maskClosable: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.modal.maskClosable === "" ? !0 : t.$VIEWUI.modal.maskClosable;
    } }, title: { type: String }, width: { type: [Number, String], default: 520 }, okText: { type: String }, cancelText: { type: String }, loading: { type: Boolean, default: !1 }, styles: { type: Object, default() {
      return {};
    } }, className: { type: String }, footerHide: { type: Boolean, default: !1 }, scrollable: { type: Boolean, default: !1 }, transitionNames: { type: Array, default() {
      return ["ease", "fade"];
    } }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !0 : t.$VIEWUI.transfer;
    } }, fullscreen: { type: Boolean, default: !1 }, mask: { type: Boolean, default: !0 }, draggable: { type: Boolean, default: !1 }, sticky: { type: Boolean, default: !1 }, stickyDistance: { type: Number, default: 10 }, resetDragPosition: { type: Boolean, default: !1 }, zIndex: { type: Number, default: 1e3 }, beforeClose: Function, render: Function }, data() {
      return { prefixCls: Kn, wrapShow: !1, showHead: !0, buttonLoading: !1, visible: this.modelValue, dragData: W(av), modalIndex: this.handleGetModalIndex(), isMouseTriggerIn: !1, id: be(6), tableList: [], sliderList: [] };
    }, computed: { wrapClasses() {
      return [`${Kn}-wrap`, { [`${Kn}-hidden`]: !this.wrapShow, [`${this.className}`]: !!this.className, [`${Kn}-no-mask`]: !this.showMask }];
    }, wrapStyles() {
      return { zIndex: this.modalIndex + this.zIndex };
    }, maskClasses() {
      return `${Kn}-mask`;
    }, classes() {
      return [`${Kn}`, { [`${Kn}-fullscreen`]: this.fullscreen, [`${Kn}-fullscreen-no-header`]: this.fullscreen && !this.showHead, [`${Kn}-fullscreen-no-footer`]: this.fullscreen && this.footerHide }];
    }, contentClasses() {
      return [`${Kn}-content`, { [`${Kn}-content-no-mask`]: !this.showMask, [`${Kn}-content-drag`]: this.draggable && !this.fullscreen, [`${Kn}-content-dragging`]: this.draggable && this.dragData.dragging }];
    }, mainStyles() {
      let t = {};
      const r = parseInt(this.width), o = this.dragData.x !== null ? { top: 0 } : { width: r <= 100 ? `${r}%` : `${r}px` }, C = this.styles ? this.styles : {};
      return Object.assign(t, o, C), t;
    }, contentStyles() {
      let t = {};
      if (this.draggable && !this.fullscreen) {
        const r = this.styles.top ? parseFloat(this.styles.top) : 0, o = this.styles.left ? parseFloat(this.styles.left) : 0;
        this.dragData.x !== null && (t.left = `${this.dragData.x - o}px`), this.dragData.y !== null && (t.top = `${this.dragData.y}px`), this.dragData.y !== null && (t.top = `${this.dragData.y - r}px`);
        const C = parseInt(this.width), g = { width: C <= 100 ? `${C}%` : `${C}px` };
        Object.assign(t, g);
      }
      return t;
    }, localeOkText() {
      return this.okText === void 0 ? this.t("i.modal.okText") : this.okText;
    }, localeCancelText() {
      return this.cancelText === void 0 ? this.t("i.modal.cancelText") : this.cancelText;
    }, showMask() {
      return this.mask;
    } }, methods: { close() {
      if (!this.beforeClose)
        return this.handleClose();
      const t = this.beforeClose();
      t && t.then ? t.then(() => {
        this.handleClose();
      }) : this.handleClose();
    }, handleClose() {
      this.visible = !1, this.$emit("update:modelValue", !1), this.$emit("on-cancel");
    }, handleMask() {
      this.maskClosable && this.showMask && this.close();
    }, handleWrapClick(t) {
      if (this.isMouseTriggerIn) {
        this.isMouseTriggerIn = !1;
        return;
      }
      const r = t.target.getAttribute("class");
      r && r.indexOf(`${Kn}-wrap`) > -1 && this.handleMask();
    }, handleMousedown() {
      this.isMouseTriggerIn = !0;
    }, cancel() {
      this.close();
    }, ok() {
      this.loading ? this.buttonLoading = !0 : (this.visible = !1, this.$emit("update:modelValue", !1)), this.$emit("on-ok");
    }, EscClose(t) {
      if (this.visible && this.closable && t.keyCode === 27) {
        const r = this.$root.modalList.map((o) => o.modal).filter((o) => o.$data.visible && o.$props.closable).sort((o, C) => o.$data.modalIndex < C.$data.modalIndex ? 1 : -1)[0];
        setTimeout(() => {
          r.close();
        }, 0);
      }
    }, animationFinish() {
      this.$emit("on-hidden");
    }, handleMoveStart(t) {
      if (!this.draggable || this.fullscreen)
        return !1;
      const r = this.$refs.content.getBoundingClientRect();
      this.dragData.rect = r, this.dragData.x = r.x || r.left, this.dragData.y = r.y || r.top;
      const o = { x: t.clientX, y: t.clientY };
      this.dragData.dragX = o.x, this.dragData.dragY = o.y, this.dragData.dragging = !0, m(window, "mousemove", this.handleMoveMove), m(window, "mouseup", this.handleMoveEnd);
    }, handleMoveMove(t) {
      if (!this.dragData.dragging || this.fullscreen)
        return !1;
      const r = { x: t.clientX, y: t.clientY }, o = { x: r.x - this.dragData.dragX, y: r.y - this.dragData.dragY };
      if (h && this.sticky) {
        const C = document.documentElement.clientWidth, g = document.documentElement.clientHeight;
        this.dragData.x + o.x <= this.stickyDistance && o.x < 0 ? this.dragData.x = 0 : this.dragData.x + this.dragData.rect.width - C > -this.stickyDistance && o.x > 0 ? this.dragData.x = C - this.dragData.rect.width : this.dragData.x += o.x, this.dragData.y + o.y <= this.stickyDistance && o.y < 0 ? this.dragData.y = 0 : this.dragData.y + this.dragData.rect.height - g > -this.stickyDistance && o.y > 0 ? this.dragData.y = g - this.dragData.rect.height : this.dragData.y += o.y;
      } else
        this.dragData.x += o.x, this.dragData.y += o.y;
      this.dragData.dragX = r.x, this.dragData.dragY = r.y;
    }, handleMoveEnd() {
      this.dragData.dragging = !1, b(window, "mousemove", this.handleMoveMove), b(window, "mouseup", this.handleMoveEnd);
    }, handleGetModalIndex() {
      return Vn(), Ut;
    }, handleClickModal() {
      if (this.draggable) {
        if (Zi !== this.lastVisibleIndex) {
          this.lastVisibleIndex = Zi;
          return;
        }
        this.modalIndex = this.handleGetModalIndex();
      }
    }, addModal() {
      const t = this.$root;
      t.modalList || (t.modalList = []), t.modalList.push({ id: this.id, modal: this });
    }, removeModal() {
      const t = this.$root;
      if (!t.modalList)
        return;
      const r = t.modalList.findIndex((o) => o.id === this.id);
      t.modalList.splice(r, 1);
    } }, watch: { modelValue(t) {
      this.visible = t;
    }, visible(t) {
      t === !1 ? (this.buttonLoading = !1, this.timer = setTimeout(() => {
        this.wrapShow = !1, this.removeScrollEffect();
      }, 300)) : (this.lastVisible !== t && (this.modalIndex = this.handleGetModalIndex(), Qs()), this.timer && clearTimeout(this.timer), this.wrapShow = !0, this.scrollable || this.addScrollEffect()), this.tableList.forEach((r) => {
        r.table.handleOnVisibleChange(t);
      }), this.sliderList.forEach((r) => {
        r.slider.handleOnVisibleChange(t);
      }), this.$emit("on-visible-change", t), this.lastVisible = t, this.lastVisibleIndex = Zi, t && this.resetDragPosition && (this.dragData = W(av));
    }, loading(t) {
      t || (this.buttonLoading = !1);
    }, scrollable(t) {
      t ? this.removeScrollEffect() : this.addScrollEffect();
    }, title(t) {
      this.$slots.header === void 0 && (this.showHead = !!t);
    } }, mounted() {
      this.visible && (this.wrapShow = !0);
      let t = !0;
      this.$slots.header === void 0 && !this.title && (t = !1), this.showHead = t, this.addModal(), h && document.addEventListener("keydown", this.EscClose);
    }, beforeUnmount() {
      this.removeModal(), h && document.removeEventListener("keydown", this.EscClose), this.removeScrollEffect();
    } };
    function FB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("i-button");
      return e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createVNode(e.Transition, { name: o.transitionNames[1] }, { default: e.withCtx(() => [a.showMask ? e.withDirectives((e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.maskClasses), style: e.normalizeStyle(a.wrapStyles), onClick: r[0] || (r[0] = (...P) => a.handleMask && a.handleMask(...P)) }, null, 6)), [[e.vShow, g.visible]]) : e.createCommentVNode("", !0)]), _: 1 }, 8, ["name"]), e.createElementVNode("div", { class: e.normalizeClass(a.wrapClasses), style: e.normalizeStyle(a.wrapStyles), onClick: r[5] || (r[5] = (...P) => a.handleWrapClick && a.handleWrapClick(...P)) }, [e.createVNode(e.Transition, { name: o.transitionNames[0], onAfterLeave: a.animationFinish }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", e.mergeProps(t.$attrs, { class: a.classes, style: a.mainStyles, onMousedown: r[4] || (r[4] = (...P) => a.handleMousedown && a.handleMousedown(...P)) }), [e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses), ref: "content", style: e.normalizeStyle(a.contentStyles), onClick: r[3] || (r[3] = (...P) => a.handleClickModal && a.handleClickModal(...P)) }, [o.closable ? (e.openBlock(), e.createElementBlock("a", { key: 0, class: e.normalizeClass([g.prefixCls + "-close"]), onClick: r[1] || (r[1] = (...P) => a.close && a.close(...P)) }, [e.renderSlot(t.$slots, "close", {}, () => [e.createVNode(x, { type: "ios-close" })])], 2)) : e.createCommentVNode("", !0), g.showHead ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass([g.prefixCls + "-header"]), onMousedown: r[2] || (r[2] = (...P) => a.handleMoveStart && a.handleMoveStart(...P)) }, [e.renderSlot(t.$slots, "header", {}, () => [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-header-inner"]) }, e.toDisplayString(o.title), 3)])], 34)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]) }, [e.renderSlot(t.$slots, "default")], 2), o.footerHide ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 2, class: e.normalizeClass([g.prefixCls + "-footer"]) }, [e.renderSlot(t.$slots, "footer", {}, () => [e.createVNode(O, { type: "text", onClick: a.cancel }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.localeCancelText), 1)]), _: 1 }, 8, ["onClick"]), e.createVNode(O, { type: "primary", loading: g.buttonLoading, onClick: a.ok }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.localeOkText), 1)]), _: 1 }, 8, ["loading", "onClick"])])], 2))], 6)], 16), [[e.vShow, g.visible]])]), _: 3 }, 8, ["name", "onAfterLeave"])], 6)], 8, ["disabled"]);
    }
    var pi = f(AB, [["render", FB]]);
    const rr = "ivu-modal-confirm";
    pi.newInstance = (t) => {
      if (!h)
        return;
      const r = t || {}, o = document.createElement("div");
      document.body.appendChild(o);
      let C = null;
      const g = e.createApp({ mixins: [Kt], data() {
        return Object.assign({}, r, { visible: !1, width: 416, title: "", body: "", iconType: "", iconName: "", okText: void 0, cancelText: void 0, showCancel: !1, loading: !1, buttonLoading: !1, scrollable: !1, closable: !1, closing: !1 });
      }, render() {
        let x = [];
        this.showCancel && x.push(e.h(zn, { type: "text", onClick: this.cancel }, () => this.localeCancelText)), x.push(e.h(zn, { type: "primary", loading: this.buttonLoading, onClick: this.ok }, () => this.localeOkText));
        let O;
        this.render ? O = e.h("div", { class: `${rr}-body ${rr}-body-render` }, [this.render(e.h)]) : O = e.h("div", { class: `${rr}-body` }, [e.h("div", { innerHTML: this.body })]);
        let P;
        return this.title && (P = e.h("div", { class: `${rr}-head` }, [e.h("div", { class: this.iconTypeCls }, [e.h("i", { class: this.iconNameCls })]), e.h("div", { class: `${rr}-head-title`, innerHTML: this.title })])), e.h(pi, Object.assign({}, r, { width: this.width, scrollable: this.scrollable, closable: this.closable, ref: "modal" }, { modelValue: this.visible, "onUpdate:modelValue": (N) => this.visible = N, "onOn-cancel": this.cancel }), () => e.h("div", { class: rr }, [P, O, e.h("div", { class: `${rr}-footer` }, x)]));
      }, computed: { iconTypeCls() {
        return [`${rr}-head-icon`, `${rr}-head-icon-${this.iconType}`];
      }, iconNameCls() {
        return ["ivu-icon", `ivu-icon-${this.iconName}`];
      }, localeOkText() {
        return this.okText ? this.okText : this.t("i.modal.okText");
      }, localeCancelText() {
        return this.cancelText ? this.cancelText : this.t("i.modal.cancelText");
      } }, methods: { cancel() {
        this.closing || (this.$refs.modal.visible = !1, this.buttonLoading = !1, this.onCancel(), this.remove());
      }, ok() {
        this.closing || (this.loading ? this.buttonLoading = !0 : (this.$refs.modal.visible = !1, this.remove()), this.onOk());
      }, remove() {
        this.closing = !0, setTimeout(() => {
          this.closing = !1, this.destroy();
        }, 300);
      }, destroy() {
        g.unmount(), document.body.removeChild(o), this.onRemove();
      }, onOk() {
      }, onCancel() {
      }, onRemove() {
      } }, created() {
        C = e.getCurrentInstance();
      } });
      g.mount(o);
      const a = C.refs.modal;
      return { show(x) {
        switch (a.$parent.showCancel = x.showCancel, a.$parent.iconType = x.icon, x.icon) {
          case "info":
            a.$parent.iconName = "ios-information-circle";
            break;
          case "success":
            a.$parent.iconName = "ios-checkmark-circle";
            break;
          case "warning":
            a.$parent.iconName = "ios-alert";
            break;
          case "error":
            a.$parent.iconName = "ios-close-circle";
            break;
          case "confirm":
            a.$parent.iconName = "ios-help-circle";
            break;
        }
        "width" in x && (a.$parent.width = x.width), "closable" in x && (a.$parent.closable = x.closable), "title" in x && (a.$parent.title = x.title), "content" in x && (a.$parent.body = x.content), "okText" in x && (a.$parent.okText = x.okText), "cancelText" in x && (a.$parent.cancelText = x.cancelText), "onCancel" in x && (a.$parent.onCancel = x.onCancel), "onOk" in x && (a.$parent.onOk = x.onOk), "loading" in x && (a.$parent.loading = x.loading), "scrollable" in x && (a.$parent.scrollable = x.scrollable), a.$parent.onRemove = x.onRemove, a.visible = !0;
      }, remove() {
        a.visible = !1, a.$parent.buttonLoading = !1, a.$parent.remove();
      }, component: a };
    };
    let wa;
    function lv(t = void 0, r = !0) {
      return wa = wa || pi.newInstance({ closable: !1, maskClosable: !1, footerHide: !0, render: t, lockScroll: r }), wa;
    }
    function ka(t) {
      const r = "render" in t ? t.render : void 0, o = "lockScroll" in t ? t.lockScroll : !0;
      let C = lv(r, o);
      t.onRemove = function() {
        wa = null;
      }, C.show(t);
    }
    pi.info = function(t = {}) {
      return t.icon = "info", t.showCancel = !1, ka(t);
    }, pi.success = function(t = {}) {
      return t.icon = "success", t.showCancel = !1, ka(t);
    }, pi.warning = function(t = {}) {
      return t.icon = "warning", t.showCancel = !1, ka(t);
    }, pi.error = function(t = {}) {
      return t.icon = "error", t.showCancel = !1, ka(t);
    }, pi.confirm = function(t = {}) {
      return t.icon = "confirm", t.showCancel = !0, ka(t);
    }, pi.remove = function() {
      if (!wa)
        return !1;
      lv().remove();
    };
    const ii = "ivu-notice", cv = "ivu-icon", LB = "ivu_notice_key_";
    let uv = 24, hv = 4.5, fo, dv = 1;
    const zB = { info: "ios-information-circle", success: "ios-checkmark-circle", warning: "ios-alert", error: "ios-close-circle" }, fv = "move-notice";
    function pv() {
      return fo = fo || oc.newInstance({ prefixCls: ii, styles: { top: `${uv}px`, right: 0 }, transitionName: fv }), fo;
    }
    function Sa(t, r) {
      const o = r.title || "", C = r.desc || "", g = r.name || `${LB}${dv}`, a = r.onClose || function() {
      }, x = r.render, O = r.duration === 0 ? 0 : r.duration || hv;
      dv++;
      let P = pv(), N, B;
      const H = r.render && !o ? "" : C || r.render ? ` ${ii}-with-desc` : "";
      if (t === "normal")
        B = !1, N = `
            <div class="${ii}-custom-content ${ii}-with-normal ${H}">
                <div class="${ii}-title">${o}</div>
                <div class="${ii}-desc">${C}</div>
            </div>
        `;
      else {
        const oe = zB[t], se = H === "" ? "" : "-outline";
        B = !0, N = `
            <div class="${ii}-custom-content ${ii}-with-icon ${ii}-with-${t} ${H}">
                <span class="${ii}-icon ${ii}-icon-${t}">
                    <i class="${cv} ${cv}-${oe}${se}"></i>
                </span>
                <div class="${ii}-title">${o}</div>
                <div class="${ii}-desc">${C}</div>
            </div>
        `;
      }
      P.notice({ name: g.toString(), duration: O, styles: {}, transitionName: fv, content: N, withIcon: B, render: x, hasTitle: !!o, onClose: a, closable: !0, type: "notice" });
    }
    var bd = { open(t) {
      return Sa("normal", t);
    }, info(t) {
      return Sa("info", t);
    }, success(t) {
      return Sa("success", t);
    }, warning(t) {
      return Sa("warning", t);
    }, error(t) {
      return Sa("error", t);
    }, config(t) {
      t.top && (uv = t.top), (t.duration || t.duration === 0) && (hv = t.duration);
    }, close(t) {
      if (t)
        t = t.toString(), fo && fo.remove(t);
      else
        return !1;
    }, destroy() {
      let t = pv();
      fo = null, t.destroy("ivu-notice");
    } };
    const Sn = "ivu-tabs", Cd = 300, mv = (t, r, o, C) => {
      const g = (t.findIndex((x) => x.name === r) + o + t.length) % t.length, a = t[g];
      return a.disabled ? mv(t, a.name, o) : a;
    }, gv = (t, r) => {
      try {
        t.focus();
      } catch {
      }
      if (h && document.activeElement == t && t !== r)
        return !0;
      const o = t.children;
      for (let C of o)
        if (gv(C, r))
          return !0;
      return !1;
    }, RB = { name: "Tabs", mixins: [kr], emits: ["on-click", "on-dblclick", "on-contextmenu", "on-tab-remove", "on-drag-drop", "update:modelValue"], components: { Icon: G, Render: Dg, Dropdown: ys, DropdownMenu: bs }, provide() {
      return { TabsInstance: this };
    }, props: { modelValue: { type: [String, Number] }, type: { validator(t) {
      return z(t, ["line", "card"]);
    }, default: "line" }, size: { validator(t) {
      return z(t, ["small", "default"]);
    }, default: "default" }, animated: { type: Boolean, default: !0 }, captureFocus: { type: Boolean, default: !1 }, closable: { type: Boolean, default: !1 }, beforeRemove: Function, name: { type: String }, draggable: { type: Boolean, default: !1 }, autoCloseContextmenu: { type: Boolean, default: !0 } }, data() {
      return { prefixCls: Sn, navList: [], barWidth: 0, barOffset: 0, activeKey: this.modelValue, focusedKey: this.modelValue, showSlot: !1, navStyle: { transform: "" }, scrollable: !1, transitioning: !1, contextMenuVisible: !1, contextMenuStyles: { top: 0, left: 0 }, paneList: [], tableList: [] };
    }, computed: { classes() {
      return [`${Sn}`, { [`${Sn}-card`]: this.type === "card", [`${Sn}-mini`]: this.size === "small" && this.type === "line", [`${Sn}-no-animation`]: !this.animated }];
    }, contentClasses() {
      return [`${Sn}-content`, { [`${Sn}-content-animated`]: this.animated }];
    }, barClasses() {
      return [`${Sn}-ink-bar`, { [`${Sn}-ink-bar-animated`]: this.animated }];
    }, contentStyle() {
      const t = this.getTabIndex(this.activeKey), r = t === 0 ? "0%" : `-${t}00%`;
      let o = {};
      return t > -1 && (o = { transform: `translateX(${r}) translateZ(0px)` }), o;
    }, barStyle() {
      let t = { visibility: "hidden", width: `${this.barWidth}px` };
      return this.type === "line" && (t.visibility = "visible"), this.animated ? t.transform = `translate3d(${this.barOffset}px, 0px, 0px)` : t.left = `${this.barOffset}px`, t;
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-close";
      return t && (t.tabs.customCloseIcon ? r = "" : t.tabs.closeIcon && (r = t.tabs.closeIcon)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.tabs.customCloseIcon && (r = t.tabs.customCloseIcon), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.tabs.closeIconSize && (r = t.tabs.closeIconSize), r;
    } }, methods: { getTabs() {
      const t = this.paneList.map((o) => o.pane), r = [];
      return t.forEach((o) => {
        o.tab && this.name ? o.tab === this.name && r.push(o) : r.push(o);
      }), r.sort((o, C) => {
        if (o.index && C.index)
          return o.index > C.index ? 1 : -1;
      }), r;
    }, updateNav() {
      this.navList = [], this.getTabs().forEach((t, r) => {
        this.navList.push({ labelType: typeof t.label, label: t.label, icon: t.icon || "", name: t.currentName || r, disabled: t.disabled, closable: t.closable, contextMenu: t.contextMenu }), t.currentName || (t.currentName = r), r === 0 && (this.activeKey || (this.activeKey = t.currentName || r));
      }), this.updateStatus(), this.updateBar();
    }, updateBar() {
      e.nextTick(() => {
        const t = this.getTabIndex(this.activeKey);
        if (!this.$refs.nav)
          return;
        const r = this.$refs.nav.querySelectorAll(`.${Sn}-tab`), o = r[t];
        if (this.barWidth = o ? parseFloat(o.offsetWidth) : 0, t > 0) {
          let C = 0;
          const g = this.size === "small" ? 0 : 16;
          for (let a = 0; a < t; a++)
            C += parseFloat(r[a].offsetWidth) + g;
          this.barOffset = C;
        } else
          this.barOffset = 0;
        this.updateNavScroll();
      });
    }, updateStatus() {
      this.getTabs().forEach((t) => t.show = t.currentName === this.activeKey || this.animated);
    }, tabCls(t) {
      return [`${Sn}-tab`, { [`${Sn}-tab-disabled`]: t.disabled, [`${Sn}-tab-active`]: t.name === this.activeKey, [`${Sn}-tab-focused`]: t.name === this.focusedKey }];
    }, handleChange(t) {
      if (this.transitioning)
        return;
      this.transitioning = !0, setTimeout(() => this.transitioning = !1, Cd);
      const r = this.navList[t];
      !r || r.disabled || (this.activeKey = r.name, this.$emit("update:modelValue", r.name), this.$emit("on-click", r.name));
    }, handleDblclick(t) {
      const r = this.navList[t];
      !r || r.disabled || this.$emit("on-dblclick", r.name);
    }, handleContextmenu(t, r) {
      this.contextMenuVisible && this.handleClickContextMenuOutside(), e.nextTick(() => {
        const o = this.navList[t];
        if (!o || o.disabled || !o.contextMenu)
          return;
        r.preventDefault();
        const C = this.$refs.tabsWrap.getBoundingClientRect(), g = { left: `${r.clientX - C.left}px`, top: `${r.clientY - C.top}px` };
        this.contextMenuStyles = g, this.contextMenuVisible = !0, this.$emit("on-contextmenu", o, r, g);
      });
    }, handleClickContextMenuOutside() {
      this.contextMenuVisible = !1;
    }, handlePreventSelect(t, r) {
      const o = this.navList[t];
      !o || o.disabled || !o.contextMenu || r.preventDefault();
    }, handleTabKeyNavigation(t) {
      if (t.keyCode !== 37 && t.keyCode !== 39)
        return;
      const r = t.keyCode === 39 ? 1 : -1, o = mv(this.navList, this.focusedKey, r);
      this.focusedKey = o.name;
    }, handleTabKeyboardSelect(t = !1) {
      if (t)
        return;
      const r = this.focusedKey || 0, o = this.getTabIndex(r);
      this.handleChange(o);
    }, handleRemove(t) {
      if (!this.beforeRemove)
        return this.handleRemoveTab(t);
      const r = this.beforeRemove(t);
      r && r.then ? r.then(() => {
        this.handleRemoveTab(t);
      }) : this.handleRemoveTab(t);
    }, handleRemoveTab(t) {
      const r = this.getTabs(), o = r[t];
      if (o.currentName === this.activeKey) {
        const C = this.getTabs();
        let g = -1;
        if (C.length) {
          const a = r.filter((O, P) => !O.disabled && P < t), x = r.filter((O, P) => !O.disabled && P > t);
          x.length ? g = x[0].currentName : a.length ? g = a[a.length - 1].currentName : g = C[0].currentName;
        }
        this.activeKey = g, this.$emit("update:modelValue", g);
      }
      this.$emit("on-tab-remove", o.currentName), this.updateNav();
    }, showClose(t) {
      return this.type === "card" ? t.closable !== null ? t.closable : this.closable : !1;
    }, scrollPrev() {
      const t = this.$refs.navScroll.offsetWidth, r = this.getCurrentScrollOffset();
      if (!r)
        return;
      let o = r > t ? r - t : 0;
      this.setOffset(o);
    }, scrollNext() {
      const t = this.$refs.nav.offsetWidth, r = this.$refs.navScroll.offsetWidth, o = this.getCurrentScrollOffset();
      if (t - o <= r)
        return;
      let C = t - o > r * 2 ? o + r : t - r;
      this.setOffset(C);
    }, getCurrentScrollOffset() {
      const { navStyle: t } = this;
      return t.transform ? Number(t.transform.match(/translateX\(-(\d+(\.\d+)*)px\)/)[1]) : 0;
    }, getTabIndex(t) {
      return this.navList.findIndex((r) => r.name === t);
    }, setOffset(t) {
      this.navStyle.transform = `translateX(-${t}px)`;
    }, scrollToActiveTab() {
      if (!this.scrollable)
        return;
      const t = this.$refs.nav, r = this.$el.querySelector(`.${Sn}-tab-active`);
      if (!r)
        return;
      const o = this.$refs.navScroll, C = r.getBoundingClientRect(), g = o.getBoundingClientRect(), a = t.getBoundingClientRect(), x = this.getCurrentScrollOffset();
      let O = x;
      a.right < g.right && (O = t.offsetWidth - g.width), C.left < g.left ? O = x - (g.left - C.left) : C.right > g.right && (O = x + C.right - g.right), x !== O && this.setOffset(Math.max(O, 0));
    }, updateNavScroll() {
      const t = this.$refs.nav.offsetWidth, r = this.$refs.navScroll.offsetWidth, o = this.getCurrentScrollOffset();
      r < t ? (this.scrollable = !0, t - o < r && this.setOffset(t - r)) : (this.scrollable = !1, o > 0 && this.setOffset(0));
    }, handleScroll(t) {
      t.preventDefault(), t.stopPropagation();
      const r = t.type;
      let o = 0;
      (r === "DOMMouseScroll" || r === "mousewheel") && (o = t.wheelDelta ? t.wheelDelta : -(t.detail || 0) * 40), o > 0 ? this.scrollPrev() : this.scrollNext();
    }, handleResize() {
      this.updateNavScroll();
    }, isInsideHiddenElement() {
      if (!h)
        return;
      let t = this.$el.parentNode;
      for (; t && t !== document.body; ) {
        if (t.style && t.style.display === "none")
          return t;
        t = t.parentNode;
      }
      return !1;
    }, updateVisibility(t) {
      [...this.$refs.panes.querySelectorAll(`.${Sn}-tabpane`)].forEach((r, o) => {
        t === o ? ([...r.children].filter((C) => C.classList.contains(`${Sn}-tabpane`)).forEach((C) => C.style.visibility = "visible"), this.captureFocus && setTimeout(() => gv(r, r), Cd)) : setTimeout(() => {
          [...r.children].filter((C) => C.classList.contains(`${Sn}-tabpane`)).forEach((C) => C.style.visibility = "hidden");
        }, Cd);
      });
    }, handleDrag(t, r) {
      const o = this.navList[t];
      o && r.dataTransfer.setData("tab-name", o.name);
    }, handleDrop(t, r) {
      const o = this.navList[t];
      if (o) {
        const C = r.dataTransfer.getData("tab-name");
        r.preventDefault();
        let g = this.navList.map((O) => O.name);
        const a = parseInt(g.findIndex((O) => O === C)), x = parseInt(g.findIndex((O) => O === o.name));
        g.splice(x, 1, ...g.splice(a, 1, g[x])), this.$emit("on-drag-drop", C, o.name, a, x, g);
      }
    }, closeContextMenu() {
      this.handleClickContextMenuOutside();
    }, handleClickDropdownItem() {
      this.autoCloseContextmenu && this.closeContextMenu();
    } }, watch: { modelValue(t) {
      this.activeKey = t, this.focusedKey = t;
    }, activeKey(t) {
      this.focusedKey = t, this.updateBar(), this.updateStatus(), this.tableList.forEach((o) => {
        o.table.handleOnVisibleChange(!0);
      }), e.nextTick(() => {
        this.scrollToActiveTab();
      });
      const r = Math.max(this.getTabIndex(this.focusedKey), 0);
      this.updateVisibility(r);
    } }, mounted() {
      this.showSlot = this.$slots.extra !== void 0, this.observer = ho(), this.observer.listenTo(this.$refs.navWrap, this.handleResize);
      const t = this.isInsideHiddenElement();
      t && (this.mutationObserver = new de(() => {
        t.style.display !== "none" && (this.updateBar(), this.mutationObserver.disconnect());
      }), this.mutationObserver.observe(t, { attributes: !0, childList: !0, characterData: !0, attributeFilter: ["style"] })), this.handleTabKeyboardSelect(!0), this.updateVisibility(this.getTabIndex(this.activeKey));
    }, beforeUnmount() {
      this.observer.removeListener(this.$refs.navWrap, this.handleResize), this.mutationObserver && this.mutationObserver.disconnect();
    } }, jB = ["onClick", "onDblclick", "onContextmenu", "onSelectstart", "draggable", "onDragstart", "onDrop"];
    function HB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Render"), P = e.resolveComponent("DropdownMenu"), N = e.resolveComponent("Dropdown");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), ref: "tabsWrap" }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-bar"]) }, [g.showSlot ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-nav-right"]) }, [e.renderSlot(t.$slots, "extra")], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-nav-container"]), tabindex: "0", ref: "navContainer", onKeydown: [r[5] || (r[5] = (...B) => a.handleTabKeyNavigation && a.handleTabKeyNavigation(...B)), r[6] || (r[6] = e.withKeys(e.withModifiers((B) => a.handleTabKeyboardSelect(!1), ["prevent"]), ["space"]))] }, [e.createElementVNode("div", { ref: "navWrap", class: e.normalizeClass([g.prefixCls + "-nav-wrap", g.scrollable ? g.prefixCls + "-nav-scrollable" : ""]) }, [e.createElementVNode("span", { class: e.normalizeClass([g.prefixCls + "-nav-prev", g.scrollable ? "" : g.prefixCls + "-nav-scroll-disabled"]), onClick: r[0] || (r[0] = (...B) => a.scrollPrev && a.scrollPrev(...B)) }, [e.createVNode(x, { type: "ios-arrow-back" })], 2), e.createElementVNode("span", { class: e.normalizeClass([g.prefixCls + "-nav-next", g.scrollable ? "" : g.prefixCls + "-nav-scroll-disabled"]), onClick: r[1] || (r[1] = (...B) => a.scrollNext && a.scrollNext(...B)) }, [e.createVNode(x, { type: "ios-arrow-forward" })], 2), e.createElementVNode("div", { ref: "navScroll", class: e.normalizeClass([g.prefixCls + "-nav-scroll"]), "on:DOMMouseScroll": r[3] || (r[3] = (...B) => a.handleScroll && a.handleScroll(...B)), onMousewheel: r[4] || (r[4] = (...B) => a.handleScroll && a.handleScroll(...B)) }, [e.createElementVNode("div", { ref: "nav", class: e.normalizeClass([g.prefixCls + "-nav"]), style: e.normalizeStyle(g.navStyle) }, [e.createElementVNode("div", { class: e.normalizeClass(a.barClasses), style: e.normalizeStyle(a.barStyle) }, null, 6), (e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.navList, (B, H) => (e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.tabCls(B)), key: H, onClick: (oe) => a.handleChange(H), onDblclick: (oe) => a.handleDblclick(H), onContextmenu: e.withModifiers((oe) => a.handleContextmenu(H, oe), ["stop"]), onSelectstart: e.withModifiers((oe) => a.handlePreventSelect(H, oe), ["stop"]), draggable: o.draggable, onDragstart: (oe) => a.handleDrag(H, oe), onDrop: (oe) => a.handleDrop(H, oe), onDragover: r[2] || (r[2] = e.withModifiers(() => {
      }, ["prevent"])) }, [B.icon !== "" ? (e.openBlock(), e.createBlock(x, { key: 0, type: B.icon }, null, 8, ["type"])) : e.createCommentVNode("", !0), B.labelType === "function" ? (e.openBlock(), e.createBlock(O, { key: 1, render: B.label }, null, 8, ["render"])) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 2 }, [e.createTextVNode(e.toDisplayString(B.label), 1)], 64)), a.showClose(B) ? (e.openBlock(), e.createBlock(x, { key: 3, class: e.normalizeClass([g.prefixCls + "-close"]), type: a.arrowType, custom: a.customArrowType, size: a.arrowSize, onClick: e.withModifiers((oe) => a.handleRemove(H), ["stop"]) }, null, 8, ["class", "type", "custom", "size", "onClick"])) : e.createCommentVNode("", !0)], 42, jB))), 128))], 6)], 34)], 2)], 34)], 2), e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses), style: e.normalizeStyle(a.contentStyle), ref: "panes" }, [e.renderSlot(t.$slots, "default")], 6), e.createElementVNode("div", { class: "ivu-tabs-context-menu", style: e.normalizeStyle(g.contextMenuStyles) }, [e.createVNode(N, { trigger: "custom", visible: g.contextMenuVisible, transfer: "", onOnClick: a.handleClickDropdownItem, onOnClickoutside: a.handleClickContextMenuOutside }, { list: e.withCtx(() => [e.createVNode(P, null, { default: e.withCtx(() => [e.renderSlot(t.$slots, "contextMenu")]), _: 3 })]), _: 3 }, 8, ["visible", "onOnClick", "onOnClickoutside"])], 4)], 2);
    }
    var Dc = f(RB, [["render", HB]]);
    const UB = { name: "Notification", components: { Dropdown: ys, DropdownMenu: bs, Badge: ql, Tabs: Dc }, emits: ["on-visible-change", "on-item-click", "on-clear", "on-load-more", "on-tab-change"], provide() {
      return { NotificationInstance: this };
    }, props: { count: { type: Number }, autoCount: { type: Boolean, default: !1 }, countType: { validator(t) {
      return z(t, ["text", "badge"]);
    }, default: "text" }, icon: { type: String, default: "md-notifications-outline" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "bottom" }, badgeProps: { type: Object, default() {
      return {};
    } }, clearClose: { type: Boolean, default: !1 }, locale: { type: Object, default() {
      return { loadedAll: "加载完毕", loading: "加载中...", loadMore: "加载更多", clear: "清空" };
    } }, tab: { type: String }, wide: { type: Boolean, default: !1 }, transferClassName: { type: String } }, data() {
      return { visible: !1, countAll: 0, tabList: [] };
    }, computed: { finalCount() {
      return this.autoCount ? this.countAll : this.count;
    }, transferClasses() {
      let t = "ivu-notifications-transfer";
      return this.transferClassName && (t += ` ${this.transferClassName}`), t;
    } }, watch: { visible(t) {
      this.$emit("on-visible-change", t);
    } }, methods: { handleVisibleChange(t) {
      this.visible = t;
    }, handleClickOutside(t) {
      this.$refs.notice.contains(t.target) || (this.visible = !1);
    }, handleToggleOpen() {
      this.visible = !this.visible;
    }, handleGetCountAll() {
      if (this.autoCount) {
        const t = this.tabList.map((o) => o.tab);
        let r = 0;
        t.forEach((o) => {
          o.count && (r += o.count);
        }), this.countAll = r;
      }
    }, handleItemClick(t, r) {
      this.$emit("on-item-click", t, r);
    }, handleClear(t) {
      this.$emit("on-clear", t), this.clearClose && this.handleClose();
    }, handleLoadMore(t) {
      this.$emit("on-load-more", t);
    }, handleClose() {
      this.visible = !1;
    }, handleTabChange(t) {
      const r = this.tabList.map((C) => C.tab);
      let o = {};
      r.forEach((C) => {
        C.$refs.tab.currentName === t && (o = C.handleGetTabBaseInfo());
      }), this.$emit("on-tab-change", o);
    } } }, WB = { class: "ivu-notifications", ref: "notice" }, YB = { class: "ivu-notifications-tabs" }, KB = { key: 0, class: "ivu-notifications-extra" };
    function GB(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Badge"), P = e.resolveComponent("Tabs"), N = e.resolveComponent("DropdownMenu"), B = e.resolveComponent("Dropdown");
      return e.openBlock(), e.createElementBlock("div", WB, [e.createVNode(B, { trigger: "custom", visible: g.visible, transfer: o.transfer, placement: o.placement, "transfer-class-name": a.transferClasses, onOnVisibleChange: a.handleVisibleChange, onOnClickoutside: a.handleClickOutside }, { list: e.withCtx(() => [t.$slots.default ? (e.openBlock(), e.createBlock(N, { key: 0, onClick: r[1] || (r[1] = e.withModifiers(() => {
      }, ["stop"])) }, { default: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass(["ivu-notifications-list", { "ivu-notifications-list-wide": o.wide }]) }, [e.createElementVNode("div", YB, [e.createVNode(P, { animated: !1, "model-value": o.tab, onOnClick: a.handleTabChange }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), _: 3 }, 8, ["model-value", "onOnClick"])])], 2), t.$slots.extra ? (e.openBlock(), e.createElementBlock("div", KB, [e.renderSlot(t.$slots, "extra")])) : e.createCommentVNode("", !0)]), _: 3 })) : e.createCommentVNode("", !0)]), default: e.withCtx(() => [e.createElementVNode("div", { class: "ivu-notifications-rel", onClick: r[0] || (r[0] = e.withModifiers((...H) => a.handleToggleOpen && a.handleToggleOpen(...H), ["prevent", "stop"])) }, [e.createVNode(O, e.mergeProps({ count: a.finalCount }, o.badgeProps), { default: e.withCtx(() => [e.renderSlot(t.$slots, "icon", {}, () => [e.createVNode(x, { type: o.icon, size: "24" }, null, 8, ["type"])])]), _: 3 }, 16, ["count"])])]), _: 3 }, 8, ["visible", "transfer", "placement", "transfer-class-name", "onOnVisibleChange", "onOnClickoutside"])], 512);
    }
    var vv = f(UB, [["render", GB]]);
    const XB = (t, r) => t <= r, Ea = (t) => t < 10 ? "0" + t : t, yv = (t, r) => {
      const o = new Date(t), C = o.getFullYear(), g = Ea(o.getMonth() + 1), a = Ea(o.getDate()), x = Ea(o.getHours()), O = Ea(o.getMinutes()), P = Ea(o.getSeconds());
      let N = "";
      return r === "year" ? N = C + "-" + g + "-" + a + " " + x + ":" + O + ":" + P : N = g + "-" + a + " " + x + ":" + O, N;
    }, qB = (t, r) => {
      const o = (/* @__PURE__ */ new Date()).getTime(), C = XB(t, o);
      let g = o - t;
      C || (g = -g);
      let a = "", x = C ? r("i.time.before") || "前" : r("i.time.after") || "后";
      return g < 1e3 ? a = r("i.time.just") || "刚刚" : g < 6e4 ? a = parseInt(g / 1e3) + (r("i.time.seconds") || "秒") + x : g >= 6e4 && g < 36e5 ? a = Math.floor(g / 6e4) + (r("i.time.minutes") || "分钟") + x : g >= 36e5 && g < 864e5 ? a = Math.floor(g / 36e5) + (r("i.time.hours") || "小时") + x : g >= 864e5 && g < 262386e4 ? a = Math.floor(g / 864e5) + (r("i.time.days") || "天") + x : g >= 262386e4 && g <= 3156786e4 && C ? a = yv(t) : a = yv(t, "year"), a;
    };
    function JB(t, r) {
      return qB(t, r);
    }
    const bv = "ivu-time", QB = { name: "Time", mixins: [Kt], props: { time: { type: [Number, Date, String], required: !0 }, type: { type: String, validator(t) {
      return z(t, ["relative", "date", "datetime"]);
    }, default: "relative" }, hash: { type: String, default: "" }, interval: { type: Number, default: 60 } }, data() {
      return { date: "" };
    }, computed: { classes() {
      return [`${bv}`, { [`${bv}-with-hash`]: this.hash }];
    } }, watch: { time() {
      this.setTime();
    } }, methods: { handleClick() {
      h && this.hash !== "" && (window.location.hash = this.hash);
    }, setTime() {
      const t = typeof this.time;
      let r;
      if (t === "number") {
        const o = this.time.toString().length > 10 ? this.time : this.time * 1e3;
        r = new Date(o).getTime();
      } else
        t === "object" ? r = this.time.getTime() : t === "string" && (r = Zn(this.time).valueOf());
      if (this.type === "relative")
        this.date = JB(r, this.t);
      else {
        const o = new Date(this.time), C = o.getFullYear(), g = o.getMonth() + 1 < 10 ? "0" + (o.getMonth() + 1) : o.getMonth() + 1, a = o.getDate() < 10 ? "0" + o.getDate() : o.getDate(), x = o.getHours() < 10 ? "0" + o.getHours() : o.getHours(), O = o.getMinutes() < 10 ? "0" + o.getMinutes() : o.getMinutes(), P = o.getSeconds() < 10 ? "0" + o.getSeconds() : o.getSeconds();
        this.type === "datetime" ? this.date = `${C}-${g}-${a} ${x}:${O}:${P}` : this.type === "date" && (this.date = `${C}-${g}-${a}`);
      }
    } }, mounted() {
      this.setTime(), this.interval !== 0 && (this.timer = setInterval(() => {
        this.setTime();
      }, 1e3 * this.interval));
    }, beforeUnmount() {
      this.timer && clearInterval(this.timer);
    } };
    function ZB(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", { class: e.normalizeClass(a.classes), onClick: r[0] || (r[0] = (...x) => a.handleClick && a.handleClick(...x)) }, e.toDisplayString(g.date), 3);
    }
    var Nc = f(QB, [["render", ZB]]);
    const eP = { name: "NotificationItem", inject: ["NotificationTabInstance", "NotificationInstance"], components: { Row: Er, Col: Ii, Avatar: Jo, Tag: so, Time: Nc }, emits: ["on-item-click"], props: { rowProps: { type: Object, default() {
      return { type: "flex", justify: "center", align: "middle" };
    } }, read: { type: [Boolean, Number], default: !1 }, icon: { type: String }, customIcon: { type: String }, iconColor: { type: String }, iconSize: { validator(t) {
      return z(t, ["small", "default", "large"]);
    }, default: "default" }, avatar: { type: String }, avatarShape: { validator(t) {
      return z(t, ["circle", "square"]);
    }, default: "circle" }, title: { type: String }, content: { type: String }, time: { type: [Number, Date, String] }, timeProps: { type: Object, default() {
      return {};
    } }, tag: { type: String }, tagProps: { type: Object, default() {
      return {};
    } }, clickClose: { type: Boolean, default: !1 } }, data() {
      return { id: be(6) };
    }, computed: { classes() {
      return { "ivu-notifications-item-unread": this.read === !1 || this.read === 0 };
    }, contentSpan() {
      return this.icon || this.customIcon || this.avatar || this.$slots.avatar ? 20 : 24;
    }, iconStyle() {
      let t = {};
      return this.iconColor && (t = { "background-color": this.iconColor }), t;
    } }, methods: { handleClick() {
      this.$emit("on-item-click", this.$attrs), this.NotificationTabInstance.handleItemClick(this.$attrs), this.clickClose && this.NotificationInstance.handleClose();
    }, addItem() {
      this.NotificationTabInstance.itemList.push({ id: this.id, item: this });
    }, removeItem() {
      const t = this.NotificationTabInstance, r = t.itemList.findIndex((o) => o.id === this.id);
      t.itemList.splice(r, 1);
    } }, mounted() {
      this.addItem(), this.NotificationTabInstance.handleGetItems();
    }, unmounted() {
      this.NotificationTabInstance.handleGetItems();
    }, beforeUnmount() {
      this.removeItem();
    } }, tP = { class: "ivu-notifications-item-title" }, nP = { key: 0 }, iP = { key: 0, class: "ivu-notifications-item-tag" }, rP = { key: 0, class: "ivu-notifications-item-desc" }, sP = { key: 1, class: "ivu-notifications-item-time" };
    function oP(t, r, o, C, g, a) {
      const x = e.resolveComponent("Avatar"), O = e.resolveComponent("Col"), P = e.resolveComponent("Tag"), N = e.resolveComponent("Time"), B = e.resolveComponent("Row");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-notifications-item", a.classes]), onClick: r[0] || (r[0] = (...H) => a.handleClick && a.handleClick(...H)) }, [e.renderSlot(t.$slots, "default", {}, () => [e.createVNode(B, e.normalizeProps(e.guardReactiveProps(o.rowProps)), { default: e.withCtx(() => [o.icon || o.customIcon || o.avatar || t.$slots.avatar ? (e.openBlock(), e.createBlock(O, { key: 0, span: "4", class: "ivu-notifications-item-icon" }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "avatar", {}, () => [o.icon ? (e.openBlock(), e.createBlock(x, { key: 0, icon: o.icon, shape: o.avatarShape, size: o.iconSize, style: e.normalizeStyle(a.iconStyle) }, null, 8, ["icon", "shape", "size", "style"])) : o.customIcon ? (e.openBlock(), e.createBlock(x, { key: 1, "custom-icon": o.customIcon, shape: o.avatarShape, size: o.iconSize, style: e.normalizeStyle(a.iconStyle) }, null, 8, ["custom-icon", "shape", "size", "style"])) : o.avatar ? (e.openBlock(), e.createBlock(x, { key: 2, src: o.avatar, shape: o.avatarShape, size: o.iconSize, style: e.normalizeStyle(a.iconStyle) }, null, 8, ["src", "shape", "size", "style"])) : e.createCommentVNode("", !0)])]), _: 3 })) : e.createCommentVNode("", !0), e.createVNode(O, { span: a.contentSpan, class: "ivu-notifications-item-content" }, { default: e.withCtx(() => [e.createElementVNode("div", tP, [o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("h4", nP, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)]), o.tag ? (e.openBlock(), e.createElementBlock("div", iP, [e.createVNode(P, e.normalizeProps(e.guardReactiveProps(o.tagProps)), { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.tag), 1)]), _: 1 }, 16)])) : e.createCommentVNode("", !0)])) : e.createCommentVNode("", !0)]), o.content || t.$slots.content ? (e.openBlock(), e.createElementBlock("div", rP, [e.renderSlot(t.$slots, "content", {}, () => [e.createTextVNode(e.toDisplayString(o.content), 1)])])) : e.createCommentVNode("", !0), o.time || t.$slots.time ? (e.openBlock(), e.createElementBlock("div", sP, [e.renderSlot(t.$slots, "time", {}, () => [e.createVNode(N, e.mergeProps({ time: o.time }, o.timeProps), null, 16, ["time"])])])) : e.createCommentVNode("", !0)]), _: 3 }, 8, ["span"])]), _: 3 }, 16)])], 2);
    }
    var Cv = f(eP, [["render", oP]]);
    const aP = "ivu-tabs-tabpane", lP = { name: "TabPane", inject: ["TabsInstance"], props: { name: { type: String }, label: { type: [String, Function], default: "" }, icon: { type: String }, disabled: { type: Boolean, default: !1 }, closable: { type: Boolean, default: null }, tab: { type: String }, index: { type: Number }, contextMenu: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: aP, show: !0, currentName: this.name, id: be(6) };
    }, computed: { contentStyle() {
      return { visibility: this.TabsInstance.activeKey !== this.currentName ? "hidden" : "visible" };
    } }, methods: { updateNav() {
      this.TabsInstance.updateNav();
    }, addPane() {
      const t = this.TabsInstance;
      t.paneList || (t.paneList = []), t.paneList.push({ id: this.id, pane: this });
    }, removePane() {
      const t = this.TabsInstance;
      if (t.paneList && t.paneList.length) {
        const r = t.paneList.findIndex((o) => o.id === this.id);
        t.paneList.splice(r, 1);
      }
    } }, watch: { name(t) {
      this.currentName = t, this.updateNav();
    }, label(t) {
      typeof t != "function" && this.updateNav();
    }, icon() {
      this.updateNav();
    }, disabled() {
      this.updateNav();
    } }, mounted() {
      this.addPane(), this.updateNav();
    }, beforeUnmount() {
      this.removePane(), this.updateNav();
    } };
    function cP(t, r, o, C, g, a) {
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(g.prefixCls), style: e.normalizeStyle(a.contentStyle) }, [e.renderSlot(t.$slots, "default")], 6)), [[e.vShow, g.show]]);
    }
    var Bc = f(lP, [["render", cP]]);
    const uP = { name: "NotificationTab", inject: ["NotificationInstance"], components: { TabPane: Bc, Icon: G }, provide() {
      return { NotificationTabInstance: this };
    }, props: { count: { type: Number }, title: { type: String, required: !0 }, name: { type: String }, emptyText: { type: String, default: "目前没有通知" }, emptyImage: { type: String, default: "https://file.iviewui.com/iview-pro/icon-no-message.svg" }, loadedAll: { type: Boolean, default: !0 }, showLoadedAll: { type: Boolean, default: !0 }, loading: { type: Boolean, default: !1 }, scrollToLoad: { type: Boolean, default: !0 }, showClear: { type: Boolean, default: !0 }, showClearIcon: { type: Boolean, default: !0 } }, data() {
      return { customLabel: (t) => t("div", [t("span", this.title), t(ql, { count: this.count })]), itemCount: 0, itemList: [], id: be(6) };
    }, computed: { currentTitle() {
      const t = this.NotificationInstance.countType;
      if (t === "text") {
        const r = this.count ? `(${this.count})` : "";
        return `${this.title} ${r}`;
      } else if (t === "badge")
        return this.customLabel;
    } }, watch: { count: { handler() {
      this.NotificationInstance.handleGetCountAll();
    }, immediate: !0 } }, methods: { handleGetTabBaseInfo() {
      return { name: this.name, title: this.title };
    }, handleGetItems() {
      const t = this.itemList.map((r) => r.item);
      this.itemCount = t.length;
    }, handleItemClick(t) {
      this.NotificationInstance.handleItemClick(this.handleGetTabBaseInfo(), t);
    }, handleClear() {
      this.NotificationInstance.handleClear(this.handleGetTabBaseInfo());
    }, handleLoadMore() {
      this.NotificationInstance.handleLoadMore(this.handleGetTabBaseInfo());
    }, handleScroll() {
      if (!this.scrollToLoad)
        return;
      const t = this.$refs.scroll, r = t.scrollHeight - t.clientHeight - t.scrollTop;
      !this.loading && r === 0 && this.handleLoadMore();
    }, addTab() {
      this.NotificationInstance.tabList.push({ id: this.id, tab: this });
    }, removeTab() {
      const t = this.NotificationInstance, r = t.tabList.findIndex((o) => o.id === this.id);
      t.tabList.splice(r, 1);
    } }, mounted() {
      this.addTab();
    }, beforeUnmount() {
      this.removeTab();
    } }, hP = { class: "ivu-notifications-container-list" }, dP = { key: 0, class: "ivu-notifications-tab-empty" }, fP = ["src"], pP = { class: "ivu-notifications-tab-empty-text" }, mP = { class: "ivu-notifications-tab-loading" }, gP = { key: 0, class: "ivu-notifications-tab-loading-item ivu-notifications-tab-loading-show" }, vP = { key: 2, class: "ivu-notifications-tab-loading-item ivu-notifications-tab-loading-all" };
    function yP(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("TabPane");
      return e.openBlock(), e.createBlock(O, { label: a.currentTitle, name: o.name, ref: "tab", class: "ivu-notifications-tab" }, { default: e.withCtx(() => [e.createElementVNode("div", { class: "ivu-notifications-container", onScroll: r[1] || (r[1] = (...P) => a.handleScroll && a.handleScroll(...P)), ref: "scroll" }, [e.renderSlot(t.$slots, "top"), e.createElementVNode("div", hP, [e.renderSlot(t.$slots, "default")]), !o.loading && g.itemCount === 0 ? (e.openBlock(), e.createElementBlock("div", dP, [e.renderSlot(t.$slots, "empty", {}, () => [o.emptyImage ? (e.openBlock(), e.createElementBlock("img", { key: 0, class: "ivu-notifications-tab-empty-img", src: o.emptyImage }, null, 8, fP)) : e.createCommentVNode("", !0), e.createElementVNode("div", pP, e.toDisplayString(o.emptyText), 1)])])) : e.createCommentVNode("", !0), e.createElementVNode("div", mP, [o.loading ? (e.openBlock(), e.createElementBlock("div", gP, [e.renderSlot(t.$slots, "loading", {}, () => [e.createVNode(x, { type: "ios-loading", class: "ivu-load-loop" }), e.createTextVNode(" " + e.toDisplayString(a.NotificationInstance.locale.loading), 1)])])) : o.loadedAll ? o.showLoadedAll && o.loadedAll ? (e.openBlock(), e.createElementBlock("div", vP, [e.renderSlot(t.$slots, "loaded-all", {}, () => [e.createTextVNode(e.toDisplayString(a.NotificationInstance.locale.loadedAll), 1)])])) : e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 1, class: "ivu-notifications-tab-loading-item ivu-notifications-tab-loading-more", onClick: r[0] || (r[0] = (...P) => a.handleLoadMore && a.handleLoadMore(...P)) }, [e.renderSlot(t.$slots, "load-more", {}, () => [e.createTextVNode(e.toDisplayString(a.NotificationInstance.locale.loadMore), 1)])]))])], 544), o.showClear && g.itemCount !== 0 ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-notifications-tab-clear", onClick: r[2] || (r[2] = (...P) => a.handleClear && a.handleClear(...P)) }, [e.renderSlot(t.$slots, "clear", {}, () => [o.showClearIcon ? (e.openBlock(), e.createBlock(x, { key: 0, type: "md-done-all" })) : e.createCommentVNode("", !0), e.createElementVNode("span", null, e.toDisplayString(a.NotificationInstance.locale.clear) + e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0)]), _: 3 }, 8, ["label", "name"]);
    }
    var wv = f(uP, [["render", yP]]);
    const bP = { name: "Trend", components: { Icon: G }, props: { flag: { validator(t) {
      return z(t, ["up", "down"]);
    } }, colorful: { type: Boolean, default: !0 }, reverseColor: { type: Boolean, default: !1 }, textColor: { type: Boolean, default: !1 }, showTitle: { type: [Boolean, String], default: !1 } }, computed: { classes() {
      return [{ "ivu-trend-up": this.flag === "up", "ivu-trend-down": this.flag === "down", "ivu-trend-reverse-color": this.reverseColor, "ivu-trend-colorful": this.colorful, "ivu-trend-text-color": this.textColor }];
    }, flagType() {
      return this.flag === "up" ? "md-arrow-dropup" : this.flag === "down" ? "md-arrow-dropdown" : "";
    } } }, CP = { class: "ivu-trend-text" };
    function wP(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-trend", a.classes]) }, [e.createElementVNode("span", CP, [e.renderSlot(t.$slots, "default")]), e.createVNode(x, { type: a.flagType, class: "ivu-trend-flag" }, null, 8, ["type"])], 2);
    }
    var wd = f(bP, [["render", wP]]);
    const kP = { name: "NumberInfo", components: { Trend: wd }, props: { title: { type: String }, subTitle: { type: String }, total: { type: [String, Number] }, subTotal: { type: [String, Number] }, status: { validator(t) {
      return z(t, ["up", "down"]);
    } }, gap: { type: [String, Number], default: 8 } }, computed: { valueStyle() {
      return { "margin-top": this.gap + "px" };
    } } }, SP = { class: "ivu-number-info" }, EP = { key: 0, class: "ivu-number-info-title" }, xP = { key: 1, class: "ivu-number-info-subTitle" }, _P = { class: "ivu-number-info-total" }, TP = { key: 0, class: "ivu-number-info-subTotal" };
    function OP(t, r, o, C, g, a) {
      const x = e.resolveComponent("Trend");
      return e.openBlock(), e.createElementBlock("div", SP, [o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("div", EP, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0), o.subTitle || t.$slots.subTitle ? (e.openBlock(), e.createElementBlock("div", xP, [e.renderSlot(t.$slots, "subTitle", {}, () => [e.createTextVNode(e.toDisplayString(o.subTitle), 1)])])) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: "ivu-number-info-value", style: e.normalizeStyle(a.valueStyle) }, [e.createElementVNode("span", _P, [e.renderSlot(t.$slots, "total", {}, () => [e.createTextVNode(e.toDisplayString(o.total), 1)])]), o.subTotal || t.$slots.subTotal ? (e.openBlock(), e.createElementBlock("span", TP, [e.renderSlot(t.$slots, "subTotal", {}, () => [e.createVNode(x, { flag: o.status }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(o.subTotal), 1)]), _: 1 }, 8, ["flag"])])])) : e.createCommentVNode("", !0)], 4)]);
    }
    var kv = f(kP, [["render", OP]]), Sv = { exports: {} };
    /*! @preserve
    * numeral.js
    * version : 2.0.6
    * author : Adam Draper
    * license : MIT
    * http://adamwdraper.github.com/Numeral-js/
    */
    (function(t) {
      (function(r, o) {
        t.exports ? t.exports = o() : r.numeral = o();
      })(pt, function() {
        var r, o, C = "2.0.6", g = {}, a = {}, x = { currentLocale: "en", zeroFormat: null, nullFormat: null, defaultFormat: "0,0", scalePercentBy100: !0 }, O = { currentLocale: x.currentLocale, zeroFormat: x.zeroFormat, nullFormat: x.nullFormat, defaultFormat: x.defaultFormat, scalePercentBy100: x.scalePercentBy100 };
        function P(N, B) {
          this._input = N, this._value = B;
        }
        return r = function(N) {
          var B, H, oe, se;
          if (r.isNumeral(N))
            B = N.value();
          else if (N === 0 || typeof N > "u")
            B = 0;
          else if (N === null || o.isNaN(N))
            B = null;
          else if (typeof N == "string")
            if (O.zeroFormat && N === O.zeroFormat)
              B = 0;
            else if (O.nullFormat && N === O.nullFormat || !N.replace(/[^0-9]+/g, "").length)
              B = null;
            else {
              for (H in g)
                if (se = typeof g[H].regexps.unformat == "function" ? g[H].regexps.unformat() : g[H].regexps.unformat, se && N.match(se)) {
                  oe = g[H].unformat;
                  break;
                }
              oe = oe || r._.stringToNumber, B = oe(N);
            }
          else
            B = Number(N) || null;
          return new P(N, B);
        }, r.version = C, r.isNumeral = function(N) {
          return N instanceof P;
        }, r._ = o = { numberToFormat: function(N, B, H) {
          var oe = a[r.options.currentLocale], se = !1, ee = !1, j = 0, pe = "", at = 1e12, Qe = 1e9, tt = 1e6, Ee = 1e3, ye = "", ze = !1, Oe, lt, it, Ze, kt, ot, Ue;
          if (N = N || 0, lt = Math.abs(N), r._.includes(B, "(") ? (se = !0, B = B.replace(/[\(|\)]/g, "")) : (r._.includes(B, "+") || r._.includes(B, "-")) && (kt = r._.includes(B, "+") ? B.indexOf("+") : N < 0 ? B.indexOf("-") : -1, B = B.replace(/[\+|\-]/g, "")), r._.includes(B, "a") && (Oe = B.match(/a(k|m|b|t)?/), Oe = Oe ? Oe[1] : !1, r._.includes(B, " a") && (pe = " "), B = B.replace(new RegExp(pe + "a[kmbt]?"), ""), lt >= at && !Oe || Oe === "t" ? (pe += oe.abbreviations.trillion, N = N / at) : lt < at && lt >= Qe && !Oe || Oe === "b" ? (pe += oe.abbreviations.billion, N = N / Qe) : lt < Qe && lt >= tt && !Oe || Oe === "m" ? (pe += oe.abbreviations.million, N = N / tt) : (lt < tt && lt >= Ee && !Oe || Oe === "k") && (pe += oe.abbreviations.thousand, N = N / Ee)), r._.includes(B, "[.]") && (ee = !0, B = B.replace("[.]", ".")), it = N.toString().split(".")[0], Ze = B.split(".")[1], ot = B.indexOf(","), j = (B.split(".")[0].split(",")[0].match(/0/g) || []).length, Ze ? (r._.includes(Ze, "[") ? (Ze = Ze.replace("]", ""), Ze = Ze.split("["), ye = r._.toFixed(N, Ze[0].length + Ze[1].length, H, Ze[1].length)) : ye = r._.toFixed(N, Ze.length, H), it = ye.split(".")[0], r._.includes(ye, ".") ? ye = oe.delimiters.decimal + ye.split(".")[1] : ye = "", ee && Number(ye.slice(1)) === 0 && (ye = "")) : it = r._.toFixed(N, 0, H), pe && !Oe && Number(it) >= 1e3 && pe !== oe.abbreviations.trillion)
            switch (it = String(Number(it) / 1e3), pe) {
              case oe.abbreviations.thousand:
                pe = oe.abbreviations.million;
                break;
              case oe.abbreviations.million:
                pe = oe.abbreviations.billion;
                break;
              case oe.abbreviations.billion:
                pe = oe.abbreviations.trillion;
                break;
            }
          if (r._.includes(it, "-") && (it = it.slice(1), ze = !0), it.length < j)
            for (var Ke = j - it.length; Ke > 0; Ke--)
              it = "0" + it;
          return ot > -1 && (it = it.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + oe.delimiters.thousands)), B.indexOf(".") === 0 && (it = ""), Ue = it + ye + (pe || ""), se ? Ue = (se && ze ? "(" : "") + Ue + (se && ze ? ")" : "") : kt >= 0 ? Ue = kt === 0 ? (ze ? "-" : "+") + Ue : Ue + (ze ? "-" : "+") : ze && (Ue = "-" + Ue), Ue;
        }, stringToNumber: function(N) {
          var B = a[O.currentLocale], H = N, oe = { thousand: 3, million: 6, billion: 9, trillion: 12 }, se, ee, j;
          if (O.zeroFormat && N === O.zeroFormat)
            ee = 0;
          else if (O.nullFormat && N === O.nullFormat || !N.replace(/[^0-9]+/g, "").length)
            ee = null;
          else {
            ee = 1, B.delimiters.decimal !== "." && (N = N.replace(/\./g, "").replace(B.delimiters.decimal, "."));
            for (se in oe)
              if (j = new RegExp("[^a-zA-Z]" + B.abbreviations[se] + "(?:\\)|(\\" + B.currency.symbol + ")?(?:\\))?)?$"), H.match(j)) {
                ee *= Math.pow(10, oe[se]);
                break;
              }
            ee *= (N.split("-").length + Math.min(N.split("(").length - 1, N.split(")").length - 1)) % 2 ? 1 : -1, N = N.replace(/[^0-9\.]+/g, ""), ee *= Number(N);
          }
          return ee;
        }, isNaN: function(N) {
          return typeof N == "number" && isNaN(N);
        }, includes: function(N, B) {
          return N.indexOf(B) !== -1;
        }, insert: function(N, B, H) {
          return N.slice(0, H) + B + N.slice(H);
        }, reduce: function(N, B) {
          if (this === null)
            throw new TypeError("Array.prototype.reduce called on null or undefined");
          if (typeof B != "function")
            throw new TypeError(B + " is not a function");
          var H = Object(N), oe = H.length >>> 0, se = 0, ee;
          if (arguments.length === 3)
            ee = arguments[2];
          else {
            for (; se < oe && !(se in H); )
              se++;
            if (se >= oe)
              throw new TypeError("Reduce of empty array with no initial value");
            ee = H[se++];
          }
          for (; se < oe; se++)
            se in H && (ee = B(ee, H[se], se, H));
          return ee;
        }, multiplier: function(N) {
          var B = N.toString().split(".");
          return B.length < 2 ? 1 : Math.pow(10, B[1].length);
        }, correctionFactor: function() {
          var N = Array.prototype.slice.call(arguments);
          return N.reduce(function(B, H) {
            var oe = o.multiplier(H);
            return B > oe ? B : oe;
          }, 1);
        }, toFixed: function(N, B, H, oe) {
          var se = N.toString().split("."), ee = B - (oe || 0), j, pe, at, Qe;
          return se.length === 2 ? j = Math.min(Math.max(se[1].length, ee), B) : j = ee, at = Math.pow(10, j), Qe = (H(N + "e+" + j) / at).toFixed(j), oe > B - j && (pe = new RegExp("\\.?0{1," + (oe - (B - j)) + "}$"), Qe = Qe.replace(pe, "")), Qe;
        } }, r.options = O, r.formats = g, r.locales = a, r.locale = function(N) {
          return N && (O.currentLocale = N.toLowerCase()), O.currentLocale;
        }, r.localeData = function(N) {
          if (!N)
            return a[O.currentLocale];
          if (N = N.toLowerCase(), !a[N])
            throw new Error("Unknown locale : " + N);
          return a[N];
        }, r.reset = function() {
          for (var N in x)
            O[N] = x[N];
        }, r.zeroFormat = function(N) {
          O.zeroFormat = typeof N == "string" ? N : null;
        }, r.nullFormat = function(N) {
          O.nullFormat = typeof N == "string" ? N : null;
        }, r.defaultFormat = function(N) {
          O.defaultFormat = typeof N == "string" ? N : "0.0";
        }, r.register = function(N, B, H) {
          if (B = B.toLowerCase(), this[N + "s"][B])
            throw new TypeError(B + " " + N + " already registered.");
          return this[N + "s"][B] = H, H;
        }, r.validate = function(N, B) {
          var H, oe, se, ee, j, pe, at, Qe;
          if (typeof N != "string" && (N += "", console.warn && console.warn("Numeral.js: Value is not string. It has been co-erced to: ", N)), N = N.trim(), N.match(/^\d+$/))
            return !0;
          if (N === "")
            return !1;
          try {
            at = r.localeData(B);
          } catch {
            at = r.localeData(r.locale());
          }
          return se = at.currency.symbol, j = at.abbreviations, H = at.delimiters.decimal, at.delimiters.thousands === "." ? oe = "\\." : oe = at.delimiters.thousands, Qe = N.match(/^[^\d]+/), Qe !== null && (N = N.substr(1), Qe[0] !== se) || (Qe = N.match(/[^\d]+$/), Qe !== null && (N = N.slice(0, -1), Qe[0] !== j.thousand && Qe[0] !== j.million && Qe[0] !== j.billion && Qe[0] !== j.trillion)) ? !1 : (pe = new RegExp(oe + "{2}"), N.match(/[^\d.,]/g) ? !1 : (ee = N.split(H), ee.length > 2 ? !1 : ee.length < 2 ? !!ee[0].match(/^\d+.*\d$/) && !ee[0].match(pe) : ee[0].length === 1 ? !!ee[0].match(/^\d+$/) && !ee[0].match(pe) && !!ee[1].match(/^\d+$/) : !!ee[0].match(/^\d+.*\d$/) && !ee[0].match(pe) && !!ee[1].match(/^\d+$/)));
        }, r.fn = P.prototype = { clone: function() {
          return r(this);
        }, format: function(N, B) {
          var H = this._value, oe = N || O.defaultFormat, se, ee, j;
          if (B = B || Math.round, H === 0 && O.zeroFormat !== null)
            ee = O.zeroFormat;
          else if (H === null && O.nullFormat !== null)
            ee = O.nullFormat;
          else {
            for (se in g)
              if (oe.match(g[se].regexps.format)) {
                j = g[se].format;
                break;
              }
            j = j || r._.numberToFormat, ee = j(H, oe, B);
          }
          return ee;
        }, value: function() {
          return this._value;
        }, input: function() {
          return this._input;
        }, set: function(N) {
          return this._value = Number(N), this;
        }, add: function(N) {
          var B = o.correctionFactor.call(null, this._value, N);
          function H(oe, se, ee, j) {
            return oe + Math.round(B * se);
          }
          return this._value = o.reduce([this._value, N], H, 0) / B, this;
        }, subtract: function(N) {
          var B = o.correctionFactor.call(null, this._value, N);
          function H(oe, se, ee, j) {
            return oe - Math.round(B * se);
          }
          return this._value = o.reduce([N], H, Math.round(this._value * B)) / B, this;
        }, multiply: function(N) {
          function B(H, oe, se, ee) {
            var j = o.correctionFactor(H, oe);
            return Math.round(H * j) * Math.round(oe * j) / Math.round(j * j);
          }
          return this._value = o.reduce([this._value, N], B, 1), this;
        }, divide: function(N) {
          function B(H, oe, se, ee) {
            var j = o.correctionFactor(H, oe);
            return Math.round(H * j) / Math.round(oe * j);
          }
          return this._value = o.reduce([this._value, N], B), this;
        }, difference: function(N) {
          return Math.abs(r(this._value).subtract(N).value());
        } }, r.register("locale", "en", { delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, ordinal: function(N) {
          var B = N % 10;
          return ~~(N % 100 / 10) === 1 ? "th" : B === 1 ? "st" : B === 2 ? "nd" : B === 3 ? "rd" : "th";
        }, currency: { symbol: "$" } }), function() {
          r.register("format", "bps", { regexps: { format: /(BPS)/, unformat: /(BPS)/ }, format: function(N, B, H) {
            var oe = r._.includes(B, " BPS") ? " " : "", se;
            return N = N * 1e4, B = B.replace(/\s?BPS/, ""), se = r._.numberToFormat(N, B, H), r._.includes(se, ")") ? (se = se.split(""), se.splice(-1, 0, oe + "BPS"), se = se.join("")) : se = se + oe + "BPS", se;
          }, unformat: function(N) {
            return +(r._.stringToNumber(N) * 1e-4).toFixed(15);
          } });
        }(), function() {
          var N = { base: 1e3, suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] }, B = { base: 1024, suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"] }, H = N.suffixes.concat(B.suffixes.filter(function(se) {
            return N.suffixes.indexOf(se) < 0;
          })), oe = H.join("|");
          oe = "(" + oe.replace("B", "B(?!PS)") + ")", r.register("format", "bytes", { regexps: { format: /([0\s]i?b)/, unformat: new RegExp(oe) }, format: function(se, ee, j) {
            var pe, at = r._.includes(ee, "ib") ? B : N, Qe = r._.includes(ee, " b") || r._.includes(ee, " ib") ? " " : "", tt, Ee, ye;
            for (ee = ee.replace(/\s?i?b/, ""), tt = 0; tt <= at.suffixes.length; tt++)
              if (Ee = Math.pow(at.base, tt), ye = Math.pow(at.base, tt + 1), se === null || se === 0 || se >= Ee && se < ye) {
                Qe += at.suffixes[tt], Ee > 0 && (se = se / Ee);
                break;
              }
            return pe = r._.numberToFormat(se, ee, j), pe + Qe;
          }, unformat: function(se) {
            var ee = r._.stringToNumber(se), j, pe;
            if (ee) {
              for (j = N.suffixes.length - 1; j >= 0; j--) {
                if (r._.includes(se, N.suffixes[j])) {
                  pe = Math.pow(N.base, j);
                  break;
                }
                if (r._.includes(se, B.suffixes[j])) {
                  pe = Math.pow(B.base, j);
                  break;
                }
              }
              ee *= pe || 1;
            }
            return ee;
          } });
        }(), function() {
          r.register("format", "currency", { regexps: { format: /(\$)/ }, format: function(N, B, H) {
            var oe = r.locales[r.options.currentLocale], se = { before: B.match(/^([\+|\-|\(|\s|\$]*)/)[0], after: B.match(/([\+|\-|\)|\s|\$]*)$/)[0] }, ee, j, pe;
            for (B = B.replace(/\s?\$\s?/, ""), ee = r._.numberToFormat(N, B, H), N >= 0 ? (se.before = se.before.replace(/[\-\(]/, ""), se.after = se.after.replace(/[\-\)]/, "")) : N < 0 && !r._.includes(se.before, "-") && !r._.includes(se.before, "(") && (se.before = "-" + se.before), pe = 0; pe < se.before.length; pe++)
              switch (j = se.before[pe], j) {
                case "$":
                  ee = r._.insert(ee, oe.currency.symbol, pe);
                  break;
                case " ":
                  ee = r._.insert(ee, " ", pe + oe.currency.symbol.length - 1);
                  break;
              }
            for (pe = se.after.length - 1; pe >= 0; pe--)
              switch (j = se.after[pe], j) {
                case "$":
                  ee = pe === se.after.length - 1 ? ee + oe.currency.symbol : r._.insert(ee, oe.currency.symbol, -(se.after.length - (1 + pe)));
                  break;
                case " ":
                  ee = pe === se.after.length - 1 ? ee + " " : r._.insert(ee, " ", -(se.after.length - (1 + pe) + oe.currency.symbol.length - 1));
                  break;
              }
            return ee;
          } });
        }(), function() {
          r.register("format", "exponential", { regexps: { format: /(e\+|e-)/, unformat: /(e\+|e-)/ }, format: function(N, B, H) {
            var oe, se = typeof N == "number" && !r._.isNaN(N) ? N.toExponential() : "0e+0", ee = se.split("e");
            return B = B.replace(/e[\+|\-]{1}0/, ""), oe = r._.numberToFormat(Number(ee[0]), B, H), oe + "e" + ee[1];
          }, unformat: function(N) {
            var B = r._.includes(N, "e+") ? N.split("e+") : N.split("e-"), H = Number(B[0]), oe = Number(B[1]);
            oe = r._.includes(N, "e-") ? oe *= -1 : oe;
            function se(ee, j, pe, at) {
              var Qe = r._.correctionFactor(ee, j), tt = ee * Qe * (j * Qe) / (Qe * Qe);
              return tt;
            }
            return r._.reduce([H, Math.pow(10, oe)], se, 1);
          } });
        }(), function() {
          r.register("format", "ordinal", { regexps: { format: /(o)/ }, format: function(N, B, H) {
            var oe = r.locales[r.options.currentLocale], se, ee = r._.includes(B, " o") ? " " : "";
            return B = B.replace(/\s?o/, ""), ee += oe.ordinal(N), se = r._.numberToFormat(N, B, H), se + ee;
          } });
        }(), function() {
          r.register("format", "percentage", { regexps: { format: /(%)/, unformat: /(%)/ }, format: function(N, B, H) {
            var oe = r._.includes(B, " %") ? " " : "", se;
            return r.options.scalePercentBy100 && (N = N * 100), B = B.replace(/\s?\%/, ""), se = r._.numberToFormat(N, B, H), r._.includes(se, ")") ? (se = se.split(""), se.splice(-1, 0, oe + "%"), se = se.join("")) : se = se + oe + "%", se;
          }, unformat: function(N) {
            var B = r._.stringToNumber(N);
            return r.options.scalePercentBy100 ? B * 0.01 : B;
          } });
        }(), function() {
          r.register("format", "time", { regexps: { format: /(:)/, unformat: /(:)/ }, format: function(N, B, H) {
            var oe = Math.floor(N / 60 / 60), se = Math.floor((N - oe * 60 * 60) / 60), ee = Math.round(N - oe * 60 * 60 - se * 60);
            return oe + ":" + (se < 10 ? "0" + se : se) + ":" + (ee < 10 ? "0" + ee : ee);
          }, unformat: function(N) {
            var B = N.split(":"), H = 0;
            return B.length === 3 ? (H = H + Number(B[0]) * 60 * 60, H = H + Number(B[1]) * 60, H = H + Number(B[2])) : B.length === 2 && (H = H + Number(B[0]) * 60, H = H + Number(B[1])), Number(H);
          } });
        }(), r;
      });
    })(Sv);
    var DP = Sv.exports;
    const NP = { name: "Numeral", emits: ["on-change"], props: { value: { type: [String, Number] }, format: { type: String }, prefix: { type: [String, Number] }, suffix: { type: [String, Number] } }, data() {
      return { currentValue: "" };
    }, watch: { value() {
      this.init();
    }, format() {
      this.init();
    } }, methods: { init() {
      if (this.value !== void 0) {
        const t = DP(this.value);
        this.format ? this.currentValue = t.format(this.format) : this.currentValue = t.value(), this.$emit("on-change", this.currentValue);
      }
    }, getValue() {
      return this.currentValue;
    } }, mounted() {
      this.init();
    } }, BP = { class: "ivu-numeral" };
    function PP(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", BP, [e.renderSlot(t.$slots, "prefix", {}, () => [e.createTextVNode(e.toDisplayString(o.prefix), 1)]), e.createTextVNode(e.toDisplayString(g.currentValue), 1), e.renderSlot(t.$slots, "suffix", {}, () => [e.createTextVNode(e.toDisplayString(o.suffix), 1)])]);
    }
    var Ev = f(NP, [["render", PP]]);
    const VP = "ivu-select-group", $P = { name: "OptionGroup", props: { label: { type: String, default: "" } }, provide() {
      return { OptionGroupInstance: this };
    }, inject: ["SelectInstance"], data() {
      return { prefixCls: VP, hidden: !1, id: be(6), optionList: [] };
    }, computed: { show() {
      return this.optionList.find((t) => t.proxy && t.proxy.isShow);
    } } };
    function IP(t, r, o, C, g, a) {
      return e.withDirectives((e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass([g.prefixCls + "-wrap"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-title"]) }, e.toDisplayString(o.label), 3), e.createElementVNode("ul", null, [e.createElementVNode("li", { class: e.normalizeClass([g.prefixCls]), ref: "options" }, [e.renderSlot(t.$slots, "default")], 2)])], 2)), [[e.vShow, a.show]]);
    }
    var xv = f($P, [["render", IP]]);
    const kd = "ivu-page";
    function MP(t) {
      return /^[1-9][0-9]*$/.test(t + "");
    }
    const AP = { name: "PageOption", mixins: [Kt], components: { iSelect: ps, iOption: Zs }, emits: ["on-size", "on-page"], props: { pageSizeOpts: Array, showSizer: Boolean, showElevator: Boolean, current: Number, _current: Number, pageSize: Number, allPages: Number, isSmall: Boolean, placement: String, transfer: Boolean, disabled: Boolean, eventsEnabled: Boolean }, data() {
      return { currentPageSize: this.pageSize };
    }, watch: { pageSize(t) {
      this.currentPageSize = t;
    } }, computed: { size() {
      return this.isSmall ? "small" : "default";
    }, optsClasses() {
      return [`${kd}-options`];
    }, sizerClasses() {
      return [`${kd}-options-sizer`];
    }, ElevatorClasses() {
      return [`${kd}-options-elevator`];
    } }, methods: { changeSize() {
      this.$emit("on-size", this.currentPageSize);
    }, changePage(t) {
      let r = t.target.value.trim(), o = 0;
      if (MP(r)) {
        if (r = Number(r), r != this.current) {
          const C = this.allPages;
          r > C ? o = C : o = r;
        }
      } else
        o = 1;
      o && (this.$emit("on-page", o), t.target.value = o);
    } } }, FP = ["value", "disabled"];
    function LP(t, r, o, C, g, a) {
      const x = e.resolveComponent("i-option"), O = e.resolveComponent("i-select");
      return o.showSizer || o.showElevator ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.optsClasses) }, [o.showSizer ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.sizerClasses) }, [e.createVNode(O, { modelValue: g.currentPageSize, "onUpdate:modelValue": r[0] || (r[0] = (P) => g.currentPageSize = P), size: a.size, placement: o.placement, transfer: o.transfer, disabled: o.disabled, eventsEnabled: o.eventsEnabled, onOnChange: a.changeSize }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.pageSizeOpts, (P) => (e.openBlock(), e.createBlock(x, { key: P, value: P, style: { "text-align": "center" } }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(P) + " " + e.toDisplayString(t.t("i.page.page")), 1)]), _: 2 }, 1032, ["value"]))), 128))]), _: 1 }, 8, ["modelValue", "size", "placement", "transfer", "disabled", "eventsEnabled", "onOnChange"])], 2)) : e.createCommentVNode("", !0), o.showElevator ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass(a.ElevatorClasses) }, [e.createTextVNode(e.toDisplayString(t.t("i.page.goto")) + " ", 1), e.createElementVNode("input", { type: "text", value: o._current, autocomplete: "off", spellcheck: "false", disabled: o.disabled, onKeyup: r[1] || (r[1] = e.withKeys((...P) => a.changePage && a.changePage(...P), ["enter"])) }, null, 40, FP), e.createTextVNode(" " + e.toDisplayString(t.t("i.page.p")), 1)], 2)) : e.createCommentVNode("", !0)], 2)) : e.createCommentVNode("", !0);
    }
    var zP = f(AP, [["render", LP]]);
    const Mn = "ivu-page", RP = { name: "Page", mixins: [Kt], components: { Options: zP }, emits: ["update:modelValue", "on-change", "on-prev", "on-next", "on-page-size-change"], props: { modelValue: { type: Number, default: 1 }, total: { type: Number, default: 0 }, pageSize: { type: Number, default: 10 }, pageSizeOpts: { type: Array, default() {
      return [10, 20, 30, 40];
    } }, placement: { validator(t) {
      return z(t, ["top", "bottom"]);
    }, default: "bottom" }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, size: { validator(t) {
      return z(t, ["small", "default"]);
    } }, simple: { type: Boolean, default: !1 }, showTotal: { type: Boolean, default: !1 }, showElevator: { type: Boolean, default: !1 }, showSizer: { type: Boolean, default: !1 }, className: { type: String }, styles: { type: Object }, prevText: { type: String, default: "" }, nextText: { type: String, default: "" }, disabled: { type: Boolean, default: !1 }, eventsEnabled: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: Mn, currentPage: this.modelValue, currentPageSize: this.pageSize };
    }, watch: { total(t) {
      let r = Math.ceil(t / this.currentPageSize);
      r < this.currentPage && (this.currentPage = r === 0 ? 1 : r);
    }, modelValue(t) {
      this.currentPage = t;
    }, pageSize(t) {
      this.currentPageSize = t;
    } }, computed: { isSmall() {
      return this.size === "small";
    }, allPages() {
      const t = Math.ceil(this.total / this.currentPageSize);
      return t === 0 ? 1 : t;
    }, simpleWrapClasses() {
      return [`${Mn}`, `${Mn}-simple`, { [`${this.className}`]: !!this.className }];
    }, simplePagerClasses() {
      return `${Mn}-simple-pager`;
    }, wrapClasses() {
      return [`${Mn}`, { [`${this.className}`]: !!this.className, [`${Mn}-with-disabled`]: this.disabled, mini: this.size === "small" }];
    }, prevClasses() {
      return [`${Mn}-prev`, { [`${Mn}-disabled`]: this.currentPage === 1 || this.disabled, [`${Mn}-custom-text`]: this.prevText !== "" }];
    }, nextClasses() {
      return [`${Mn}-next`, { [`${Mn}-disabled`]: this.currentPage === this.allPages || this.disabled, [`${Mn}-custom-text`]: this.nextText !== "" }];
    }, firstPageClasses() {
      return [`${Mn}-item`, { [`${Mn}-item-active`]: this.currentPage === 1 }];
    }, lastPageClasses() {
      return [`${Mn}-item`, { [`${Mn}-item-active`]: this.currentPage === this.allPages }];
    } }, methods: { changePage(t) {
      this.disabled || this.currentPage != t && (this.currentPage = t, this.$emit("update:modelValue", t), this.$emit("on-change", t));
    }, prev() {
      if (this.disabled)
        return;
      const t = this.currentPage;
      if (t <= 1)
        return !1;
      this.changePage(t - 1), this.$emit("on-prev", t - 1);
    }, next() {
      if (this.disabled)
        return;
      const t = this.currentPage;
      if (t >= this.allPages)
        return !1;
      this.changePage(t + 1), this.$emit("on-next", t + 1);
    }, fastPrev() {
      if (this.disabled)
        return;
      const t = this.currentPage - 5;
      t > 0 ? this.changePage(t) : this.changePage(1);
    }, fastNext() {
      if (this.disabled)
        return;
      const t = this.currentPage + 5;
      t > this.allPages ? this.changePage(this.allPages) : this.changePage(t);
    }, onSize(t) {
      this.disabled || (this.currentPageSize = t, this.$emit("on-page-size-change", t), this.changePage(1));
    }, onPage(t) {
      this.disabled || this.changePage(t);
    }, keyDown(t) {
      const r = t.keyCode;
      r >= 48 && r <= 57 || r >= 96 && r <= 105 || r === 8 || r === 37 || r === 39 || t.preventDefault();
    }, keyUp(t) {
      const r = t.keyCode, o = parseInt(t.target.value);
      if (r === 38)
        this.prev();
      else if (r === 40)
        this.next();
      else if (r === 13) {
        let C = 1;
        o > this.allPages ? C = this.allPages : o <= 0 || !o ? C = 1 : C = o, t.target.value = C, this.changePage(C);
      }
    } } }, jP = ["title"], HP = [e.createElementVNode("a", null, [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-arrow-back" })], -1)], UP = ["title"], WP = ["value", "disabled"], YP = e.createElementVNode("span", null, "/", -1), KP = ["title"], GP = [e.createElementVNode("a", null, [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-arrow-forward" })], -1)], XP = ["title"], qP = { key: 1, class: "ivu-icon ivu-icon-ios-arrow-back" }, JP = [e.createElementVNode("a", null, "1", -1)], QP = ["title"], ZP = [e.createElementVNode("a", null, [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-arrow-back" }), e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-more" })], -1)], e5 = ["title"], t5 = ["title"], n5 = ["title"], i5 = ["title"], r5 = ["title"], s5 = ["title"], o5 = ["title"], a5 = ["title"], l5 = [e.createElementVNode("a", null, [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-arrow-forward" }), e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-more" })], -1)], c5 = ["title"], u5 = ["title"], h5 = { key: 1, class: "ivu-icon ivu-icon-ios-arrow-forward" };
    function d5(t, r, o, C, g, a) {
      const x = e.resolveComponent("Options");
      return o.simple ? (e.openBlock(), e.createElementBlock("ul", { key: 0, class: e.normalizeClass(a.simpleWrapClasses), style: e.normalizeStyle(o.styles) }, [e.createElementVNode("li", { title: t.t("i.page.prev"), class: e.normalizeClass(a.prevClasses), onClick: r[0] || (r[0] = (...O) => a.prev && a.prev(...O)) }, HP, 10, jP), e.createElementVNode("div", { class: e.normalizeClass(a.simplePagerClasses), title: g.currentPage + "/" + a.allPages }, [e.createElementVNode("input", { type: "text", value: g.currentPage, autocomplete: "off", spellcheck: "false", disabled: o.disabled, onKeydown: r[1] || (r[1] = (...O) => a.keyDown && a.keyDown(...O)), onKeyup: r[2] || (r[2] = (...O) => a.keyUp && a.keyUp(...O)), onChange: r[3] || (r[3] = (...O) => a.keyUp && a.keyUp(...O)) }, null, 40, WP), YP, e.createTextVNode(" " + e.toDisplayString(a.allPages), 1)], 10, UP), e.createElementVNode("li", { title: t.t("i.page.next"), class: e.normalizeClass(a.nextClasses), onClick: r[4] || (r[4] = (...O) => a.next && a.next(...O)) }, GP, 10, KP)], 6)) : (e.openBlock(), e.createElementBlock("ul", { key: 1, class: e.normalizeClass(a.wrapClasses), style: e.normalizeStyle(o.styles) }, [o.showTotal ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass([g.prefixCls + "-total"]) }, [e.renderSlot(t.$slots, "default", {}, () => [e.createTextVNode(e.toDisplayString(t.t("i.page.total")) + " " + e.toDisplayString(o.total) + " ", 1), o.total <= 1 ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(t.t("i.page.item")), 1)], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createTextVNode(e.toDisplayString(t.t("i.page.items")), 1)], 64))])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("li", { title: t.t("i.page.prev"), class: e.normalizeClass(a.prevClasses), onClick: r[5] || (r[5] = (...O) => a.prev && a.prev(...O)) }, [e.createElementVNode("a", null, [o.prevText !== "" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(o.prevText), 1)], 64)) : (e.openBlock(), e.createElementBlock("i", qP))])], 10, XP), e.createElementVNode("li", { title: "1", class: e.normalizeClass(a.firstPageClasses), onClick: r[6] || (r[6] = (O) => a.changePage(1)) }, JP, 2), g.currentPage > 5 ? (e.openBlock(), e.createElementBlock("li", { key: 1, title: t.t("i.page.prev5"), class: e.normalizeClass([g.prefixCls + "-item-jump-prev"]), onClick: r[7] || (r[7] = (...O) => a.fastPrev && a.fastPrev(...O)) }, ZP, 10, QP)) : e.createCommentVNode("", !0), g.currentPage === 5 ? (e.openBlock(), e.createElementBlock("li", { key: 2, title: g.currentPage - 3, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[8] || (r[8] = (O) => a.changePage(g.currentPage - 3)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage - 3), 1)], 10, e5)) : e.createCommentVNode("", !0), g.currentPage - 2 > 1 ? (e.openBlock(), e.createElementBlock("li", { key: 3, title: g.currentPage - 2, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[9] || (r[9] = (O) => a.changePage(g.currentPage - 2)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage - 2), 1)], 10, t5)) : e.createCommentVNode("", !0), g.currentPage - 1 > 1 ? (e.openBlock(), e.createElementBlock("li", { key: 4, title: g.currentPage - 1, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[10] || (r[10] = (O) => a.changePage(g.currentPage - 1)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage - 1), 1)], 10, n5)) : e.createCommentVNode("", !0), g.currentPage != 1 && g.currentPage != a.allPages ? (e.openBlock(), e.createElementBlock("li", { key: 5, title: g.currentPage, class: e.normalizeClass([g.prefixCls + "-item", g.prefixCls + "-item-active"]) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage), 1)], 10, i5)) : e.createCommentVNode("", !0), g.currentPage + 1 < a.allPages ? (e.openBlock(), e.createElementBlock("li", { key: 6, title: g.currentPage + 1, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[11] || (r[11] = (O) => a.changePage(g.currentPage + 1)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage + 1), 1)], 10, r5)) : e.createCommentVNode("", !0), g.currentPage + 2 < a.allPages ? (e.openBlock(), e.createElementBlock("li", { key: 7, title: g.currentPage + 2, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[12] || (r[12] = (O) => a.changePage(g.currentPage + 2)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage + 2), 1)], 10, s5)) : e.createCommentVNode("", !0), a.allPages - g.currentPage === 4 ? (e.openBlock(), e.createElementBlock("li", { key: 8, title: g.currentPage + 3, class: e.normalizeClass([g.prefixCls + "-item"]), onClick: r[13] || (r[13] = (O) => a.changePage(g.currentPage + 3)) }, [e.createElementVNode("a", null, e.toDisplayString(g.currentPage + 3), 1)], 10, o5)) : e.createCommentVNode("", !0), a.allPages - g.currentPage >= 5 ? (e.openBlock(), e.createElementBlock("li", { key: 9, title: t.t("i.page.next5"), class: e.normalizeClass([g.prefixCls + "-item-jump-next"]), onClick: r[14] || (r[14] = (...O) => a.fastNext && a.fastNext(...O)) }, l5, 10, a5)) : e.createCommentVNode("", !0), a.allPages > 1 ? (e.openBlock(), e.createElementBlock("li", { key: 10, title: a.allPages, class: e.normalizeClass(a.lastPageClasses), onClick: r[15] || (r[15] = (O) => a.changePage(a.allPages)) }, [e.createElementVNode("a", null, e.toDisplayString(a.allPages), 1)], 10, c5)) : e.createCommentVNode("", !0), e.createElementVNode("li", { title: t.t("i.page.next"), class: e.normalizeClass(a.nextClasses), onClick: r[16] || (r[16] = (...O) => a.next && a.next(...O)) }, [e.createElementVNode("a", null, [o.nextText !== "" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(o.nextText), 1)], 64)) : (e.openBlock(), e.createElementBlock("i", h5))])], 10, u5), e.createVNode(x, { "show-sizer": o.showSizer, "page-size": g.currentPageSize, "page-size-opts": o.pageSizeOpts, placement: o.placement, transfer: o.transfer, "show-elevator": o.showElevator, _current: g.currentPage, current: g.currentPage, disabled: o.disabled, "all-pages": a.allPages, "is-small": a.isSmall, eventsEnabled: o.eventsEnabled, onOnSize: a.onSize, onOnPage: a.onPage }, null, 8, ["show-sizer", "page-size", "page-size-opts", "placement", "transfer", "show-elevator", "_current", "current", "disabled", "all-pages", "is-small", "eventsEnabled", "onOnSize", "onOnPage"])], 6));
    }
    var _v = f(RP, [["render", d5]]);
    const f5 = { name: "PageHeader", components: { Breadcrumb: Ph, BreadcrumbItem: Vh, Divider: mc, Icon: G, Tabs: Dc, TabPane: Bc }, emits: ["on-tab-change", "on-back"], props: { title: { type: String }, back: { type: Boolean, default: !1 }, logo: { type: String }, action: { type: String }, content: { type: String }, extra: { type: String }, breadcrumbList: { type: Array }, hiddenBreadcrumb: { type: Boolean, default: !1 }, tabList: { type: Array }, tabActiveKey: { type: String }, wide: { type: Boolean, default: !1 } }, computed: { classes() {
      return { "ivu-page-header-wide": this.wide };
    } }, methods: { handleTabChange(t) {
      const r = this.tabList.find((o) => o.name === t);
      this.$emit("on-tab-change", JSON.parse(JSON.stringify(r)));
    }, handleBack() {
      this.$emit("on-back");
    } } }, p5 = { key: 0, class: "ivu-page-header-breadcrumb" }, m5 = { class: "ivu-page-header-detail" }, g5 = { key: 1, class: "ivu-page-header-logo" }, v5 = ["src"], y5 = { class: "ivu-page-header-main" }, b5 = { class: "ivu-page-header-row" }, C5 = { key: 1, class: "ivu-page-header-title" }, w5 = { key: 2, class: "ivu-page-header-action" }, k5 = { class: "ivu-page-header-row" }, S5 = { key: 0, class: "ivu-page-header-content" }, E5 = { key: 1, class: "ivu-page-header-extra" }, x5 = { key: 1, class: "ivu-page-header-tabs" };
    function _5(t, r, o, C, g, a) {
      const x = e.resolveComponent("BreadcrumbItem"), O = e.resolveComponent("Breadcrumb"), P = e.resolveComponent("Icon"), N = e.resolveComponent("Divider"), B = e.resolveComponent("TabPane"), H = e.resolveComponent("Tabs");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-page-header", a.classes]) }, [t.$slots.breadcrumb || !o.hiddenBreadcrumb ? (e.openBlock(), e.createElementBlock("div", p5, [e.renderSlot(t.$slots, "breadcrumb", {}, () => [e.createVNode(O, null, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.breadcrumbList, (oe, se) => (e.openBlock(), e.createBlock(x, { key: se, to: oe.to, replace: oe.replace, target: oe.target }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(oe.title), 1)]), _: 2 }, 1032, ["to", "replace", "target"]))), 128))]), _: 1 })])])) : e.createCommentVNode("", !0), e.createElementVNode("div", m5, [o.back || t.$slots.back ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-page-header-back", onClick: r[0] || (r[0] = (...oe) => a.handleBack && a.handleBack(...oe)) }, [e.renderSlot(t.$slots, "back", {}, () => [e.createVNode(P, { type: "md-arrow-back" })]), e.createVNode(N, { type: "vertical" })])) : e.createCommentVNode("", !0), o.logo || t.$slots.logo ? (e.openBlock(), e.createElementBlock("div", g5, [e.renderSlot(t.$slots, "logo", {}, () => [e.createElementVNode("img", { src: o.logo }, null, 8, v5)])])) : e.createCommentVNode("", !0), e.createElementVNode("div", y5, [e.createElementVNode("div", b5, [o.back || t.$slots.back ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-page-header-back", onClick: r[1] || (r[1] = (...oe) => a.handleBack && a.handleBack(...oe)) }, [e.renderSlot(t.$slots, "back", {}, () => [e.createVNode(P, { type: "md-arrow-back" })]), e.createVNode(N, { type: "vertical" })])) : e.createCommentVNode("", !0), o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("div", C5, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0), o.action || t.$slots.action ? (e.openBlock(), e.createElementBlock("div", w5, [e.renderSlot(t.$slots, "action", {}, () => [e.createTextVNode(e.toDisplayString(o.action), 1)])])) : e.createCommentVNode("", !0)]), e.createElementVNode("div", k5, [o.content || t.$slots.content ? (e.openBlock(), e.createElementBlock("div", S5, [e.renderSlot(t.$slots, "content", {}, () => [e.createTextVNode(e.toDisplayString(o.content), 1)])])) : e.createCommentVNode("", !0), o.extra || t.$slots.extra ? (e.openBlock(), e.createElementBlock("div", E5, [e.renderSlot(t.$slots, "extra", {}, () => [e.createTextVNode(e.toDisplayString(o.extra), 1)])])) : e.createCommentVNode("", !0)])])]), o.tabList && o.tabList.length ? (e.openBlock(), e.createElementBlock("div", x5, [e.createVNode(H, { animated: !1, "model-value": o.tabActiveKey, onOnClick: a.handleTabChange }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.tabList, (oe, se) => (e.openBlock(), e.createBlock(B, { key: se, label: oe.label, name: oe.name }, null, 8, ["label", "name"]))), 128))]), _: 1 }, 8, ["model-value", "onOnClick"])])) : e.createCommentVNode("", !0)], 2);
    }
    var Tv = f(f5, [["render", _5]]);
    const T5 = e.defineComponent({ name: "CollapseTransition", props: { ready: { type: Boolean, default: !0 } }, setup(t) {
      return { on: { beforeEnter(r) {
        !t.ready || (fe(r, "collapse-transition"), r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.style.height = "0", r.style.paddingTop = 0, r.style.paddingBottom = 0);
      }, enter(r) {
        !t.ready || (r.dataset.oldOverflow = r.style.overflow, r.scrollHeight !== 0 ? (r.style.height = r.scrollHeight + "px", r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom) : (r.style.height = "", r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom), r.style.overflow = "hidden");
      }, afterEnter(r) {
        !t.ready || (Se(r, "collapse-transition"), r.style.height = "", r.style.overflow = r.dataset.oldOverflow);
      }, beforeLeave(r) {
        !t.ready || (r.dataset || (r.dataset = {}), r.dataset.oldPaddingTop = r.style.paddingTop, r.dataset.oldPaddingBottom = r.style.paddingBottom, r.dataset.oldOverflow = r.style.overflow, r.style.height = r.scrollHeight + "px", r.style.overflow = "hidden");
      }, leave(r) {
        !t.ready || r.scrollHeight !== 0 && (fe(r, "collapse-transition"), r.style.height = 0, r.style.paddingTop = 0, r.style.paddingBottom = 0);
      }, afterLeave(r) {
        !t.ready || (Se(r, "collapse-transition"), r.style.height = "", r.style.overflow = r.dataset.oldOverflow, r.style.paddingTop = r.dataset.oldPaddingTop, r.style.paddingBottom = r.dataset.oldPaddingBottom);
      } } };
    } });
    function O5(t, r, o, C, g, a) {
      return e.openBlock(), e.createBlock(e.Transition, e.toHandlers(t.on), { default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), _: 3 }, 16);
    }
    var Sd = f(T5, [["render", O5]]);
    const xa = "ivu-collapse", D5 = { name: "Panel", components: { Icon: G, CollapseTransition: Sd }, inject: ["CollapseInstance"], props: { name: { type: String }, hideArrow: { type: Boolean, default: !1 } }, data() {
      return { index: 0, mounted: !1 };
    }, computed: { itemClasses() {
      return [`${xa}-item`, { [`${xa}-item-active`]: this.isActive }];
    }, headerClasses() {
      return `${xa}-header`;
    }, contentClasses() {
      return `${xa}-content`;
    }, boxClasses() {
      return `${xa}-content-box`;
    }, isActive() {
      const t = this.CollapseInstance.getActiveKey(), r = this.name || this.index.toString();
      return t.indexOf(r) > -1;
    } }, methods: { setIndex() {
      this.index = this.CollapseInstance.panelCount + 1, this.CollapseInstance.panelCount = this.index;
    }, toggle() {
      this.CollapseInstance.toggle({ name: this.name || this.index, isActive: this.isActive });
    } }, mounted() {
      this.setIndex(), this.mounted = !0;
    } };
    function N5(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("collapse-transition");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.itemClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.headerClasses), onClick: r[0] || (r[0] = (...P) => a.toggle && a.toggle(...P)) }, [o.hideArrow ? e.createCommentVNode("", !0) : (e.openBlock(), e.createBlock(x, { key: 0, type: "ios-arrow-forward" })), e.renderSlot(t.$slots, "default")], 2), g.mounted ? (e.openBlock(), e.createBlock(O, { key: 0 }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.boxClasses) }, [e.renderSlot(t.$slots, "content")], 2)], 2), [[e.vShow, a.isActive]])]), _: 3 })) : e.createCommentVNode("", !0)], 2);
    }
    var Ov = f(D5, [["render", N5]]);
    const Dv = { name: "Paragraph", mixins: [ga], render() {
      return e.h(xc, p(v(p({}, this.$props), { component: "div" }), this.commonEvents()), this.commonSlots());
    } }, Nv = { name: "Password", mixins: [ia], data() {
      return { className: "ivu-login-password", prefix: "ios-lock-outline", placeholder: "请输入密码", type: "password" };
    } }, Pr = "ivu-poptip", B5 = { name: "Poptip", mixins: [Wm, Kt], emits: ["on-ok", "on-cancel"], directives: { clickOutside: Hh }, components: { iButton: zn }, props: { trigger: { validator(t) {
      return z(t, ["click", "focus", "hover"]);
    }, default: "click" }, placement: { validator(t) {
      return z(t, ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"]);
    }, default: "top" }, title: { type: [String, Number] }, content: { type: [String, Number], default: "" }, width: { type: [String, Number] }, confirm: { type: Boolean, default: !1 }, okText: { type: String }, cancelText: { type: String }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } }, popperClass: { type: String }, wordWrap: { type: Boolean, default: !1 }, padding: { type: String }, disabled: { type: Boolean, default: !1 }, capture: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return t.$VIEWUI ? t.$VIEWUI.capture : !1;
    } }, transferClassName: { type: String } }, data() {
      return { prefixCls: Pr, showTitle: !0, isInput: !1, disableCloseUnderTransfer: !1, tIndex: this.handleGetIndex() };
    }, computed: { classes() {
      return [`${Pr}`, { [`${Pr}-confirm`]: this.confirm }];
    }, popperClasses() {
      return [`${Pr}-popper`, { [`${Pr}-confirm`]: this.transfer && this.confirm, [`${this.popperClass}`]: !!this.popperClass, [Pr + "-transfer"]: this.transfer, [this.transferClassName]: this.transferClassName }];
    }, styles() {
      let t = {};
      return this.width && (t.width = `${this.width}px`), this.transfer && (t["z-index"] = 1060 + this.tIndex), t;
    }, localeOkText() {
      return this.okText === void 0 ? this.t("i.poptip.okText") : this.okText;
    }, localeCancelText() {
      return this.cancelText === void 0 ? this.t("i.poptip.cancelText") : this.cancelText;
    }, contentClasses() {
      return [`${Pr}-body-content`, { [`${Pr}-body-content-word-wrap`]: this.wordWrap }];
    }, contentPaddingStyle() {
      const t = {};
      return this.padding !== "" && (t.padding = this.padding), t;
    } }, methods: { handleClick() {
      if (!this.disabled) {
        if (this.confirm)
          return this.visible = !this.visible, !0;
        if (this.trigger !== "click")
          return !1;
        this.visible = !this.visible;
      }
    }, handleTransferClick() {
      this.transfer && (this.disableCloseUnderTransfer = !0);
    }, handleClose() {
      if (this.disableCloseUnderTransfer)
        return this.disableCloseUnderTransfer = !1, !1;
      if (this.confirm)
        return this.visible = !1, !0;
      if (this.trigger !== "click")
        return !1;
      this.visible = !1;
    }, handleFocus(t = !0) {
      if (!this.disabled) {
        if (this.trigger !== "focus" || this.confirm || this.isInput && !t)
          return !1;
        this.visible = !0;
      }
    }, handleBlur(t = !0) {
      if (this.trigger !== "focus" || this.confirm || this.isInput && !t)
        return !1;
      this.visible = !1;
    }, handleMouseenter() {
      if (!this.disabled) {
        if (this.trigger !== "hover" || this.confirm)
          return !1;
        this.enterTimer && clearTimeout(this.enterTimer), this.enterTimer = setTimeout(() => {
          this.visible = !0;
        }, 100);
      }
    }, handleMouseleave() {
      if (this.trigger !== "hover" || this.confirm)
        return !1;
      this.enterTimer && (clearTimeout(this.enterTimer), this.enterTimer = setTimeout(() => {
        this.visible = !1;
      }, 100));
    }, cancel() {
      this.visible = !1, this.$emit("on-cancel");
    }, ok() {
      this.visible = !1, this.$emit("on-ok");
    }, getInputChildren() {
      const t = this.$refs.reference.querySelectorAll("input"), r = this.$refs.reference.querySelectorAll("textarea");
      let o = null;
      return t.length ? o = t[0] : r.length && (o = r[0]), o;
    }, handleGetIndex() {
      return Vn(), Ut;
    }, handleIndexIncrease() {
      this.tIndex = this.handleGetIndex();
    } }, mounted() {
      this.confirm || (this.showTitle = this.$slots.title !== void 0 || this.title), this.trigger === "focus" && e.nextTick(() => {
        const t = this.getInputChildren();
        t && (this.isInput = !0, t.addEventListener("focus", this.handleFocus, !1), t.addEventListener("blur", this.handleBlur, !1));
      });
    }, beforeUnmount() {
      const t = this.getInputChildren();
      t && (t.removeEventListener("focus", this.handleFocus, !1), t.removeEventListener("blur", this.handleBlur, !1));
    } }, P5 = e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-help-circle" }, null, -1);
    function V5(t, r, o, C, g, a) {
      const x = e.resolveComponent("i-button"), O = e.resolveDirective("click-outside");
      return e.withDirectives((e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onMouseenter: r[6] || (r[6] = (...P) => a.handleMouseenter && a.handleMouseenter(...P)), onMouseleave: r[7] || (r[7] = (...P) => a.handleMouseleave && a.handleMouseleave(...P)) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-rel"]), ref: "reference", onClick: r[0] || (r[0] = (...P) => a.handleClick && a.handleClick(...P)), onMousedown: r[1] || (r[1] = (P) => a.handleFocus(!1)), onMouseup: r[2] || (r[2] = (P) => a.handleBlur(!1)) }, [e.renderSlot(t.$slots, "default")], 34), (e.openBlock(), e.createBlock(e.Teleport, { to: "body", disabled: !o.transfer }, [e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass(a.popperClasses), style: e.normalizeStyle(a.styles), ref: "popper", onClick: r[3] || (r[3] = (...P) => a.handleTransferClick && a.handleTransferClick(...P)), onMouseenter: r[4] || (r[4] = (...P) => a.handleMouseenter && a.handleMouseenter(...P)), onMouseleave: r[5] || (r[5] = (...P) => a.handleMouseleave && a.handleMouseleave(...P)) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-content"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-arrow"]) }, null, 2), o.confirm ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-inner"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]) }, [P5, e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body-message"]) }, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])], 2)], 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-footer"]) }, [e.createVNode(x, { type: "text", size: "small", onClick: a.cancel }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.localeCancelText), 1)]), _: 1 }, 8, ["onClick"]), e.createVNode(x, { type: "primary", size: "small", onClick: a.ok }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(a.localeOkText), 1)]), _: 1 }, 8, ["onClick"])], 2)], 2)) : e.createCommentVNode("", !0), o.confirm ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass([g.prefixCls + "-inner"]) }, [g.showTitle ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-title"]), style: e.normalizeStyle(a.contentPaddingStyle), ref: "title" }, [e.renderSlot(t.$slots, "title", {}, () => [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-title-inner"]) }, e.toDisplayString(o.title), 3)])], 6)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]), style: e.normalizeStyle(a.contentPaddingStyle) }, [e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses) }, [e.renderSlot(t.$slots, "content", {}, () => [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body-content-inner"]) }, e.toDisplayString(o.content), 3)])], 2)], 6)], 2))], 2)], 38), [[e.vShow, t.visible]])]), _: 3 })], 8, ["disabled"]))], 34)), [[O, a.handleClose]]);
    }
    var Ed = f(B5, [["render", V5]]);
    const Li = "ivu-progress", $5 = { name: "Progress", components: { Icon: G }, props: { percent: { type: Number, default: 0 }, successPercent: { type: Number, default: 0 }, status: { validator(t) {
      return z(t, ["normal", "active", "wrong", "success"]);
    }, default: "normal" }, hideInfo: { type: Boolean, default: !1 }, strokeWidth: { type: Number, default: 10 }, vertical: { type: Boolean, default: !1 }, strokeColor: { type: [String, Array] }, textInside: { type: Boolean, default: !1 } }, data() {
      return { currentStatus: this.status };
    }, computed: { isStatus() {
      return this.currentStatus === "wrong" || this.currentStatus === "success";
    }, statusIcon() {
      let t = "";
      switch (this.currentStatus) {
        case "wrong":
          t = "ios-close-circle";
          break;
        case "success":
          t = "ios-checkmark-circle";
          break;
      }
      return t;
    }, bgStyle() {
      const t = this.vertical ? { height: `${this.percent}%`, width: `${this.strokeWidth}px` } : { width: `${this.percent}%`, height: `${this.strokeWidth}px` };
      return this.strokeColor && (typeof this.strokeColor == "string" ? t["background-color"] = this.strokeColor : t["background-image"] = `linear-gradient(to right, ${this.strokeColor[0]} 0%, ${this.strokeColor[1]} 100%)`), t;
    }, successBgStyle() {
      return this.vertical ? { height: `${this.successPercent}%`, width: `${this.strokeWidth}px` } : { width: `${this.successPercent}%`, height: `${this.strokeWidth}px` };
    }, wrapClasses() {
      return [`${Li}`, `${Li}-${this.currentStatus}`, { [`${Li}-show-info`]: !this.hideInfo && !this.textInside, [`${Li}-vertical`]: this.vertical }];
    }, textClasses() {
      return `${Li}-text`;
    }, textInnerClasses() {
      return `${Li}-text-inner`;
    }, outerClasses() {
      return `${Li}-outer`;
    }, innerClasses() {
      return `${Li}-inner`;
    }, bgClasses() {
      return `${Li}-bg`;
    }, successBgClasses() {
      return `${Li}-success-bg`;
    } }, created() {
      this.handleStatus();
    }, methods: { handleStatus(t) {
      t ? (this.currentStatus = "normal", this.$emit("on-status-change", "normal")) : parseInt(this.percent, 10) === 100 && (this.currentStatus = "success", this.$emit("on-status-change", "success"));
    } }, watch: { percent(t, r) {
      t < r ? this.handleStatus(!0) : this.handleStatus();
    }, status(t) {
      this.currentStatus = t;
    } } }, I5 = { key: 0, class: "ivu-progress-inner-text" };
    function M5(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.outerClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.innerClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.bgClasses), style: e.normalizeStyle(a.bgStyle) }, [o.textInside ? (e.openBlock(), e.createElementBlock("div", I5, e.toDisplayString(o.percent) + "%", 1)) : e.createCommentVNode("", !0)], 6), e.createElementVNode("div", { class: e.normalizeClass(a.successBgClasses), style: e.normalizeStyle(a.successBgStyle) }, null, 6)], 2)], 2), !o.hideInfo && !o.textInside ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.textClasses) }, [e.renderSlot(t.$slots, "default", {}, () => [a.isStatus ? (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass(a.textInnerClasses) }, [e.createVNode(x, { type: a.statusIcon }, null, 8, ["type"])], 2)) : (e.openBlock(), e.createElementBlock("span", { key: 1, class: e.normalizeClass(a.textInnerClasses) }, e.toDisplayString(o.percent) + "% ", 3))])], 2)) : e.createCommentVNode("", !0)], 2);
    }
    var Pc = f($5, [["render", M5]]);
    const Vr = "ivu-rate", A5 = { name: "Rate", mixins: [Kt, nn], emits: ["update:modelValue", "on-change"], props: { count: { type: Number, default: 5 }, modelValue: { type: Number, default: 0 }, allowHalf: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, showText: { type: Boolean, default: !1 }, name: { type: String }, clearable: { type: Boolean, default: !1 }, character: { type: String, default: "" }, icon: { type: String, default: "" }, customIcon: { type: String, default: "" } }, data() {
      const t = this.modelValue || 0;
      return { prefixCls: Vr, hoverIndex: -1, isHover: !1, isHalf: this.allowHalf && t.toString().indexOf(".") >= 0, currentValue: t };
    }, computed: { classes() {
      return [`${Vr}`, { [`${Vr}-disabled`]: this.itemDisabled }];
    }, iconClasses() {
      return ["ivu-icon", { [`ivu-icon-${this.icon}`]: this.icon !== "", [`${this.customIcon}`]: this.customIcon !== "" }];
    }, showCharacter() {
      return this.character !== "" || this.icon !== "" || this.customIcon !== "";
    } }, watch: { modelValue(t) {
      this.currentValue = t || 0;
    }, currentValue(t) {
      this.setHalf(t);
    } }, methods: { starCls(t) {
      const r = this.hoverIndex, o = this.isHover ? r : this.currentValue;
      let C = !1, g = !1;
      return o >= t && (C = !0), this.isHover ? g = o === t : g = Math.ceil(this.currentValue) === t, [{ [`${Vr}-star`]: !this.showCharacter, [`${Vr}-star-chart`]: this.showCharacter, [`${Vr}-star-full`]: !g && C || g && !this.isHalf, [`${Vr}-star-half`]: g && this.isHalf, [`${Vr}-star-zero`]: !C }];
    }, handleMousemove(t, r) {
      if (!this.itemDisabled) {
        if (this.isHover = !0, this.allowHalf) {
          const o = r.target.getAttribute("type") || !1;
          this.isHalf = o === "half";
        } else
          this.isHalf = !1;
        this.hoverIndex = t;
      }
    }, handleMouseleave() {
      this.itemDisabled || (this.isHover = !1, this.setHalf(this.currentValue), this.hoverIndex = -1);
    }, setHalf(t) {
      this.isHalf = this.allowHalf && t.toString().indexOf(".") >= 0;
    }, handleClick(t) {
      this.itemDisabled || (this.isHalf && (t -= 0.5), this.clearable && Math.abs(t - this.currentValue) < 0.01 && (t = 0), this.currentValue = t, this.$emit("update:modelValue", t), this.$emit("on-change", t), this.handleFormItemChange("change", t));
    } } }, F5 = ["name", "value"], L5 = ["onMousemove", "onClick"], z5 = { key: 0 }, R5 = { key: 1 };
    function j5(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), onMouseleave: r[0] || (r[0] = (...x) => a.handleMouseleave && a.handleMouseleave(...x)) }, [e.createElementVNode("input", { type: "hidden", name: o.name, value: g.currentValue }, null, 8, F5), (e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.count, (x) => (e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.starCls(x)), onMousemove: (O) => a.handleMousemove(x, O), key: x, onClick: (O) => a.handleClick(x) }, [a.showCharacter ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createElementVNode("span", { class: e.normalizeClass([g.prefixCls + "-star-first"]), type: "half" }, [o.character !== "" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(o.character), 1)], 64)) : (e.openBlock(), e.createElementBlock("i", { key: 1, class: e.normalizeClass(a.iconClasses), type: "half" }, null, 2))], 2), e.createElementVNode("span", { class: e.normalizeClass([g.prefixCls + "-star-second"]) }, [o.character !== "" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createTextVNode(e.toDisplayString(o.character), 1)], 64)) : (e.openBlock(), e.createElementBlock("i", { key: 1, class: e.normalizeClass(a.iconClasses) }, null, 2))], 2)], 64)) : (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass([g.prefixCls + "-star-content"]), type: "half" }, null, 2))], 42, L5))), 128)), o.showText ? e.withDirectives((e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-text"]) }, [e.renderSlot(t.$slots, "default", {}, () => [e.createElementVNode("span", null, e.toDisplayString(g.currentValue), 1), e.createTextVNode(), g.currentValue <= 1 ? (e.openBlock(), e.createElementBlock("span", z5, e.toDisplayString(t.t("i.rate.star")), 1)) : (e.openBlock(), e.createElementBlock("span", R5, e.toDisplayString(t.t("i.rate.stars")), 1))])], 2)), [[e.vShow, g.currentValue > 0]]) : e.createCommentVNode("", !0)], 34);
    }
    var Bv = f(A5, [["render", j5]]);
    const H5 = { name: "Result", components: { Icon: G }, props: { type: { validator(t) {
      return z(t, ["success", "error", "warning"]);
    } }, title: { type: String }, desc: { type: String }, extra: { type: String } }, computed: { iconClasses() {
      return { "ivu-result-icon-success": this.type === "success", "ivu-result-icon-error": this.type === "error", "ivu-result-icon-warning": this.type === "warning" };
    } } }, U5 = { class: "ivu-result" }, W5 = { key: 0, class: "ivu-result-title" }, Y5 = { key: 1, class: "ivu-result-desc" }, K5 = { key: 2, class: "ivu-result-extra" }, G5 = { key: 3, class: "ivu-result-actions" };
    function X5(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", U5, [e.createElementVNode("div", { class: e.normalizeClass(["ivu-result-icon", a.iconClasses]) }, [o.type === "success" ? (e.openBlock(), e.createBlock(x, { key: 0, type: "ios-checkmark" })) : e.createCommentVNode("", !0), o.type === "error" ? (e.openBlock(), e.createBlock(x, { key: 1, type: "ios-close" })) : e.createCommentVNode("", !0), o.type === "warning" ? (e.openBlock(), e.createBlock(x, { key: 2, type: "ios-information" })) : e.createCommentVNode("", !0)], 2), o.title || t.$slots.title ? (e.openBlock(), e.createElementBlock("div", W5, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])])) : e.createCommentVNode("", !0), o.desc || t.$slots.desc ? (e.openBlock(), e.createElementBlock("div", Y5, [e.renderSlot(t.$slots, "desc", {}, () => [e.createTextVNode(e.toDisplayString(o.desc), 1)])])) : e.createCommentVNode("", !0), o.extra || t.$slots.extra ? (e.openBlock(), e.createElementBlock("div", K5, [e.renderSlot(t.$slots, "extra", {}, () => [e.createTextVNode(e.toDisplayString(o.extra), 1)])])) : e.createCommentVNode("", !0), t.$slots.actions ? (e.openBlock(), e.createElementBlock("div", G5, [e.renderSlot(t.$slots, "actions")])) : e.createCommentVNode("", !0)]);
    }
    var Pv = f(H5, [["render", X5]]);
    const _a = "ivu-scroll", q5 = { props: ["text", "active", "spinnerHeight"], components: { Spin: ni, Icon: G }, computed: { wrapperClasses() {
      return [`${_a}-loader-wrapper`, { [`${_a}-loader-wrapper-active`]: this.active }];
    }, spinnerClasses() {
      return `${_a}-spinner`;
    }, iconClasses() {
      return `${_a}-spinner-icon`;
    }, textClasses() {
      return `${_a}-loader-text`;
    } } };
    function J5(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Spin");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapperClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.spinnerClasses) }, [e.createVNode(O, { fix: "" }, { default: e.withCtx(() => [e.createVNode(x, { type: "ios-loading", size: "18", class: e.normalizeClass(a.iconClasses) }, null, 8, ["class"]), o.text ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.textClasses) }, e.toDisplayString(o.text), 3)) : e.createCommentVNode("", !0)]), _: 1 })], 2)], 2);
    }
    var Q5 = f(q5, [["render", J5]]);
    const po = "ivu-scroll", Vv = { sensitivity: 10, minimumStartDragOffset: 5 }, xd = () => Promise.resolve(), Z5 = { name: "Scroll", mixins: [Kt], components: { loader: Q5 }, props: { height: { type: [Number, String], default: 300 }, onReachTop: { type: Function }, onReachBottom: { type: Function }, onReachEdge: { type: Function }, loadingText: { type: String }, distanceToEdge: [Number, Array], stopSlide: { type: Boolean, default: !1 } }, data() {
      const t = this.calculateProximityThreshold();
      return { showTopLoader: !1, showBottomLoader: !1, showBodyLoader: !1, lastScroll: 0, reachedTopScrollLimit: !0, reachedBottomScrollLimit: !1, topRubberPadding: 0, bottomRubberPadding: 0, rubberRollBackTimeout: !1, isLoading: !1, pointerTouchDown: null, touchScroll: !1, handleScroll: () => {
      }, pointerUpHandler: () => {
      }, pointerMoveHandler: () => {
      }, topProximityThreshold: t[0], bottomProximityThreshold: t[1] };
    }, computed: { wrapClasses() {
      return `${po}-wrapper`;
    }, scrollContainerClasses() {
      return [`${po}-container`, { [`${po}-container-loading`]: this.showBodyLoader && this.stopSlide }];
    }, slotContainerClasses() {
      return [`${po}-content`, { [`${po}-content-loading`]: this.showBodyLoader }];
    }, loaderClasses() {
      return `${po}-loader`;
    }, wrapperPadding() {
      return { paddingTop: this.topRubberPadding + "px", paddingBottom: this.bottomRubberPadding + "px" };
    }, localeLoadingText() {
      return this.loadingText === void 0 ? this.t("i.select.loading") : this.loadingText;
    } }, methods: { waitOneSecond() {
      return new Promise((t) => {
        setTimeout(t, 1e3);
      });
    }, calculateProximityThreshold() {
      const t = this.distanceToEdge;
      return typeof t > "u" ? [20, 20] : Array.isArray(t) ? t : [t, t];
    }, onCallback(t) {
      if (this.isLoading = !0, this.showBodyLoader = !0, t > 0)
        this.showTopLoader = !0, this.topRubberPadding = 20;
      else {
        this.showBottomLoader = !0, this.bottomRubberPadding = 20;
        let C = 0;
        const g = this.$refs.scrollContainer, a = g.scrollTop;
        for (let x = 0; x < 20; x++)
          setTimeout(() => {
            C = Math.max(C, this.$refs.bottomLoader.getBoundingClientRect().height), g.scrollTop = a + C;
          }, x * 50);
      }
      const r = [this.waitOneSecond(), this.onReachEdge ? this.onReachEdge(t) : xd()];
      r.push(t > 0 ? this.onReachTop ? this.onReachTop() : xd() : this.onReachBottom ? this.onReachBottom() : xd());
      let o = setTimeout(() => {
        this.reset();
      }, 5e3);
      Promise.all(r).then(() => {
        clearTimeout(o), this.reset();
      });
    }, reset() {
      ["showTopLoader", "showBottomLoader", "showBodyLoader", "isLoading", "reachedTopScrollLimit", "reachedBottomScrollLimit"].forEach((t) => this[t] = !1), this.lastScroll = 0, this.topRubberPadding = 0, this.bottomRubberPadding = 0, clearInterval(this.rubberRollBackTimeout), this.touchScroll && setTimeout(() => {
        b(window, "touchend", this.pointerUpHandler), this.$refs.scrollContainer.removeEventListener("touchmove", this.pointerMoveHandler), this.touchScroll = !1;
      }, 500);
    }, onWheel(t) {
      if (this.isLoading)
        return;
      const r = t.wheelDelta ? t.wheelDelta : -(t.detail || t.deltaY);
      this.stretchEdge(r);
    }, stretchEdge(t) {
      if (clearTimeout(this.rubberRollBackTimeout), !this.onReachEdge) {
        if (t > 0) {
          if (!this.onReachTop)
            return;
        } else if (!this.onReachBottom)
          return;
      }
      this.rubberRollBackTimeout = setTimeout(() => {
        this.isLoading || this.reset();
      }, 250), t > 0 && this.reachedTopScrollLimit ? (this.topRubberPadding += 5 - this.topRubberPadding / 5, this.topRubberPadding > this.topProximityThreshold && this.onCallback(1)) : t < 0 && this.reachedBottomScrollLimit ? (this.bottomRubberPadding += 6 - this.bottomRubberPadding / 4, this.bottomRubberPadding > this.bottomProximityThreshold && this.onCallback(-1)) : this.onScroll();
    }, onScroll() {
      const t = this.$refs.scrollContainer;
      if (this.isLoading || !t)
        return;
      const r = Math.sign(this.lastScroll - t.scrollTop), o = t.scrollHeight - t.clientHeight - t.scrollTop, C = this.topProximityThreshold < 0 ? this.topProximityThreshold : 0, g = this.bottomProximityThreshold < 0 ? this.bottomProximityThreshold : 0;
      r == -1 && o + g <= Vv.sensitivity ? this.reachedBottomScrollLimit = !0 : r >= 0 && t.scrollTop + C <= 0 ? this.reachedTopScrollLimit = !0 : (this.reachedTopScrollLimit = !1, this.reachedBottomScrollLimit = !1, this.lastScroll = t.scrollTop);
    }, getTouchCoordinates(t) {
      return { x: t.touches[0].pageX, y: t.touches[0].pageY };
    }, onPointerDown(t) {
      if (!this.isLoading) {
        if (t.type == "touchstart") {
          const r = this.$refs.scrollContainer;
          this.reachedTopScrollLimit ? r.scrollTop = 5 : this.reachedBottomScrollLimit && (r.scrollTop -= 5);
        }
        t.type == "touchstart" && this.$refs.scrollContainer.scrollTop == 0 && (this.$refs.scrollContainer.scrollTop = 5), this.pointerTouchDown = this.getTouchCoordinates(t), m(window, "touchend", this.pointerUpHandler), this.$refs.scrollContainer.parentElement.addEventListener("touchmove", (r) => {
          r.stopPropagation(), this.pointerMoveHandler(r);
        }, { passive: !1, useCapture: !0 });
      }
    }, onPointerMove(t) {
      if (!this.pointerTouchDown || this.isLoading)
        return;
      const r = this.getTouchCoordinates(t).y - this.pointerTouchDown.y;
      this.stretchEdge(r), this.touchScroll || Math.abs(r) > Vv.minimumStartDragOffset && (this.touchScroll = !0);
    }, onPointerUp() {
      this.pointerTouchDown = null;
    } }, created() {
      this.handleScroll = wc(this.onScroll, 150, { leading: !1 }), this.pointerUpHandler = this.onPointerUp.bind(this), this.pointerMoveHandler = wc(this.onPointerMove, 50, { leading: !1 });
    } };
    function eV(t, r, o, C, g, a) {
      const x = e.resolveComponent("loader");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses), style: { "touch-action": "none" } }, [e.createElementVNode("div", { class: e.normalizeClass(a.scrollContainerClasses), style: e.normalizeStyle({ height: o.height + "px" }), onScroll: r[0] || (r[0] = (...O) => g.handleScroll && g.handleScroll(...O)), onWheel: r[1] || (r[1] = (...O) => a.onWheel && a.onWheel(...O)), onTouchstart: r[2] || (r[2] = (...O) => a.onPointerDown && a.onPointerDown(...O)), ref: "scrollContainer" }, [e.createElementVNode("div", { class: e.normalizeClass(a.loaderClasses), style: e.normalizeStyle({ paddingTop: a.wrapperPadding.paddingTop }), ref: "toploader" }, [e.createVNode(x, { text: a.localeLoadingText, active: g.showTopLoader }, null, 8, ["text", "active"])], 6), e.createElementVNode("div", { class: e.normalizeClass(a.slotContainerClasses), ref: "scrollContent" }, [e.renderSlot(t.$slots, "default")], 2), e.createElementVNode("div", { class: e.normalizeClass(a.loaderClasses), style: e.normalizeStyle({ paddingBottom: a.wrapperPadding.paddingBottom }), ref: "bottomLoader" }, [e.createVNode(x, { text: a.localeLoadingText, active: g.showBottomLoader }, null, 8, ["text", "active"])], 6)], 38)], 2);
    }
    var $v = f(Z5, [["render", eV]]);
    const tV = "COMPLETE", Iv = "CANCELED";
    function nV(t) {
      if (h && "requestAnimationFrame" in window)
        return window.requestAnimationFrame(t);
      setTimeout(t, 16);
    }
    function Mv(t, r, o) {
      t === window ? t.scrollTo(r, o) : (t.scrollLeft = r, t.scrollTop = o);
    }
    function iV(t, r, o) {
      if (!h)
        return;
      let C = t.getBoundingClientRect(), g = null, a = null, x = null, O = null, P = null, N = null, B = null, H = o && o.left != null ? o.left : 0.5, oe = o && o.top != null ? o.top : 0.5, se = o && o.leftOffset != null ? o.leftOffset : 0, ee = o && o.topOffset != null ? o.topOffset : 0, j = H, pe = oe;
      if (r === window)
        N = Math.min(C.width, window.innerWidth), B = Math.min(C.height, window.innerHeight), a = C.left + window.pageXOffset - window.innerWidth * j + N * j, x = C.top + window.pageYOffset - window.innerHeight * pe + B * pe, a -= se, x -= ee, O = a - window.pageXOffset, P = x - window.pageYOffset;
      else {
        N = C.width, B = C.height, g = r.getBoundingClientRect();
        let at = C.left - (g.left - r.scrollLeft), Qe = C.top - (g.top - r.scrollTop);
        a = at + N * j - r.clientWidth * j, x = Qe + B * pe - r.clientHeight * pe, a = Math.max(Math.min(a, r.scrollWidth - r.clientWidth), 0), x = Math.max(Math.min(x, r.scrollHeight - r.clientHeight), 0), a -= se, x -= ee, O = a - r.scrollLeft, P = x - r.scrollTop;
      }
      return { x: a, y: x, differenceX: O, differenceY: P };
    }
    function Av(t) {
      nV(function() {
        let r = t.scrollOption;
        if (!r)
          return;
        let o = iV(r.target, t, r.align), C = Date.now() - r.startTime, g = Math.min(1 / r.time * C, 1);
        if (C > r.time + 20)
          return Mv(t, o.x, o.y), t.scrollOption = null, r.end(tV);
        let a = 1 - r.ease(g);
        Mv(t, o.x - o.differenceX * a, o.y - o.differenceY * a), Av(t);
      });
    }
    function rV(t, r, o, C) {
      let g = !r.scrollOption, a = r.scrollOption, x = Date.now(), O;
      a && a.end(Iv);
      function P(N) {
        r.scrollOption = null, r.parentElement && r.parentElement.scrollOption && r.parentElement.scrollOption.end(N), C(N), r.removeEventListener("touchstart", O);
      }
      r.scrollOption = { startTime: a ? a.startTime : Date.now(), target: t, time: o.time + (a ? x - a.startTime : 0), ease: o.ease, align: o.align, end: P }, O = P.bind(null, Iv), r.addEventListener("touchstart", O), g && Av(r);
    }
    function Fv(t) {
      if (h)
        return t === window || (t.scrollHeight !== t.clientHeight || t.scrollWidth !== t.clientWidth) && getComputedStyle(t).overflow !== "hidden";
    }
    function sV() {
      return !0;
    }
    function _d(t, r, o) {
      if (!t)
        return;
      typeof r == "function" && (o = r, r = null), r || (r = {}), r.time = isNaN(r.time) ? 1e3 : r.time, r.ease = r.ease || function(P) {
        return 1 - Math.pow(1 - P, P / 2);
      };
      let C = t.parentElement, g = 0;
      function a(P) {
        g -= 1, !g && o && o(P);
      }
      let x = r.validTarget || sV, O = r.isScrollable;
      for (; C; ) {
        if (x(C, g) && (O ? O(C, Fv) : Fv(C)) && (g += 1, rV(t, C, r, a)), C = C.parentElement, !C)
          return;
        C.tagName === "BODY" && (C = window);
      }
    }
    function oV(t) {
      if (h && "requestAnimationFrame" in window)
        return window.requestAnimationFrame(t);
      setTimeout(t, 16);
    }
    function Td(t, r, o) {
      if (!t)
        return;
      typeof r == "function" && (o = r, r = null), r || (r = {}), r.time = isNaN(r.time) ? 500 : r.time;
      const C = t.scrollTop, g = r.to || 0, a = Math.abs(C - g), x = Math.ceil(a / r.time * 50);
      function O(P, N, B) {
        if (P === N) {
          o && o();
          return;
        }
        let H = P + B > N ? N : P + B;
        P > N && (H = P - B < N ? N : P - B), t.scrollTop = H, oV(() => O(H, N, B));
      }
      O(C, g, x);
    }
    const sr = "ivu-layout-sider";
    De();
    const aV = { name: "Sider", emits: ["on-collapse", "update:modelValue"], props: { modelValue: { type: Boolean, default: !1 }, width: { type: [Number, String], default: 200 }, collapsedWidth: { type: [Number, String], default: 64 }, hideTrigger: { type: Boolean, default: !1 }, breakpoint: { type: String, validator(t) {
      return z(t, ["xs", "sm", "md", "lg", "xl", "xxl"]);
    } }, collapsible: { type: Boolean, default: !1 }, defaultCollapsed: { type: Boolean, default: !1 }, reverseArrow: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: sr, mediaMatched: !1 };
    }, computed: { wrapClasses() {
      return [`${sr}`, this.siderWidth ? "" : `${sr}-zero-width`, this.modelValue ? `${sr}-collapsed` : ""];
    }, wrapStyles() {
      return { width: `${this.siderWidth}px`, minWidth: `${this.siderWidth}px`, maxWidth: `${this.siderWidth}px`, flex: `0 0 ${this.siderWidth}px` };
    }, triggerClasses() {
      return [`${sr}-trigger`, this.modelValue ? `${sr}-trigger-collapsed` : ""];
    }, childClasses() {
      return `${this.prefixCls}-children`;
    }, zeroWidthTriggerClasses() {
      return [`${sr}-zero-width-trigger`, this.reverseArrow ? `${sr}-zero-width-trigger-left` : ""];
    }, triggerIconClasses() {
      return ["ivu-icon", `ivu-icon-ios-arrow-${this.reverseArrow ? "forward" : "back"}`, `${sr}-trigger-icon`];
    }, siderWidth() {
      return this.collapsible ? this.modelValue ? this.mediaMatched ? 0 : parseInt(this.collapsedWidth) : parseInt(this.width) : this.width;
    }, showZeroTrigger() {
      return this.collapsible ? this.mediaMatched && !this.hideTrigger || parseInt(this.collapsedWidth) === 0 && this.modelValue && !this.hideTrigger : !1;
    }, showBottomTrigger() {
      return this.collapsible ? !this.mediaMatched && !this.hideTrigger : !1;
    } }, methods: { toggleCollapse() {
      let t = this.collapsible ? !this.modelValue : !1;
      this.$emit("update:modelValue", t);
    }, matchMedia() {
      if (!h)
        return;
      let t;
      window.matchMedia && (t = window.matchMedia);
      let r = this.mediaMatched;
      this.mediaMatched = t(`(max-width: ${we[this.breakpoint]})`).matches, this.mediaMatched !== r && this.$emit("update:modelValue", this.mediaMatched);
    }, onWindowResize() {
      this.matchMedia();
    } }, watch: { modelValue(t) {
      this.$emit("on-collapse", t);
    } }, mounted() {
      this.defaultCollapsed && this.$emit("update:modelValue", this.defaultCollapsed), this.breakpoint !== void 0 && (m(window, "resize", this.onWindowResize), this.matchMedia());
    }, beforeUnmount() {
      this.breakpoint !== void 0 && b(window, "resize", this.onWindowResize);
    } }, lV = [e.createElementVNode("i", { class: "ivu-icon ivu-icon-ios-menu" }, null, -1)];
    function cV(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses), style: e.normalizeStyle(a.wrapStyles) }, [e.withDirectives(e.createElementVNode("span", { onClick: r[0] || (r[0] = (...x) => a.toggleCollapse && a.toggleCollapse(...x)), class: e.normalizeClass(a.zeroWidthTriggerClasses) }, lV, 2), [[e.vShow, a.showZeroTrigger]]), e.createElementVNode("div", { class: e.normalizeClass(a.childClasses) }, [e.renderSlot(t.$slots, "default")], 2), e.renderSlot(t.$slots, "trigger", {}, () => [e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass(a.triggerClasses), onClick: r[1] || (r[1] = (...x) => a.toggleCollapse && a.toggleCollapse(...x)), style: e.normalizeStyle({ width: a.siderWidth + "px" }) }, [e.createElementVNode("i", { class: e.normalizeClass(a.triggerIconClasses) }, null, 2)], 6), [[e.vShow, a.showBottomTrigger]])])], 6);
    }
    var Lv = f(aV, [["render", cV]]);
    const $r = "ivu-skeleton-item", uV = { name: "SkeletonItem", components: { Icon: G }, inject: { SkeletonInstance: { default: null } }, props: { animated: { type: Boolean, default: !1 }, type: { validator(t) {
      return z(t, ["circle", "square", "rect", "image"]);
    }, default: "rect" }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, width: { type: [String, Number] }, height: { type: [String, Number] }, block: { type: Boolean, default: !1 }, imgSrc: { type: String } }, data() {
      return { prefixCls: $r };
    }, computed: { classes() {
      return [$r, $r + "-" + this.type, $r + "-" + this.type + "-" + this.size, { [$r + "-animated"]: this.animated || !!this.SkeletonInstance && this.SkeletonInstance.animated, [$r + "-inline"]: !this.block, [$r + "-with-image"]: this.showImage, [$r + "-round"]: !!this.SkeletonInstance && this.SkeletonInstance.round }];
    }, styles() {
      const t = {};
      return ["rect", "image"].includes(this.type) && (this.width && (t.width = typeof this.width == "number" ? `${this.width}px` : this.width), this.height && (t.height = typeof this.height == "number" ? `${this.height}px` : this.height), this.showImage && (t.background = `no-repeat url(${this.imgSrc}) center center`, t.backgroundSize = "contain")), t;
    }, showIcon() {
      return this.type === "image" && !this.imgSrc;
    }, showImage() {
      return this.type === "image" && !!this.imgSrc;
    }, iconSize() {
      let t = 16;
      return this.size === "large" && (t = 32), this.size === "small" && (t = 10), t;
    } } };
    function hV(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(a.styles) }, [a.showIcon ? (e.openBlock(), e.createBlock(x, { key: 0, class: e.normalizeClass(g.prefixCls + "-image-icon"), type: "ios-image", size: a.iconSize }, null, 8, ["class", "size"])) : e.createCommentVNode("", !0)], 6);
    }
    var Od = f(uV, [["render", hV]]);
    const Ss = "ivu-skeleton", dV = { name: "Skeleton", components: { SkeletonItem: Od, Row: Er, Col: Ii }, provide() {
      return { SkeletonInstance: this };
    }, props: { animated: { type: Boolean, default: !1 }, loading: { type: Boolean, default: !1 }, round: { type: Boolean, default: !1 }, paragraph: { validator(t) {
      return typeof t == "number" ? t >= 1 : typeof t.rows == "number" && t.rows >= 1;
    }, type: [Number, Object], default: 3 }, title: { validator(t) {
      return typeof t == "object" && t.width ? ["number", "string"].includes(typeof t.width) : !0;
    }, type: [Boolean, Object], default: !0 }, avatar: { validator(t) {
      if (typeof t == "object") {
        if (t.type)
          return z(t.type, ["circle", "square"]);
        if (t.size)
          return z(t.size, ["small", "large", "default"]);
      }
      return !0;
    }, type: [Boolean, Object], default: !1 } }, data() {
      return { prefixCls: Ss };
    }, computed: { classes() {
      return [Ss, { [Ss + "-with-title"]: this.showTitle, [Ss + "-with-avatar"]: this.showAvatar }];
    }, rows() {
      return typeof this.paragraph == "number" ? this.paragraph : this.paragraph.rows;
    }, rowsCount() {
      return this.rows + Number(this.showTitle);
    }, showTitle() {
      return !!this.title;
    }, titleWidth() {
      return typeof this.title == "object" && this.title.width ? typeof this.title.width == "string" ? this.title.width : `${this.title.width}px` : "";
    }, showAvatar() {
      return !!this.avatar;
    }, avatarType() {
      return typeof this.avatar == "object" && this.avatar.type ? this.avatar.type : "circle";
    }, avatarSize() {
      return typeof this.avatar == "object" && this.avatar.size ? this.avatar.size : !this.$VIEWUI || this.$VIEWUI.size === "" ? "default" : this.$VIEWUI.size;
    } }, methods: { rowClasses(t) {
      return [Ss + "-item-inner", { [Ss + "-item-round"]: this.round, [Ss + "-item-title"]: this.showTitle && t === 1 }];
    }, rowWidth(t) {
      if (this.showTitle && t === 1)
        return this.titleWidth || "38%";
      if (typeof this.paragraph == "object") {
        if (typeof this.paragraph.width == "string")
          return this.paragraph.width;
        if (typeof this.paragraph.width == "number")
          return `${this.paragraph.width}px`;
        const r = t - 1 - Number(this.showTitle);
        if (Array.isArray(this.paragraph.width) && this.paragraph.width[r])
          return typeof this.paragraph.width[r] == "number" ? `${this.paragraph.width[r]}px` : this.paragraph.width[r];
      }
      return t === this.rowsCount ? "62%" : "100%";
    } } };
    function fV(t, r, o, C, g, a) {
      const x = e.resolveComponent("SkeletonItem"), O = e.resolveComponent("Col"), P = e.resolveComponent("Row");
      return o.loading ? (e.openBlock(), e.createElementBlock("div", e.mergeProps({ key: 0 }, t.$attrs, { class: a.classes }), [o.loading ? e.renderSlot(t.$slots, "template", { key: 0 }, () => [e.createVNode(P, null, { default: e.withCtx(() => [a.showAvatar ? (e.openBlock(), e.createBlock(O, { key: 0, flex: "0" }, { default: e.withCtx(() => [e.createVNode(x, { type: a.avatarType, size: a.avatarSize, animated: o.animated, class: e.normalizeClass(g.prefixCls + "-item-avatar") }, null, 8, ["type", "size", "animated", "class"])]), _: 1 })) : e.createCommentVNode("", !0), e.createVNode(O, { flex: "1" }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.rowsCount, (N) => (e.openBlock(), e.createBlock(x, { key: N, class: e.normalizeClass(a.rowClasses(N)), animated: o.animated, width: a.rowWidth(N), block: "" }, null, 8, ["class", "animated", "width"]))), 128))]), _: 1 })]), _: 1 })]) : e.createCommentVNode("", !0)], 16)) : e.renderSlot(t.$slots, "default", e.normalizeProps(e.mergeProps({ key: 1 }, t.$attrs)));
    }
    var zv = f(dV, [["render", fV]]), pV = { name: "SliderMarker", props: { mark: { type: [String, Object] } }, render() {
      let t = typeof this.mark == "string" ? this.mark : [this.mark.label];
      return e.h("div", { class: "ivu-slider-marks-item", style: this.mark.style || {} }, t);
    } };
    const or = "ivu-slider", mV = { name: "Slider", mixins: [nn], emits: ["update:modelValue", "on-input", "on-change"], components: { InputNumber: fd, Tooltip: tr, SliderMarker: pV }, inject: { ModalInstance: { default: null }, DrawerInstance: { default: null } }, props: { min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, step: { type: Number, default: 1 }, range: { type: Boolean, default: !1 }, modelValue: { type: [Number, Array], default: 0 }, disabled: { type: Boolean, default: !1 }, showInput: { type: Boolean, default: !1 }, inputSize: { type: String, default: "default", validator(t) {
      return z(t, ["small", "large", "default"]);
    } }, showStops: { type: Boolean, default: !1 }, tipFormat: { type: Function, default(t) {
      return t;
    } }, showTip: { type: String, default: "hover", validator(t) {
      return z(t, ["hover", "always", "never"]);
    } }, name: { type: String }, activeChange: { type: Boolean, default: !0 }, marks: { type: Object } }, data() {
      let t = this.checkLimits(Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue]);
      return this.range && this.modelValue === null && (t = [0, 0]), { prefixCls: or, currentValue: t, dragging: !1, pointerDown: "", startX: 0, currentX: 0, startPos: 0, oldValue: [...t], valueIndex: { min: 0, max: 1 }, sliderWidth: 0, isValueNull: !1, id: be(6) };
    }, watch: { modelValue(t) {
      t === null && (this.isValueNull = !0), t = this.checkLimits(Array.isArray(t) ? t : [t]), !this.dragging && (t[0] !== this.currentValue[0] || t[1] !== this.currentValue[1]) && (this.isValueNull && this.range ? this.currentValue = [0, 0] : this.currentValue = t);
    }, exportValue(t) {
      e.nextTick(() => {
        this.$refs.minTooltip.updatePopper(), this.range && this.$refs.maxTooltip.updatePopper();
      });
      const r = this.range ? t : t[0];
      this.isValueNull ? (this.isValueNull = !1, this.$emit("update:modelValue", null)) : this.$emit("update:modelValue", r), this.$emit("on-input", r);
    } }, computed: { classes() {
      return [`${or}`, { [`${or}-input`]: this.showInput && !this.range, [`${or}-range`]: this.range, [`${or}-disabled`]: this.itemDisabled }];
    }, minButtonClasses() {
      return [`${or}-button`, { [`${or}-button-dragging`]: this.pointerDown === "min" }];
    }, maxButtonClasses() {
      return [`${or}-button`, { [`${or}-button-dragging`]: this.pointerDown === "max" }];
    }, exportValue() {
      const t = (String(this.step).split(".")[1] || "").length;
      return this.currentValue.map((r) => Number(r.toFixed(t)));
    }, minPosition() {
      return (this.currentValue[0] - this.min) / this.valueRange * 100;
    }, maxPosition: function() {
      return (this.currentValue[1] - this.min) / this.valueRange * 100;
    }, barStyle() {
      const t = { width: (this.currentValue[0] - this.min) / this.valueRange * 100 + "%" };
      return this.range && (t.left = (this.currentValue[0] - this.min) / this.valueRange * 100 + "%", t.width = (this.currentValue[1] - this.currentValue[0]) / this.valueRange * 100 + "%"), t;
    }, stops() {
      let t = this.valueRange / this.step, r = [], o = 100 * this.step / this.valueRange;
      for (let C = 1; C < t; C++)
        r.push(C * o);
      return r;
    }, markList() {
      return this.marks ? Object.keys(this.marks).map(parseFloat).sort((t, r) => t - r).filter((t) => t <= this.max && t >= this.min).map((t) => ({ point: t, position: (t - this.min) * 100 / (this.max - this.min), mark: this.marks[t] })) : [];
    }, tipDisabled() {
      return this.tipFormat(this.currentValue[0]) === null || this.showTip === "never";
    }, valueRange() {
      return this.max - this.min;
    }, firstPosition() {
      return this.currentValue[0];
    }, secondPosition() {
      return this.currentValue[1];
    } }, methods: { getPointerX(t) {
      return t.type.indexOf("touch") !== -1 ? t.touches[0].clientX : t.clientX;
    }, checkLimits([t, r]) {
      return t = Math.max(this.min, t), t = Math.min(this.max, t), r = Math.max(this.min, t, r), r = Math.min(this.max, r), [t, r];
    }, getCurrentValue(t, r) {
      if (this.itemDisabled)
        return;
      const o = this.valueIndex[r];
      if (typeof o < "u")
        return this.currentValue[o];
    }, onKeyLeft(t, r) {
      const o = this.getCurrentValue(t, r);
      Number.isFinite(o) && this.changeButtonPosition(o - this.step, r);
    }, onKeyRight(t, r) {
      const o = this.getCurrentValue(t, r);
      Number.isFinite(o) && this.changeButtonPosition(o + this.step, r);
    }, onPointerDown(t, r) {
      this.itemDisabled || (t.preventDefault(), this.pointerDown = r, this.onPointerDragStart(t), m(window, "mousemove", this.onPointerDrag), m(window, "touchmove", this.onPointerDrag), m(window, "mouseup", this.onPointerDragEnd), m(window, "touchend", this.onPointerDragEnd));
    }, onPointerDragStart(t) {
      this.dragging = !1, this.startX = this.getPointerX(t), this.startPos = this[`${this.pointerDown}Position`] * this.valueRange / 100 + this.min;
    }, onPointerDrag(t) {
      this.dragging = !0, this.$refs[`${this.pointerDown}Tooltip`].visible = !0, this.currentX = this.getPointerX(t);
      const r = (this.currentX - this.startX) / this.sliderWidth * this.valueRange;
      this.changeButtonPosition(this.startPos + r);
    }, onPointerDragEnd() {
      this.dragging && (this.dragging = !1, this.$refs[`${this.pointerDown}Tooltip`].visible = !1, this.emitChange()), this.pointerDown = "", b(window, "mousemove", this.onPointerDrag), b(window, "touchmove", this.onPointerDrag), b(window, "mouseup", this.onPointerDragEnd), b(window, "touchend", this.onPointerDragEnd);
    }, changeButtonPosition(t, r) {
      const o = r || this.pointerDown, C = o === "min" ? 0 : 1;
      o === "min" ? t = this.checkLimits([t, this.max])[0] : t = this.checkLimits([this.min, t])[1];
      const g = this.handleDecimal(t, this.step), a = this.currentValue;
      a[C] = t - g, this.range && (o === "min" && a[0] > a[1] && (a[1] = a[0]), o === "max" && a[0] > a[1] && (a[0] = a[1])), this.currentValue = [...a], this.dragging || this.currentValue[C] !== this.oldValue[C] && (this.emitChange(), this.oldValue[C] = this.currentValue[C]);
    }, handleDecimal(t, r) {
      if (r < 1) {
        let o = r.toString(), C = 1, g;
        try {
          g = o.split(".")[1].length;
        } catch {
          g = 0;
        }
        return C = Math.pow(10, g), t * C % (r * C) / C;
      } else
        return t % r;
    }, emitChange() {
      const t = this.range ? this.exportValue : this.exportValue[0];
      this.$emit("on-change", t), this.handleFormItemChange("change", t);
    }, sliderClick(t) {
      if (this.itemDisabled)
        return;
      const r = this.getPointerX(t), o = this.$refs.slider.getBoundingClientRect().left;
      let C = (r - o) / this.sliderWidth * this.valueRange + this.min, g = C / this.valueRange * 100;
      !this.range || g <= this.minPosition ? this.changeButtonPosition(C, "min") : g >= this.maxPosition ? this.changeButtonPosition(C, "max") : this.changeButtonPosition(C, C - this.firstPosition <= this.secondPosition - C ? "min" : "max");
    }, handleInputChange(t) {
      this.currentValue = [t === 0 ? 0 : t || this.min, this.currentValue[1]], this.emitChange();
    }, handleFocus(t) {
      this.$refs[`${t}Tooltip`].handleShowPopper();
    }, handleBlur(t) {
      this.$refs[`${t}Tooltip`].handleClosePopper();
    }, handleSetSliderWidth() {
      this.sliderWidth = parseInt(Be(this.$refs.slider, "width"), 10);
    }, handleOnVisibleChange(t) {
      t && this.showTip === "always" && (this.$refs.minTooltip.doDestroy(), this.range && this.$refs.maxTooltip.doDestroy(), e.nextTick(() => {
        this.$refs.minTooltip.updatePopper(), this.range && this.$refs.maxTooltip.updatePopper();
      }));
    }, addSlider(t) {
      const r = this[t];
      !r || (r.sliderList || (r.sliderList = []), r.sliderList.push({ id: this.id, slider: this }));
    }, removeSlider(t) {
      const r = this[t];
      if (!r || !r.sliderList)
        return;
      const o = r.sliderList.findIndex((C) => C.id === this.id);
      r.sliderList.splice(o, 1);
    } }, mounted() {
      this.addSlider("ModalInstance"), this.addSlider("DrawerInstance"), this.observer = ho(), this.observer.listenTo(this.$refs.slider, this.handleSetSliderWidth);
    }, beforeUnmount() {
      this.removeSlider("ModalInstance"), this.removeSlider("DrawerInstance"), this.observer.removeListener(this.$refs.slider, this.handleSetSliderWidth);
    } }, gV = ["name", "value"], vV = { class: "ivu-slider-marks" };
    function yV(t, r, o, C, g, a) {
      const x = e.resolveComponent("Input-number"), O = e.resolveComponent("SliderMarker"), P = e.resolveComponent("Tooltip");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [!o.range && o.showInput ? (e.openBlock(), e.createBlock(x, { key: 0, min: o.min, size: o.inputSize, max: o.max, step: o.step, modelValue: a.exportValue[0], disabled: t.itemDisabled, "active-change": o.activeChange, onOnChange: a.handleInputChange }, null, 8, ["min", "size", "max", "step", "modelValue", "disabled", "active-change", "onOnChange"])) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-wrap"]), ref: "slider", onClick: r[19] || (r[19] = e.withModifiers((...N) => a.sliderClick && a.sliderClick(...N), ["self"])) }, [e.createElementVNode("input", { type: "hidden", name: o.name, value: a.exportValue }, null, 8, gV), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-bar"]), style: e.normalizeStyle(a.barStyle), onClick: r[0] || (r[0] = e.withModifiers((...N) => a.sliderClick && a.sliderClick(...N), ["self"])) }, null, 6), o.showStops ? (e.openBlock(!0), e.createElementBlock(e.Fragment, { key: 0 }, e.renderList(a.stops, (N) => (e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls + "-stop"]), key: N, style: e.normalizeStyle({ left: N + "%" }), onClick: r[1] || (r[1] = e.withModifiers((...B) => a.sliderClick && a.sliderClick(...B), ["self"])) }, null, 6))), 128)) : e.createCommentVNode("", !0), a.markList.length > 0 ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.markList, (N, B) => (e.openBlock(), e.createElementBlock("div", { key: B, class: e.normalizeClass([g.prefixCls + "-stop"]), style: e.normalizeStyle({ left: N.position + "%" }), onClick: r[2] || (r[2] = e.withModifiers((...H) => a.sliderClick && a.sliderClick(...H), ["self"])) }, null, 6))), 128)), e.createElementVNode("div", vV, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.markList, (N, B) => (e.openBlock(), e.createBlock(O, { key: B, mark: N.mark, style: e.normalizeStyle({ left: N.position + "%" }), onClick: a.sliderClick }, null, 8, ["mark", "style", "onClick"]))), 128))])], 64)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-button-wrap"]), style: e.normalizeStyle({ left: a.minPosition + "%" }), onTouchstart: r[9] || (r[9] = (N) => a.onPointerDown(N, "min")), onMousedown: r[10] || (r[10] = (N) => a.onPointerDown(N, "min")) }, [e.createVNode(P, { controlled: g.pointerDown === "min", placement: "top", content: o.tipFormat(a.exportValue[0]), disabled: a.tipDisabled, always: o.showTip === "always", ref: "minTooltip" }, { default: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass(a.minButtonClasses), tabindex: "0", onFocus: r[3] || (r[3] = (N) => a.handleFocus("min")), onBlur: r[4] || (r[4] = (N) => a.handleBlur("min")), onKeydown: [r[5] || (r[5] = e.withKeys((N) => a.onKeyLeft(N, "min"), ["left"])), r[6] || (r[6] = e.withKeys((N) => a.onKeyLeft(N, "min"), ["down"])), r[7] || (r[7] = e.withKeys((N) => a.onKeyRight(N, "min"), ["right"])), r[8] || (r[8] = e.withKeys((N) => a.onKeyRight(N, "min"), ["up"]))] }, null, 34)]), _: 1 }, 8, ["controlled", "content", "disabled", "always"])], 38), o.range ? (e.openBlock(), e.createElementBlock("div", { key: 2, class: e.normalizeClass([g.prefixCls + "-button-wrap"]), style: e.normalizeStyle({ left: a.maxPosition + "%" }), onTouchstart: r[17] || (r[17] = (N) => a.onPointerDown(N, "max")), onMousedown: r[18] || (r[18] = (N) => a.onPointerDown(N, "max")) }, [e.createVNode(P, { controlled: g.pointerDown === "max", placement: "top", content: o.tipFormat(a.exportValue[1]), disabled: a.tipDisabled, always: o.showTip === "always", ref: "maxTooltip" }, { default: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass(a.maxButtonClasses), tabindex: "0", onFocus: r[11] || (r[11] = (N) => a.handleFocus("max")), onBlur: r[12] || (r[12] = (N) => a.handleBlur("max")), onKeydown: [r[13] || (r[13] = e.withKeys((N) => a.onKeyLeft(N, "max"), ["left"])), r[14] || (r[14] = e.withKeys((N) => a.onKeyLeft(N, "max"), ["down"])), r[15] || (r[15] = e.withKeys((N) => a.onKeyRight(N, "max"), ["right"])), r[16] || (r[16] = e.withKeys((N) => a.onKeyRight(N, "max"), ["up"]))] }, null, 34)]), _: 1 }, 8, ["controlled", "content", "disabled", "always"])], 38)) : e.createCommentVNode("", !0)], 2)], 2);
    }
    var Rv = f(mV, [["render", yV]]);
    const bV = { small: 8, default: 16, large: 24 }, jv = { name: "Space", props: { size: { type: [String, Number, Array], validator(t) {
      const r = ["small", "large", "default"];
      return typeof t == "string" ? z(t, r) : Array.isArray(t) ? t.length > 0 && t.every((o) => typeof o == "number" || z(o, r)) : !0;
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || !t.$VIEWUI.space || t.$VIEWUI.space.size === "" ? "small" : t.$VIEWUI.space.size;
    } }, direction: { type: String, validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "horizontal" }, align: { type: String, validator(t) {
      return z(t, ["start", "end", "center", "baseline", "stretch"]);
    } }, wrap: { type: Boolean, default: !1 }, split: { type: Boolean, default: !1 }, type: { type: String, validator(t) {
      return z(t, ["inline-flex", "flex"]);
    }, default: "inline-flex" } }, computed: { mergedAlign() {
      if (!this.align) {
        if (this.direction === "horizontal")
          return "center";
        if (this.type === "flex")
          return "stretch";
      }
      return this.align;
    }, classes() {
      return ["ivu-space", `ivu-space-${this.direction}`, { "ivu-space-flex": this.type === "flex", "ivu-space-wrap": this.wrap, [`ivu-space-${this.mergedAlign}`]: this.mergedAlign }];
    }, styles() {
      const t = {};
      return ["number", "string"].includes(typeof this.size) && (t.gap = this.getSize(this.size)), Array.isArray(this.size) && (this.size.length === 1 ? t.columnGap = this.getSize(this.size[0]) : this.size.length > 1 && (t.columnGap = this.getSize(this.size[0]), t.rowGap = this.getSize(this.size[1]))), t;
    } }, methods: { getSize(t) {
      return `${typeof t == "string" ? bV[t] : t || 0}px`;
    }, filterEmpty(t = []) {
      const r = [];
      return t.forEach((o) => {
        Array.isArray(o) ? r.push(...o) : o.type === e.Fragment ? r.push(...o.children) : r.push(o);
      }), r.filter((o) => !this.isEmptyElement(o));
    }, isEmptyElement(t) {
      return t && (t.type === e.Comment || t.type === e.Fragment && t.children.length === 0 || t.type === e.Text && t.children.trim() === "");
    } }, render() {
      const t = this.filterEmpty(this.$slots.default ? this.$slots.default() : []), r = t.length;
      if (r === 0)
        return null;
      let o = null;
      return this.split && !this.$slots.split ? o = e.h(mc, { type: "vertical" }) : this.$slots.split && (o = this.$slots.split()), e.h("div", { class: this.classes, style: this.styles }, t.map((C, g) => {
        const a = e.h("div", { class: "ivu-space-item" }, [C]);
        return o && g + 1 < r ? [a, e.h("div", { class: "ivu-space-split" }, [o])] : a;
      }));
    } }, CV = { name: "Trigger", props: { mode: String }, data() {
      return { prefix: "ivu-split-trigger", initOffset: 0 };
    }, computed: { isVertical() {
      return this.mode === "vertical";
    }, classes() {
      return [this.prefix, this.isVertical ? `${this.prefix}-vertical` : `${this.prefix}-horizontal`];
    }, barConClasses() {
      return [`${this.prefix}-bar-con`, this.isVertical ? "vertical" : "horizontal"];
    } } };
    function wV(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("div", { class: e.normalizeClass(a.barConClasses) }, [r[0] || (e.setBlockTracking(-1), r[0] = (e.openBlock(), e.createElementBlock(e.Fragment, null, e.renderList(8, (x) => e.createElementVNode("i", { class: e.normalizeClass(`${g.prefix}-bar`), key: `trigger-${x}` }, null, 2)), 64)), e.setBlockTracking(1), r[0])], 2)], 2);
    }
    var kV = f(CV, [["render", wV]]);
    const SV = { name: "Split", components: { Trigger: kV }, emits: ["update:modelValue", "on-move-start", "on-moving", "on-move-end"], props: { modelValue: { type: [Number, String], default: 0.5 }, mode: { validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "horizontal" }, min: { type: [Number, String], default: "40px" }, max: { type: [Number, String], default: "40px" } }, data() {
      return { prefix: "ivu-split", offset: 0, oldOffset: 0, isMoving: !1, computedMin: 0, computedMax: 0, currentValue: 0.5 };
    }, computed: { wrapperClasses() {
      return [`${this.prefix}-wrapper`, this.isMoving ? "no-select" : ""];
    }, paneClasses() {
      return [`${this.prefix}-pane`, { [`${this.prefix}-pane-moving`]: this.isMoving }];
    }, isHorizontal() {
      return this.mode === "horizontal";
    }, anotherOffset() {
      return 100 - this.offset;
    }, valueIsPx() {
      return typeof this.modelValue == "string";
    }, offsetSize() {
      return this.isHorizontal ? "offsetWidth" : "offsetHeight";
    } }, methods: { px2percent(t, r) {
      return parseFloat(t) / parseFloat(r);
    }, getComputedThresholdValue(t) {
      let r = this.$refs.outerWrapper[this.offsetSize];
      return this.valueIsPx ? typeof this[t] == "string" ? this[t] : r * this[t] : typeof this[t] == "string" ? this.px2percent(this[t], r) : this[t];
    }, getMin(t, r) {
      return this.valueIsPx ? `${Math.min(parseFloat(t), parseFloat(r))}px` : Math.min(t, r);
    }, getMax(t, r) {
      return this.valueIsPx ? `${Math.max(parseFloat(t), parseFloat(r))}px` : Math.max(t, r);
    }, getAnotherOffset(t) {
      let r = 0;
      return this.valueIsPx ? r = `${this.$refs.outerWrapper[this.offsetSize] - parseFloat(t)}px` : r = 1 - t, r;
    }, handleMove(t) {
      let r = (this.isHorizontal ? t.pageX : t.pageY) - this.initOffset, o = this.$refs.outerWrapper[this.offsetSize], C = this.valueIsPx ? `${parseFloat(this.oldOffset) + r}px` : this.px2percent(o * this.oldOffset + r, o), g = this.getAnotherOffset(C);
      parseFloat(C) <= parseFloat(this.computedMin) && (C = this.getMax(C, this.computedMin)), parseFloat(g) <= parseFloat(this.computedMax) && (C = this.getAnotherOffset(this.getMax(g, this.computedMax))), t.atMin = this.modelValue === this.computedMin, t.atMax = this.valueIsPx ? this.getAnotherOffset(this.modelValue) === this.computedMax : this.getAnotherOffset(this.modelValue).toFixed(5) === this.computedMax.toFixed(5), this.$emit("update:modelValue", C), this.$emit("on-moving", t);
    }, handleUp() {
      this.isMoving = !1, b(document, "mousemove", this.handleMove), b(document, "mouseup", this.handleUp), this.$emit("on-move-end");
    }, handleMousedown(t) {
      this.initOffset = this.isHorizontal ? t.pageX : t.pageY, this.oldOffset = this.modelValue, this.isMoving = !0, m(document, "mousemove", this.handleMove), m(document, "mouseup", this.handleUp), this.$emit("on-move-start");
    }, computeOffset() {
      e.nextTick(() => {
        this.computedMin = this.getComputedThresholdValue("min"), this.computedMax = this.getComputedThresholdValue("max"), this.offset = (this.valueIsPx ? this.px2percent(this.modelValue, this.$refs.outerWrapper[this.offsetSize]) : this.modelValue) * 1e4 / 100;
      });
    } }, watch: { modelValue(t) {
      t !== this.currentValue && (this.currentValue = t, this.computeOffset());
    } }, mounted() {
      e.nextTick(() => {
        this.computeOffset();
      }), m(window, "resize", this.computeOffset);
    }, beforeUnmount() {
      b(window, "resize", this.computeOffset);
    } };
    function EV(t, r, o, C, g, a) {
      const x = e.resolveComponent("trigger");
      return e.openBlock(), e.createElementBlock("div", { ref: "outerWrapper", class: e.normalizeClass(a.wrapperClasses) }, [a.isHorizontal ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(`${g.prefix}-horizontal`) }, [e.createElementVNode("div", { style: e.normalizeStyle({ right: `${a.anotherOffset}%` }), class: e.normalizeClass(["left-pane", a.paneClasses]) }, [e.renderSlot(t.$slots, "left")], 6), e.createElementVNode("div", { class: e.normalizeClass(`${g.prefix}-trigger-con`), style: e.normalizeStyle({ left: `${g.offset}%` }), onMousedown: r[0] || (r[0] = (...O) => a.handleMousedown && a.handleMousedown(...O)) }, [e.renderSlot(t.$slots, "trigger", {}, () => [e.createVNode(x, { mode: "vertical" })])], 38), e.createElementVNode("div", { style: e.normalizeStyle({ left: `${g.offset}%` }), class: e.normalizeClass(["right-pane", a.paneClasses]) }, [e.renderSlot(t.$slots, "right")], 6)], 2)) : (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass(`${g.prefix}-vertical`) }, [e.createElementVNode("div", { style: e.normalizeStyle({ bottom: `${a.anotherOffset}%` }), class: e.normalizeClass(["top-pane", a.paneClasses]) }, [e.renderSlot(t.$slots, "top")], 6), e.createElementVNode("div", { class: e.normalizeClass(`${g.prefix}-trigger-con`), style: e.normalizeStyle({ top: `${g.offset}%` }), onMousedown: r[1] || (r[1] = (...O) => a.handleMousedown && a.handleMousedown(...O)) }, [e.renderSlot(t.$slots, "trigger", {}, () => [e.createVNode(x, { mode: "horizontal" })])], 38), e.createElementVNode("div", { style: e.normalizeStyle({ top: `${g.offset}%` }), class: e.normalizeClass(["bottom-pane", a.paneClasses]) }, [e.renderSlot(t.$slots, "bottom")], 6)], 2))], 2);
    }
    var Hv = f(SV, [["render", EV]]);
    const mo = "ivu-steps", Uv = "ivu-icon", xV = { name: "Step", inject: ["StepsInstance"], props: { status: { validator(t) {
      return z(t, ["wait", "process", "finish", "error"]);
    } }, title: { type: String, default: "" }, content: { type: String }, icon: { type: String } }, data() {
      return { prefixCls: mo, id: be(6) };
    }, computed: { wrapClasses() {
      return [`${mo}-item`, `${mo}-status-${this.currentStatus}`, { [`${mo}-custom`]: !!this.icon || !!this.$slots.icon, [`${mo}-next-error`]: this.nextError }];
    }, iconClasses() {
      let t = "";
      return this.icon ? t = this.icon : this.currentStatus === "finish" ? t = "ios-checkmark" : this.currentStatus === "error" && (t = "ios-close"), [`${mo}-icon`, `${Uv}`, { [`${Uv}-${t}`]: t !== "" }];
    }, stepNumber() {
      return this.StepsInstance.steps.findIndex((t) => t.id === this.id) + 1;
    }, total() {
      return this.StepsInstance.direction === "horizontal" ? this.StepsInstance.steps.length : 1;
    }, currentStatus() {
      let t = "";
      if (this.status)
        t = this.status;
      else {
        const r = this.StepsInstance, o = r.current, C = r.steps.findIndex((g) => g.id === this.id);
        C === o ? r.status !== "error" ? t = "process" : t = "error" : C < o ? t = "finish" : t = "wait";
      }
      return t;
    }, nextError() {
      let t = !1;
      const r = this.StepsInstance, o = r.steps.findIndex((C) => C.id === this.id);
      return o + 1 < r.steps.length && r.steps[o + 1].currentStatus === "error" && (t = !0), t;
    } }, beforeMount() {
      this.StepsInstance.addStep(this.id, this);
    }, beforeUnmount() {
      this.StepsInstance.removeStep(this.id);
    } }, _V = [e.createElementVNode("i", null, null, -1)], TV = { key: 0 }, OV = { key: 1, class: "ivu-steps-icon" };
    function DV(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-tail"]) }, _V, 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-head"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-head-inner"]) }, [!o.icon && !t.$slots.icon && a.currentStatus !== "finish" && a.currentStatus !== "error" ? (e.openBlock(), e.createElementBlock("span", TV, e.toDisplayString(a.stepNumber), 1)) : t.$slots.icon ? (e.openBlock(), e.createElementBlock("span", OV, [e.renderSlot(t.$slots, "icon")])) : (e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass(a.iconClasses) }, null, 2))], 2)], 2), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-main"]) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-title"]) }, [e.renderSlot(t.$slots, "title", {}, () => [e.createTextVNode(e.toDisplayString(o.title), 1)])], 2), o.content || t.$slots.content ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-content"]) }, [e.renderSlot(t.$slots, "content", {}, () => [e.createTextVNode(e.toDisplayString(o.content), 1)])], 2)) : e.createCommentVNode("", !0)], 2)], 2);
    }
    var Wv = f(xV, [["render", DV]]);
    const Dd = "ivu-steps", NV = { name: "Steps", provide() {
      return { StepsInstance: this };
    }, props: { current: { type: Number, default: 0 }, status: { validator(t) {
      return z(t, ["wait", "process", "finish", "error"]);
    }, default: "process" }, size: { validator(t) {
      return z(t, ["small"]);
    } }, direction: { validator(t) {
      return z(t, ["horizontal", "vertical"]);
    }, default: "horizontal" } }, data() {
      return { steps: [] };
    }, computed: { classes() {
      return [`${Dd}`, `${Dd}-${this.direction}`, { [`${Dd}-${this.size}`]: !!this.size }];
    }, children() {
      return this.steps.map((t) => t.step);
    } }, methods: { addStep(t, r) {
      this.steps.push({ id: t, step: r });
    }, removeStep(t) {
      const r = this.steps.findIndex((o) => o.id === t);
      this.steps.splice(r, 1);
    } } };
    function BV(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var Yv = f(NV, [["render", BV]]);
    const Es = "ivu-menu", PV = { name: "Submenu", mixins: [yd, kr], components: { Icon: G, Drop: er, CollapseTransition: Sd }, provide() {
      return { SubmenuInstance: this };
    }, props: { name: { type: [String, Number], required: !0 }, disabled: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: Es, active: !1, opened: !1, dropWidth: parseFloat(Be(this.$el, "width")), id: be(6), childSubmenuList: [] };
    }, computed: { classes() {
      return [`${Es}-submenu`, { [`${Es}-item-active`]: this.active && !this.hasParentSubmenu, [`${Es}-opened`]: this.opened, [`${Es}-submenu-disabled`]: this.disabled, [`${Es}-submenu-has-parent-submenu`]: this.hasParentSubmenu, [`${Es}-child-item-active`]: this.active }];
    }, accordion() {
      return this.menu.accordion;
    }, dropStyle() {
      let t = {};
      return this.dropWidth && (t.minWidth = `${this.dropWidth}px`), t;
    }, titleStyle() {
      return this.hasParentSubmenu && this.mode !== "horizontal" ? { paddingLeft: 43 + (this.parentSubmenuNum - 1) * 24 + "px" } : {};
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-down";
      return t && (t.menu.customArrow ? r = "" : t.menu.arrow && (r = t.menu.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.menu.customArrow && (r = t.menu.customArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.menu.arrowSize && (r = t.menu.arrowSize), r;
    } }, methods: { handleMouseenter() {
      this.disabled || this.mode !== "vertical" && (clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.menu.updateOpenKeys(this.name), this.opened = !0;
      }, 250));
    }, handleMouseleave() {
      this.disabled || this.mode !== "vertical" && (clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.menu.updateOpenKeys(this.name), this.opened = !1;
      }, 150));
    }, handleClick() {
      if (this.disabled || this.mode === "horizontal")
        return;
      const t = this.opened;
      this.opened = !t, this.menu.updateOpenKeys(this.name);
    }, addSubmenu() {
      const t = this.MenuInstance;
      t.submenuList || (t.submenuList = []), t.submenuList.push({ id: this.id, submenu: this });
      const r = me(this, "Submenu");
      r && (r.childSubmenuList || (r.childSubmenuList = []), r.childSubmenuList.push({ id: this.id, submenu: this }));
    }, removeSubmenu() {
      const t = this.MenuInstance;
      if (t.submenuList && t.submenuList.length) {
        const o = t.submenuList.findIndex((C) => C.id === this.id);
        t.submenuList.splice(o, 1);
      }
      const r = me(this, "Submenu");
      if (r && r.childSubmenuList && r.childSubmenuList.length) {
        const o = r.childSubmenuList.findIndex((C) => C.id === this.id);
        r.childSubmenuList.splice(o, 1);
      }
    }, handleMenuItemSelect(t) {
      this.mode === "horizontal" && (this.opened = !1), this.MenuInstance.handleMenuItemSelect(t);
    }, handleUpdateActiveName(t) {
      me(this, "Submenu") && this.SubmenuInstance.handleUpdateActiveName(t), this.childSubmenuList && this.childSubmenuList.length && this.childSubmenuList.map((r) => r.submenu).forEach((r) => {
        r.active = !1;
      }), this.active = t;
    } }, watch: { mode(t) {
      t === "horizontal" && this.$refs.drop.update();
    }, opened(t) {
      this.mode !== "vertical" && (t ? (this.dropWidth = parseFloat(Be(this.$el, "width")), this.$refs.drop.update()) : this.$refs.drop.destroy());
    } }, mounted() {
      this.addSubmenu();
    }, beforeUnmount() {
      this.removeSubmenu();
    } };
    function VV(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("collapse-transition"), P = e.resolveComponent("Drop");
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.classes), onMouseenter: r[1] || (r[1] = (...N) => a.handleMouseenter && a.handleMouseenter(...N)), onMouseleave: r[2] || (r[2] = (...N) => a.handleMouseleave && a.handleMouseleave(...N)) }, [e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-submenu-title"]), ref: "reference", onClick: r[0] || (r[0] = e.withModifiers((...N) => a.handleClick && a.handleClick(...N), ["stop"])), style: e.normalizeStyle(a.titleStyle) }, [e.renderSlot(t.$slots, "title"), e.createVNode(x, { type: a.arrowType, custom: a.customArrowType, size: a.arrowSize, class: e.normalizeClass([g.prefixCls + "-submenu-title-icon"]) }, null, 8, ["type", "custom", "size", "class"])], 6), t.mode === "vertical" ? (e.openBlock(), e.createBlock(O, { key: 0, ready: t.menu.ready }, { default: e.withCtx(() => [e.withDirectives(e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls]) }, [e.renderSlot(t.$slots, "default")], 2), [[e.vShow, g.opened]])]), _: 3 }, 8, ["ready"])) : e.createCommentVNode("", !0), t.mode === "horizontal" ? (e.openBlock(), e.createBlock(P, { key: 1, ref: "drop", visible: g.opened, placement: "bottom", "transition-name": "slide-up", styles: a.dropStyle }, { default: e.withCtx(() => [e.createElementVNode("ul", { class: e.normalizeClass([g.prefixCls + "-drop-list"]) }, [e.renderSlot(t.$slots, "default")], 2)]), _: 3 }, 8, ["visible", "styles"])) : e.createCommentVNode("", !0)], 34);
    }
    var Kv = f(PV, [["render", VV]]);
    const Gv = { name: "Submit", inject: ["LoginInstance"], props: {}, methods: { handleSubmit() {
      this.LoginInstance.handleSubmit();
    } }, render() {
      const t = Object.assign({ size: "large", type: "primary", long: !0 }, this.$attrs), r = e.h(zn, v(p({}, t), { onClick: this.handleSubmit }), this.$slots.default || (() => "登录"));
      return e.h("div", { class: "ivu-login-submit" }, [r]);
    } }, go = "ivu-switch", $V = { name: "iSwitch", mixins: [nn], emits: ["update:modelValue", "on-change"], props: { modelValue: { type: [String, Number, Boolean], default: !1 }, trueValue: { type: [String, Number, Boolean], default: !0 }, falseValue: { type: [String, Number, Boolean], default: !1 }, disabled: { type: Boolean, default: !1 }, size: { validator(t) {
      return z(t, ["large", "small", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, name: { type: String }, loading: { type: Boolean, default: !1 }, trueColor: { type: String }, falseColor: { type: String }, beforeChange: Function }, data() {
      return { currentValue: this.modelValue };
    }, computed: { wrapClasses() {
      return [`${go}`, { [`${go}-checked`]: this.currentValue === this.trueValue, [`${go}-disabled`]: this.itemDisabled, [`${go}-${this.size}`]: !!this.size, [`${go}-loading`]: this.loading }];
    }, wrapStyles() {
      let t = {};
      return this.trueColor && this.currentValue === this.trueValue ? (t["border-color"] = this.trueColor, t["background-color"] = this.trueColor) : this.falseColor && this.currentValue === this.falseValue && (t["border-color"] = this.falseColor, t["background-color"] = this.falseColor), t;
    }, innerClasses() {
      return `${go}-inner`;
    } }, methods: { handleToggle() {
      const t = this.currentValue === this.trueValue ? this.falseValue : this.trueValue;
      this.currentValue = t, this.$emit("update:modelValue", t), this.$emit("on-change", t), this.handleFormItemChange("change", t);
    }, toggle(t) {
      if (t.preventDefault(), this.itemDisabled || this.loading)
        return !1;
      if (!this.beforeChange)
        return this.handleToggle();
      const r = this.beforeChange();
      r && r.then ? r.then(() => {
        this.handleToggle();
      }) : this.handleToggle();
    } }, watch: { modelValue(t) {
      if (t !== this.trueValue && t !== this.falseValue && t !== null)
        throw "Value should be trueValue or falseValue.";
      this.currentValue = t;
    } } }, IV = ["name", "value"];
    function MV(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("span", { tabindex: "0", class: e.normalizeClass(a.wrapClasses), style: e.normalizeStyle(a.wrapStyles), onClick: r[0] || (r[0] = (...x) => a.toggle && a.toggle(...x)), onKeydown: r[1] || (r[1] = e.withKeys((...x) => a.toggle && a.toggle(...x), ["space"])) }, [e.createElementVNode("input", { type: "hidden", name: o.name, value: g.currentValue }, null, 8, IV), e.createElementVNode("span", { class: e.normalizeClass(a.innerClasses) }, [g.currentValue === o.trueValue ? e.renderSlot(t.$slots, "open", { key: 0 }) : e.createCommentVNode("", !0), g.currentValue === o.falseValue ? e.renderSlot(t.$slots, "close", { key: 1 }) : e.createCommentVNode("", !0)], 2)], 38);
    }
    var Nd = f($V, [["render", MV]]), AV = { name: "TableRenderHeader", props: { render: Function, column: Object, index: Number }, render() {
      const t = { column: this.column, index: this.index };
      return this.render(e.h, t);
    } }, Bd = { methods: { alignCls(t, r = {}) {
      let o = "";
      return r.cellClassName && t.key && r.cellClassName[t.key] && (o = r.cellClassName[t.key]), [`${this.prefixCls}-column-${t.__id}`, { [`${o}`]: o, [`${t.className}`]: t.className, [`${this.prefixCls}-column-${t.align}`]: t.align, [`${this.prefixCls}-hidden`]: this.fixed === "left" && t.fixed !== "left" || this.fixed === "right" && t.fixed !== "right" || !this.fixed && t.fixed && (t.fixed === "left" || t.fixed === "right") }];
    }, isPopperShow(t) {
      return t.filters && (!this.fixed && !t.fixed || this.fixed === "left" && t.fixed === "left" || this.fixed === "right" && t.fixed === "right");
    }, setCellWidth(t) {
      let r = "";
      return t.width ? r = t.width : this.columnsWidth[t._index] && (r = this.columnsWidth[t._index].width), r === "0" && (r = ""), r;
    } } };
    const FV = { name: "TableHead", mixins: [Bd, Kt], components: { CheckboxGroup: Uh, Checkbox: ro, Poptip: Ed, iButton: zn, renderHeader: AV }, props: { prefixCls: String, styleObject: Object, columns: Array, objData: Object, data: Array, columnsWidth: Object, fixed: { type: [Boolean, String], default: !1 }, columnRows: Array, fixedColumnRows: Array }, data() {
      return { draggingColumn: null, dragging: !1, dragState: {} };
    }, computed: { styles() {
      const t = Object.assign({}, this.styleObject), r = parseInt(this.styleObject.width);
      return t.width = `${r}px`, t;
    }, isSelectAll() {
      let t = !0;
      this.data.length || (t = !1);
      let r = !0;
      for (let o in this.objData) {
        const C = this.objData[o];
        if (!C._isChecked && !C._isDisabled) {
          t = !1;
          break;
        } else
          C.children && C.children.length && (t = this.isChildrenSelected(C, t));
        C._isDisabled && !C._isChecked ? C.children && C.children.length && (r = this.isChildrenAllDisabledAndUnSelected(C, r)) : r = !1;
      }
      return r && (t = !1), t;
    }, headRows() {
      return this.columnRows.length > 1 ? this.fixed ? this.fixedColumnRows : this.columnRows : [this.columns];
    }, isSelectDisabled() {
      let t = !0;
      if (this.data.length)
        for (let r in this.objData) {
          const o = this.objData[r];
          o._isDisabled ? o.children && o.children.length && (t = this.isChildrenDisabled(o, t)) : t = !1;
        }
      return t;
    } }, methods: { cellClasses(t) {
      return [`${this.prefixCls}-cell`, { [`${this.prefixCls}-hidden`]: !this.fixed && t.fixed && (t.fixed === "left" || t.fixed === "right"), [`${this.prefixCls}-cell-with-selection`]: t.type === "selection" }];
    }, scrollBarCellClass() {
      let t = !1;
      for (let r in this.headRows)
        for (let o in this.headRows[r]) {
          if (this.headRows[r][o].fixed === "right") {
            t = !0;
            break;
          }
          if (t)
            break;
        }
      return [{ [`${this.prefixCls}-hidden`]: t }];
    }, itemClasses(t, r) {
      return [`${this.prefixCls}-filter-select-item`, { [`${this.prefixCls}-filter-select-item-selected`]: t._filterChecked[0] === r.value }];
    }, itemAllClasses(t) {
      return [`${this.prefixCls}-filter-select-item`, { [`${this.prefixCls}-filter-select-item-selected`]: !t._filterChecked.length }];
    }, selectAll() {
      const t = !this.isSelectAll;
      this.$parent.selectAll(t);
    }, handleSort(t, r) {
      const o = this.columns.find((g) => g._index === t), C = o._index;
      o._sortType === r && (r = "normal"), this.$parent.handleSort(C, r);
    }, handleSortByHead(t) {
      const r = this.columns.find((o) => o._index === t);
      if (r.sortable) {
        const o = r._sortType;
        o === "normal" ? this.handleSort(t, "asc") : o === "asc" ? this.handleSort(t, "desc") : this.handleSort(t, "normal");
      }
    }, handleFilter(t) {
      this.$parent.handleFilter(t);
    }, handleSelect(t, r) {
      this.$parent.handleFilterSelect(t, r);
    }, handleReset(t) {
      this.$parent.handleFilterReset(t);
    }, handleFilterHide(t) {
      this.$parent.handleFilterHide(t);
    }, getColumn(t, r) {
      if (this.columnRows.length > 1) {
        const o = this.headRows[t][r].__id;
        return this.columns.filter((C) => C.__id === o)[0];
      } else
        return this.headRows[t][r];
    }, handleMouseDown(t, r) {
      if (!this.$isServer && h && this.draggingColumn) {
        this.dragging = !0;
        const o = this.$parent, C = o.$el.getBoundingClientRect().left, g = this.$el.querySelector(`th.ivu-table-column-${t.__id}`).getBoundingClientRect(), a = g.left - C + 30;
        o.showResizeLine = !0, this.dragState = { startMouseLeft: r.clientX, startLeft: g.right - C, startColumnLeft: g.left - C, tableLeft: C };
        const x = o.$refs.resizeLine;
        x.style.left = this.dragState.startLeft + "px", document.onselectstart = function() {
          return !1;
        }, document.ondragstart = function() {
          return !1;
        };
        const O = (N) => {
          const B = N.clientX - this.dragState.startMouseLeft, H = this.dragState.startLeft + B;
          x.style.left = Math.max(a, H) + "px";
        }, P = () => {
          if (this.dragging) {
            const { startColumnLeft: N, startLeft: B } = this.dragState, H = parseInt(x.style.left, 10) - N, oe = o.allColumns.find((se) => se.__id === t.__id);
            oe && (oe.width = H, t.width = H, o.handleResize()), o.$emit("on-column-width-resize", oe.width, B - N, t, r), h && (document.body.style.cursor = ""), this.dragging = !1, this.draggingColumn = null, this.dragState = {}, o.showResizeLine = !1;
          }
          !h || (document.removeEventListener("mousemove", O), document.removeEventListener("mouseup", P), document.onselectstart = null, document.ondragstart = null);
        };
        if (!h)
          return;
        document.addEventListener("mousemove", O), document.addEventListener("mouseup", P);
      }
    }, handleMouseMove(t, r) {
      let o = r.target;
      for (; o && o.tagName !== "TH"; )
        o = o.parentNode;
      if (!(!t || !t.resizable) && h && !this.dragging) {
        let C = o.getBoundingClientRect();
        const g = document.body.style;
        C.width > 12 && C.right - r.pageX < 8 ? (g.cursor = "col-resize", this.draggingColumn = t) : this.dragging || (g.cursor = "", this.draggingColumn = null);
      }
    }, handleMouseOut() {
      this.$isServer || h && (document.body.style.cursor = "");
    }, isChildrenSelected(t, r) {
      let o = r;
      return t.children && t.children.length && t.children.forEach((C) => {
        !C._isChecked && !C._isDisabled ? o = !1 : C.children && C.children.length && (o = this.isChildrenSelected(C, o));
      }), o;
    }, isChildrenAllDisabledAndUnSelected(t, r) {
      let o = r;
      return t.children && t.children.length && t.children.forEach((C) => {
        C._isDisabled && !C._isChecked ? C.children && C.children.length && (o = this.isChildrenAllDisabledAndUnSelected(C, o)) : o = !1;
      }), o;
    }, isChildrenDisabled(t, r) {
      let o = r;
      return t.children && t.children.length && t.children.forEach((C) => {
        C._isDisabled ? C.children && C.children.length && (o = this.isChildrenDisabled(C, o)) : o = !1;
      }), o;
    } } }, LV = ["width"], zV = ["width"], RV = ["colspan", "rowspan"], jV = { key: 0 }, HV = ["onClick"], UV = ["onClick"], WV = ["onClick"], YV = ["onMousedown", "onMousemove"], KV = ["rowspan"];
    function GV(t, r, o, C, g, a) {
      const x = e.resolveComponent("render-header"), O = e.resolveComponent("Checkbox"), P = e.resolveComponent("checkbox"), N = e.resolveComponent("checkbox-group"), B = e.resolveComponent("i-button"), H = e.resolveComponent("Poptip");
      return e.openBlock(), e.createElementBlock("table", { cellspacing: "0", cellpadding: "0", border: "0", style: e.normalizeStyle(a.styles) }, [e.createElementVNode("colgroup", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.columns, (oe, se) => (e.openBlock(), e.createElementBlock("col", { key: se, width: t.setCellWidth(oe) }, null, 8, LV))), 128)), t.$parent.showVerticalScrollBar ? (e.openBlock(), e.createElementBlock("col", { key: 0, width: t.$parent.scrollBarWidth }, null, 8, zV)) : e.createCommentVNode("", !0)]), e.createElementVNode("thead", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.headRows, (oe, se) => (e.openBlock(), e.createElementBlock("tr", { key: se }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(oe, (ee, j) => (e.openBlock(), e.createElementBlock("th", { key: j, colspan: ee.colSpan, rowspan: ee.rowSpan, class: e.normalizeClass(t.alignCls(ee)) }, [e.createElementVNode("div", { class: e.normalizeClass(a.cellClasses(ee)) }, [ee.type === "expand" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [ee.renderHeader ? (e.openBlock(), e.createBlock(x, { key: 1, render: ee.renderHeader, column: ee, index: j }, null, 8, ["render", "column", "index"])) : (e.openBlock(), e.createElementBlock("span", jV, e.toDisplayString(ee.title || ""), 1))], 64)) : ee.type === "selection" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [ee.hideSelectAll ? e.createCommentVNode("", !0) : (e.openBlock(), e.createBlock(O, { key: 0, "model-value": a.isSelectAll, disabled: a.isSelectDisabled, onOnChange: a.selectAll }, null, 8, ["model-value", "disabled", "onOnChange"]))], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 2 }, [ee.renderHeader ? (e.openBlock(), e.createBlock(x, { key: 1, render: ee.renderHeader, column: ee, index: j }, null, 8, ["render", "column", "index"])) : (e.openBlock(), e.createElementBlock("span", { key: 0, class: e.normalizeClass({ [o.prefixCls + "-cell-sort"]: ee.sortable }), onClick: (pe) => ee.sortable && a.handleSortByHead(a.getColumn(se, j)._index) }, e.toDisplayString(ee.title || "#"), 11, HV)), ee.sortable ? (e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass([o.prefixCls + "-sort"]) }, [e.createElementVNode("i", { class: e.normalizeClass(["ivu-icon ivu-icon-md-arrow-dropup", { on: a.getColumn(se, j)._sortType === "asc" }]), onClick: (pe) => a.handleSort(a.getColumn(se, j)._index, "asc") }, null, 10, UV), e.createElementVNode("i", { class: e.normalizeClass(["ivu-icon ivu-icon-md-arrow-dropdown", { on: a.getColumn(se, j)._sortType === "desc" }]), onClick: (pe) => a.handleSort(a.getColumn(se, j)._index, "desc") }, null, 10, WV)], 2)) : e.createCommentVNode("", !0), t.isPopperShow(ee) ? (e.openBlock(), e.createBlock(H, { key: 3, modelValue: a.getColumn(se, j)._filterVisible, "onUpdate:modelValue": (pe) => a.getColumn(se, j)._filterVisible = pe, placement: "bottom", "popper-class": "ivu-table-popper", transfer: "", capture: !1, onOnPopperHide: (pe) => a.handleFilterHide(a.getColumn(se, j)._index) }, e.createSlots({ default: e.withCtx(() => [e.createElementVNode("span", { class: e.normalizeClass([o.prefixCls + "-filter"]) }, [e.createElementVNode("i", { class: e.normalizeClass(["ivu-icon ivu-icon-ios-funnel", { on: a.getColumn(se, j)._isFiltered }]) }, null, 2)], 2)]), _: 2 }, [a.getColumn(se, j)._filterMultiple ? { name: "content", fn: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass([o.prefixCls + "-filter-list"]) }, [e.createElementVNode("div", { class: e.normalizeClass([o.prefixCls + "-filter-list-item"]) }, [e.createVNode(N, { modelValue: a.getColumn(se, j)._filterChecked, "onUpdate:modelValue": (pe) => a.getColumn(se, j)._filterChecked = pe }, { default: e.withCtx(() => [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(ee.filters, (pe, at) => (e.openBlock(), e.createBlock(P, { key: at, label: pe.value }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(pe.label), 1)]), _: 2 }, 1032, ["label"]))), 128))]), _: 2 }, 1032, ["modelValue", "onUpdate:modelValue"])], 2), e.createElementVNode("div", { class: e.normalizeClass([o.prefixCls + "-filter-footer"]) }, [e.createVNode(B, { type: "text", size: "small", disabled: !a.getColumn(se, j)._filterChecked.length, onClick: (pe) => a.handleFilter(a.getColumn(se, j)._index) }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(t.t("i.table.confirmFilter")), 1)]), _: 2 }, 1032, ["disabled", "onClick"]), e.createVNode(B, { type: "text", size: "small", onClick: (pe) => a.handleReset(a.getColumn(se, j)._index) }, { default: e.withCtx(() => [e.createTextVNode(e.toDisplayString(t.t("i.table.resetFilter")), 1)]), _: 2 }, 1032, ["onClick"])], 2)], 2)]), key: "0" } : { name: "content", fn: e.withCtx(() => [e.createElementVNode("div", { class: e.normalizeClass([o.prefixCls + "-filter-list"]) }, [e.createElementVNode("ul", { class: e.normalizeClass([o.prefixCls + "-filter-list-single"]) }, [e.createElementVNode("li", { class: e.normalizeClass(a.itemAllClasses(a.getColumn(se, j))), onClick: (pe) => a.handleReset(a.getColumn(se, j)._index) }, e.toDisplayString(t.t("i.table.clearFilter")), 11, ["onClick"]), (e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(ee.filters, (pe) => (e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.itemClasses(a.getColumn(se, j), pe)), key: pe.value, onClick: (at) => a.handleSelect(a.getColumn(se, j)._index, pe.value) }, e.toDisplayString(pe.label), 11, ["onClick"]))), 128))], 2)], 2)]), key: "1" }]), 1032, ["modelValue", "onUpdate:modelValue", "onOnPopperHide"])) : e.createCommentVNode("", !0)], 64))], 2), ee.resizable ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-table-header-resizable", onMousedown: (pe) => a.handleMouseDown(ee, pe), onMousemove: (pe) => a.handleMouseMove(ee, pe), onMouseout: r[0] || (r[0] = (...pe) => a.handleMouseOut && a.handleMouseOut(...pe)) }, null, 40, YV)) : e.createCommentVNode("", !0)], 10, RV))), 128)), t.$parent.showVerticalScrollBar && se === 0 ? (e.openBlock(), e.createElementBlock("th", { key: 0, class: e.normalizeClass(a.scrollBarCellClass()), rowspan: a.headRows.length }, null, 10, KV)) : e.createCommentVNode("", !0)]))), 128))])], 4);
    }
    var XV = f(FV, [["render", GV]]);
    const qV = { props: { row: Object, prefixCls: String, draggable: Boolean, isChildren: Boolean }, computed: { objData() {
      return this.$parent.objData;
    } }, methods: { onDrag(t, r) {
      t.dataTransfer.setData("index", r);
    }, onDrop(t, r) {
      const o = t.dataTransfer.getData("index");
      this.$parent.$parent.dragAndDrop(o, r), t.preventDefault();
    }, allowDrop(t) {
      t.preventDefault();
    }, rowClasses(t) {
      const r = this.isChildren ? this.$parent.$parent.getDataByRowKey(this.row._rowKey) : this.objData[t];
      return [`${this.prefixCls}-row`, this.rowClsName(t), { [`${this.prefixCls}-row-highlight`]: r && r._isHighlight, [`${this.prefixCls}-row-hover`]: r && r._isHover }];
    }, rowClsName(t) {
      return this.$parent.$parent.rowClassName(this.objData[t], t);
    } } }, JV = ["draggable"];
    function QV(t, r, o, C, g, a) {
      return o.draggable ? (e.openBlock(), e.createElementBlock("tr", { key: 0, class: e.normalizeClass(a.rowClasses(o.row._index)), draggable: o.draggable, onDragstart: r[0] || (r[0] = (x) => a.onDrag(x, o.row._index)), onDrop: r[1] || (r[1] = (x) => a.onDrop(x, o.row._index)), onDragover: r[2] || (r[2] = (x) => a.allowDrop(x)) }, [e.renderSlot(t.$slots, "default")], 42, JV)) : (e.openBlock(), e.createElementBlock("tr", { key: 1, class: e.normalizeClass(a.rowClasses(o.row._index)), draggable: !1 }, [e.renderSlot(t.$slots, "default")], 2));
    }
    var Pd = f(qV, [["render", QV]]), Vd = { name: "TableExpand", props: { row: Object, render: Function, index: Number, column: { type: Object, default: null } }, render() {
      const t = { row: this.row, index: this.index };
      return this.column && (t.column = this.column), this.render(e.h, t);
    } }, ZV = { name: "TableSlot", inject: ["TableInstance"], props: { row: Object, index: Number, column: { type: Object, default: null }, display: { type: String, default: "block" } }, render() {
      return e.h("div", { class: { "ivu-table-cell-slot": !0, "ivu-table-cell-slot-inline": this.display === "inline", "ivu-table-cell-slot-inline-block": this.display === "inline-block" } }, this.TableInstance.$slots[this.column.slot]({ row: this.row, column: this.column, index: this.index }));
    } };
    const e$ = { name: "TableCell", components: { Icon: G, Checkbox: ro, TableExpand: Vd, TableSlot: ZV, Tooltip: tr }, inject: ["TableInstance"], props: { prefixCls: String, row: Object, column: Object, naturalIndex: Number, index: Number, checked: Boolean, disabled: Boolean, expanded: Boolean, fixed: { type: [Boolean, String], default: !1 }, treeNode: Boolean, treeLevel: { type: Number, default: 0 } }, data() {
      return { renderType: "", uid: -1, context: this.$parent.$parent.$parent.currentContext, showTooltip: !1 };
    }, computed: { classes() {
      return [`${this.prefixCls}-cell`, { [`${this.prefixCls}-hidden`]: !this.fixed && this.column.fixed && (this.column.fixed === "left" || this.column.fixed === "right"), [`${this.prefixCls}-cell-ellipsis`]: this.column.ellipsis || !1, [`${this.prefixCls}-cell-with-expand`]: this.renderType === "expand", [`${this.prefixCls}-cell-with-selection`]: this.renderType === "selection" }];
    }, expandCls() {
      return [`${this.prefixCls}-cell-expand`, { [`${this.prefixCls}-cell-expand-expanded`]: this.expanded }];
    }, showChildren() {
      let t = !1;
      if (this.renderType === "html" || this.renderType === "normal" || this.renderType === "render" || this.renderType === "slot") {
        const r = this.row;
        (r.children && r.children.length || "_loading" in r) && this.column.tree && (t = !0);
      }
      return t;
    }, showTreeNode() {
      let t = !1;
      return (this.renderType === "html" || this.renderType === "normal" || this.renderType === "render" || this.renderType === "slot") && this.column.tree && this.treeNode && (t = !0), t;
    }, showLevel() {
      let t = !1;
      return (this.renderType === "html" || this.renderType === "normal" || this.renderType === "render" || this.renderType === "slot") && this.column.tree && this.treeNode && (t = !0), t;
    }, treeLevelStyle() {
      return { "padding-left": this.treeLevel * this.TableInstance.indentSize + "px" };
    }, childrenExpand() {
      return this.TableInstance.getDataByRowKey(this.row._rowKey)._isShowChildren;
    }, childrenLoading() {
      const t = this.TableInstance.getDataByRowKey(this.row._rowKey);
      return "_loading" in t && t._loading;
    } }, methods: { toggleSelect() {
      this.treeNode ? this.$parent.$parent.$parent.toggleSelect(this.index, this.row._rowKey) : this.$parent.$parent.$parent.toggleSelect(this.index);
    }, toggleExpand() {
      this.$parent.$parent.$parent.toggleExpand(this.index);
    }, handleClick() {
    }, handleTooltipIn() {
      if (!h)
        return;
      const t = this.$refs.content;
      let r = document.createRange();
      r.setStart(t, 0), r.setEnd(t, t.childNodes.length);
      const o = r.getBoundingClientRect().width;
      this.showTooltip = o > t.offsetWidth, r = null;
    }, handleToggleTree() {
      this.$parent.$parent.$parent.toggleTree(this.row._rowKey);
    } }, created() {
      this.column.type === "index" ? this.renderType = "index" : this.column.type === "selection" ? this.renderType = "selection" : this.column.type === "html" ? this.renderType = "html" : this.column.type === "expand" ? this.renderType = "expand" : this.column.render ? this.renderType = "render" : this.column.slot ? this.renderType = "slot" : this.renderType = "normal";
    } }, t$ = { key: 0 }, n$ = { key: 4, class: "ivu-table-cell-tree ivu-table-cell-tree-empty" }, i$ = ["innerHTML"], r$ = { key: 1 };
    function s$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Checkbox"), O = e.resolveComponent("Icon"), P = e.resolveComponent("Tooltip"), N = e.resolveComponent("table-expand"), B = e.resolveComponent("table-slot");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), ref: "cell" }, [g.renderType === "index" ? (e.openBlock(), e.createElementBlock("span", t$, e.toDisplayString(o.column.indexMethod ? o.column.indexMethod(o.row, o.naturalIndex) : o.naturalIndex + 1), 1)) : e.createCommentVNode("", !0), g.renderType === "selection" ? (e.openBlock(), e.createBlock(x, { key: 1, "model-value": o.checked, onClick: e.withModifiers(a.handleClick, ["stop"]), onOnChange: a.toggleSelect, disabled: o.disabled }, null, 8, ["model-value", "onClick", "onOnChange", "disabled"])) : e.createCommentVNode("", !0), a.showLevel ? (e.openBlock(), e.createElementBlock("div", { key: 2, class: "ivu-table-cell-tree-level", style: e.normalizeStyle(a.treeLevelStyle) }, null, 4)) : e.createCommentVNode("", !0), a.showChildren ? (e.openBlock(), e.createElementBlock("div", { key: 3, class: e.normalizeClass(["ivu-table-cell-tree", { "ivu-table-cell-tree-loading": a.childrenLoading }]), onClick: r[0] || (r[0] = e.withModifiers((...H) => a.handleToggleTree && a.handleToggleTree(...H), ["prevent", "stop"])) }, [a.childrenLoading ? (e.openBlock(), e.createBlock(O, { key: 0, type: "ios-loading", class: "ivu-load-loop" })) : a.childrenExpand ? (e.openBlock(), e.createBlock(O, { key: 2, type: "ios-remove" })) : (e.openBlock(), e.createBlock(O, { key: 1, type: "ios-add" }))], 2)) : a.showTreeNode ? (e.openBlock(), e.createElementBlock("div", n$)) : e.createCommentVNode("", !0), g.renderType === "html" ? (e.openBlock(), e.createElementBlock("span", { key: 5, innerHTML: o.row[o.column.key] }, null, 8, i$)) : e.createCommentVNode("", !0), g.renderType === "normal" ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 6 }, [o.column.tooltip ? (e.openBlock(), e.createBlock(P, { key: 0, transfer: "", content: o.row[o.column.key], theme: o.column.tooltipTheme ? o.column.tooltipTheme : a.TableInstance.tooltipTheme, disabled: !g.showTooltip, "max-width": o.column.tooltipMaxWidth ? o.column.tooltipMaxWidth : a.TableInstance.tooltipMaxWidth, class: "ivu-table-cell-tooltip" }, { default: e.withCtx(() => [e.createElementVNode("span", { ref: "content", onMouseenter: r[1] || (r[1] = (...H) => a.handleTooltipIn && a.handleTooltipIn(...H)), class: "ivu-table-cell-tooltip-content" }, e.toDisplayString(o.row[o.column.key]), 545)]), _: 1 }, 8, ["content", "theme", "disabled", "max-width"])) : (e.openBlock(), e.createElementBlock("span", r$, e.toDisplayString(o.row[o.column.key]), 1))], 64)) : e.createCommentVNode("", !0), g.renderType === "expand" && !o.row._disableExpand ? (e.openBlock(), e.createElementBlock("div", { key: 7, class: e.normalizeClass(a.expandCls), onClick: r[2] || (r[2] = (...H) => a.toggleExpand && a.toggleExpand(...H)) }, [e.createVNode(O, { type: "ios-arrow-forward" })], 2)) : e.createCommentVNode("", !0), g.renderType === "render" ? (e.openBlock(), e.createBlock(N, { key: 8, row: o.row, column: o.column, index: o.index, render: o.column.render }, null, 8, ["row", "column", "index", "render"])) : e.createCommentVNode("", !0), g.renderType === "slot" ? (e.openBlock(), e.createBlock(B, { key: 9, row: o.row, column: o.column, display: o.column.display || "block", index: o.index }, null, 8, ["row", "column", "display", "index"])) : e.createCommentVNode("", !0)], 2);
    }
    var $d = f(e$, [["render", s$]]);
    const o$ = { name: "TableBody", mixins: [Bd], components: { TableCell: $d, Expand: Vd, TableTr: Pd }, props: { prefixCls: String, styleObject: Object, columns: Array, data: Array, objData: Object, columnsWidth: Object, fixed: { type: [Boolean, String], default: !1 }, draggable: { type: Boolean, default: !1 }, rowKey: { type: [Boolean, String], default: !1 } }, computed: { expandRender() {
      let t = function() {
        return "";
      };
      for (let r = 0; r < this.columns.length; r++) {
        const o = this.columns[r];
        o.type && o.type === "expand" && o.render && (t = o.render);
      }
      return t;
    } }, methods: { rowChecked(t) {
      return this.objData[t] && this.objData[t]._isChecked;
    }, rowDisabled(t) {
      return this.objData[t] && this.objData[t]._isDisabled;
    }, rowExpanded(t) {
      return this.objData[t] && this.objData[t]._isExpanded;
    }, rowStatusByRowKey(t, r) {
      return this.$parent.getDataByRowKey(r)[t];
    }, handleMouseIn(t, r, o) {
      r.stopPropagation(), this.$parent.handleMouseIn(t, o);
    }, handleMouseOut(t, r, o) {
      r.stopPropagation(), this.$parent.handleMouseOut(t, o);
    }, clickCurrentRow(t, r, o) {
      this.$parent.clickCurrentRow(t, o);
    }, dblclickCurrentRow(t, r, o) {
      r.stopPropagation(), this.$parent.dblclickCurrentRow(t, o);
    }, clickCell(t, r, o, C) {
      this.$parent.$emit("on-cell-click", t, r, t[o], C);
    }, contextmenuCurrentRow(t, r, o) {
      r.stopPropagation(), this.$parent.contextMenu && r.preventDefault(), this.$parent.contextmenuCurrentRow(t, o, r);
    }, selectStartCurrentRow() {
      this.$parent.contextMenu;
    }, getSpan(t, r, o, C) {
      const g = this.$parent.spanMethod;
      if (typeof g == "function") {
        const a = g({ row: t, column: r, rowIndex: o, columnIndex: C });
        let x = 1, O = 1;
        return Array.isArray(a) ? (x = a[0], O = a[1]) : typeof a == "object" && (x = a.rowspan, O = a.colspan), { rowspan: x, colspan: O };
      } else
        return {};
    }, showWithSpan(t, r, o, C) {
      const g = this.getSpan(t, r, o, C);
      return !("rowspan" in g && g.rowspan === 0 || "colspan" in g && g.colspan === 0);
    }, isTrShow(t) {
      let r = !0, o;
      for (let C in this.objData) {
        const g = this.objData[C], a = g._isShowChildren;
        if (g._rowKey === t) {
          r = r && a;
          break;
        } else if (g.children && g.children.length && (o = this.getTrStatus(t, g, r && a), o[0] && o[0]._rowKey === t))
          return o[1];
      }
      return r;
    }, getTrStatus(t, r, o) {
      let C = o, g;
      if (r.children && r.children.length)
        for (let a = 0; a < r.children.length; a++) {
          const x = r.children[a], O = x._isShowChildren;
          if (x._rowKey === t) {
            g = x, C = C && O;
            break;
          } else if (x.children && x.children.length) {
            const P = this.getTrStatus(t, x, C && O);
            if (P[0] && P[0]._rowKey === t)
              return P;
          }
        }
      return [g, C];
    }, getLevel(t) {
      let r, o;
      for (let C = 0; C < this.data.length; C++) {
        const g = this.data[C];
        if (g[this.rowKey] === t) {
          r = 0;
          break;
        } else if (g.children && g.children.length && (o = this.getChildLevel(g, t, 1), o[0] && o[0][this.rowKey] === t))
          return o[1];
      }
      return r;
    }, getChildLevel(t, r, o) {
      let C, g;
      if (t.children && t.children.length)
        for (let a = 0; a < t.children.length; a++) {
          const x = t.children[a];
          if (x[this.rowKey] === r) {
            g = x, C = o;
            break;
          } else if (x.children && x.children.length) {
            const O = this.getChildLevel(x, r, o + 1);
            if (O[0] && O[0][this.rowKey] === r)
              return O;
          }
        }
      return [g, C];
    }, getChildNode(t, r, o) {
      return r.children && r.children.length && r.children.forEach((C, g) => {
        let a = [];
        this.columns.forEach((P, N) => {
          if (this.showWithSpan(C, P, g, N)) {
            const B = t($d, { fixed: this.fixed, "prefix-cls": this.prefixCls, row: C, column: P, "natural-index": g, index: C._index, checked: this.rowStatusByRowKey("_isChecked", C._rowKey), disabled: this.rowStatusByRowKey("_isDisabled", C._rowKey), expanded: this.rowStatusByRowKey("_isExpanded", C._rowKey), treeNode: !0, treeLevel: this.getLevel(C._rowKey), key: P._columnKey }), H = t("td", v(p({ class: this.alignCls(P, C) }, this.getSpan(C, P, g, N)), { onClick: (oe) => this.clickCell(C, P, P.key, oe) }), [B]);
            a.push(H);
          }
        });
        const x = {};
        this.isTrShow(r._rowKey) || (x.display = "none");
        const O = t(Pd, { draggable: !1, row: C, "prefix-cls": this.prefixCls, isChildren: !0, style: x, key: this.rowKey ? C._rowKey : g, onMouseenter: (P) => this.handleMouseIn(C._index, P, C._rowKey), onMouseleave: (P) => this.handleMouseOut(C._index, P, C._rowKey), onClick: (P) => this.clickCurrentRow(C._index, P, C._rowKey), onDblclick: (P) => this.dblclickCurrentRow(C._index, P, C._rowKey), onContextmenu: (P) => this.contextmenuCurrentRow(C._index, P, C._rowKey), onSelectstart: (P) => this.selectStartCurrentRow(C._index, P, C._rowKey) }, () => a);
        o.push(O), C.children && C.children.length && this.getChildNode(t, C, o);
      }), o;
    } }, render() {
      let t = [];
      this.columns.forEach((g) => {
        const a = e.h("col", { width: this.setCellWidth(g) });
        t.push(a);
      });
      const r = e.h("colgroup", {}, t);
      let o = [];
      this.data.forEach((g, a) => {
        let x = [];
        this.columns.forEach((P, N) => {
          if (this.showWithSpan(g, P, a, N)) {
            const B = e.h($d, { fixed: this.fixed, "prefix-cls": this.prefixCls, row: g, column: P, "natural-index": a, index: g._index, checked: this.rowChecked(g._index), disabled: this.rowDisabled(g._index), expanded: this.rowExpanded(g._index), key: P._columnKey }), H = e.h("td", v(p({ class: this.alignCls(P, g) }, this.getSpan(g, P, a, N)), { onClick: (oe) => this.clickCell(g, P, P.key, oe) }), [B]);
            x.push(H);
          }
        });
        const O = e.h(Pd, { draggable: this.draggable, row: g, "prefix-cls": this.prefixCls, key: this.rowKey ? g._rowKey : a, onMouseenter: (P) => this.handleMouseIn(g._index, P), onMouseleave: (P) => this.handleMouseOut(g._index, P), onClick: (P) => this.clickCurrentRow(g._index, P), onDblclick: (P) => this.dblclickCurrentRow(g._index, P), onContextmenu: (P) => this.contextmenuCurrentRow(g._index, P), onSelectstart: (P) => this.selectStartCurrentRow(g._index, P) }, () => x);
        if (o.push(O), this.rowExpanded(g._index)) {
          const P = e.h(Vd, { row: g, render: this.expandRender, index: g._index, key: this.rowKey ? g._rowKey : a }), N = e.h("td", { colspan: this.columns.length, class: this.prefixCls + "-expanded-cell" }, [P]), B = e.h("tr", { class: { [this.prefixCls + "-expanded-hidden"]: this.fixed } }, [N]);
          o.push(B);
        }
        g.children && g.children.length && this.getChildNode(e.h, g, []).forEach((P) => {
          o.push(P);
        });
      });
      const C = e.h("tbody", { class: this.prefixCls + "-tbody" }, [o]);
      return e.h("table", { cellspacing: "0", cellpadding: "0", border: "0", style: this.styleObject }, [r, C]);
    } }, a$ = { name: "TableSummary", mixins: [Bd], props: { prefixCls: String, styleObject: Object, columns: Array, data: Object, columnsWidth: Object, fixed: { type: [Boolean, String], default: !1 } }, methods: { cellCls(t) {
      return [{ "ivu-table-hidden": this.fixed === "left" && t.fixed !== "left" || this.fixed === "right" && t.fixed !== "right" || !this.fixed && t.fixed && (t.fixed === "left" || t.fixed === "right") }];
    } } }, l$ = { style: { overflow: "hidden" } }, c$ = ["width"], u$ = { class: "ivu-table-row" };
    function h$(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("div", l$, [e.createElementVNode("table", { class: "ivu-table-summary", cellspacing: "0", cellpadding: "0", border: "0", style: e.normalizeStyle(o.styleObject) }, [e.createElementVNode("colgroup", null, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.columns, (x, O) => (e.openBlock(), e.createElementBlock("col", { key: O, width: t.setCellWidth(x) }, null, 8, c$))), 128))]), e.createElementVNode("tbody", { class: e.normalizeClass([o.prefixCls + "-tbody"]) }, [e.createElementVNode("tr", u$, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.columns, (x, O) => (e.openBlock(), e.createElementBlock("td", { key: O, class: e.normalizeClass(t.alignCls(x)) }, [e.createElementVNode("div", { class: e.normalizeClass(["ivu-table-cell", a.cellCls(x)]) }, [e.createElementVNode("span", null, e.toDisplayString(o.data[x.key].value), 1)], 2)], 2))), 128))])], 2)], 4)]);
    }
    var d$ = f(a$, [["render", h$]]);
    const f$ = `\r
`, Id = (t, r, { separator: o, quoted: C }) => {
      const g = r.map((a) => C ? (a = typeof a == "string" ? a.replace(/"/g, '"') : a, `"${a}"`) : a);
      t.push(g.join(o));
    }, p$ = { separator: ",", quoted: !1 };
    function m$(t, r, o, C = !1) {
      o = Object.assign({}, p$, o);
      let g;
      const a = [], x = [];
      return t ? (g = t.map((O) => typeof O == "string" ? O : (C || x.push(typeof O.title < "u" ? O.title : O.key), O.key)), x.length > 0 && Id(a, x, o)) : (g = [], r.forEach((O) => {
        Array.isArray(O) || (g = g.concat(Object.keys(O)));
      }), g.length > 0 && (g = g.filter((O, P, N) => N.indexOf(O) === P), C || Id(a, g, o))), Array.isArray(r) && r.forEach((O) => {
        Array.isArray(O) || (O = g.map((P) => typeof O[P] < "u" ? O[P] : "")), Id(a, O, o);
      }), a.join(f$);
    }
    function Md(t) {
      const r = navigator.userAgent;
      return t === "ie" ? r.indexOf("compatible") > -1 && r.indexOf("MSIE") > -1 ? (new RegExp("MSIE (\\d+\\.\\d+);").test(r), parseFloat(RegExp.$1)) : !1 : r.indexOf(t) > -1;
    }
    const g$ = { _isIE11() {
      let t = 0;
      const r = /MSIE (\d+\.\d+);/.test(navigator.userAgent), o = !!navigator.userAgent.match(/Trident\/7.0/), C = navigator.userAgent.indexOf("rv:11.0");
      return r && (t = Number(RegExp.$1)), navigator.appVersion.indexOf("MSIE 10") !== -1 && (t = 10), o && C !== -1 && (t = 11), t === 11;
    }, _isEdge() {
      return /Edge/.test(navigator.userAgent);
    }, _getDownloadUrl(t) {
      const r = "\uFEFF";
      if (h && window.Blob && window.URL && window.URL.createObjectURL) {
        const o = new Blob([r + t], { type: "text/csv" });
        return URL.createObjectURL(o);
      } else
        return "data:attachment/csv;charset=utf-8," + r + encodeURIComponent(t);
    }, download(t, r) {
      if (h)
        if (Md("ie") && Md("ie") < 10) {
          const o = window.top.open("about:blank", "_blank");
          o.document.charset = "utf-8", o.document.write(r), o.document.close(), o.document.execCommand("SaveAs", t), o.close();
        } else if (Md("ie") === 10 || this._isIE11() || this._isEdge()) {
          const o = "\uFEFF", C = new Blob([o + r], { type: "text/csv" });
          navigator.msSaveBlob(C, t);
        } else {
          const o = document.createElement("a");
          o.download = t, o.href = this._getDownloadUrl(r), document.body.appendChild(o), o.click(), document.body.removeChild(o);
        }
    } }, Vc = (t, r) => {
      let o = [], C = [];
      return t.forEach((g) => {
        g.fixed && g.fixed === r ? o.push(g) : C.push(g);
      }), o.concat(C);
    }, Ta = (t, r = !1) => {
      const o = W(t), C = [];
      return o.forEach((g) => {
        g.children ? (r && C.push(g), C.push.apply(C, Ta(g.children, r))) : C.push(g);
      }), C;
    }, v$ = (t, r = !1) => {
      const o = W(r ? r === "left" ? Vc(t, "left") : Vc(t, "right") : t);
      let C = 1;
      const g = (x, O) => {
        if (O && (x.level = O.level + 1, C < x.level && (C = x.level)), x.children) {
          let P = 0;
          x.children.forEach((N) => {
            g(N, x), P += N.colSpan;
          }), x.colSpan = P;
        } else
          x.colSpan = 1;
      };
      o.forEach((x) => {
        x.level = 1, g(x);
      });
      const a = [];
      for (let x = 0; x < C; x++)
        a.push([]);
      return Ta(o, !0).forEach((x) => {
        x.children ? x.rowSpan = 1 : x.rowSpan = C - x.level + 1, a[x.level - 1].push(x);
      }), a;
    }, y$ = function(t = 32) {
      const r = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890", o = r.length;
      let C = "";
      for (let g = 0; g < t; g++)
        C += r.charAt(Math.floor(Math.random() * o));
      return C;
    }, En = "ivu-table";
    let Xv = 1, b$ = 1;
    const C$ = { name: "Table", mixins: [Kt], components: { tableHead: XV, tableBody: o$, tableSummary: d$, Spin: ni, Dropdown: ys, DropdownMenu: bs }, emits: ["on-current-change", "on-row-click", "on-row-dblclick", "on-contextmenu", "on-select", "on-select-cancel", "on-selection-change", "on-expand", "on-expand-tree", "on-select-all", "on-select-all-cancel", "on-sort-change", "on-filter-change", "on-drag-drop", "on-cell-click", "on-column-width-resize"], provide() {
      return { TableInstance: this };
    }, inject: { TabsInstance: { default: null }, ModalInstance: { default: null }, DrawerInstance: { default: null } }, props: { data: { type: Array, default() {
      return [];
    } }, columns: { type: Array, default() {
      return [];
    } }, size: { validator(t) {
      return z(t, ["small", "large", "default"]);
    }, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.size === "" ? "default" : t.$VIEWUI.size;
    } }, width: { type: [Number, String] }, height: { type: [Number, String] }, maxHeight: { type: [Number, String] }, stripe: { type: Boolean, default: !1 }, border: { type: Boolean, default: !1 }, showHeader: { type: Boolean, default: !0 }, highlightRow: { type: Boolean, default: !1 }, rowClassName: { type: Function, default() {
      return "";
    } }, context: { type: Object }, noDataText: { type: String }, noFilteredDataText: { type: String }, disabledHover: { type: Boolean }, loading: { type: Boolean, default: !1 }, draggable: { type: Boolean, default: !1 }, tooltipTheme: { validator(t) {
      return z(t, ["dark", "light"]);
    }, default: "dark" }, tooltipMaxWidth: { type: Number, default: 300 }, rowKey: { type: [Boolean, String], default: !1 }, spanMethod: { type: Function }, showSummary: { type: Boolean, default: !1 }, summaryMethod: { type: Function }, sumText: { type: String }, indentSize: { type: Number, default: 16 }, loadData: { type: Function }, updateShowChildren: { type: Boolean, default: !1 }, contextMenu: { type: Boolean, default: !1 }, showContextMenu: { type: Boolean, default: !1 }, fixedShadow: { validator(t) {
      return z(t, ["auto", "show", "hide"]);
    }, default: "show" }, autoCloseContextmenu: { type: Boolean, default: !0 } }, data() {
      const t = this.makeColumnsId(this.columns);
      return { ready: !1, tableWidth: 0, columnsWidth: {}, prefixCls: En, compiledUids: [], objData: this.makeObjData(), rebuildData: [], cloneColumns: this.makeColumns(t), columnRows: this.makeColumnRows(!1, t), leftFixedColumnRows: this.makeColumnRows("left", t), rightFixedColumnRows: this.makeColumnRows("right", t), allColumns: Ta(t), showSlotHeader: !0, showSlotFooter: !0, bodyHeight: 0, scrollBarWidth: he(), currentContext: this.context, cloneData: W(this.data), showVerticalScrollBar: !1, showHorizontalScrollBar: !1, headerWidth: 0, headerHeight: 0, showResizeLine: !1, contextMenuVisible: !1, contextMenuStyles: { top: 0, left: 0 }, scrollOnTheLeft: !1, scrollOnTheRight: !1, id: be(6) };
    }, computed: { localeNoDataText() {
      return this.noDataText === void 0 ? this.t("i.table.noDataText") : this.noDataText;
    }, localeNoFilteredDataText() {
      return this.noFilteredDataText === void 0 ? this.t("i.table.noFilteredDataText") : this.noFilteredDataText;
    }, localeSumText() {
      return this.sumText === void 0 ? this.t("i.table.sumText") : this.sumText;
    }, wrapClasses() {
      return [`${En}-wrapper`, { [`${En}-hide`]: !this.ready, [`${En}-with-header`]: this.showSlotHeader, [`${En}-with-footer`]: this.showSlotFooter, [`${En}-with-summary`]: this.showSummary, [`${En}-wrapper-with-border`]: this.border }];
    }, classes() {
      return [`${En}`, { [`${En}-${this.size}`]: !!this.size, [`${En}-border`]: this.border, [`${En}-stripe`]: this.stripe, [`${En}-with-fixed-top`]: !!this.height }];
    }, fixedTableClasses() {
      return [`${En}-fixed`, { [`${En}-fixed-shadow`]: this.fixedShadow === "show" || this.fixedShadow === "auto" && !this.scrollOnTheLeft }];
    }, fixedRightTableClasses() {
      return [`${En}-fixed-right`, { [`${En}-fixed-shadow`]: this.fixedShadow === "show" || this.fixedShadow === "auto" && !this.scrollOnTheRight }];
    }, fixedHeaderClasses() {
      return [`${En}-fixed-header`, { [`${En}-fixed-header-with-empty`]: !this.rebuildData.length }];
    }, styles() {
      let t = {}, r = 0;
      if (this.showSummary && (this.size === "small" ? r = 40 : this.size === "large" ? r = 60 : r = 48), this.height) {
        let o = parseInt(this.height) + r;
        t.height = `${o}px`;
      }
      if (this.maxHeight) {
        const o = parseInt(this.maxHeight) + r;
        t.maxHeight = `${o}px`;
      }
      return this.width && (t.width = `${this.width}px`), t;
    }, tableStyle() {
      let t = {};
      if (this.tableWidth !== 0) {
        let r = "";
        this.bodyHeight === 0 ? r = this.tableWidth : r = this.tableWidth - (this.showVerticalScrollBar ? this.scrollBarWidth : 0), t.width = `${r}px`;
      }
      return t;
    }, tableHeaderStyle() {
      let t = {};
      if (this.tableWidth !== 0) {
        let r = "";
        r = this.tableWidth, t.width = `${r}px`;
      }
      return t;
    }, fixedTableStyle() {
      let t = {}, r = 0;
      return this.leftFixedColumns.forEach((o) => {
        o.fixed && o.fixed === "left" && (r += o._width);
      }), t.width = `${r}px`, t;
    }, fixedRightTableStyle() {
      let t = {}, r = 0;
      return this.rightFixedColumns.forEach((o) => {
        o.fixed && o.fixed === "right" && (r += o._width);
      }), t.width = `${r}px`, t.right = `${this.showVerticalScrollBar ? this.scrollBarWidth : 0}px`, t;
    }, fixedRightHeaderStyle() {
      let t = {}, r = 0, o = this.headerHeight + 1;
      return this.showVerticalScrollBar && (r = this.scrollBarWidth), t.width = `${r}px`, t.height = `${o}px`, t;
    }, bodyStyle() {
      let t = {};
      if (this.bodyHeight !== 0) {
        const r = this.bodyHeight;
        this.height ? t.height = `${r}px` : this.maxHeight && (t.maxHeight = `${r}px`);
      }
      return t;
    }, fixedBodyStyle() {
      let t = {};
      if (this.bodyHeight !== 0) {
        let r = this.bodyHeight - (this.showHorizontalScrollBar ? this.scrollBarWidth : 0);
        const o = this.showHorizontalScrollBar ? `${r}px` : `${r - 1}px`;
        this.height ? t.height = o : this.maxHeight && (t.maxHeight = o);
      }
      return t;
    }, leftFixedColumns() {
      return Vc(this.cloneColumns, "left");
    }, rightFixedColumns() {
      return Vc(this.cloneColumns, "right");
    }, isLeftFixed() {
      return this.columns.some((t) => t.fixed && t.fixed === "left");
    }, isRightFixed() {
      return this.columns.some((t) => t.fixed && t.fixed === "right");
    }, summaryData() {
      if (!this.showSummary)
        return {};
      let t = {};
      return this.summaryMethod ? t = this.summaryMethod({ columns: this.cloneColumns, data: this.rebuildData }) : this.cloneColumns.forEach((r, o) => {
        const C = r.key;
        if (o === 0) {
          t[C] = { key: r.key, value: this.localeSumText };
          return;
        }
        const g = this.rebuildData.map((P) => Number(P[r.key])), a = [];
        let x = !0;
        g.forEach((P) => {
          if (!isNaN(P)) {
            x = !1;
            let N = ("" + P).split(".")[1];
            a.push(N ? N.length : 0);
          }
        });
        const O = Math.max.apply(null, a);
        if (x)
          t[C] = { key: r.key, value: "" };
        else {
          const P = g.reduce((N, B) => {
            const H = Number(B);
            return isNaN(H) ? N : parseFloat((N + B).toFixed(Math.min(O, 20)));
          }, 0);
          t[C] = { key: r.key, value: P };
        }
      }), t;
    } }, methods: { rowClsName(t) {
      return this.rowClassName(this.data[t], t);
    }, handleResize() {
      let t = this.$el.offsetWidth - 1, r = {}, o = 0, C = [], g = [], a = [];
      this.cloneColumns.forEach((B) => {
        B.width ? C.push(B) : (g.push(B), B.minWidth && (o += B.minWidth), B.maxWidth || a.push(B)), B._width = null;
      });
      let x = C.map((B) => B.width).reduce((B, H) => B + H, 0), O = t - x - o - (this.showVerticalScrollBar ? this.scrollBarWidth : 0) - 1, P = g.length, N = 0;
      O > 0 && P > 0 && (N = parseInt(O / P));
      for (let B = 0; B < this.cloneColumns.length; B++) {
        const H = this.cloneColumns[B];
        let oe = N + (H.minWidth ? H.minWidth : 0);
        H.width ? oe = H.width : H._width ? oe = H._width : (H.minWidth > oe ? oe = H.minWidth : H.maxWidth < oe && (oe = H.maxWidth), O > 0 ? (O -= oe - (H.minWidth ? H.minWidth : 0), P--, P > 0 ? N = parseInt(O / P) : N = 0) : N = 0), H._width = oe, r[H._index] = { width: oe };
      }
      if (O > 0) {
        P = a.length, N = parseInt(O / P);
        for (let B = 0; B < a.length; B++) {
          const H = a[B];
          let oe = H._width + N;
          P > 1 ? (P--, O -= N, N = parseInt(O / P)) : N = 0, H._width = oe, r[H._index] = { width: oe };
        }
      }
      this.tableWidth = this.cloneColumns.map((B) => B._width).reduce((B, H) => B + H, 0) + (this.showVerticalScrollBar ? this.scrollBarWidth : 0) + 1, this.columnsWidth = r, this.fixedHeader(), this.fixedShadow === "auto" && e.nextTick(() => {
        const B = this.$refs.body;
        this.scrollOnTheLeft = B.scrollLeft === 0, this.scrollOnTheRight = B.scrollWidth === B.scrollLeft + B.clientWidth;
      });
    }, handleMouseIn(t, r) {
      if (this.disabledHover)
        return;
      const o = r ? this.getDataByRowKey(r) : this.objData[t];
      o._isHover || (o._isHover = !0);
    }, handleMouseOut(t, r) {
      if (this.disabledHover)
        return;
      const o = r ? this.getDataByRowKey(r) : this.objData[t];
      o._isHover = !1;
    }, handleCurrentRow(t, r, o) {
      const C = o ? this.getDataByRowKey(o) : this.objData[r];
      let g = null, a = -1;
      for (let O in this.objData)
        if (this.objData[O]._isHighlight) {
          a = parseInt(O), this.objData[O]._isHighlight = !1;
          break;
        } else if (this.objData[O].children && this.objData[O].children.length) {
          const P = this.handleResetChildrenRow(this.objData[O]);
          P && (g = JSON.parse(JSON.stringify(P)));
        }
      t === "highlight" && (C._isHighlight = !0), a >= 0 && (g = JSON.parse(JSON.stringify(this.cloneData[a])));
      const x = t === "highlight" ? JSON.parse(JSON.stringify(o ? this.getBaseDataByRowKey(o) : this.cloneData[r])) : null;
      this.$emit("on-current-change", x, g);
    }, handleResetChildrenRow(t) {
      let r = null;
      if (t.children && t.children.length)
        for (let o = 0; o < t.children.length; o++) {
          const C = t.children[o];
          if (C._isHighlight) {
            C._isHighlight = !1, r = C;
            break;
          } else
            C.children && C.children.length && (r = this.handleResetChildrenRow(C));
        }
      return r;
    }, highlightCurrentRow(t, r) {
      const o = r ? this.getDataByRowKey(r) : this.objData[t];
      !this.highlightRow || o._isHighlight || this.handleCurrentRow("highlight", t, r);
    }, clearCurrentRow() {
      !this.highlightRow || this.handleCurrentRow("clear");
    }, clickCurrentRow(t, r) {
      this.highlightCurrentRow(t, r), r ? this.$emit("on-row-click", JSON.parse(JSON.stringify(this.getBaseDataByRowKey(r)))) : this.$emit("on-row-click", JSON.parse(JSON.stringify(this.cloneData[t])), t);
    }, dblclickCurrentRow(t, r) {
      this.highlightCurrentRow(t, r), r ? this.$emit("on-row-dblclick", JSON.parse(JSON.stringify(this.getBaseDataByRowKey(r)))) : this.$emit("on-row-dblclick", JSON.parse(JSON.stringify(this.cloneData[t])), t);
    }, contextmenuCurrentRow(t, r, o) {
      this.contextMenuVisible && this.handleClickContextMenuOutside(), e.nextTick(() => {
        const C = this.$refs.tableWrap.getBoundingClientRect(), g = { left: `${o.clientX - C.left}px`, top: `${o.clientY - C.top}px` };
        this.contextMenuStyles = g, this.contextMenuVisible = !0, r ? this.$emit("on-contextmenu", JSON.parse(JSON.stringify(this.getBaseDataByRowKey(r))), o, g) : this.$emit("on-contextmenu", JSON.parse(JSON.stringify(this.cloneData[t])), o, g);
      });
    }, getSelection() {
      let t = [], r = [];
      for (let C in this.objData) {
        const g = this.objData[C];
        g._isChecked && t.push(parseInt(C)), g.children && g.children.length && (r = r.concat(this.getSelectionChildrenRowKeys(g, r)));
      }
      r = [...new Set(r)];
      let o = [];
      return this.data.forEach((C, g) => {
        t.indexOf(g) > -1 && (o = o.concat(C)), C.children && C.children.length && r.length && (o = o.concat(this.getSelectionChildren(C, o, r)));
      }), o = [...new Set(o)], JSON.parse(JSON.stringify(o));
    }, getSelectionChildrenRowKeys(t, r) {
      return t.children && t.children.length && t.children.forEach((o) => {
        o._isChecked && r.push(o._rowKey), o.children && o.children.length && (r = r.concat(this.getSelectionChildrenRowKeys(o, r)));
      }), r;
    }, getSelectionChildren(t, r, o) {
      return t.children && t.children.length && t.children.forEach((C) => {
        o.indexOf(C[this.rowKey]) > -1 && (r = r.concat(C)), C.children && C.children.length && (r = r.concat(this.getSelectionChildren(C, r, o)));
      }), r;
    }, toggleSelect(t, r) {
      let o = {};
      if (r)
        o = this.getDataByRowKey(r);
      else
        for (let x in this.objData)
          if (parseInt(x) === t) {
            o = this.objData[x];
            break;
          }
      const C = !o._isChecked;
      o._isChecked = C;
      const g = this.getSelection(), a = r ? this.getBaseDataByRowKey(r, this.data) : this.data[t];
      this.$emit(C ? "on-select" : "on-select-cancel", g, JSON.parse(JSON.stringify(a))), this.$emit("on-selection-change", g);
    }, toggleExpand(t) {
      let r = {};
      for (let C in this.objData)
        if (parseInt(C) === t) {
          r = this.objData[C];
          break;
        }
      const o = !r._isExpanded;
      this.objData[t]._isExpanded = o, this.$emit("on-expand", JSON.parse(JSON.stringify(this.cloneData[t])), o), (this.height || this.maxHeight) && e.nextTick(() => this.fixedBody());
    }, toggleTree(t) {
      const r = this.getDataByRowKey(t);
      if (!("_loading" in r && r._loading)) {
        if ("_loading" in r && !r._loading && r.children.length === 0) {
          const o = this.getBaseDataByRowKey(t, this.data);
          o._loading = !0, this.loadData(o, (C) => {
            o._loading = !1, C.length && (o.children = C, e.nextTick(() => {
              const g = this.getDataByRowKey(t);
              g._isShowChildren = !g._isShowChildren, this.updateDataStatus(t, "_showChildren", g._isShowChildren);
            }));
          });
          return;
        }
        r._isShowChildren = !r._isShowChildren, this.updateShowChildren && this.updateDataStatus(t, "_showChildren", r._isShowChildren), this.$emit("on-expand-tree", t, r._isShowChildren);
      }
    }, updateDataStatus(t, r, o) {
      const C = this.getBaseDataByRowKey(t, this.data);
      C[r] = o;
    }, getDataByRowKey(t, r = this.objData) {
      let o = null;
      for (let C in r) {
        const g = r[C];
        if (g._rowKey === t) {
          o = g;
          break;
        } else if (g.children && g.children.length && (o = this.getChildrenByRowKey(t, g), o))
          break;
      }
      return o;
    }, getChildrenByRowKey(t, r) {
      let o = null;
      if (r.children && r.children.length)
        for (let C = 0; C < r.children.length; C++) {
          const g = r.children[C];
          if (g._rowKey === t) {
            o = g;
            break;
          } else if (g.children && g.children.length && (o = this.getChildrenByRowKey(t, g), o))
            break;
        }
      return o;
    }, getBaseDataByRowKey(t, r = this.cloneData) {
      let o = null;
      for (let C = 0; C < r.length; C++) {
        const g = r[C];
        if (g[this.rowKey] === t) {
          o = g;
          break;
        } else if (g.children && g.children.length && (o = this.getChildrenDataByRowKey(t, g), o && o[this.rowKey] === t))
          return o;
      }
      return o;
    }, getChildrenDataByRowKey(t, r) {
      let o = null;
      if (r.children && r.children.length)
        for (let C = 0; C < r.children.length; C++) {
          const g = r.children[C];
          if (g[this.rowKey] === t) {
            o = g;
            break;
          } else if (g.children && g.children.length && (o = this.getChildrenDataByRowKey(t, g), o))
            break;
        }
      return o;
    }, selectAll(t) {
      for (const o of this.rebuildData) {
        const C = this.objData[o._index];
        C._isDisabled || (C._isChecked = t), o.children && o.children.length && this.selectAllChildren(C, t);
      }
      const r = this.getSelection();
      t ? this.$emit("on-select-all", r) : this.$emit("on-select-all-cancel", r), this.$emit("on-selection-change", r);
    }, selectAllChildren(t, r) {
      t.children && t.children.length && t.children.map((o) => {
        o._isDisabled || (o._isChecked = r), o.children && o.children.length && this.selectAllChildren(o, r);
      });
    }, fixedHeader() {
      this.height || this.maxHeight ? e.nextTick(() => {
        const t = parseInt(Be(this.$refs.title, "height")) || 0, r = parseInt(Be(this.$refs.header, "height")) || 0, o = parseInt(Be(this.$refs.footer, "height")) || 0;
        this.height ? this.bodyHeight = this.height - t - r - o : this.maxHeight && (this.bodyHeight = this.maxHeight - t - r - o), e.nextTick(() => this.fixedBody());
      }) : (this.bodyHeight = 0, e.nextTick(() => this.fixedBody()));
    }, fixedBody() {
      if (this.$refs.header && (this.headerWidth = this.$refs.header.children[0].offsetWidth, this.headerHeight = this.$refs.header.children[0].offsetHeight), !this.$refs.tbody || !this.data || this.data.length === 0)
        this.showVerticalScrollBar = !1;
      else {
        let t = this.$refs.tbody.$el, r = t.parentElement, o = t.offsetHeight, C = r.offsetHeight;
        this.showHorizontalScrollBar = r.offsetWidth < t.offsetWidth + (this.showVerticalScrollBar ? this.scrollBarWidth : 0), this.showVerticalScrollBar = this.bodyHeight ? C - (this.showHorizontalScrollBar ? this.scrollBarWidth : 0) < o : !1, this.showVerticalScrollBar ? r.classList.add(this.prefixCls + "-overflowY") : r.classList.remove(this.prefixCls + "-overflowY"), this.showHorizontalScrollBar ? r.classList.add(this.prefixCls + "-overflowX") : r.classList.remove(this.prefixCls + "-overflowX");
      }
    }, hideColumnFilter() {
      this.cloneColumns.forEach((t) => t._filterVisible = !1);
    }, handleBodyScroll(t) {
      this.scrollOnTheLeft = t.target.scrollLeft === 0, this.scrollOnTheRight = t.target.scrollWidth === t.target.scrollLeft + t.target.clientWidth, this.showHeader && (this.$refs.header.scrollLeft = t.target.scrollLeft), this.isLeftFixed && (this.$refs.fixedBody.scrollTop = t.target.scrollTop), this.isRightFixed && (this.$refs.fixedRightBody.scrollTop = t.target.scrollTop), this.showSummary && this.$refs.summary && (this.$refs.summary.$el.scrollLeft = t.target.scrollLeft), this.hideColumnFilter();
    }, handleFixedMousewheel(t) {
      let r = t.deltaY;
      if (!r && t.detail && (r = t.detail * 40), !r && t.wheelDeltaY && (r = -t.wheelDeltaY), !r && t.wheelDelta && (r = -t.wheelDelta), !r)
        return;
      const o = this.$refs.body, C = o.scrollTop;
      r < 0 && C !== 0 && t.preventDefault(), r > 0 && o.scrollHeight - o.clientHeight > C && t.preventDefault();
      let g = 0, a = setInterval(() => {
        g += 5, r > 0 ? o.scrollTop += 2 : o.scrollTop -= 2, g >= Math.abs(r) && clearInterval(a);
      }, 5);
    }, handleMouseWheel(t) {
      const r = t.deltaX, o = this.$refs.body;
      r > 0 ? o.scrollLeft = o.scrollLeft + 10 : o.scrollLeft = o.scrollLeft - 10;
    }, sortData(t, r, o) {
      const C = this.cloneColumns[o].key;
      t.sort((g, a) => {
        if (this.cloneColumns[o].sortMethod)
          return this.cloneColumns[o].sortMethod(g[C], a[C], r);
        if (r === "asc")
          return g[C] > a[C] ? 1 : -1;
        if (r === "desc")
          return g[C] < a[C] ? 1 : -1;
      });
      for (let g = 0; g < t.length; g++)
        t[g].children && t[g].children.length && (t[g].children = this.sortData(t[g].children, r, o));
      return t;
    }, handleSort(t, r) {
      const o = this.GetOriginalIndex(t);
      this.cloneColumns.forEach((g) => g._sortType = "normal");
      const C = this.cloneColumns[o].key;
      this.cloneColumns[o].sortable !== "custom" && (r === "normal" ? this.rebuildData = this.makeDataWithFilter() : this.rebuildData = this.sortData(this.rebuildData, r, o)), this.cloneColumns[o]._sortType = r, this.$emit("on-sort-change", { column: JSON.parse(JSON.stringify(this.allColumns[this.cloneColumns[o]._index])), key: C, order: r });
    }, handleFilterHide(t) {
      this.cloneColumns[t]._isFiltered || (this.cloneColumns[t]._filterChecked = []);
    }, filterData(t, r) {
      return t.filter((o) => {
        if (typeof r.filterRemote == "function")
          return !0;
        let C = !r._filterChecked.length;
        for (let g = 0; g < r._filterChecked.length && (C = r.filterMethod(r._filterChecked[g], o), !C); g++)
          ;
        return C;
      });
    }, filterOtherData(t, r) {
      let o = this.cloneColumns[r];
      return typeof o.filterRemote == "function" && o.filterRemote.call(this.$parent, o._filterChecked, o.key, o), this.cloneColumns.forEach((C, g) => {
        g !== r && (t = this.filterData(t, C));
      }), t;
    }, handleFilter(t) {
      const r = this.cloneColumns[t];
      let o = this.makeDataWithSort();
      o = this.filterOtherData(o, t), this.rebuildData = this.filterData(o, r), this.cloneColumns[t]._isFiltered = !0, this.cloneColumns[t]._filterVisible = !1, this.$emit("on-filter-change", r);
    }, GetOriginalIndex(t) {
      return this.cloneColumns.findIndex((r) => r._index === t);
    }, handleFilterSelect(t, r) {
      const o = this.GetOriginalIndex(t);
      this.cloneColumns[o]._filterChecked = [r], this.handleFilter(o);
    }, handleFilterReset(t) {
      const r = this.GetOriginalIndex(t);
      this.cloneColumns[r]._isFiltered = !1, this.cloneColumns[r]._filterVisible = !1, this.cloneColumns[r]._filterChecked = [];
      let o = this.makeDataWithSort();
      o = this.filterOtherData(o, r), this.rebuildData = o, this.$emit("on-filter-change", this.cloneColumns[r]);
    }, makeData() {
      let t = W(this.data);
      return t.forEach((r, o) => {
        r._index = o, r._rowKey = typeof this.rowKey == "string" ? r[this.rowKey] : Xv++, r.children && r.children.length && (r.children = this.makeChildrenData(r));
      }), t;
    }, makeChildrenData(t) {
      return t.children && t.children.length ? t.children.map((r, o) => {
        const C = W(r);
        return C._index = o, C._rowKey = typeof this.rowKey == "string" ? C[this.rowKey] : Xv++, C.children && C.children.length && (C.children = this.makeChildrenData(C)), C;
      }) : t;
    }, makeDataWithSort() {
      let t = this.makeData(), r = "normal", o = -1, C = !1;
      for (let g = 0; g < this.cloneColumns.length; g++)
        if (this.cloneColumns[g]._sortType !== "normal") {
          r = this.cloneColumns[g]._sortType, o = g, C = this.cloneColumns[g].sortable === "custom";
          break;
        }
      return r !== "normal" && !C && (t = this.sortData(t, r, o)), t;
    }, makeDataWithFilter() {
      let t = this.makeData();
      return this.cloneColumns.forEach((r) => t = this.filterData(t, r)), t;
    }, makeDataWithSortAndFilter() {
      let t = this.makeDataWithSort();
      return this.cloneColumns.forEach((r) => t = this.filterData(t, r)), t;
    }, makeObjBaseData(t) {
      const r = W(t);
      return typeof this.rowKey == "string" && (r._rowKey = r[this.rowKey]), r._isHover = !1, r._disabled ? r._isDisabled = r._disabled : r._isDisabled = !1, r._checked ? r._isChecked = r._checked : r._isChecked = !1, r._expanded ? r._isExpanded = r._expanded : r._isExpanded = !1, r._highlight ? r._isHighlight = r._highlight : r._isHighlight = !1, r;
    }, makeObjData() {
      let t = {};
      return this.data.forEach((r, o) => {
        const C = this.makeObjBaseData(r);
        C.children && C.children.length && (C._showChildren ? C._isShowChildren = C._showChildren : C._isShowChildren = !1, C.children = this.makeChildrenObjData(C)), t[o] = C;
      }), t;
    }, makeChildrenObjData(t) {
      return t.children && t.children.length ? t.children.map((r) => {
        const o = this.makeObjBaseData(r);
        return o._showChildren ? o._isShowChildren = o._showChildren : o._isShowChildren = !1, o.children && o.children.length && (o.children = this.makeChildrenObjData(o)), o;
      }) : t;
    }, makeColumnsId(t) {
      return W(t).map((r) => ("children" in r && this.makeColumnsId(r.children), r.__id = y$(6), r));
    }, makeColumns(t) {
      let r = W(Ta(t)), o = [], C = [], g = [];
      return r.forEach((a, x) => {
        a._index = x, a._columnKey = b$++, a.width = parseInt(a.width), a._width = a.width ? a.width : "", a._sortType = "normal", a._filterVisible = !1, a._isFiltered = !1, a._filterChecked = [], "filterMultiple" in a ? a._filterMultiple = a.filterMultiple : a._filterMultiple = !0, "filteredValue" in a && (a._filterChecked = a.filteredValue, a._isFiltered = !0), "sortType" in a && (a._sortType = a.sortType), a.fixed && a.fixed === "left" ? o.push(a) : a.fixed && a.fixed === "right" ? C.push(a) : g.push(a);
      }), o.concat(g).concat(C);
    }, makeColumnRows(t, r) {
      return v$(r, t);
    }, exportCsv(t) {
      t.filename ? t.filename.indexOf(".csv") === -1 && (t.filename += ".csv") : t.filename = "table.csv";
      let r = [], o = [];
      t.columns && t.data ? (r = t.columns, o = t.data) : (r = this.allColumns, "original" in t || (t.original = !0), o = t.original ? this.data : this.rebuildData);
      let C = !1;
      "noHeader" in t && (C = t.noHeader);
      const g = m$(r, o, t, C);
      t.callback ? t.callback(g) : g$.download(t.filename, g);
    }, dragAndDrop(t, r) {
      this.$emit("on-drag-drop", t, r);
    }, handleClickContextMenuOutside() {
      this.contextMenuVisible = !1;
    }, handleOnVisibleChange(t) {
      t && e.nextTick(() => {
        this.handleResize();
      });
    }, addTable(t) {
      const r = this[t];
      !r || (r.tableList || (r.tableList = []), r.tableList.push({ id: this.id, table: this }));
    }, removeTable(t) {
      const r = this[t];
      if (!r || !r.tableList)
        return;
      const o = r.tableList.findIndex((C) => C.id === this.id);
      r.tableList.splice(o, 1);
    }, closeContextMenu() {
      this.handleClickContextMenuOutside();
    }, handleClickDropdownItem() {
      this.autoCloseContextmenu && this.closeContextMenu();
    } }, created() {
      this.context || (this.currentContext = this.$parent), this.showSlotHeader = this.$slots.header !== void 0, this.showSlotFooter = this.$slots.footer !== void 0, this.rebuildData = this.makeDataWithSortAndFilter();
    }, mounted() {
      this.addTable("TabsInstance"), this.addTable("ModalInstance"), this.addTable("DrawerInstance"), this.handleResize(), e.nextTick(() => this.ready = !0), m(window, "resize", this.handleResize), this.observer = ho(), this.observer.listenTo(this.$el, this.handleResize);
    }, beforeUnmount() {
      this.removeTable("TabsInstance"), this.removeTable("ModalInstance"), this.removeTable("DrawerInstance"), b(window, "resize", this.handleResize), this.observer.removeAllListeners(this.$el), this.observer.uninstall(this.$el), this.observer = null;
    }, watch: { data: { handler() {
      const t = this.rebuildData.length;
      this.objData = this.makeObjData(), this.rebuildData = this.makeDataWithSortAndFilter(), this.handleResize(), t || this.fixedHeader(), setTimeout(() => {
        this.cloneData = W(this.data);
      }, 0);
    }, deep: !0 }, columns: { handler() {
      const t = this.makeColumnsId(this.columns);
      this.allColumns = Ta(t), this.cloneColumns = this.makeColumns(t), this.columnRows = this.makeColumnRows(!1, t), this.leftFixedColumnRows = this.makeColumnRows("left", t), this.rightFixedColumnRows = this.makeColumnRows("right", t), this.rebuildData = this.makeDataWithSortAndFilter(), this.handleResize();
    }, deep: !0 }, height() {
      this.handleResize();
    }, maxHeight() {
      this.handleResize();
    }, showHorizontalScrollBar() {
      this.handleResize();
    }, showVerticalScrollBar() {
      this.handleResize();
    } } }, w$ = { cellspacing: "0", cellpadding: "0", border: "0" }, k$ = ["innerHTML"], S$ = ["innerHTML"], E$ = { class: "ivu-table-resize-line", ref: "resizeLine" };
    function x$(t, r, o, C, g, a) {
      const x = e.resolveComponent("table-head"), O = e.resolveComponent("table-body"), P = e.resolveComponent("table-summary"), N = e.resolveComponent("DropdownMenu"), B = e.resolveComponent("Dropdown"), H = e.resolveComponent("Spin");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.wrapClasses), style: e.normalizeStyle(a.styles), ref: "tableWrap" }, [e.createElementVNode("div", { class: e.normalizeClass(a.classes) }, [g.showSlotHeader ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-title"]), ref: "title" }, [e.renderSlot(t.$slots, "header")], 2)) : e.createCommentVNode("", !0), o.showHeader ? (e.openBlock(), e.createElementBlock("div", { key: 1, class: e.normalizeClass([g.prefixCls + "-header"]), ref: "header", onMousewheel: r[0] || (r[0] = (...oe) => a.handleMouseWheel && a.handleMouseWheel(...oe)) }, [e.createVNode(x, { "prefix-cls": g.prefixCls, styleObject: a.tableHeaderStyle, columns: g.cloneColumns, "column-rows": g.columnRows, "obj-data": g.objData, "columns-width": g.columnsWidth, data: g.rebuildData }, null, 8, ["prefix-cls", "styleObject", "columns", "column-rows", "obj-data", "columns-width", "data"])], 34)) : e.createCommentVNode("", !0), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-body"]), style: e.normalizeStyle(a.bodyStyle), ref: "body", onScroll: r[1] || (r[1] = (...oe) => a.handleBodyScroll && a.handleBodyScroll(...oe)) }, [e.createVNode(O, { ref: "tbody", draggable: o.draggable, "prefix-cls": g.prefixCls, styleObject: a.tableStyle, columns: g.cloneColumns, data: g.rebuildData, "row-key": o.rowKey, "columns-width": g.columnsWidth, "obj-data": g.objData }, null, 8, ["draggable", "prefix-cls", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 38), [[e.vShow, !(a.localeNoDataText && (!o.data || o.data.length === 0) || a.localeNoFilteredDataText && (!g.rebuildData || g.rebuildData.length === 0))]]), o.showSummary && o.data && o.data.length ? (e.openBlock(), e.createBlock(P, { key: 2, ref: "summary", "prefix-cls": g.prefixCls, styleObject: a.tableStyle, columns: g.cloneColumns, data: a.summaryData, "columns-width": g.columnsWidth }, null, 8, ["prefix-cls", "styleObject", "columns", "data", "columns-width"])) : e.createCommentVNode("", !0), e.withDirectives(e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-tip"]), style: e.normalizeStyle(a.bodyStyle), onScroll: r[2] || (r[2] = (...oe) => a.handleBodyScroll && a.handleBodyScroll(...oe)) }, [e.createElementVNode("table", w$, [e.createElementVNode("tbody", null, [e.createElementVNode("tr", null, [e.createElementVNode("td", { style: e.normalizeStyle({ height: a.bodyStyle.height, width: `${g.headerWidth}px` }) }, [!o.data || o.data.length === 0 ? (e.openBlock(), e.createElementBlock("span", { key: 0, innerHTML: a.localeNoDataText }, null, 8, k$)) : (e.openBlock(), e.createElementBlock("span", { key: 1, innerHTML: a.localeNoFilteredDataText }, null, 8, S$))], 4)])])])], 38), [[e.vShow, !!a.localeNoDataText && (!o.data || o.data.length === 0) || !!a.localeNoFilteredDataText && (!g.rebuildData || g.rebuildData.length === 0)]]), a.isLeftFixed ? (e.openBlock(), e.createElementBlock("div", { key: 3, class: e.normalizeClass(a.fixedTableClasses), style: e.normalizeStyle(a.fixedTableStyle) }, [o.showHeader ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.fixedHeaderClasses) }, [e.createVNode(x, { fixed: "left", "prefix-cls": g.prefixCls, styleObject: a.fixedTableStyle, columns: a.leftFixedColumns, "column-rows": g.columnRows, "fixed-column-rows": g.leftFixedColumnRows, "obj-data": g.objData, "columns-width": g.columnsWidth, data: g.rebuildData }, null, 8, ["prefix-cls", "styleObject", "columns", "column-rows", "fixed-column-rows", "obj-data", "columns-width", "data"])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-fixed-body"]), style: e.normalizeStyle(a.fixedBodyStyle), ref: "fixedBody", onMousewheel: r[3] || (r[3] = (...oe) => a.handleFixedMousewheel && a.handleFixedMousewheel(...oe)), "on:DOMMouseScroll": r[4] || (r[4] = (...oe) => a.handleFixedMousewheel && a.handleFixedMousewheel(...oe)) }, [e.createVNode(O, { fixed: "left", draggable: o.draggable, "prefix-cls": g.prefixCls, styleObject: a.fixedTableStyle, columns: a.leftFixedColumns, data: g.rebuildData, "row-key": o.rowKey, "columns-width": g.columnsWidth, "obj-data": g.objData }, null, 8, ["draggable", "prefix-cls", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 38), o.showSummary && o.data && o.data.length ? (e.openBlock(), e.createBlock(P, { key: 1, fixed: "left", "prefix-cls": g.prefixCls, styleObject: a.fixedTableStyle, columns: a.leftFixedColumns, data: a.summaryData, "columns-width": g.columnsWidth, style: e.normalizeStyle({ "margin-top": g.showHorizontalScrollBar ? g.scrollBarWidth + "px" : 0 }) }, null, 8, ["prefix-cls", "styleObject", "columns", "data", "columns-width", "style"])) : e.createCommentVNode("", !0)], 6)) : e.createCommentVNode("", !0), a.isRightFixed ? (e.openBlock(), e.createElementBlock("div", { key: 4, class: e.normalizeClass(a.fixedRightTableClasses), style: e.normalizeStyle(a.fixedRightTableStyle) }, [o.showHeader ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(a.fixedHeaderClasses) }, [e.createVNode(x, { fixed: "right", "prefix-cls": g.prefixCls, styleObject: a.fixedRightTableStyle, columns: a.rightFixedColumns, "column-rows": g.columnRows, "fixed-column-rows": g.rightFixedColumnRows, "obj-data": g.objData, "columns-width": g.columnsWidth, data: g.rebuildData }, null, 8, ["prefix-cls", "styleObject", "columns", "column-rows", "fixed-column-rows", "obj-data", "columns-width", "data"])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("div", { class: e.normalizeClass([g.prefixCls + "-fixed-body"]), style: e.normalizeStyle(a.fixedBodyStyle), ref: "fixedRightBody", onMousewheel: r[5] || (r[5] = (...oe) => a.handleFixedMousewheel && a.handleFixedMousewheel(...oe)), "on:DOMMouseScroll": r[6] || (r[6] = (...oe) => a.handleFixedMousewheel && a.handleFixedMousewheel(...oe)) }, [e.createVNode(O, { fixed: "right", draggable: o.draggable, "prefix-cls": g.prefixCls, styleObject: a.fixedRightTableStyle, columns: a.rightFixedColumns, data: g.rebuildData, "row-key": o.rowKey, "columns-width": g.columnsWidth, "obj-data": g.objData }, null, 8, ["draggable", "prefix-cls", "styleObject", "columns", "data", "row-key", "columns-width", "obj-data"])], 38), o.showSummary && o.data && o.data.length ? (e.openBlock(), e.createBlock(P, { key: 1, fixed: "right", "prefix-cls": g.prefixCls, styleObject: a.fixedRightTableStyle, columns: a.rightFixedColumns, data: a.summaryData, "columns-width": g.columnsWidth, style: e.normalizeStyle({ "margin-top": g.showHorizontalScrollBar ? g.scrollBarWidth + "px" : 0 }) }, null, 8, ["prefix-cls", "styleObject", "columns", "data", "columns-width", "style"])) : e.createCommentVNode("", !0)], 6)) : e.createCommentVNode("", !0), a.isRightFixed ? (e.openBlock(), e.createElementBlock("div", { key: 5, class: e.normalizeClass([g.prefixCls + "-fixed-right-header"]), style: e.normalizeStyle(a.fixedRightHeaderStyle) }, null, 6)) : e.createCommentVNode("", !0), g.showSlotFooter ? (e.openBlock(), e.createElementBlock("div", { key: 6, class: e.normalizeClass([g.prefixCls + "-footer"]), ref: "footer" }, [e.renderSlot(t.$slots, "footer")], 2)) : e.createCommentVNode("", !0)], 2), e.withDirectives(e.createElementVNode("div", E$, null, 512), [[e.vShow, g.showResizeLine]]), o.showContextMenu ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: "ivu-table-context-menu", style: e.normalizeStyle(g.contextMenuStyles) }, [e.createVNode(B, { trigger: "custom", visible: g.contextMenuVisible, transfer: "", onOnClick: a.handleClickDropdownItem, onOnClickoutside: a.handleClickContextMenuOutside }, { list: e.withCtx(() => [e.createVNode(N, null, { default: e.withCtx(() => [e.renderSlot(t.$slots, "contextMenu")]), _: 3 })]), _: 3 }, 8, ["visible", "onOnClick", "onOnClickoutside"])], 4)) : e.createCommentVNode("", !0), e.createVNode(H, { fix: "", size: "large", show: o.loading }, { default: e.withCtx(() => [e.renderSlot(t.$slots, "loading")]), _: 3 }, 8, ["show"])], 6);
    }
    var $c = f(C$, [["render", x$]]);
    const _$ = { name: "TablePaste", components: { Row: Er, Col: Ii, Input: di, Table: $c }, emits: ["on-change", "on-error", "on-success"], props: { value: { type: String }, inputProps: { type: Object, default() {
      return {};
    } }, tableProps: { type: Object, default() {
      return {};
    } }, hideTable: { type: Boolean, default: !1 } }, data() {
      return { content: "", tableColumns: [], tableData: [] };
    }, watch: { value: { handler(t) {
      this.handleResolveContent(t);
    }, immediate: !0 } }, methods: { handleContentChange(t) {
      const r = t.target.value.trim();
      this.$emit("on-change", r), this.handleResolveContent(r);
    }, handleResolveContent(t) {
      let r = [];
      t !== "" && t !== void 0 && (r = t.split(/[\n\u0085\u2028\u2029]|\r\n?/g).map((g) => g.split("	")));
      const o = this.handleGetErrorIndex(r), C = this.contentToTable(r);
      this.tableColumns = C.columns, this.tableData = C.data, o.length ? this.$emit("on-error", C, o) : this.$emit("on-success", C);
    }, handleGetErrorIndex(t) {
      const r = W(t), o = [];
      if (r.length) {
        const C = r[0].length;
        r.forEach((g, a) => {
          g.length !== C && o.push(a);
        });
      }
      return o;
    }, contentToTable(t) {
      const r = W(t);
      let o = [], C = [];
      return r.length > 1 && (o = r.shift().map((g, a) => ({ title: g, key: `key${a}` })), C = r.map((g) => {
        const a = {};
        return g.forEach((x, O) => {
          a[`key${O}`] = x;
        }), a;
      })), { columns: o, data: C };
    } } }, T$ = { class: "ivu-table-paste" }, O$ = { key: 0, class: "ivu-table-paste-input" }, D$ = { key: 0, class: "ivu-table-paste-input" };
    function N$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Input"), O = e.resolveComponent("Col"), P = e.resolveComponent("Table"), N = e.resolveComponent("Row");
      return e.openBlock(), e.createElementBlock("div", T$, [o.hideTable ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [o.value !== void 0 || !t.$slots.default ? (e.openBlock(), e.createElementBlock("div", D$, [e.renderSlot(t.$slots, "default", {}, () => [e.createVNode(x, e.mergeProps({ modelValue: g.content, "onUpdate:modelValue": r[1] || (r[1] = (B) => g.content = B), type: "textarea" }, o.inputProps, { onOnChange: a.handleContentChange }), null, 16, ["modelValue", "onOnChange"])])])) : e.createCommentVNode("", !0)], 64)) : (e.openBlock(), e.createBlock(N, { key: 0, gutter: 32 }, { default: e.withCtx(() => [e.createVNode(O, { span: "12" }, { default: e.withCtx(() => [o.value !== void 0 || !t.$slots.default ? (e.openBlock(), e.createElementBlock("div", O$, [e.renderSlot(t.$slots, "default", {}, () => [e.createVNode(x, e.mergeProps({ modelValue: g.content, "onUpdate:modelValue": r[0] || (r[0] = (B) => g.content = B), type: "textarea" }, o.inputProps, { onOnChange: a.handleContentChange }), null, 16, ["modelValue", "onOnChange"])])])) : e.createCommentVNode("", !0)]), _: 3 }), e.createVNode(O, { span: "12" }, { default: e.withCtx(() => [e.createVNode(P, e.mergeProps({ columns: g.tableColumns, data: g.tableData }, o.tableProps), null, 16, ["columns", "data"])]), _: 1 })]), _: 3 }))]);
    }
    var qv = f(_$, [["render", N$]]);
    const B$ = { name: "TagSelect", mixins: [nn], components: { Tag: so, Icon: G }, emits: ["on-change", "on-checked-all", "update:modelValue"], provide() {
      return { TagSelectInstance: this };
    }, props: { modelValue: { type: Array, default() {
      return [];
    } }, expandable: { type: Boolean, default: !1 }, hideCheckAll: { type: Boolean, default: !1 }, locale: { type: Object, default() {
      return { collapseText: "收起", expandText: "展开" };
    } } }, data() {
      return { currentValue: this.modelValue, checkedAll: !1, expand: !1, tagSelectOptionList: [] };
    }, computed: { classes() {
      return { "ivu-tag-select-with-expanded": this.expandable, "ivu-tag-select-expanded": this.expand };
    } }, watch: { modelValue(t) {
      this.currentValue = t, this.handleUpdateTags();
    } }, methods: { handleUpdateTags() {
      let t = !0;
      this.tagSelectOptionList.map((r) => r.option).forEach((r) => {
        this.currentValue.indexOf(r.name) >= 0 ? r.checked = !0 : (r.checked = !1, t = !1);
      }), this.checkedAll = t;
    }, handleChangeTag(t) {
      const r = [];
      let o = !0;
      this.tagSelectOptionList.map((C) => C.option).forEach((C) => {
        C.checked ? r.push(C.name) : o = !1;
      }), this.currentValue = r, this.$emit("update:modelValue", r), this.$emit("on-change", [...r], t), this.handleFormItemChange("change", t), t && (this.checkedAll = o);
    }, handleCheckAll(t) {
      this.checkedAll = t, this.tagSelectOptionList.map((r) => r.option).forEach((r) => {
        r.checked = t;
      }), this.handleChangeTag(), this.$emit("on-checked-all", t);
    }, handleToggleExpand() {
      this.expand = !this.expand;
    } }, mounted() {
      this.handleUpdateTags();
    } }, P$ = { key: 0, class: "ivu-tag-select-option" }, V$ = { key: 0 }, $$ = { key: 1 };
    function I$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Tag"), O = e.resolveComponent("Icon");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(["ivu-tag-select", a.classes]) }, [o.hideCheckAll ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", P$, [e.createVNode(x, { checkable: "", checked: g.checkedAll, onOnChange: a.handleCheckAll, color: "primary" }, { default: e.withCtx(() => [e.createTextVNode("全部")]), _: 1 }, 8, ["checked", "onOnChange"])])), e.renderSlot(t.$slots, "default"), o.expandable ? (e.openBlock(), e.createElementBlock("a", { key: 1, class: "ivu-tag-select-expand-btn", onClick: r[0] || (r[0] = (...P) => a.handleToggleExpand && a.handleToggleExpand(...P)) }, [g.expand ? (e.openBlock(), e.createElementBlock("span", V$, e.toDisplayString(o.locale.collapseText), 1)) : (e.openBlock(), e.createElementBlock("span", $$, e.toDisplayString(o.locale.expandText), 1)), g.expand ? (e.openBlock(), e.createBlock(O, { key: 2, type: "ios-arrow-up" })) : (e.openBlock(), e.createBlock(O, { key: 3, type: "ios-arrow-down" }))])) : e.createCommentVNode("", !0)], 2);
    }
    var Jv = f(B$, [["render", I$]]);
    const M$ = { name: "TagSelectOption", components: { Tag: so }, inject: ["TagSelectInstance"], props: { name: { type: [String, Number], required: !0 }, tagProps: { type: Object, default() {
      return {};
    } }, color: { type: String, default: "primary" } }, data() {
      return { checked: !1, id: be(6) };
    }, methods: { handleChange(t) {
      this.checked = t, this.TagSelectInstance.handleChangeTag(this.name);
    }, addOption() {
      this.TagSelectInstance.tagSelectOptionList.push({ id: this.id, option: this });
    }, removeOption() {
      const t = this.TagSelectInstance, r = t.tagSelectOptionList.findIndex((o) => o.id === this.id);
      t.tagSelectOptionList.splice(r, 1);
    } }, mounted() {
      this.addOption();
    }, beforeUnmount() {
      this.removeOption();
    } }, A$ = { class: "ivu-tag-select-option" };
    function F$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Tag");
      return e.openBlock(), e.createElementBlock("div", A$, [e.createVNode(x, e.mergeProps({ checkable: "", checked: g.checked, onOnChange: a.handleChange, color: o.color }, o.tagProps), { default: e.withCtx(() => [e.renderSlot(t.$slots, "default")]), _: 3 }, 16, ["checked", "onOnChange", "color"])]);
    }
    var Qv = f(M$, [["render", F$]]);
    const Zv = { name: "Text", mixins: [ga], render() {
      return e.h(xc, p(v(p({}, this.$props), { component: "span" }), this.commonEvents()), this.commonSlots());
    } }, ey = "ivu-timeline", L$ = { name: "Timeline", props: { pending: { type: Boolean, default: !1 } }, computed: { classes() {
      return [`${ey}`, { [`${ey}-pending`]: this.pending }];
    } } };
    function z$(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("ul", { class: e.normalizeClass(a.classes) }, [e.renderSlot(t.$slots, "default")], 2);
    }
    var ty = f(L$, [["render", z$]]);
    const vo = "ivu-timeline", R$ = { name: "TimelineItem", props: { color: { type: String, default: "blue" } }, data() {
      return { dot: !1 };
    }, mounted() {
      this.dot = !!this.$refs.dot.innerHTML.length;
    }, computed: { itemClasses() {
      return `${vo}-item`;
    }, tailClasses() {
      return `${vo}-item-tail`;
    }, headClasses() {
      return [`${vo}-item-head`, { [`${vo}-item-head-custom`]: this.dot, [`${vo}-item-head-${this.color}`]: this.headColorShow }];
    }, headColorShow() {
      return this.color === "blue" || this.color === "red" || this.color === "green";
    }, customColor() {
      let t = {};
      return this.color && (this.headColorShow || (t = { color: this.color, "border-color": this.color })), t;
    }, contentClasses() {
      return `${vo}-item-content`;
    } } };
    function j$(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("li", { class: e.normalizeClass(a.itemClasses) }, [e.createElementVNode("div", { class: e.normalizeClass(a.tailClasses) }, null, 2), e.createElementVNode("div", { class: e.normalizeClass(a.headClasses), style: e.normalizeStyle(a.customColor), ref: "dot" }, [e.renderSlot(t.$slots, "dot")], 6), e.createElementVNode("div", { class: e.normalizeClass(a.contentClasses) }, [e.renderSlot(t.$slots, "default")], 2)], 2);
    }
    var ny = f(R$, [["render", j$]]), iy = { mixins: [Kg, dc], components: { TimePickerPanel: a0, RangeTimePickerPanel: d0 }, props: { type: { validator(t) {
      return z(t, ["time", "timerange"]);
    }, default: "time" } }, computed: { panel() {
      return this.type === "timerange" ? "RangeTimePickerPanel" : "TimePickerPanel";
    }, ownPickerProps() {
      return { disabledHours: this.disabledHours, disabledMinutes: this.disabledMinutes, disabledSeconds: this.disabledSeconds, hideDisabledOptions: this.hideDisabledOptions };
    } }, watch: { visible(t) {
      t && e.nextTick(() => {
        this.timeSpinnerList.map((r) => r.timeSpinner).forEach((r) => r.updateScroll());
      });
    } } };
    const ry = { name: "Title", mixins: [ga], props: { level: { type: Number, validator(t) {
      return z(t, [1, 2, 3, 4, 5, 6]);
    }, default: 1 } }, render() {
      return e.h(xc, p(v(p({}, this.$props), { component: `h${this.level}` }), this.commonEvents()), this.commonSlots());
    } }, H$ = { name: "Search", components: { Input: di }, emits: ["on-query-change", "on-query-clear"], props: { prefixCls: String, placeholder: String, query: String }, data() {
      return { currentQuery: this.query };
    }, watch: { query(t) {
      this.currentQuery = t;
    }, currentQuery(t) {
      this.$emit("on-query-change", t);
    } }, computed: { icon() {
      return this.query === "" ? "ios-search" : "ios-close-circle";
    } }, methods: { handleClick() {
      this.currentQuery !== "" && (this.currentQuery = "", this.$emit("on-query-clear"));
    } } };
    function U$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Input");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(o.prefixCls) }, [e.createVNode(x, { modelValue: g.currentQuery, "onUpdate:modelValue": r[0] || (r[0] = (O) => g.currentQuery = O), size: "small", icon: a.icon, placeholder: o.placeholder, onOnClick: a.handleClick }, null, 8, ["modelValue", "icon", "placeholder", "onOnClick"])], 2);
    }
    var W$ = f(H$, [["render", U$]]);
    const Y$ = { name: "TransferList", components: { Search: W$, Checkbox: ro }, inject: ["TransferInstance"], emits: ["on-checked-keys-change"], props: { prefixCls: String, data: Array, renderFormat: Function, checkedKeys: Array, listStyle: Object, title: [String, Number], filterable: Boolean, filterPlaceholder: String, filterMethod: Function, notFoundText: String, validKeysCount: Number }, data() {
      return { showItems: [], query: "", showFooter: !0 };
    }, watch: { data() {
      this.updateFilteredData();
    } }, computed: { classes() {
      return [`${this.prefixCls}`, { [`${this.prefixCls}-with-footer`]: this.showFooter }];
    }, bodyClasses() {
      return [`${this.prefixCls}-body`, { [`${this.prefixCls}-body-with-search`]: this.filterable, [`${this.prefixCls}-body-with-footer`]: this.showFooter }];
    }, count() {
      const t = this.validKeysCount;
      return (t > 0 ? `${t}/` : "") + `${this.data.length}`;
    }, checkedAll() {
      return this.filterData.filter((t) => !t.disabled).length === this.validKeysCount && this.validKeysCount !== 0;
    }, checkedAllDisabled() {
      return this.filterData.filter((t) => !t.disabled).length <= 0;
    }, filterData() {
      return this.showItems.filter((t) => this.filterMethod(t, this.query));
    } }, methods: { itemClasses(t) {
      return [`${this.prefixCls}-content-item`, { [`${this.prefixCls}-content-item-disabled`]: t.disabled }];
    }, showLabel(t) {
      return this.renderFormat(t);
    }, isCheck(t) {
      return this.checkedKeys.some((r) => r === t.key);
    }, select(t) {
      if (t.disabled)
        return;
      const r = this.checkedKeys.indexOf(t.key);
      r > -1 ? this.checkedKeys.splice(r, 1) : this.checkedKeys.push(t.key), this.TransferInstance.handleCheckedKeys();
    }, updateFilteredData() {
      this.showItems = this.data;
    }, toggleSelectAll(t) {
      const r = t ? this.filterData.filter((o) => !o.disabled || this.checkedKeys.indexOf(o.key) > -1).map((o) => o.key) : this.filterData.filter((o) => o.disabled && this.checkedKeys.indexOf(o.key) > -1).map((o) => o.key);
      this.$emit("on-checked-keys-change", r);
    }, handleQueryClear() {
      this.query = "";
    }, handleQueryChange(t) {
      this.query = t;
    } }, created() {
      this.updateFilteredData();
    }, mounted() {
      this.showFooter = this.$slots.default !== void 0;
    } }, K$ = ["onClick"], G$ = ["innerHTML"];
    function X$(t, r, o, C, g, a) {
      const x = e.resolveComponent("Checkbox"), O = e.resolveComponent("Search");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(a.classes), style: e.normalizeStyle(o.listStyle) }, [e.createElementVNode("div", { class: e.normalizeClass(o.prefixCls + "-header") }, [e.createVNode(x, { modelValue: a.checkedAll, disabled: a.checkedAllDisabled, "onUpdate:modelValue": a.toggleSelectAll }, null, 8, ["modelValue", "disabled", "onUpdate:modelValue"]), e.createElementVNode("span", { class: e.normalizeClass(o.prefixCls + "-header-title"), onClick: r[0] || (r[0] = (P) => a.toggleSelectAll(!a.checkedAll)) }, e.toDisplayString(o.title), 3), e.createElementVNode("span", { class: e.normalizeClass(o.prefixCls + "-header-count") }, e.toDisplayString(a.count), 3)], 2), e.createElementVNode("div", { class: e.normalizeClass(a.bodyClasses) }, [o.filterable ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(o.prefixCls + "-body-search-wrapper") }, [e.createVNode(O, { "prefix-cls": o.prefixCls + "-search", query: g.query, onOnQueryClear: a.handleQueryClear, onOnQueryChange: a.handleQueryChange, placeholder: o.filterPlaceholder }, null, 8, ["prefix-cls", "query", "onOnQueryClear", "onOnQueryChange", "placeholder"])], 2)) : e.createCommentVNode("", !0), e.createElementVNode("ul", { class: e.normalizeClass(o.prefixCls + "-content") }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.filterData, (P, N) => (e.openBlock(), e.createElementBlock("li", { key: N, class: e.normalizeClass(a.itemClasses(P)), onClick: e.withModifiers((B) => a.select(P), ["prevent"]) }, [e.createVNode(x, { modelValue: a.isCheck(P), disabled: P.disabled }, null, 8, ["modelValue", "disabled"]), e.createElementVNode("span", { innerHTML: a.showLabel(P) }, null, 8, G$)], 10, K$))), 128)), e.createElementVNode("li", { class: e.normalizeClass(o.prefixCls + "-content-not-found") }, e.toDisplayString(o.notFoundText), 3)], 2)], 2), g.showFooter ? (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass(o.prefixCls + "-footer") }, [e.renderSlot(t.$slots, "default")], 2)) : e.createCommentVNode("", !0)], 6);
    }
    var sy = f(Y$, [["render", X$]]);
    const q$ = { name: "Operation", components: { Button: zn, Icon: G }, inject: ["TransferInstance"], props: { prefixCls: String, operations: Array, leftActive: Boolean, rightActive: Boolean, reverseOperation: Boolean }, methods: { moveToLeft() {
      this.TransferInstance.moveTo("left");
    }, moveToRight() {
      this.TransferInstance.moveTo("right");
    } } }, J$ = { key: 0 }, Q$ = { key: 0 }, Z$ = { key: 0 }, eI = { key: 0 };
    function tI(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Button");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(o.prefixCls + "-operation") }, [o.reverseOperation ? (e.openBlock(), e.createElementBlock(e.Fragment, { key: 0 }, [e.createVNode(O, { type: "primary", size: "small", disabled: !o.leftActive, onClick: a.moveToRight }, { default: e.withCtx(() => [o.operations[1] ? (e.openBlock(), e.createElementBlock("span", J$, e.toDisplayString(o.operations[1]), 1)) : e.createCommentVNode("", !0), e.createVNode(x, { type: "ios-arrow-forward" })]), _: 1 }, 8, ["disabled", "onClick"]), e.createVNode(O, { type: "primary", size: "small", disabled: !o.rightActive, onClick: a.moveToLeft }, { default: e.withCtx(() => [e.createVNode(x, { type: "ios-arrow-back" }), o.operations[0] ? (e.openBlock(), e.createElementBlock("span", Q$, e.toDisplayString(o.operations[0]), 1)) : e.createCommentVNode("", !0)]), _: 1 }, 8, ["disabled", "onClick"])], 64)) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [e.createVNode(O, { type: "primary", size: "small", disabled: !o.rightActive, onClick: a.moveToLeft }, { default: e.withCtx(() => [e.createVNode(x, { type: "ios-arrow-back" }), o.operations[0] ? (e.openBlock(), e.createElementBlock("span", Z$, e.toDisplayString(o.operations[0]), 1)) : e.createCommentVNode("", !0)]), _: 1 }, 8, ["disabled", "onClick"]), e.createVNode(O, { type: "primary", size: "small", disabled: !o.leftActive, onClick: a.moveToRight }, { default: e.withCtx(() => [o.operations[1] ? (e.openBlock(), e.createElementBlock("span", eI, e.toDisplayString(o.operations[1]), 1)) : e.createCommentVNode("", !0), e.createVNode(x, { type: "ios-arrow-forward" })]), _: 1 }, 8, ["disabled", "onClick"])], 64))], 2);
    }
    var nI = f(q$, [["render", tI]]);
    const oy = "ivu-transfer", ay = { name: "Transfer", mixins: [Kt, nn], emits: ["on-change", "on-selected-change"], provide() {
      return { TransferInstance: this };
    }, render() {
      const t = this.$slots.default ? this.$slots.default() : "";
      return e.h("div", { class: this.classes }, [e.h(sy, { ref: "left", prefixCls: this.prefixCls + "-list", data: this.leftData, renderFormat: this.renderFormat, checkedKeys: this.leftCheckedKeys, validKeysCount: this.leftValidKeysCount, listStyle: this.listStyle, title: this.localeTitles[0], filterable: this.filterable, filterPlaceholder: this.localeFilterPlaceholder, filterMethod: this.filterMethod, notFoundText: this.localeNotFoundText, "onOn-checked-keys-change": this.handleLeftCheckedKeysChange }, () => t), e.h(nI, { prefixCls: this.prefixCls, operations: this.operations, leftActive: this.leftValidKeysCount > 0, rightActive: this.rightValidKeysCount > 0, reverseOperation: this.reverseOperation }), e.h(sy, { ref: "right", prefixCls: this.prefixCls + "-list", data: this.rightData, renderFormat: this.renderFormat, checkedKeys: this.rightCheckedKeys, validKeysCount: this.rightValidKeysCount, listStyle: this.listStyle, title: this.localeTitles[1], filterable: this.filterable, filterPlaceholder: this.localeFilterPlaceholder, filterMethod: this.filterMethod, notFoundText: this.localeNotFoundText, "onOn-checked-keys-change": this.handleRightCheckedKeysChange }, () => t)]);
    }, props: { data: { type: Array, default() {
      return [];
    } }, renderFormat: { type: Function, default(t) {
      return t.label || t.key;
    } }, targetKeys: { type: Array, default() {
      return [];
    } }, selectedKeys: { type: Array, default() {
      return [];
    } }, listStyle: { type: Object, default() {
      return {};
    } }, titles: { type: Array }, operations: { type: Array, default() {
      return [];
    } }, filterable: { type: Boolean, default: !1 }, filterPlaceholder: { type: String }, filterMethod: { type: Function, default(t, r) {
      const o = "label" in t ? "label" : "key";
      return t[o].indexOf(r) > -1;
    } }, notFoundText: { type: String }, reverseOperation: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: oy, leftData: [], rightData: [], leftCheckedKeys: [], rightCheckedKeys: [] };
    }, computed: { classes() {
      return [`${oy}`];
    }, leftValidKeysCount() {
      return this.getValidKeys("left").length;
    }, rightValidKeysCount() {
      return this.getValidKeys("right").length;
    }, localeFilterPlaceholder() {
      return this.filterPlaceholder === void 0 ? this.t("i.transfer.filterPlaceholder") : this.filterPlaceholder;
    }, localeNotFoundText() {
      return this.notFoundText === void 0 ? this.t("i.transfer.notFoundText") : this.notFoundText;
    }, localeTitles() {
      return this.titles === void 0 ? [this.t("i.transfer.titles.source"), this.t("i.transfer.titles.target")] : this.titles;
    } }, methods: { getValidKeys(t) {
      return this[`${t}Data`].filter((r) => !r.disabled && this[`${t}CheckedKeys`].indexOf(r.key) > -1).map((r) => r.key);
    }, splitData(t = !1) {
      this.leftData = [...this.data], this.rightData = [], this.targetKeys.length > 0 && this.targetKeys.forEach((r) => {
        const o = this.leftData.filter((C, g) => C.key === r ? (this.leftData.splice(g, 1), !0) : !1);
        o && o.length > 0 && this.rightData.push(o[0]);
      }), t && this.splitSelectedKey();
    }, splitSelectedKey() {
      const t = this.selectedKeys;
      t.length > 0 && (this.leftCheckedKeys = this.leftData.filter((r) => t.indexOf(r.key) > -1).map((r) => r.key), this.rightCheckedKeys = this.rightData.filter((r) => t.indexOf(r.key) > -1).map((r) => r.key));
    }, moveTo(t) {
      const r = this.targetKeys, o = t === "left" ? "right" : "left", C = this.getValidKeys(o), g = t === "right" ? C.concat(r) : r.filter((a) => !C.some((x) => a === x));
      this.$refs[o].toggleSelectAll(!1), this.$emit("on-change", g, t, C), this.handleFormItemChange("change", { tarketKeys: g, direction: t, moveKeys: C });
    }, handleLeftCheckedKeysChange(t) {
      this.leftCheckedKeys = t;
    }, handleRightCheckedKeysChange(t) {
      this.rightCheckedKeys = t;
    }, handleCheckedKeys() {
      const t = this.getValidKeys("left"), r = this.getValidKeys("right");
      this.$emit("on-selected-change", t, r);
    } }, watch: { targetKeys() {
      this.splitData(!1);
    }, data() {
      this.splitData(!1);
    } }, mounted() {
      this.splitData(!0);
    } };
    var iI = { name: "RenderCell", props: { render: Function, data: Object, node: Array }, render() {
      const t = { root: this.node[0], node: this.node[1], data: this.data };
      return this.render(e.h, t);
    } };
    const Ir = "ivu-tree", rI = { name: "TreeNode", inject: ["TreeInstance"], components: { Checkbox: ro, Icon: G, CollapseTransition: Sd, Render: iI }, props: { data: { type: Object, default: () => {
    } }, multiple: { type: Boolean, default: !1 }, childrenKey: { type: String, default: "children" }, showCheckbox: { type: Boolean, default: !1 }, appear: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: Ir, appearByClickArrow: !1, globalConfig: {} };
    }, computed: { classes() {
      return [`${Ir}-children`];
    }, selectedCls() {
      return [{ [`${Ir}-node-selected`]: this.data.selected }];
    }, arrowClasses() {
      return [`${Ir}-arrow`, { [`${Ir}-arrow-disabled`]: this.data.disabled, [`${Ir}-arrow-open`]: this.data.expand }];
    }, titleClasses() {
      return [`${Ir}-title`, { [`${Ir}-title-selected`]: this.data.selected }];
    }, showArrow() {
      return this.data[this.childrenKey] && this.data[this.childrenKey].length || "loading" in this.data && !this.data.loading;
    }, showLoading() {
      return "loading" in this.data && this.data.loading;
    }, isParentRender() {
      const t = me(this, "Tree");
      return t && t.render;
    }, parentRender() {
      const t = me(this, "Tree");
      return t && t.render ? t.render : null;
    }, node() {
      const t = me(this, "Tree");
      return t ? [t.flatState, t.flatState.find((r) => r.nodeKey === this.data.nodeKey)] : [];
    }, children() {
      return this.data[this.childrenKey];
    }, arrowType() {
      const t = this.globalConfig;
      let r = "ios-arrow-forward";
      return t && (t.tree.customArrow ? r = "" : t.tree.arrow && (r = t.tree.arrow)), r;
    }, customArrowType() {
      const t = this.globalConfig;
      let r = "";
      return t && t.tree.customArrow && (r = t.tree.customArrow), r;
    }, arrowSize() {
      const t = this.globalConfig;
      let r = "";
      return t && t.tree.arrowSize && (r = t.tree.arrowSize), r;
    } }, methods: { handleExpand() {
      const t = this.data;
      if (this.appearByClickArrow = !0, t[this.childrenKey].length === 0) {
        const r = me(this, "Tree");
        if (r && r.loadData) {
          this.data.loading = !0, r.loadData(t, (o) => {
            this.data.loading = !1, o.length && (this.data[this.childrenKey] = o, e.nextTick(() => this.handleExpand()));
          });
          return;
        }
      }
      t[this.childrenKey] && t[this.childrenKey].length && (this.data.expand = !this.data.expand, this.TreeInstance.handleToggleExpand(this.data));
    }, handleClickNode() {
      this.TreeInstance.expandNode ? this.showArrow && this.handleExpand() : this.TreeInstance.selectNode && this.handleSelect();
    }, handleSelect() {
      this.data.disabled || (this.TreeInstance.showCheckbox && this.TreeInstance.checkDirectly ? this.handleCheck() : this.TreeInstance.handleOnSelected(this.data.nodeKey));
    }, handleCheck() {
      if (this.data.disabled)
        return;
      const t = { checked: !this.data.checked && !this.data.indeterminate, nodeKey: this.data.nodeKey };
      this.TreeInstance.handleOnCheck(t);
    }, handleContextmenu(t, r) {
      t.contextmenu && (r.preventDefault(), this.TreeInstance.handleOnContextmenu({ data: t, event: r }));
    }, handlePreventSelect(t, r) {
      t.contextmenu && r.preventDefault();
    } }, created() {
      const t = e.getCurrentInstance();
      this.globalConfig = t.appContext.config.globalProperties.$VIEWUI;
    } }, sI = { key: 0, class: "ivu-tree-expand" };
    function oI(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("Checkbox"), P = e.resolveComponent("Render"), N = e.resolveComponent("TreeNode"), B = e.resolveComponent("collapse-transition");
      return e.openBlock(), e.createElementBlock("ul", { class: e.normalizeClass(a.classes) }, [e.createElementVNode("li", { onContextmenu: r[2] || (r[2] = e.withModifiers((H) => a.handleContextmenu(o.data, H), ["stop"])), onSelectstart: r[3] || (r[3] = e.withModifiers((H) => a.handlePreventSelect(o.data, H), ["stop"])) }, [e.createElementVNode("span", { class: e.normalizeClass(a.arrowClasses), onClick: r[0] || (r[0] = (...H) => a.handleExpand && a.handleExpand(...H)) }, [a.showArrow ? (e.openBlock(), e.createBlock(x, { key: 0, type: a.arrowType, custom: a.customArrowType, size: a.arrowSize }, null, 8, ["type", "custom", "size"])) : e.createCommentVNode("", !0), a.showLoading ? (e.openBlock(), e.createBlock(x, { key: 1, type: "ios-loading", class: "ivu-load-loop" })) : e.createCommentVNode("", !0)], 2), o.showCheckbox ? (e.openBlock(), e.createBlock(O, { key: 0, "model-value": o.data.checked, indeterminate: o.data.indeterminate, disabled: o.data.disabled || o.data.disableCheckbox, onClick: e.withModifiers(a.handleCheck, ["prevent"]) }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : e.createCommentVNode("", !0), e.createElementVNode("span", { class: e.normalizeClass(a.titleClasses), onClick: r[1] || (r[1] = (...H) => a.handleClickNode && a.handleClickNode(...H)) }, [o.data.render ? (e.openBlock(), e.createBlock(P, { key: 0, render: o.data.render, data: o.data, node: a.node }, null, 8, ["render", "data", "node"])) : a.isParentRender ? (e.openBlock(), e.createBlock(P, { key: 1, render: a.parentRender, data: o.data, node: a.node }, null, 8, ["render", "data", "node"])) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 2 }, [e.createTextVNode(e.toDisplayString(o.data.title), 1)], 64))], 2), e.createVNode(B, { appear: o.appear }, { default: e.withCtx(() => [o.data.expand ? (e.openBlock(), e.createElementBlock("div", sI, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(a.children, (H, oe) => (e.openBlock(), e.createBlock(N, { appear: g.appearByClickArrow, key: oe, data: H, multiple: o.multiple, "show-checkbox": o.showCheckbox, "children-key": o.childrenKey }, null, 8, ["appear", "data", "multiple", "show-checkbox", "children-key"]))), 128))])) : e.createCommentVNode("", !0)]), _: 1 }, 8, ["appear"])], 32)], 2);
    }
    var aI = f(rI, [["render", oI]]);
    const lI = "ivu-tree", cI = { name: "Tree", mixins: [Kt], components: { TreeNode: aI, Dropdown: ys, DropdownMenu: bs }, emits: ["on-select-change", "on-check-change", "on-contextmenu", "on-toggle-expand"], provide() {
      return { TreeInstance: this };
    }, props: { data: { type: Array, default: () => [] }, multiple: { type: Boolean, default: !1 }, showCheckbox: { type: Boolean, default: !1 }, checkStrictly: { type: Boolean, default: !1 }, checkDirectly: { type: Boolean, default: !1 }, emptyText: { type: String }, childrenKey: { type: String, default: "children" }, loadData: { type: Function }, render: { type: Function }, selectNode: { type: Boolean, default: !0 }, expandNode: { type: Boolean, default: !1 }, autoCloseContextmenu: { type: Boolean, default: !0 } }, data() {
      return { prefixCls: lI, stateTree: this.data, flatState: [], contextMenuVisible: !1, contextMenuStyles: { top: 0, left: 0 } };
    }, watch: { data: { deep: !0, handler() {
      this.stateTree = this.data, this.flatState = this.compileFlatState(), this.rebuildTree();
    } } }, computed: { localeEmptyText() {
      return typeof this.emptyText > "u" ? this.t("i.tree.emptyText") : this.emptyText;
    } }, methods: { compileFlatState() {
      let t = 0, r = this.childrenKey;
      const o = [];
      function C(g, a) {
        g.nodeKey = t++, o[g.nodeKey] = { node: g, nodeKey: g.nodeKey }, typeof a < "u" && (o[g.nodeKey].parent = a.nodeKey, o[a.nodeKey][r].push(g.nodeKey)), g[r] && (o[g.nodeKey][r] = [], g[r].forEach((x) => C(x, g)));
      }
      return this.stateTree.forEach((g) => {
        C(g);
      }), o;
    }, updateTreeUp(t) {
      const r = this.flatState[t].parent;
      if (typeof r > "u" || this.checkStrictly)
        return;
      const o = this.flatState[t].node, C = this.flatState[r].node;
      o.checked == C.checked && o.indeterminate == C.indeterminate || (o.checked == !0 ? (C.checked = C[this.childrenKey].every((g) => g.checked), C.indeterminate = !C.checked) : (C.checked = !1, C.indeterminate = C[this.childrenKey].some((g) => g.checked || g.indeterminate)), this.updateTreeUp(r));
    }, rebuildTree() {
      this.getCheckedNodes().forEach((t) => {
        this.updateTreeDown(t, { checked: !0 });
        const r = this.flatState[t.nodeKey].parent;
        if (!r && r !== 0)
          return;
        const o = this.flatState[r].node;
        typeof t.checked < "u" && t.checked && o.checked != t.checked && this.updateTreeUp(t.nodeKey);
      });
    }, getSelectedNodes() {
      return this.flatState.filter((t) => t.node.selected).map((t) => t.node);
    }, getCheckedNodes() {
      return this.flatState.filter((t) => t.node.checked).map((t) => t.node);
    }, getCheckedAndIndeterminateNodes() {
      return this.flatState.filter((t) => t.node.checked || t.node.indeterminate).map((t) => t.node);
    }, updateTreeDown(t, r = {}) {
      if (!this.checkStrictly) {
        for (let o in r)
          t[o] = r[o];
        t[this.childrenKey] && t[this.childrenKey].forEach((o) => {
          this.updateTreeDown(o, r);
        });
      }
    }, handleSelect(t) {
      if (!this.flatState[t])
        return;
      const r = this.flatState[t].node;
      if (!this.multiple) {
        const o = this.flatState.findIndex((C) => C.node.selected);
        o >= 0 && o !== t && (this.flatState[o].node.selected = !1);
      }
      r.selected = !r.selected, this.$emit("on-select-change", this.getSelectedNodes(), r);
    }, handleCheck({ checked: t, nodeKey: r }) {
      if (!this.flatState[r])
        return;
      const o = this.flatState[r].node;
      o.checked = t, o.indeterminate = !1, this.updateTreeUp(r), this.updateTreeDown(o, { checked: t, indeterminate: !1 }), this.$emit("on-check-change", this.getCheckedNodes(), o);
    }, handleContextmenu({ data: t, event: r }) {
      this.contextMenuVisible && this.handleClickContextMenuOutside(), e.nextTick(() => {
        const o = this.$refs.treeWrap.getBoundingClientRect(), C = { left: `${r.clientX - o.left}px`, top: `${r.clientY - o.top}px` };
        this.contextMenuStyles = C, this.contextMenuVisible = !0, this.$emit("on-contextmenu", t, r, C);
      });
    }, handleClickContextMenuOutside() {
      this.contextMenuVisible = !1;
    }, handleOnCheck(t) {
      this.handleCheck(t);
    }, handleOnSelected(t) {
      this.handleSelect(t);
    }, handleToggleExpand(t) {
      this.$emit("on-toggle-expand", t);
    }, handleOnContextmenu(t) {
      this.handleContextmenu(t);
    }, closeContextMenu() {
      this.handleClickContextMenuOutside();
    }, handleClickDropdownItem() {
      this.autoCloseContextmenu && this.closeContextMenu();
    } }, created() {
      this.flatState = this.compileFlatState(), this.rebuildTree();
    } };
    function uI(t, r, o, C, g, a) {
      const x = e.resolveComponent("TreeNode"), O = e.resolveComponent("DropdownMenu"), P = e.resolveComponent("Dropdown");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass(g.prefixCls), ref: "treeWrap" }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(g.stateTree, (N, B) => (e.openBlock(), e.createBlock(x, { key: B, data: N, visible: "", multiple: o.multiple, "show-checkbox": o.showCheckbox, "children-key": o.childrenKey }, null, 8, ["data", "multiple", "show-checkbox", "children-key"]))), 128)), g.stateTree.length ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock("div", { key: 0, class: e.normalizeClass([g.prefixCls + "-empty"]) }, e.toDisplayString(a.localeEmptyText), 3)), e.createElementVNode("div", { class: "ivu-tree-context-menu", style: e.normalizeStyle(g.contextMenuStyles) }, [e.createVNode(P, { trigger: "custom", visible: g.contextMenuVisible, transfer: "", onOnClick: a.handleClickDropdownItem, onOnClickoutside: a.handleClickContextMenuOutside }, { list: e.withCtx(() => [e.createVNode(O, null, { default: e.withCtx(() => [e.renderSlot(t.$slots, "contextMenu")]), _: 3 })]), _: 3 }, 8, ["visible", "onOnClick", "onOnClickoutside"])], 4)], 2);
    }
    var Ad = f(cI, [["render", uI]]);
    const hI = { name: "TreeSelect", components: { Select: ps, Tree: Ad }, emits: ["on-change", "update:modelValue", "on-open-change"], mixins: [nn], props: { modelValue: { type: [String, Number, Array] }, data: { type: Array, default: () => [] }, multiple: { type: Boolean, default: !1 }, showCheckbox: { type: Boolean, default: !1 }, loadData: { type: Function }, transfer: { type: Boolean, default() {
      const t = e.getCurrentInstance().appContext.config.globalProperties;
      return !t.$VIEWUI || t.$VIEWUI.transfer === "" ? !1 : t.$VIEWUI.transfer;
    } } }, data() {
      let t = this.modelValue;
      return t === null && (this.multiple ? t = [] : t = ""), { currentValue: t, isChangeValueInTree: !1, isValueChangeByTree: !1, isValueNull: !1 };
    }, watch: { modelValue(t) {
      if (this.isChangeValueInTree)
        this.isChangeValueInTree = !1;
      else {
        let r = t;
        r === null && (this.isValueNull = !0, this.multiple ? r = [] : r = ""), this.currentValue = r, this.$refs.select.reset(), this.handleUpdateTreeNodes(this.data, !0);
      }
    }, data() {
      this.isChangeValueInTree ? this.isChangeValueInTree = !1 : (this.$refs.select.reset(), this.handleUpdateTreeNodes(this.data, !0));
    } }, computed: { valueToArray() {
      return typeof this.currentValue == "object" ? this.currentValue : [this.currentValue];
    }, isCheckboxUsable() {
      return this.multiple && this.showCheckbox;
    }, transferClassName() {
      return this.transfer ? "ivu-tree-select-transfer" : "";
    }, classes() {
      return { "ivu-tree-select-with-checkbox": this.showCheckbox };
    } }, methods: { handleSelectNode(t, r) {
      if (this.multiple)
        t.length ? (this.currentValue = t.map((o) => o.value), this.handleUpdateSelectValue(r.value, r.title)) : (this.currentValue = [], this.handleUpdateSelectValue("", ""));
      else if (t.length) {
        const o = t[0];
        this.currentValue = o.value, this.handleUpdateSelectValue(o.value, o.title);
      } else
        this.currentValue = "", this.handleUpdateSelectValue("", "");
      this.isChangeValueInTree = !0, this.$emit("update:modelValue", this.currentValue), this.$emit("on-change", this.currentValue), this.handleFormItemChange("change", this.currentValue);
    }, handleUpdateTreeNodes(t, r = !1) {
      t.forEach((o) => {
        this.valueToArray.indexOf(o.value) >= 0 ? (this.isCheckboxUsable ? o.checked = !0 : o.selected = !0, this.handleUpdateSelectValue(o.value, o.title)) : this.isCheckboxUsable ? o.checked = !1 : o.selected = !1, o.children && o.children.length && this.handleUpdateTreeNodes(o.children);
      }), r && (this.$refs.select.isFocused = !1);
    }, handleUpdateSelectValue(t, r) {
      t === "" ? this.$refs.select.reset() : (this.isValueChangeByTree = !0, this.$refs.select.onOptionClick({ value: t, label: r }));
    }, handleChange(t) {
      this.isValueChangeByTree ? this.isValueChangeByTree = !1 : (this.currentValue = t, this.isValueNull ? (this.isValueNull = !1, this.$emit("update:modelValue", null)) : this.$emit("update:modelValue", t), this.$emit("on-change", t), this.handleFormItemChange("change", t), this.$refs.select.reset(), this.handleUpdateTreeNodes(this.data, !0), e.nextTick(() => {
        this.isValueChangeByTree = !1;
      }));
    }, handleOpenChange(t) {
      this.$emit("on-open-change", t);
    } }, mounted() {
      this.handleUpdateTreeNodes(this.data, !0);
    } };
    function dI(t, r, o, C, g, a) {
      const x = e.resolveComponent("Tree"), O = e.resolveComponent("Select");
      return e.openBlock(), e.createBlock(O, e.mergeProps({ ref: "select" }, t.$attrs, { multiple: o.multiple, class: ["ivu-tree-select", a.classes], "transfer-class-name": a.transferClassName, onOnChange: a.handleChange, onOnOpenChange: a.handleOpenChange, hideNotFound: "", transfer: o.transfer }), { default: e.withCtx(() => [e.createVNode(x, { data: o.data, multiple: o.multiple, onOnSelectChange: a.handleSelectNode, onOnCheckChange: a.handleSelectNode, "check-strictly": "", "show-checkbox": o.multiple && o.showCheckbox, "check-directly": "", "load-data": o.loadData }, null, 8, ["data", "multiple", "onOnSelectChange", "onOnCheckChange", "show-checkbox", "load-data"])]), _: 1 }, 16, ["multiple", "class", "transfer-class-name", "onOnChange", "onOnOpenChange", "transfer"]);
    }
    var ly = f(hI, [["render", dI]]);
    const fI = { name: "Typography" }, pI = { class: "ivu-typography" };
    function mI(t, r, o, C, g, a) {
      return e.openBlock(), e.createElementBlock("article", pI, [e.renderSlot(t.$slots, "default")]);
    }
    var cy = f(fI, [["render", mI]]);
    const Fd = "ivu-upload", gI = { name: "UploadList", components: { Icon: G, iProgress: Pc }, emits: ["on-file-click", "on-file-preview", "on-file-remove"], props: { files: { type: Array, default() {
      return [];
    } } }, data() {
      return { prefixCls: Fd };
    }, methods: { fileCls(t) {
      return [`${Fd}-list-file`, { [`${Fd}-list-file-finish`]: t.status === "finished" }];
    }, handleClick(t) {
      this.$emit("on-file-click", t);
    }, handlePreview(t) {
      this.$emit("on-file-preview", t);
    }, handleRemove(t) {
      this.$emit("on-file-remove", t);
    }, format(t) {
      const r = t.name.split(".").pop().toLocaleLowerCase() || "";
      let o = "ios-document-outline";
      return ["gif", "jpg", "jpeg", "png", "bmp", "webp"].indexOf(r) > -1 && (o = "ios-image"), ["mp4", "m3u8", "rmvb", "avi", "swf", "3gp", "mkv", "flv"].indexOf(r) > -1 && (o = "ios-film"), ["mp3", "wav", "wma", "ogg", "aac", "flac"].indexOf(r) > -1 && (o = "ios-musical-notes"), ["doc", "txt", "docx", "pages", "epub", "pdf"].indexOf(r) > -1 && (o = "md-document"), ["numbers", "csv", "xls", "xlsx"].indexOf(r) > -1 && (o = "ios-stats"), ["keynote", "ppt", "pptx"].indexOf(r) > -1 && (o = "ios-videocam"), o;
    }, parsePercentage(t) {
      return parseInt(t, 10);
    } } }, vI = ["onClick"], yI = ["onClick"];
    function bI(t, r, o, C, g, a) {
      const x = e.resolveComponent("Icon"), O = e.resolveComponent("i-progress");
      return e.openBlock(), e.createElementBlock("ul", { class: e.normalizeClass([g.prefixCls + "-list"]) }, [(e.openBlock(!0), e.createElementBlock(e.Fragment, null, e.renderList(o.files, (P, N) => (e.openBlock(), e.createElementBlock("li", { key: N, class: e.normalizeClass(a.fileCls(P)), onClick: (B) => a.handleClick(P) }, [e.createElementVNode("span", { onClick: (B) => a.handlePreview(P) }, [e.createVNode(x, { type: a.format(P) }, null, 8, ["type"]), e.createTextVNode(" " + e.toDisplayString(P.name), 1)], 8, yI), e.withDirectives(e.createVNode(x, { type: "ios-close", class: e.normalizeClass([g.prefixCls + "-list-remove"]), onClick: (B) => a.handleRemove(P) }, null, 8, ["class", "onClick"]), [[e.vShow, P.status === "finished"]]), e.createVNode(e.Transition, { name: "fade" }, { default: e.withCtx(() => [P.showProgress ? (e.openBlock(), e.createBlock(O, { key: 0, "stroke-width": 2, percent: a.parsePercentage(P.percentage), status: P.status === "finished" && P.showProgress ? "success" : "normal" }, null, 8, ["percent", "status"])) : e.createCommentVNode("", !0)]), _: 2 }, 1024)], 10, vI))), 128))], 2);
    }
    var CI = f(gI, [["render", bI]]);
    function wI(t, r, o) {
      const C = `fail to post ${t} ${o.status}'`, g = new Error(C);
      return g.status = o.status, g.method = "post", g.url = t, g;
    }
    function uy(t) {
      const r = t.responseText || t.response;
      if (!r)
        return r;
      try {
        return JSON.parse(r);
      } catch {
        return r;
      }
    }
    function kI(t) {
      if (typeof XMLHttpRequest > "u")
        return;
      const r = new XMLHttpRequest(), o = t.action;
      r.upload && (r.upload.onprogress = function(a) {
        a.total > 0 && (a.percent = a.loaded / a.total * 100), t.onProgress(a);
      });
      const C = new FormData();
      t.data && Object.keys(t.data).map((a) => {
        C.append(a, t.data[a]);
      }), C.append(t.filename, t.file), r.onerror = function(a) {
        t.onError(a);
      }, r.onload = function() {
        if (r.status < 200 || r.status >= 300)
          return t.onError(wI(o, t, r), uy(r));
        t.onSuccess(uy(r));
      }, r.open("post", o, !0), t.withCredentials && "withCredentials" in r && (r.withCredentials = !0);
      const g = t.headers || {};
      for (let a in g)
        g.hasOwnProperty(a) && g[a] !== null && r.setRequestHeader(a, g[a]);
      r.send(C);
    }
    const Oa = "ivu-upload", SI = { name: "Upload", mixins: [nn], components: { UploadList: CI }, props: { action: { type: String, required: !0 }, headers: { type: Object, default() {
      return {};
    } }, multiple: { type: Boolean, default: !1 }, data: { type: Object }, name: { type: String, default: "file" }, withCredentials: { type: Boolean, default: !1 }, showUploadList: { type: Boolean, default: !0 }, type: { type: String, validator(t) {
      return z(t, ["select", "drag"]);
    }, default: "select" }, format: { type: Array, default() {
      return [];
    } }, accept: { type: String }, maxSize: { type: Number }, beforeUpload: Function, onProgress: { type: Function, default() {
      return {};
    } }, onSuccess: { type: Function, default() {
      return {};
    } }, onError: { type: Function, default() {
      return {};
    } }, onRemove: { type: Function, default() {
      return {};
    } }, onPreview: { type: Function, default() {
      return {};
    } }, onExceededSize: { type: Function, default() {
      return {};
    } }, onFormatError: { type: Function, default() {
      return {};
    } }, defaultFileList: { type: Array, default() {
      return [];
    } }, paste: { type: Boolean, default: !1 }, disabled: { type: Boolean, default: !1 }, webkitdirectory: { type: Boolean, default: !1 } }, data() {
      return { prefixCls: Oa, dragOver: !1, fileList: [], tempIndex: 1 };
    }, computed: { classes() {
      return [`${Oa}`, { [`${Oa}-select`]: this.type === "select", [`${Oa}-drag`]: this.type === "drag", [`${Oa}-dragOver`]: this.type === "drag" && this.dragOver }];
    } }, methods: { handleClick() {
      this.itemDisabled || this.$refs.input.click();
    }, handleChange(t) {
      const r = t.target.files;
      !r || (this.uploadFiles(r), this.$refs.input.value = null);
    }, onDrop(t) {
      this.dragOver = !1, !this.itemDisabled && this.uploadFiles(t.dataTransfer.files);
    }, handlePaste(t) {
      this.itemDisabled || this.paste && this.uploadFiles(t.clipboardData.files);
    }, uploadFiles(t) {
      let r = Array.prototype.slice.call(t);
      this.multiple || (r = r.slice(0, 1)), r.length !== 0 && r.forEach((o) => {
        this.upload(o);
      });
    }, upload(t) {
      if (!this.beforeUpload)
        return this.post(t);
      const r = this.beforeUpload(t);
      r && r.then ? r.then((o) => {
        Object.prototype.toString.call(o) === "[object File]" ? this.post(o) : this.post(t);
      }, () => {
      }) : r !== !1 && this.post(t);
    }, post(t) {
      if (this.format.length) {
        const r = t.name.split(".").pop().toLocaleLowerCase();
        if (!this.format.some((o) => o.toLocaleLowerCase() === r))
          return this.onFormatError(t, this.fileList), !1;
      }
      if (this.maxSize && t.size > this.maxSize * 1024)
        return this.onExceededSize(t, this.fileList), !1;
      this.handleStart(t), new FormData().append(this.name, t), kI({ headers: this.headers, withCredentials: this.withCredentials, file: t, data: this.data, filename: this.name, action: this.action, onProgress: (r) => {
        this.handleProgress(r, t);
      }, onSuccess: (r) => {
        this.handleSuccess(r, t);
      }, onError: (r, o) => {
        this.handleError(r, o, t);
      } });
    }, handleStart(t) {
      t.uid = Date.now() + this.tempIndex++;
      const r = { status: "uploading", name: t.name, size: t.size, percentage: 0, uid: t.uid, showProgress: !0 };
      this.fileList.push(r);
    }, getFile(t) {
      const r = this.fileList;
      let o;
      return r.every((C) => (o = t.uid === C.uid ? C : null, !o)), o;
    }, handleProgress(t, r) {
      const o = this.getFile(r);
      this.onProgress(t, o, this.fileList), o.percentage = t.percent || 0;
    }, handleSuccess(t, r) {
      const o = this.getFile(r);
      o && (o.status = "finished", o.response = t, this.onSuccess(t, o, this.fileList), this.handleFormItemChange("change", o), setTimeout(() => {
        o.showProgress = !1;
      }, 1e3));
    }, handleError(t, r, o) {
      const C = this.getFile(o), g = this.fileList;
      C.status = "fail", g.splice(g.indexOf(C), 1), this.onError(t, r, o);
    }, handleRemove(t) {
      const r = this.fileList;
      r.splice(r.indexOf(t), 1), this.onRemove(t, r);
    }, handlePreview(t) {
      t.status === "finished" && this.onPreview(t);
    }, clearFiles() {
      this.fileList = [];
    } }, watch: { defaultFileList: { immediate: !0, handler(t) {
      this.fileList = t.map((r) => (r.status = "finished", r.percentage = 100, r.uid = Date.now() + this.tempIndex++, r));
    } } } }, EI = ["multiple", "webkitdirectory", "accept"];
    function xI(t, r, o, C, g, a) {
      const x = e.resolveComponent("upload-list");
      return e.openBlock(), e.createElementBlock("div", { class: e.normalizeClass([g.prefixCls]) }, [e.createElementVNode("div", { class: e.normalizeClass(a.classes), onClick: r[1] || (r[1] = (...O) => a.handleClick && a.handleClick(...O)), onDrop: r[2] || (r[2] = e.withModifiers((...O) => a.onDrop && a.onDrop(...O), ["prevent"])), onPaste: r[3] || (r[3] = (...O) => a.handlePaste && a.handlePaste(...O)), onDragover: r[4] || (r[4] = e.withModifiers((O) => g.dragOver = !0, ["prevent"])), onDragleave: r[5] || (r[5] = e.withModifiers((O) => g.dragOver = !1, ["prevent"])) }, [e.createElementVNode("input", { ref: "input", type: "file", class: e.normalizeClass([g.prefixCls + "-input"]), onChange: r[0] || (r[0] = (...O) => a.handleChange && a.handleChange(...O)), multiple: o.multiple, webkitdirectory: o.webkitdirectory, accept: o.accept }, null, 42, EI), e.renderSlot(t.$slots, "default")], 34), e.renderSlot(t.$slots, "tip"), o.showUploadList ? (e.openBlock(), e.createBlock(x, { key: 0, files: g.fileList, onOnFileRemove: a.handleRemove, onOnFilePreview: a.handlePreview }, null, 8, ["files", "onOnFileRemove", "onOnFilePreview"])) : e.createCommentVNode("", !0)], 2);
    }
    var hy = f(SI, [["render", xI]]);
    const dy = { name: "UserName", mixins: [ia], data() {
      return { className: "ivu-login-username", prefix: "ios-contact-outline", placeholder: "请输入用户名", type: "text", validateMessage: "请输入用户名！" };
    } }, _I = { name: "WordCount", components: { Circle: ic }, props: { value: { type: [String, Number], default: "" }, total: { type: Number, default: 0 }, hideTotal: { type: Boolean, default: !1 }, overflow: { type: Boolean, default: !1 }, circle: { type: Boolean, default: !1 }, size: { type: [String, Number], default: 14 } }, computed: { isOverflow() {
      return this.value.length > this.total;
    }, percent() {
      let t = this.value.length / this.total * 100;
      return t > 100 && (t = 100), t;
    }, strokeColor() {
      return this.isOverflow ? "#ed4014" : "#2d8cf0";
    } } }, TI = { class: "ivu-word-count" }, OI = { key: 0, class: "ivu-word-count-prefix" }, DI = { key: 1, class: "ivu-word-count-prefix ivu-word-count-overflow" }, NI = { key: 3, class: "ivu-word-count-overflow" }, BI = { key: 5, class: "ivu-word-count-suffix" }, PI = { key: 6, class: "ivu-word-count-suffix ivu-word-count-overflow" };
    function VI(t, r, o, C, g, a) {
      const x = e.resolveComponent("Circle");
      return e.openBlock(), e.createElementBlock("div", TI, [o.circle ? (e.openBlock(), e.createBlock(x, { key: 0, percent: a.percent, size: o.size, "stroke-color": a.strokeColor }, null, 8, ["percent", "size", "stroke-color"])) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 1 }, [a.isOverflow ? (e.openBlock(), e.createElementBlock("span", DI, [e.renderSlot(t.$slots, "prefix-overflow")])) : (e.openBlock(), e.createElementBlock("span", OI, [e.renderSlot(t.$slots, "prefix")])), !a.isOverflow || !o.overflow ? (e.openBlock(), e.createElementBlock("span", { key: 2, class: e.normalizeClass({ "ivu-word-count-overflow": a.isOverflow }) }, [e.renderSlot(t.$slots, "length", { length: o.value.length }, () => [e.createTextVNode(e.toDisplayString(o.value.length), 1)])], 2)) : (e.openBlock(), e.createElementBlock("span", NI, e.toDisplayString(o.value.length - o.total), 1)), o.hideTotal ? e.createCommentVNode("", !0) : (e.openBlock(), e.createElementBlock(e.Fragment, { key: 4 }, [e.renderSlot(t.$slots, "separator", {}, () => [e.createTextVNode(" / ")]), e.renderSlot(t.$slots, "total", { total: o.total }, () => [e.createTextVNode(e.toDisplayString(o.total), 1)])], 64)), a.isOverflow ? (e.openBlock(), e.createElementBlock("span", PI, [e.renderSlot(t.$slots, "suffix-overflow")])) : (e.openBlock(), e.createElementBlock("span", BI, [e.renderSlot(t.$slots, "suffix")]))], 64))]);
    }
    var fy = f(_I, [["render", VI]]), py = Object.freeze(Object.defineProperty({ __proto__: null, Affix: V, Alert: te, Anchor: ge, AnchorLink: Ae, Auth: st, AutoComplete: Hm, Avatar: Jo, AvatarList: Ym, BackTop: Km, Badge: ql, Breadcrumb: Ph, BreadcrumbItem: Vh, Button: zn, ButtonGroup: $h, Calendar: ig, Captcha: ug, Card: dg, Carousel: fg, CarouselItem: pg, Cascader: mg, Cell: gg, CellGroup: vg, Checkbox: ro, CheckboxGroup: Uh, Circle: ic, City: wg, Col: Ii, Collapse: Sg, ColorPicker: Og, Content: Yh, Copy: lc, CountDown: Ig, CountUp: Mg, DatePicker: p0, Description: m0, DescriptionList: g0, Divider: mc, Drawer: v0, Dropdown: ys, DropdownItem: y0, DropdownMenu: bs, Ellipsis: b0, Email: C0, Exception: w0, Footer: ad, FooterToolbar: k0, Form: bc, FormItem: nc, GlobalFooter: S0, Grid: M0, GridItem: A0, Header: dd, Icon: G, Image: F0, ImagePreview: Br, Input: di, InputNumber: fd, Layout: z0, Link: U0, List: G0, ListItem: X0, ListItemMeta: q0, LoadingBar: md, Login: iv, Menu: vd, MenuGroup: rv, MenuItem: sv, Message: ua, Mobile: ov, Modal: pi, Notice: bd, Notification: vv, NotificationItem: Cv, NotificationTab: wv, NumberInfo: kv, Numeral: Ev, Option: Zs, OptionGroup: xv, Page: _v, PageHeader: Tv, Panel: Ov, Paragraph: Dv, Password: Nv, Poptip: Ed, Progress: Pc, Radio: Zl, RadioGroup: Ql, Rate: Bv, Result: Pv, Row: Er, Scroll: $v, ScrollIntoView: _d, ScrollTop: Td, Select: ps, Sider: Lv, Skeleton: zv, SkeletonItem: Od, Slider: Rv, Space: jv, Spin: ni, Split: Hv, Step: Wv, Steps: Yv, Submenu: Kv, Submit: Gv, Switch: Nd, Table: $c, TablePaste: qv, TabPane: Bc, Tabs: Dc, Tag: so, TagSelect: Jv, TagSelectOption: Qv, Text: Zv, Time: Nc, Timeline: ty, TimelineItem: ny, TimePicker: iy, Title: ry, Tooltip: tr, Transfer: ay, Tree: Ad, TreeSelect: ly, Trend: wd, Typography: cy, Upload: hy, UserName: dy, WordCount: fy }, Symbol.toStringTag, { value: "Module" })), $I = { mounted(t, r) {
      r.value && (fe(t, "ivu-line-clamp"), t.style["-webkit-line-clamp"] = r.value);
    }, updated(t, r) {
      r.value && (t.style["-webkit-line-clamp"] = r.value);
    }, unmounted(t) {
      Se(t, "ivu-line-clamp"), t.style["-webkit-line-clamp"] = null;
    } }, II = { mounted(t, r) {
      function o(C) {
        r.value(C);
      }
      t.__resizeHandler__ = o, t.__observer__ = ho(), t.__observer__.listenTo(t, o);
    }, updated() {
    }, unmounted(t, r) {
      t.__observer__.removeListener(t, t.__resizeHandler__), delete t.__resizeHandler__, delete t.__observer__;
    } };
    function Mr(t) {
      return String(t).endsWith("%") ? "" : "px";
    }
    var Ar = { display: { mounted(t, r) {
      r.value && (t.style.display = r.value);
    }, updated(t, r) {
      r.value && (t.style.display = r.value);
    }, unmounted(t) {
      t.style.display = null;
    } }, width: { mounted(t, r) {
      r.value && (t.style.width = r.value + Mr(r.value));
    }, updated(t, r) {
      r.value && (t.style.width = r.value + Mr(r.value));
    }, unmounted(t) {
      t.style.width = null;
    } }, height: { mounted(t, r) {
      r.value && (t.style.height = r.value + Mr(r.value));
    }, updated(t, r) {
      r.value && (t.style.height = r.value + Mr(r.value));
    }, unmounted(t) {
      t.style.height = null;
    } }, margin: { mounted(t, r) {
      r.value && (t.style.margin = r.value + Mr(r.value));
    }, updated(t, r) {
      r.value && (t.style.margin = r.value + Mr(r.value));
    }, unmounted(t) {
      t.style.margin = null;
    } }, padding: { mounted(t, r) {
      r.value && (t.style.padding = r.value + Mr(r.value));
    }, updated(t, r) {
      r.value && (t.style.padding = r.value + Mr(r.value));
    }, unmounted(t) {
      t.style.padding = null;
    } }, font: { mounted(t, r) {
      r && r.value && (t.style.fontSize = `${r.value}px`);
    }, updated(t, r) {
      r && r.value && (t.style.fontSize = `${r.value}px`);
    }, unmounted(t) {
      t.style.fontSize = null;
    } }, color: { mounted(t, r) {
      r.value && (t.style.color = r.value);
    }, updated(t, r) {
      r.value && (t.style.color = r.value);
    }, unmounted(t) {
      t.style.color = null;
    } }, bgColor: { mounted(t, r) {
      r.value && (t.style.backgroundColor = r.value);
    }, updated(t, r) {
      r.value && (t.style.backgroundColor = r.value);
    }, unmounted(t) {
      t.style.backgroundColor = null;
    } } }, MI = { name: "view-ui-plus", version: "1.3.14", title: "ViewUIPlus", description: "A high quality UI components Library with Vue.js 3", homepage: "http://www.iviewui.com", keywords: ["iview", "vue", "viewui", "viewuiplus", "vue.js", "component", "components", "ui", "framework"], main: "dist/viewuiplus.min.js", typings: "types/index.d.ts", files: ["dist", "src", "types"], scripts: { dev: "vue-cli-service serve", build: "npm run build:prod && npm run build:style && npm run build:lang", "build:style": "gulp --gulpfile build/build-style.js", "build:prod": "vite build", "build:lang": "vite build --config build/vite.lang.config.js", lint: "vue-cli-service lint --fix" }, repository: { type: "git", url: "https://github.com/view-design/ViewUIPlus" }, author: "Aresn", license: "MIT", bugs: { url: "https://github.com/view-design/ViewUIPlus/issues" }, dependencies: { "async-validator": "^3.3.0", "countup.js": "^1.9.3", dayjs: "^1.11.0", deepmerge: "^2.2.1", "element-resize-detector": "^1.2.0", "js-calendar": "^1.2.3", "lodash.chunk": "^4.2.0", "lodash.throttle": "^4.1.1", numeral: "^2.0.6", "popper.js": "^1.14.6", select: "^1.1.2", tinycolor2: "^1.4.1", "v-click-outside-x": "^3.7.1" }, devDependencies: { "@vitejs/plugin-vue": "^1.9.3", "@vue/cli-plugin-babel": "~4.5.0", "@vue/cli-plugin-eslint": "~4.5.0", "@vue/cli-service": "~4.5.0", "@vue/compiler-sfc": "^3.0.0", "babel-eslint": "^10.1.0", "babel-plugin-import": "^1.13.3", chai: "^4.2.0", "copy-webpack-plugin": "^6.4.1", "cross-env": "^5.2.0", eslint: "^6.7.2", "eslint-plugin-vue": "^7.0.0-0", gulp: "^4.0.2", "gulp-autoprefixer": "^8.0.0", "gulp-clean-css": "^4.3.0", "gulp-less": "^4.0.1", "gulp-rename": "^2.0.0", karma: "^2.0.5", "karma-chrome-launcher": "^2.2.0", "karma-coverage": "^1.1.1", "karma-mocha": "^1.3.0", "karma-sinon-chai": "^1.3.3", "karma-sourcemap-loader": "^0.3.7", "karma-spec-reporter": "^0.0.32", "karma-webpack": "^2.0.13", less: "^2.7.3", "less-loader": "^4.1.0", "lint-staged": "^10.5.4", lolex: "^2.7.5", mocha: "^5.0.4", sinon: "^4.4.2", "sinon-chai": "^3.3.0", "style-loader": "^0.20.2", tslint: "^5.14.0", typescript: "^3.3.4000", "uglifyjs-webpack-plugin": "^1.3.0", "url-loader": "^1.1.2", vite: "^2.6.4", vue: "^3.2.47", "vue-hot-reload-api": "^2.3.4", "vue-html-loader": "^1.2.4", "vue-loader": "^17.0.0", "vue-router": "^4.0.14", "vue-style-loader": "^4.1.3", "vue-template-compiler": "^2.6.14" } };
    const my = { display: Ar.display, width: Ar.width, height: Ar.height, margin: Ar.margin, padding: Ar.padding, font: Ar.font, color: Ar.color, "bg-color": Ar.bgColor, resize: II, "line-clamp": $I }, gy = v(p({}, py), { iButton: zn, iCircle: ic, iCol: Ii, iContent: Yh, iForm: bc, iFooter: ad, iHeader: dd, iInput: di, iMenu: vd, iOption: Zs, iProgress: Pc, iSelect: ps, iSwitch: Nd, iTable: $c, iTime: Nc }), Ld = function(t, r = {}) {
      Ld.installed || (r.locale && Go.use(r.locale), r.i18n && Go.i18n(r.i18n), Object.keys(gy).forEach((o) => {
        t.component(o, gy[o]);
      }), Object.keys(my).forEach((o) => {
        t.directive(o, my[o]);
      }), t.config.globalProperties.$VIEWUI = { size: r.size || "", capture: "capture" in r ? r.capture : !0, transfer: "transfer" in r ? r.transfer : "", cell: { arrow: r.cell && r.cell.arrow ? r.cell.arrow : "", customArrow: r.cell && r.cell.customArrow ? r.cell.customArrow : "", arrowSize: r.cell && r.cell.arrowSize ? r.cell.arrowSize : "" }, menu: { arrow: r.menu && r.menu.arrow ? r.menu.arrow : "", customArrow: r.menu && r.menu.customArrow ? r.menu.customArrow : "", arrowSize: r.menu && r.menu.arrowSize ? r.menu.arrowSize : "" }, modal: { maskClosable: r.modal && "maskClosable" in r.modal ? r.modal.maskClosable : "" }, tabs: { closeIcon: r.tabs && r.tabs.closeIcon ? r.tabs.closeIcon : "", customCloseIcon: r.tabs && r.tabs.customCloseIcon ? r.tabs.customCloseIcon : "", closeIconSize: r.tabs && r.tabs.closeIconSize ? r.tabs.closeIconSize : "" }, select: { arrow: r.select && r.select.arrow ? r.select.arrow : "", customArrow: r.select && r.select.customArrow ? r.select.customArrow : "", arrowSize: r.select && r.select.arrowSize ? r.select.arrowSize : "" }, colorPicker: { arrow: r.colorPicker && r.colorPicker.arrow ? r.colorPicker.arrow : "", customArrow: r.colorPicker && r.colorPicker.customArrow ? r.colorPicker.customArrow : "", arrowSize: r.colorPicker && r.colorPicker.arrowSize ? r.colorPicker.arrowSize : "" }, cascader: { arrow: r.cascader && r.cascader.arrow ? r.cascader.arrow : "", customArrow: r.cascader && r.cascader.customArrow ? r.cascader.customArrow : "", arrowSize: r.cascader && r.cascader.arrowSize ? r.cascader.arrowSize : "", itemArrow: r.cascader && r.cascader.itemArrow ? r.cascader.itemArrow : "", customItemArrow: r.cascader && r.cascader.customItemArrow ? r.cascader.customItemArrow : "", itemArrowSize: r.cascader && r.cascader.itemArrowSize ? r.cascader.itemArrowSize : "" }, tree: { arrow: r.tree && r.tree.arrow ? r.tree.arrow : "", customArrow: r.tree && r.tree.customArrow ? r.tree.customArrow : "", arrowSize: r.tree && r.tree.arrowSize ? r.tree.arrowSize : "" }, datePicker: { icon: r.datePicker && r.datePicker.icon ? r.datePicker.icon : "", customIcon: r.datePicker && r.datePicker.customIcon ? r.datePicker.customIcon : "", iconSize: r.datePicker && r.datePicker.iconSize ? r.datePicker.iconSize : "" }, timePicker: { icon: r.timePicker && r.timePicker.icon ? r.timePicker.icon : "", customIcon: r.timePicker && r.timePicker.customIcon ? r.timePicker.customIcon : "", iconSize: r.timePicker && r.timePicker.iconSize ? r.timePicker.iconSize : "" }, typography: { copyConfig: r.typography && r.typography.copyConfig ? r.typography.copyConfig : "", editConfig: r.typography && r.typography.editConfig ? r.typography.editConfig : "", ellipsisConfig: r.typography && r.typography.ellipsisConfig ? r.typography.ellipsisConfig : "" }, space: { size: r.space && r.space.size ? r.space.size : "" }, image: { toolbar: r.image && r.image.toolbar ? r.image.toolbar : "" } }, t.config.globalProperties.$Spin = ni, t.config.globalProperties.$Loading = md, t.config.globalProperties.$Message = ua, t.config.globalProperties.$Notice = bd, t.config.globalProperties.$Modal = pi, t.config.globalProperties.$ImagePreview = Br, t.config.globalProperties.$Copy = lc, t.config.globalProperties.$ScrollIntoView = _d, t.config.globalProperties.$ScrollTop = Td, t.config.globalProperties.$Date = Zn);
    }, vy = MI.version, yy = Go.use, by = Go.i18n, Cy = (t) => {
      const r = window["viewuiplus/locale"].default;
      t === r.i.locale ? Go.use(r) : console.log(`The ${t} language pack is not loaded.`);
    }, AI = p({ version: vy, locale: yy, i18n: by, install: Ld, lang: Cy }, py);
    c.Affix = V, c.Alert = te, c.Anchor = ge, c.AnchorLink = Ae, c.Auth = st, c.AutoComplete = Hm, c.Avatar = Jo, c.AvatarList = Ym, c.BackTop = Km, c.Badge = ql, c.Breadcrumb = Ph, c.BreadcrumbItem = Vh, c.Button = zn, c.ButtonGroup = $h, c.Calendar = ig, c.Captcha = ug, c.Card = dg, c.Carousel = fg, c.CarouselItem = pg, c.Cascader = mg, c.Cell = gg, c.CellGroup = vg, c.Checkbox = ro, c.CheckboxGroup = Uh, c.Circle = ic, c.City = wg, c.Col = Ii, c.Collapse = Sg, c.ColorPicker = Og, c.Content = Yh, c.Copy = lc, c.CountDown = Ig, c.CountUp = Mg, c.DatePicker = p0, c.Description = m0, c.DescriptionList = g0, c.Divider = mc, c.Drawer = v0, c.Dropdown = ys, c.DropdownItem = y0, c.DropdownMenu = bs, c.Ellipsis = b0, c.Email = C0, c.Exception = w0, c.Footer = ad, c.FooterToolbar = k0, c.Form = bc, c.FormItem = nc, c.GlobalFooter = S0, c.Grid = M0, c.GridItem = A0, c.Header = dd, c.Icon = G, c.Image = F0, c.ImagePreview = Br, c.Input = di, c.InputNumber = fd, c.Layout = z0, c.Link = U0, c.List = G0, c.ListItem = X0, c.ListItemMeta = q0, c.LoadingBar = md, c.Login = iv, c.Menu = vd, c.MenuGroup = rv, c.MenuItem = sv, c.Message = ua, c.Mobile = ov, c.Modal = pi, c.Notice = bd, c.Notification = vv, c.NotificationItem = Cv, c.NotificationTab = wv, c.NumberInfo = kv, c.Numeral = Ev, c.Option = Zs, c.OptionGroup = xv, c.Page = _v, c.PageHeader = Tv, c.Panel = Ov, c.Paragraph = Dv, c.Password = Nv, c.Poptip = Ed, c.Progress = Pc, c.Radio = Zl, c.RadioGroup = Ql, c.Rate = Bv, c.Result = Pv, c.Row = Er, c.Scroll = $v, c.ScrollIntoView = _d, c.ScrollTop = Td, c.Select = ps, c.Sider = Lv, c.Skeleton = zv, c.SkeletonItem = Od, c.Slider = Rv, c.Space = jv, c.Spin = ni, c.Split = Hv, c.Step = Wv, c.Steps = Yv, c.Submenu = Kv, c.Submit = Gv, c.Switch = Nd, c.TabPane = Bc, c.Table = $c, c.TablePaste = qv, c.Tabs = Dc, c.Tag = so, c.TagSelect = Jv, c.TagSelectOption = Qv, c.Text = Zv, c.Time = Nc, c.TimePicker = iy, c.Timeline = ty, c.TimelineItem = ny, c.Title = ry, c.Tooltip = tr, c.Transfer = ay, c.Tree = Ad, c.TreeSelect = ly, c.Trend = wd, c.Typography = cy, c.Upload = hy, c.UserName = dy, c.WordCount = fy, c.default = AI, c.i18n = by, c.install = Ld, c.lang = Cy, c.locale = yy, c.version = vy, Object.defineProperties(c, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  });
})(Zf, Zf.exports);
var Fb = Zf.exports;
function Pk(i) {
  return N4(i).promise.value;
}
function Vk(i) {
  return new Promise((n) => {
    const { onChange: s, open: u } = A4(i);
    s((y) => {
      n(y);
    }), u();
  });
}
function F4(i) {
  return new Promise((n) => {
    const s = document.createElement("img");
    s.src = i, document.body.appendChild(s), s.onload = () => {
      n(s);
    };
  });
}
const $k = async (i, n) => {
  try {
    await P4({ source: i, ...n }).copy(), Fb.Message.success("复制成功");
  } catch (s) {
    throw Fb.Message.error("复制失败"), s;
  }
}, J8 = {
  getImgStr: Pk,
  selectFiles: Vk,
  insertImgFile: F4,
  clipboardText: $k
};
var Ne = {};
const L4 = {}, z4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: L4
}, Symbol.toStringTag, { value: "Module" })), uf = /* @__PURE__ */ Vu(z4);
(function(i) {
  /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
  var n = n || { version: "5.3.0" };
  if (i.fabric = n, typeof document < "u" && typeof window < "u")
    document instanceof (typeof HTMLDocument < "u" ? HTMLDocument : Document) ? n.document = document : n.document = document.implementation.createHTMLDocument(""), n.window = window;
  else {
    var s = uf, u = new s.JSDOM(
      decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"),
      {
        features: {
          FetchExternalResources: ["img"]
        },
        resources: "usable"
      }
    ).window;
    n.document = u.document, n.jsdomImplForWrapper = uf.implForWrapper, n.nodeCanvas = uf.Canvas, n.window = u, DOMParser = n.window.DOMParser;
  }
  n.isTouchSupported = "ontouchstart" in n.window || "ontouchstart" in n.document || n.window && n.window.navigator && n.window.navigator.maxTouchPoints > 0, n.isLikelyNode = typeof Buffer < "u" && typeof window > "u", n.SHARED_ATTRIBUTES = [
    "display",
    "transform",
    "fill",
    "fill-opacity",
    "fill-rule",
    "opacity",
    "stroke",
    "stroke-dasharray",
    "stroke-linecap",
    "stroke-dashoffset",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width",
    "id",
    "paint-order",
    "vector-effect",
    "instantiated_by_use",
    "clip-path"
  ], n.DPI = 96, n.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", n.commaWsp = "(?:\\s+,?\\s*|,\\s*)", n.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig, n.reNonWord = /[ \n\.,;!\?\-]/, n.fontPaths = {}, n.iMatrix = [1, 0, 0, 1, 0, 0], n.svgNS = "http://www.w3.org/2000/svg", n.perfLimitSizeTotal = 2097152, n.maxCacheSideLimit = 4096, n.minCacheSideLimit = 256, n.charWidthsCache = {}, n.textureSize = 2048, n.disableStyleCopyPaste = !1, n.enableGLFiltering = !0, n.devicePixelRatio = n.window.devicePixelRatio || n.window.webkitDevicePixelRatio || n.window.mozDevicePixelRatio || 1, n.browserShadowBlurConstant = 1, n.arcToSegmentsCache = {}, n.boundsOfCurveCache = {}, n.cachesBoundsOfCurve = !0, n.forceGLPutImageData = !1, n.initFilterBackend = function() {
    if (n.enableGLFiltering && n.isWebglSupported && n.isWebglSupported(n.textureSize))
      return console.log("max texture size: " + n.maxTextureSize), new n.WebglFilterBackend({ tileSize: n.textureSize });
    if (n.Canvas2dFilterBackend)
      return new n.Canvas2dFilterBackend();
  }, typeof document < "u" && typeof window < "u" && (window.fabric = n), function() {
    function d(h, m) {
      if (this.__eventListeners[h]) {
        var b = this.__eventListeners[h];
        m ? b[b.indexOf(m)] = !1 : n.util.array.fill(b, !1);
      }
    }
    function l(h, m) {
      if (this.__eventListeners || (this.__eventListeners = {}), arguments.length === 1)
        for (var b in h)
          this.on(b, h[b]);
      else
        this.__eventListeners[h] || (this.__eventListeners[h] = []), this.__eventListeners[h].push(m);
      return this;
    }
    function p(h, m) {
      var b = (function() {
        m.apply(this, arguments), this.off(h, b);
      }).bind(this);
      this.on(h, b);
    }
    function v(h, m) {
      if (arguments.length === 1)
        for (var b in h)
          p.call(this, b, h[b]);
      else
        p.call(this, h, m);
      return this;
    }
    function c(h, m) {
      if (!this.__eventListeners)
        return this;
      if (arguments.length === 0)
        for (h in this.__eventListeners)
          d.call(this, h);
      else if (arguments.length === 1 && typeof arguments[0] == "object")
        for (var b in h)
          d.call(this, b, h[b]);
      else
        d.call(this, h, m);
      return this;
    }
    function e(h, m) {
      if (!this.__eventListeners)
        return this;
      var b = this.__eventListeners[h];
      if (!b)
        return this;
      for (var f = 0, k = b.length; f < k; f++)
        b[f] && b[f].call(this, m || {});
      return this.__eventListeners[h] = b.filter(function(E) {
        return E !== !1;
      }), this;
    }
    n.Observable = {
      fire: e,
      on: l,
      once: v,
      off: c
    };
  }(), n.Collection = {
    _objects: [],
    /**
     * Adds objects to collection, Canvas or Group, then renders canvas
     * (if `renderOnAddRemove` is not `false`).
     * in case of Group no changes to bounding box are made.
     * Objects should be instances of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the add method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    add: function() {
      if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded)
        for (var d = 0, l = arguments.length; d < l; d++)
          this._onObjectAdded(arguments[d]);
      return this.renderOnAddRemove && this.requestRenderAll(), this;
    },
    /**
     * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
     * An object should be an instance of (or inherit from) fabric.Object
     * Use of this function is highly discouraged for groups.
     * you can add a bunch of objects with the insertAt method but then you NEED
     * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
     * @param {Object} object Object to insert
     * @param {Number} index Index to insert object at
     * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
     * @return {Self} thisArg
     * @chainable
     */
    insertAt: function(d, l, p) {
      var v = this._objects;
      return p ? v[l] = d : v.splice(l, 0, d), this._onObjectAdded && this._onObjectAdded(d), this.renderOnAddRemove && this.requestRenderAll(), this;
    },
    /**
     * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
     * @param {...fabric.Object} object Zero or more fabric instances
     * @return {Self} thisArg
     * @chainable
     */
    remove: function() {
      for (var d = this._objects, l, p = !1, v = 0, c = arguments.length; v < c; v++)
        l = d.indexOf(arguments[v]), l !== -1 && (p = !0, d.splice(l, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[v]));
      return this.renderOnAddRemove && p && this.requestRenderAll(), this;
    },
    /**
     * Executes given function for each object in this group
     * @param {Function} callback
     *                   Callback invoked with current object as first argument,
     *                   index - as second and an array of all objects - as third.
     *                   Callback is invoked in a context of Global Object (e.g. `window`)
     *                   when no `context` argument is given
     *
     * @param {Object} context Context (aka thisObject)
     * @return {Self} thisArg
     * @chainable
     */
    forEachObject: function(d, l) {
      for (var p = this.getObjects(), v = 0, c = p.length; v < c; v++)
        d.call(l, p[v], v, p);
      return this;
    },
    /**
     * Returns an array of children objects of this instance
     * Type parameter introduced in 1.3.10
     * since 2.3.5 this method return always a COPY of the array;
     * @param {String} [type] When specified, only objects of this type are returned
     * @return {Array}
     */
    getObjects: function(d) {
      return typeof d > "u" ? this._objects.concat() : this._objects.filter(function(l) {
        return l.type === d;
      });
    },
    /**
     * Returns object at specified index
     * @param {Number} index
     * @return {Self} thisArg
     */
    item: function(d) {
      return this._objects[d];
    },
    /**
     * Returns true if collection contains no objects
     * @return {Boolean} true if collection is empty
     */
    isEmpty: function() {
      return this._objects.length === 0;
    },
    /**
     * Returns a size of a collection (i.e: length of an array containing its objects)
     * @return {Number} Collection size
     */
    size: function() {
      return this._objects.length;
    },
    /**
     * Returns true if collection contains an object
     * @param {Object} object Object to check against
     * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`
     * @return {Boolean} `true` if collection contains an object
     */
    contains: function(d, l) {
      return this._objects.indexOf(d) > -1 ? !0 : l ? this._objects.some(function(p) {
        return typeof p.contains == "function" && p.contains(d, !0);
      }) : !1;
    },
    /**
     * Returns number representation of a collection complexity
     * @return {Number} complexity
     */
    complexity: function() {
      return this._objects.reduce(function(d, l) {
        return d += l.complexity ? l.complexity() : 0, d;
      }, 0);
    }
  }, n.CommonMethods = {
    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    _setOptions: function(d) {
      for (var l in d)
        this.set(l, d[l]);
    },
    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Gradient to
     */
    _initGradient: function(d, l) {
      d && d.colorStops && !(d instanceof n.Gradient) && this.set(l, new n.Gradient(d));
    },
    /**
     * @private
     * @param {Object} [filler] Options object
     * @param {String} [property] property to set the Pattern to
     * @param {Function} [callback] callback to invoke after pattern load
     */
    _initPattern: function(d, l, p) {
      d && d.source && !(d instanceof n.Pattern) ? this.set(l, new n.Pattern(d, p)) : p && p();
    },
    /**
     * @private
     */
    _setObject: function(d) {
      for (var l in d)
        this._set(l, d[l]);
    },
    /**
     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    set: function(d, l) {
      return typeof d == "object" ? this._setObject(d) : this._set(d, l), this;
    },
    _set: function(d, l) {
      this[d] = l;
    },
    /**
     * Toggles specified property from `true` to `false` or from `false` to `true`
     * @param {String} property Property to toggle
     * @return {fabric.Object} thisArg
     * @chainable
     */
    toggle: function(d) {
      var l = this.get(d);
      return typeof l == "boolean" && this.set(d, !l), this;
    },
    /**
     * Basic getter
     * @param {String} property Property name
     * @return {*} value of a property
     */
    get: function(d) {
      return this[d];
    }
  }, function(d) {
    var l = Math.sqrt, p = Math.atan2, v = Math.pow, c = Math.PI / 180, e = Math.PI / 2;
    n.util = {
      /**
       * Calculate the cos of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      cos: function(h) {
        if (h === 0)
          return 1;
        h < 0 && (h = -h);
        var m = h / e;
        switch (m) {
          case 1:
          case 3:
            return 0;
          case 2:
            return -1;
        }
        return Math.cos(h);
      },
      /**
       * Calculate the sin of an angle, avoiding returning floats for known results
       * @static
       * @memberOf fabric.util
       * @param {Number} angle the angle in radians or in degree
       * @return {Number}
       */
      sin: function(h) {
        if (h === 0)
          return 0;
        var m = h / e, b = 1;
        switch (h < 0 && (b = -1), m) {
          case 1:
            return b;
          case 2:
            return 0;
          case 3:
            return -b;
        }
        return Math.sin(h);
      },
      /**
       * Removes value from an array.
       * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
       * @static
       * @memberOf fabric.util
       * @param {Array} array
       * @param {*} value
       * @return {Array} original array
       */
      removeFromArray: function(h, m) {
        var b = h.indexOf(m);
        return b !== -1 && h.splice(b, 1), h;
      },
      /**
       * Returns random number between 2 specified ones.
       * @static
       * @memberOf fabric.util
       * @param {Number} min lower limit
       * @param {Number} max upper limit
       * @return {Number} random value (between min and max)
       */
      getRandomInt: function(h, m) {
        return Math.floor(Math.random() * (m - h + 1)) + h;
      },
      /**
       * Transforms degrees to radians.
       * @static
       * @memberOf fabric.util
       * @param {Number} degrees value in degrees
       * @return {Number} value in radians
       */
      degreesToRadians: function(h) {
        return h * c;
      },
      /**
       * Transforms radians to degrees.
       * @static
       * @memberOf fabric.util
       * @param {Number} radians value in radians
       * @return {Number} value in degrees
       */
      radiansToDegrees: function(h) {
        return h / c;
      },
      /**
       * Rotates `point` around `origin` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {fabric.Point} point The point to rotate
       * @param {fabric.Point} origin The origin of the rotation
       * @param {Number} radians The radians of the angle for the rotation
       * @return {fabric.Point} The new rotated point
       */
      rotatePoint: function(h, m, b) {
        var f = new n.Point(h.x - m.x, h.y - m.y), k = n.util.rotateVector(f, b);
        return new n.Point(k.x, k.y).addEquals(m);
      },
      /**
       * Rotates `vector` with `radians`
       * @static
       * @memberOf fabric.util
       * @param {Object} vector The vector to rotate (x and y)
       * @param {Number} radians The radians of the angle for the rotation
       * @return {Object} The new rotated point
       */
      rotateVector: function(h, m) {
        var b = n.util.sin(m), f = n.util.cos(m), k = h.x * f - h.y * b, E = h.x * b + h.y * f;
        return {
          x: k,
          y: E
        };
      },
      /**
       * Creates a vetor from points represented as a point
       * @static
       * @memberOf fabric.util
       *
       * @typedef {Object} Point
       * @property {number} x
       * @property {number} y
       *
       * @param {Point} from
       * @param {Point} to
       * @returns {Point} vector
       */
      createVector: function(h, m) {
        return new n.Point(m.x - h.x, m.y - h.y);
      },
      /**
       * Calculates angle between 2 vectors using dot product
       * @static
       * @memberOf fabric.util
       * @param {Point} a
       * @param {Point} b
       * @returns the angle in radian between the vectors
       */
      calcAngleBetweenVectors: function(h, m) {
        return Math.acos((h.x * m.x + h.y * m.y) / (Math.hypot(h.x, h.y) * Math.hypot(m.x, m.y)));
      },
      /**
       * @static
       * @memberOf fabric.util
       * @param {Point} v
       * @returns {Point} vector representing the unit vector of pointing to the direction of `v`
       */
      getHatVector: function(h) {
        return new n.Point(h.x, h.y).multiply(1 / Math.hypot(h.x, h.y));
      },
      /**
       * @static
       * @memberOf fabric.util
       * @param {Point} A
       * @param {Point} B
       * @param {Point} C
       * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle
       */
      getBisector: function(h, m, b) {
        var f = n.util.createVector(h, m), k = n.util.createVector(h, b), E = n.util.calcAngleBetweenVectors(f, k), _ = n.util.calcAngleBetweenVectors(n.util.rotateVector(f, E), k), T = E * (_ === 0 ? 1 : -1) / 2;
        return {
          vector: n.util.getHatVector(n.util.rotateVector(f, T)),
          angle: E
        };
      },
      /**
       * Project stroke width on points returning 2 projections for each point as follows:
       * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.
       * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.
       * - `round`: same as `bevel`
       * Used to calculate object's bounding box
       * @static
       * @memberOf fabric.util
       * @param {Point[]} points
       * @param {Object} options
       * @param {number} options.strokeWidth
       * @param {'miter'|'bevel'|'round'} options.strokeLineJoin
       * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit
       * @param {boolean} options.strokeUniform
       * @param {number} options.scaleX
       * @param {number} options.scaleY
       * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points
       * @returns {fabric.Point[]} array of size 2n/4n of all suspected points
       */
      projectStrokeOnPoints: function(h, m, b) {
        var f = [], k = m.strokeWidth / 2, E = m.strokeUniform ? new n.Point(1 / m.scaleX, 1 / m.scaleY) : new n.Point(1, 1), _ = function(T) {
          var D = k / Math.hypot(T.x, T.y);
          return new n.Point(T.x * D * E.x, T.y * D * E.y);
        };
        return h.length <= 1 || h.forEach(function(T, D) {
          var V = new n.Point(T.x, T.y), I, M;
          D === 0 ? (M = h[D + 1], I = b ? _(n.util.createVector(M, V)).addEquals(V) : h[h.length - 1]) : D === h.length - 1 ? (I = h[D - 1], M = b ? _(n.util.createVector(I, V)).addEquals(V) : h[0]) : (I = h[D - 1], M = h[D + 1]);
          var Q = n.util.getBisector(V, I, M), G = Q.vector, z = Q.angle, re, he;
          if (m.strokeLineJoin === "miter" && (re = -k / Math.sin(z / 2), he = new n.Point(
            G.x * re * E.x,
            G.y * re * E.y
          ), Math.hypot(he.x, he.y) / k <= m.strokeMiterLimit)) {
            f.push(V.add(he)), f.push(V.subtract(he));
            return;
          }
          re = -k * Math.SQRT2, he = new n.Point(
            G.x * re * E.x,
            G.y * re * E.y
          ), f.push(V.add(he)), f.push(V.subtract(he));
        }), f;
      },
      /**
       * Apply transform t to point p
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Point} p The point to transform
       * @param  {Array} t The transform
       * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
       * @return {fabric.Point} The transformed point
       */
      transformPoint: function(h, m, b) {
        return b ? new n.Point(
          m[0] * h.x + m[2] * h.y,
          m[1] * h.x + m[3] * h.y
        ) : new n.Point(
          m[0] * h.x + m[2] * h.y + m[4],
          m[1] * h.x + m[3] * h.y + m[5]
        );
      },
      /**
       * Returns coordinates of points's bounding rectangle (left, top, width, height)
       * @param {Array} points 4 points array
       * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
       * @return {Object} Object with left, top, width, height properties
       */
      makeBoundingBoxFromPoints: function(h, m) {
        if (m)
          for (var b = 0; b < h.length; b++)
            h[b] = n.util.transformPoint(h[b], m);
        var f = [h[0].x, h[1].x, h[2].x, h[3].x], k = n.util.array.min(f), E = n.util.array.max(f), _ = E - k, T = [h[0].y, h[1].y, h[2].y, h[3].y], D = n.util.array.min(T), V = n.util.array.max(T), I = V - D;
        return {
          left: k,
          top: D,
          width: _,
          height: I
        };
      },
      /**
       * Invert transformation t
       * @static
       * @memberOf fabric.util
       * @param {Array} t The transform
       * @return {Array} The inverted transform
       */
      invertTransform: function(h) {
        var m = 1 / (h[0] * h[3] - h[1] * h[2]), b = [m * h[3], -m * h[1], -m * h[2], m * h[0]], f = n.util.transformPoint({ x: h[4], y: h[5] }, b, !0);
        return b[4] = -f.x, b[5] = -f.y, b;
      },
      /**
       * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
       * @static
       * @memberOf fabric.util
       * @param {Number|String} number number to operate on
       * @param {Number} fractionDigits number of fraction digits to "leave"
       * @return {Number}
       */
      toFixed: function(h, m) {
        return parseFloat(Number(h).toFixed(m));
      },
      /**
       * Converts from attribute value to pixel value if applicable.
       * Returns converted pixels or original value not converted.
       * @param {Number|String} value number to operate on
       * @param {Number} fontSize
       * @return {Number|String}
       */
      parseUnit: function(h, m) {
        var b = /\D{0,2}$/.exec(h), f = parseFloat(h);
        switch (m || (m = n.Text.DEFAULT_SVG_FONT_SIZE), b[0]) {
          case "mm":
            return f * n.DPI / 25.4;
          case "cm":
            return f * n.DPI / 2.54;
          case "in":
            return f * n.DPI;
          case "pt":
            return f * n.DPI / 72;
          case "pc":
            return f * n.DPI / 72 * 12;
          case "em":
            return f * m;
          default:
            return f;
        }
      },
      /**
       * Function which always returns `false`.
       * @static
       * @memberOf fabric.util
       * @return {Boolean}
       */
      falseFunction: function() {
        return !1;
      },
      /**
       * Returns klass "Class" object of given namespace
       * @memberOf fabric.util
       * @param {String} type Type of object (eg. 'circle')
       * @param {String} namespace Namespace to get klass "Class" object from
       * @return {Object} klass "Class"
       */
      getKlass: function(h, m) {
        return h = n.util.string.camelize(h.charAt(0).toUpperCase() + h.slice(1)), n.util.resolveNamespace(m)[h];
      },
      /**
       * Returns array of attributes for given svg that fabric parses
       * @memberOf fabric.util
       * @param {String} type Type of svg element (eg. 'circle')
       * @return {Array} string names of supported attributes
       */
      getSvgAttributes: function(h) {
        var m = [
          "instantiated_by_use",
          "style",
          "id",
          "class"
        ];
        switch (h) {
          case "linearGradient":
            m = m.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
            break;
          case "radialGradient":
            m = m.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
            break;
          case "stop":
            m = m.concat(["offset", "stop-color", "stop-opacity"]);
            break;
        }
        return m;
      },
      /**
       * Returns object of given namespace
       * @memberOf fabric.util
       * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
       * @return {Object} Object for given namespace (default fabric)
       */
      resolveNamespace: function(h) {
        if (!h)
          return n;
        var m = h.split("."), b = m.length, f, k = d || n.window;
        for (f = 0; f < b; ++f)
          k = k[m[f]];
        return k;
      },
      /**
       * Loads image element from given url and passes it to a callback
       * @memberOf fabric.util
       * @param {String} url URL representing an image
       * @param {Function} callback Callback; invoked with loaded image
       * @param {*} [context] Context to invoke callback in
       * @param {Object} [crossOrigin] crossOrigin value to set image element to
       */
      loadImage: function(h, m, b, f) {
        if (!h) {
          m && m.call(b, h);
          return;
        }
        var k = n.util.createImage(), E = function() {
          m && m.call(b, k, !1), k = k.onload = k.onerror = null;
        };
        k.onload = E, k.onerror = function() {
          n.log("Error loading " + k.src), m && m.call(b, null, !0), k = k.onload = k.onerror = null;
        }, h.indexOf("data") !== 0 && f !== void 0 && f !== null && (k.crossOrigin = f), h.substring(0, 14) === "data:image/svg" && (k.onload = null, n.util.loadImageInDom(k, E)), k.src = h;
      },
      /**
       * Attaches SVG image with data: URL to the dom
       * @memberOf fabric.util
       * @param {Object} img Image object with data:image/svg src
       * @param {Function} callback Callback; invoked with loaded image
       * @return {Object} DOM element (div containing the SVG image)
       */
      loadImageInDom: function(h, m) {
        var b = n.document.createElement("div");
        b.style.width = b.style.height = "1px", b.style.left = b.style.top = "-100%", b.style.position = "absolute", b.appendChild(h), n.document.querySelector("body").appendChild(b), h.onload = function() {
          m(), b.parentNode.removeChild(b), b = null;
        };
      },
      /**
       * Creates corresponding fabric instances from their object representations
       * @static
       * @memberOf fabric.util
       * @param {Array} objects Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * @param {String} namespace Namespace to get klass "Class" object from
       * @param {Function} reviver Method for further parsing of object elements,
       * called after each fabric object created.
       */
      enlivenObjects: function(h, m, b, f) {
        h = h || [];
        var k = [], E = 0, _ = h.length;
        function T() {
          ++E === _ && m && m(k.filter(function(D) {
            return D;
          }));
        }
        if (!_) {
          m && m(k);
          return;
        }
        h.forEach(function(D, V) {
          if (!D || !D.type) {
            T();
            return;
          }
          var I = n.util.getKlass(D.type, b);
          I.fromObject(D, function(M, Q) {
            Q || (k[V] = M), f && f(D, M, Q), T();
          });
        });
      },
      /**
       * Creates corresponding fabric instances residing in an object, e.g. `clipPath`
       * @see {@link fabric.Object.ENLIVEN_PROPS}
       * @param {Object} object
       * @param {Object} [context] assign enlived props to this object (pass null to skip this)
       * @param {(objects:fabric.Object[]) => void} callback
       */
      enlivenObjectEnlivables: function(h, m, b) {
        var f = n.Object.ENLIVEN_PROPS.filter(function(k) {
          return !!h[k];
        });
        n.util.enlivenObjects(f.map(function(k) {
          return h[k];
        }), function(k) {
          var E = {};
          f.forEach(function(_, T) {
            E[_] = k[T], m && (m[_] = k[T]);
          }), b && b(E);
        });
      },
      /**
       * Create and wait for loading of patterns
       * @static
       * @memberOf fabric.util
       * @param {Array} patterns Objects to enliven
       * @param {Function} callback Callback to invoke when all objects are created
       * called after each fabric object created.
       */
      enlivenPatterns: function(h, m) {
        h = h || [];
        function b() {
          ++k === E && m && m(f);
        }
        var f = [], k = 0, E = h.length;
        if (!E) {
          m && m(f);
          return;
        }
        h.forEach(function(_, T) {
          _ && _.source ? new n.Pattern(_, function(D) {
            f[T] = D, b();
          }) : (f[T] = _, b());
        });
      },
      /**
       * Groups SVG elements (usually those retrieved from SVG document)
       * @static
       * @memberOf fabric.util
       * @param {Array} elements SVG elements to group
       * @param {Object} [options] Options object
       * @param {String} path Value to set sourcePath to
       * @return {fabric.Object|fabric.Group}
       */
      groupSVGElements: function(h, m, b) {
        var f;
        return h && h.length === 1 ? (typeof b < "u" && (h[0].sourcePath = b), h[0]) : (m && (m.width && m.height ? m.centerPoint = {
          x: m.width / 2,
          y: m.height / 2
        } : (delete m.width, delete m.height)), f = new n.Group(h, m), typeof b < "u" && (f.sourcePath = b), f);
      },
      /**
       * Populates an object with properties of another object
       * @static
       * @memberOf fabric.util
       * @param {Object} source Source object
       * @param {Object} destination Destination object
       * @return {Array} properties Properties names to include
       */
      populateWithProperties: function(h, m, b) {
        if (b && Array.isArray(b))
          for (var f = 0, k = b.length; f < k; f++)
            b[f] in h && (m[b[f]] = h[b[f]]);
      },
      /**
       * Creates canvas element
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      createCanvasElement: function() {
        return n.document.createElement("canvas");
      },
      /**
       * Creates a canvas element that is a copy of another and is also painted
       * @param {CanvasElement} canvas to copy size and content of
       * @static
       * @memberOf fabric.util
       * @return {CanvasElement} initialized canvas element
       */
      copyCanvasElement: function(h) {
        var m = n.util.createCanvasElement();
        return m.width = h.width, m.height = h.height, m.getContext("2d").drawImage(h, 0, 0), m;
      },
      /**
       * since 2.6.0 moved from canvas instance to utility.
       * @param {CanvasElement} canvasEl to copy size and content of
       * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
       * @param {Number} quality <= 1 and > 0
       * @static
       * @memberOf fabric.util
       * @return {String} data url
       */
      toDataURL: function(h, m, b) {
        return h.toDataURL("image/" + m, b);
      },
      /**
       * Creates image element (works on client and node)
       * @static
       * @memberOf fabric.util
       * @return {HTMLImageElement} HTML image element
       */
      createImage: function() {
        return n.document.createElement("img");
      },
      /**
       * Multiply matrix A by matrix B to nest transformations
       * @static
       * @memberOf fabric.util
       * @param  {Array} a First transformMatrix
       * @param  {Array} b Second transformMatrix
       * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
       * @return {Array} The product of the two transform matrices
       */
      multiplyTransformMatrices: function(h, m, b) {
        return [
          h[0] * m[0] + h[2] * m[1],
          h[1] * m[0] + h[3] * m[1],
          h[0] * m[2] + h[2] * m[3],
          h[1] * m[2] + h[3] * m[3],
          b ? 0 : h[0] * m[4] + h[2] * m[5] + h[4],
          b ? 0 : h[1] * m[4] + h[3] * m[5] + h[5]
        ];
      },
      /**
       * Decomposes standard 2x3 matrix into transform components
       * @static
       * @memberOf fabric.util
       * @param  {Array} a transformMatrix
       * @return {Object} Components of transform
       */
      qrDecompose: function(h) {
        var m = p(h[1], h[0]), b = v(h[0], 2) + v(h[1], 2), f = l(b), k = (h[0] * h[3] - h[2] * h[1]) / f, E = p(h[0] * h[2] + h[1] * h[3], b);
        return {
          angle: m / c,
          scaleX: f,
          scaleY: k,
          skewX: E / c,
          skewY: 0,
          translateX: h[4],
          translateY: h[5]
        };
      },
      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.angle] angle in degrees
       * @return {Number[]} transform matrix
       */
      calcRotateMatrix: function(h) {
        if (!h.angle)
          return n.iMatrix.concat();
        var m = n.util.degreesToRadians(h.angle), b = n.util.cos(m), f = n.util.sin(m);
        return [b, f, -f, b, 0, 0];
      },
      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet.
       * is called DimensionsTransformMatrix because those properties are the one that influence
       * the size of the resulting box of the object.
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.scaleX]
       * @param  {Number} [options.scaleY]
       * @param  {Boolean} [options.flipX]
       * @param  {Boolean} [options.flipY]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.skewY]
       * @return {Number[]} transform matrix
       */
      calcDimensionsMatrix: function(h) {
        var m = typeof h.scaleX > "u" ? 1 : h.scaleX, b = typeof h.scaleY > "u" ? 1 : h.scaleY, f = [
          h.flipX ? -m : m,
          0,
          0,
          h.flipY ? -b : b,
          0,
          0
        ], k = n.util.multiplyTransformMatrices, E = n.util.degreesToRadians;
        return h.skewX && (f = k(
          f,
          [1, 0, Math.tan(E(h.skewX)), 1],
          !0
        )), h.skewY && (f = k(
          f,
          [1, Math.tan(E(h.skewY)), 0, 1],
          !0
        )), f;
      },
      /**
       * Returns a transform matrix starting from an object of the same kind of
       * the one returned from qrDecompose, useful also if you want to calculate some
       * transformations from an object that is not enlived yet
       * @static
       * @memberOf fabric.util
       * @param  {Object} options
       * @param  {Number} [options.angle]
       * @param  {Number} [options.scaleX]
       * @param  {Number} [options.scaleY]
       * @param  {Boolean} [options.flipX]
       * @param  {Boolean} [options.flipY]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.skewX]
       * @param  {Number} [options.translateX]
       * @param  {Number} [options.translateY]
       * @return {Number[]} transform matrix
       */
      composeMatrix: function(h) {
        var m = [1, 0, 0, 1, h.translateX || 0, h.translateY || 0], b = n.util.multiplyTransformMatrices;
        return h.angle && (m = b(m, n.util.calcRotateMatrix(h))), (h.scaleX !== 1 || h.scaleY !== 1 || h.skewX || h.skewY || h.flipX || h.flipY) && (m = b(m, n.util.calcDimensionsMatrix(h))), m;
      },
      /**
       * reset an object transform state to neutral. Top and left are not accounted for
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Object} target object to transform
       */
      resetObjectTransform: function(h) {
        h.scaleX = 1, h.scaleY = 1, h.skewX = 0, h.skewY = 0, h.flipX = !1, h.flipY = !1, h.rotate(0);
      },
      /**
       * Extract Object transform values
       * @static
       * @memberOf fabric.util
       * @param  {fabric.Object} target object to read from
       * @return {Object} Components of transform
       */
      saveObjectTransform: function(h) {
        return {
          scaleX: h.scaleX,
          scaleY: h.scaleY,
          skewX: h.skewX,
          skewY: h.skewY,
          angle: h.angle,
          left: h.left,
          flipX: h.flipX,
          flipY: h.flipY,
          top: h.top
        };
      },
      /**
       * Returns true if context has transparent pixel
       * at specified location (taking tolerance into account)
       * @param {CanvasRenderingContext2D} ctx context
       * @param {Number} x x coordinate
       * @param {Number} y y coordinate
       * @param {Number} tolerance Tolerance
       */
      isTransparent: function(h, m, b, f) {
        f > 0 && (m > f ? m -= f : m = 0, b > f ? b -= f : b = 0);
        var k = !0, E, _, T = h.getImageData(m, b, f * 2 || 1, f * 2 || 1), D = T.data.length;
        for (E = 3; E < D && (_ = T.data[E], k = _ <= 0, k !== !1); E += 4)
          ;
        return T = null, k;
      },
      /**
       * Parse preserveAspectRatio attribute from element
       * @param {string} attribute to be parsed
       * @return {Object} an object containing align and meetOrSlice attribute
       */
      parsePreserveAspectRatioAttribute: function(h) {
        var m = "meet", b = "Mid", f = "Mid", k = h.split(" "), E;
        return k && k.length && (m = k.pop(), m !== "meet" && m !== "slice" ? (E = m, m = "meet") : k.length && (E = k.pop())), b = E !== "none" ? E.slice(1, 4) : "none", f = E !== "none" ? E.slice(5, 8) : "none", {
          meetOrSlice: m,
          alignX: b,
          alignY: f
        };
      },
      /**
       * Clear char widths cache for the given font family or all the cache if no
       * fontFamily is specified.
       * Use it if you know you are loading fonts in a lazy way and you are not waiting
       * for custom fonts to load properly when adding text objects to the canvas.
       * If a text object is added when its own font is not loaded yet, you will get wrong
       * measurement and so wrong bounding boxes.
       * After the font cache is cleared, either change the textObject text content or call
       * initDimensions() to trigger a recalculation
       * @memberOf fabric.util
       * @param {String} [fontFamily] font family to clear
       */
      clearFabricFontCache: function(h) {
        h = (h || "").toLowerCase(), h ? n.charWidthsCache[h] && delete n.charWidthsCache[h] : n.charWidthsCache = {};
      },
      /**
       * Given current aspect ratio, determines the max width and height that can
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Number} ar aspect ratio
       * @param {Number} maximumArea Maximum area you want to achieve
       * @return {Object.x} Limited dimensions by X
       * @return {Object.y} Limited dimensions by Y
       */
      limitDimsByArea: function(h, m) {
        var b = Math.sqrt(m * h), f = Math.floor(m / b);
        return { x: Math.floor(b), y: f };
      },
      capValue: function(h, m, b) {
        return Math.max(h, Math.min(m, b));
      },
      /**
       * Finds the scale for the object source to fit inside the object destination,
       * keeping aspect ratio intact.
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Object | fabric.Object} source
       * @param {Number} source.height natural unscaled height of the object
       * @param {Number} source.width natural unscaled width of the object
       * @param {Object | fabric.Object} destination
       * @param {Number} destination.height natural unscaled height of the object
       * @param {Number} destination.width natural unscaled width of the object
       * @return {Number} scale factor to apply to source to fit into destination
       */
      findScaleToFit: function(h, m) {
        return Math.min(m.width / h.width, m.height / h.height);
      },
      /**
       * Finds the scale for the object source to cover entirely the object destination,
       * keeping aspect ratio intact.
       * respect the total allowed area for the cache.
       * @memberOf fabric.util
       * @param {Object | fabric.Object} source
       * @param {Number} source.height natural unscaled height of the object
       * @param {Number} source.width natural unscaled width of the object
       * @param {Object | fabric.Object} destination
       * @param {Number} destination.height natural unscaled height of the object
       * @param {Number} destination.width natural unscaled width of the object
       * @return {Number} scale factor to apply to source to cover destination
       */
      findScaleToCover: function(h, m) {
        return Math.max(m.width / h.width, m.height / h.height);
      },
      /**
       * given an array of 6 number returns something like `"matrix(...numbers)"`
       * @memberOf fabric.util
       * @param {Array} transform an array with 6 numbers
       * @return {String} transform matrix for svg
       * @return {Object.y} Limited dimensions by Y
       */
      matrixToSVG: function(h) {
        return "matrix(" + h.map(function(m) {
          return n.util.toFixed(m, n.Object.NUM_FRACTION_DIGITS);
        }).join(" ") + ")";
      },
      /**
       * given an object and a transform, apply the inverse transform to the object,
       * this is equivalent to remove from that object that transformation, so that
       * added in a space with the removed transform, the object will be the same as before.
       * Removing from an object a transform that scale by 2 is like scaling it by 1/2.
       * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg
       * in the opposite direction.
       * This util is used to add objects inside transformed groups or nested groups.
       * @memberOf fabric.util
       * @param {fabric.Object} object the object you want to transform
       * @param {Array} transform the destination transform
       */
      removeTransformFromObject: function(h, m) {
        var b = n.util.invertTransform(m), f = n.util.multiplyTransformMatrices(b, h.calcOwnMatrix());
        n.util.applyTransformToObject(h, f);
      },
      /**
       * given an object and a transform, apply the transform to the object.
       * this is equivalent to change the space where the object is drawn.
       * Adding to an object a transform that scale by 2 is like scaling it by 2.
       * This is used when removing an object from an active selection for example.
       * @memberOf fabric.util
       * @param {fabric.Object} object the object you want to transform
       * @param {Array} transform the destination transform
       */
      addTransformToObject: function(h, m) {
        n.util.applyTransformToObject(
          h,
          n.util.multiplyTransformMatrices(m, h.calcOwnMatrix())
        );
      },
      /**
       * discard an object transform state and apply the one from the matrix.
       * @memberOf fabric.util
       * @param {fabric.Object} object the object you want to transform
       * @param {Array} transform the destination transform
       */
      applyTransformToObject: function(h, m) {
        var b = n.util.qrDecompose(m), f = new n.Point(b.translateX, b.translateY);
        h.flipX = !1, h.flipY = !1, h.set("scaleX", b.scaleX), h.set("scaleY", b.scaleY), h.skewX = b.skewX, h.skewY = b.skewY, h.angle = b.angle, h.setPositionByOrigin(f, "center", "center");
      },
      /**
       * given a width and height, return the size of the bounding box
       * that can contains the box with width/height with applied transform
       * described in options.
       * Use to calculate the boxes around objects for controls.
       * @memberOf fabric.util
       * @param {Number} width
       * @param {Number} height
       * @param {Object} options
       * @param {Number} options.scaleX
       * @param {Number} options.scaleY
       * @param {Number} options.skewX
       * @param {Number} options.skewY
       * @return {Object.x} width of containing
       * @return {Object.y} height of containing
       */
      sizeAfterTransform: function(h, m, b) {
        var f = h / 2, k = m / 2, E = [
          {
            x: -f,
            y: -k
          },
          {
            x: f,
            y: -k
          },
          {
            x: -f,
            y: k
          },
          {
            x: f,
            y: k
          }
        ], _ = n.util.calcDimensionsMatrix(b), T = n.util.makeBoundingBoxFromPoints(E, _);
        return {
          x: T.width,
          y: T.height
        };
      },
      /**
       * Merges 2 clip paths into one visually equal clip path
       *
       * **IMPORTANT**:\
       * Does **NOT** clone the arguments, clone them proir if necessary.
       *
       * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.
       * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.
       *
       * In order to handle the `inverted` property we follow logic described in the following cases:\
       * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\
       * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\
       * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.
       *
       * @memberOf fabric.util
       * @param {fabric.Object} c1
       * @param {fabric.Object} c2
       * @returns {fabric.Object} merged clip path
       */
      mergeClipPaths: function(h, m) {
        var b = h, f = m;
        b.inverted && !f.inverted && (b = m, f = h), n.util.applyTransformToObject(
          f,
          n.util.multiplyTransformMatrices(
            n.util.invertTransform(b.calcTransformMatrix()),
            f.calcTransformMatrix()
          )
        );
        var k = b.inverted && f.inverted;
        return k && (b.inverted = f.inverted = !1), new n.Group([b], { clipPath: f, inverted: k });
      },
      /**
       * @memberOf fabric.util
       * @param {Object} prevStyle first style to compare
       * @param {Object} thisStyle second style to compare
       * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties
       * @return {boolean} true if the style changed
       */
      hasStyleChanged: function(h, m, b) {
        return b = b || !1, h.fill !== m.fill || h.stroke !== m.stroke || h.strokeWidth !== m.strokeWidth || h.fontSize !== m.fontSize || h.fontFamily !== m.fontFamily || h.fontWeight !== m.fontWeight || h.fontStyle !== m.fontStyle || h.textBackgroundColor !== m.textBackgroundColor || h.deltaY !== m.deltaY || b && (h.overline !== m.overline || h.underline !== m.underline || h.linethrough !== m.linethrough);
      },
      /**
       * Returns the array form of a text object's inline styles property with styles grouped in ranges
       * rather than per character. This format is less verbose, and is better suited for storage
       * so it is used in serialization (not during runtime).
       * @memberOf fabric.util
       * @param {object} styles per character styles for a text object
       * @param {String} text the text string that the styles are applied to
       * @return {{start: number, end: number, style: object}[]}
       */
      stylesToArray: function(b, m) {
        for (var b = n.util.object.clone(b, !0), f = m.split(`
`), k = -1, E = {}, _ = [], T = 0; T < f.length; T++) {
          if (!b[T]) {
            k += f[T].length;
            continue;
          }
          for (var D = 0; D < f[T].length; D++) {
            k++;
            var V = b[T][D];
            if (V && Object.keys(V).length > 0) {
              var I = n.util.hasStyleChanged(E, V, !0);
              I ? _.push({
                start: k,
                end: k + 1,
                style: V
              }) : _[_.length - 1].end++;
            }
            E = V || {};
          }
        }
        return _;
      },
      /**
       * Returns the object form of the styles property with styles that are assigned per
       * character rather than grouped by range. This format is more verbose, and is
       * only used during runtime (not for serialization/storage)
       * @memberOf fabric.util
       * @param {Array} styles the serialized form of a text object's styles
       * @param {String} text the text string that the styles are applied to
       * @return {Object}
       */
      stylesFromArray: function(h, m) {
        if (!Array.isArray(h))
          return h;
        for (var b = m.split(`
`), f = -1, k = 0, E = {}, _ = 0; _ < b.length; _++)
          for (var T = 0; T < b[_].length; T++)
            f++, h[k] && h[k].start <= f && f < h[k].end && (E[_] = E[_] || {}, E[_][T] = Object.assign({}, h[k].style), f === h[k].end - 1 && k++);
        return E;
      }
    };
  }(i), function() {
    var d = Array.prototype.join, l = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7
    }, p = {
      m: "l",
      M: "L"
    };
    function v(L, Z, W, Y, me, K, R, le, fe, Se, we) {
      var De = n.util.cos(L), Le = n.util.sin(L), Ye = n.util.cos(Z), $ = n.util.sin(Z), A = W * me * Ye - Y * K * $ + R, X = Y * me * Ye + W * K * $ + le, te = Se + fe * (-W * me * Le - Y * K * De), J = we + fe * (-Y * me * Le + W * K * De), ae = A + fe * (W * me * $ + Y * K * Ye), ge = X + fe * (Y * me * $ - W * K * Ye);
      return [
        "C",
        te,
        J,
        ae,
        ge,
        A,
        X
      ];
    }
    function c(L, Z, W, Y, me, K, R) {
      var le = Math.PI, fe = R * le / 180, Se = n.util.sin(fe), we = n.util.cos(fe), De = 0, Le = 0;
      W = Math.abs(W), Y = Math.abs(Y);
      var Ye = -we * L * 0.5 - Se * Z * 0.5, $ = -we * Z * 0.5 + Se * L * 0.5, A = W * W, X = Y * Y, te = $ * $, J = Ye * Ye, ae = A * X - A * te - X * J, ge = 0;
      if (ae < 0) {
        var be = Math.sqrt(1 - ae / (A * X));
        W *= be, Y *= be;
      } else
        ge = (me === K ? -1 : 1) * Math.sqrt(ae / (A * te + X * J));
      var ke = ge * W * $ / Y, ne = -ge * Y * Ye / W, Ve = we * ke - Se * ne + L * 0.5, Ae = Se * ke + we * ne + Z * 0.5, je = e(1, 0, (Ye - ke) / W, ($ - ne) / Y), rt = e((Ye - ke) / W, ($ - ne) / Y, (-Ye - ke) / W, (-$ - ne) / Y);
      K === 0 && rt > 0 ? rt -= 2 * le : K === 1 && rt < 0 && (rt += 2 * le);
      for (var st = Math.ceil(Math.abs(rt / le * 2)), pt = [], vt = rt / st, Lt = 8 / 3 * Math.sin(vt / 4) * Math.sin(vt / 4) / Math.sin(vt / 2), cn = je + vt, Ut = 0; Ut < st; Ut++)
        pt[Ut] = v(je, cn, we, Se, W, Y, Ve, Ae, Lt, De, Le), De = pt[Ut][5], Le = pt[Ut][6], je = cn, cn += vt;
      return pt;
    }
    function e(L, Z, W, Y) {
      var me = Math.atan2(Z, L), K = Math.atan2(Y, W);
      return K >= me ? K - me : 2 * Math.PI - (me - K);
    }
    function h(L, Z, W, Y, me, K, R, le) {
      var fe;
      if (n.cachesBoundsOfCurve && (fe = d.call(arguments), n.boundsOfCurveCache[fe]))
        return n.boundsOfCurveCache[fe];
      var Se = Math.sqrt, we = Math.min, De = Math.max, Le = Math.abs, Ye = [], $ = [[], []], A, X, te, J, ae, ge, be, ke;
      X = 6 * L - 12 * W + 6 * me, A = -3 * L + 9 * W - 9 * me + 3 * R, te = 3 * W - 3 * L;
      for (var ne = 0; ne < 2; ++ne) {
        if (ne > 0 && (X = 6 * Z - 12 * Y + 6 * K, A = -3 * Z + 9 * Y - 9 * K + 3 * le, te = 3 * Y - 3 * Z), Le(A) < 1e-12) {
          if (Le(X) < 1e-12)
            continue;
          J = -te / X, 0 < J && J < 1 && Ye.push(J);
          continue;
        }
        be = X * X - 4 * te * A, !(be < 0) && (ke = Se(be), ae = (-X + ke) / (2 * A), 0 < ae && ae < 1 && Ye.push(ae), ge = (-X - ke) / (2 * A), 0 < ge && ge < 1 && Ye.push(ge));
      }
      for (var Ve, Ae, je = Ye.length, rt = je, st; je--; )
        J = Ye[je], st = 1 - J, Ve = st * st * st * L + 3 * st * st * J * W + 3 * st * J * J * me + J * J * J * R, $[0][je] = Ve, Ae = st * st * st * Z + 3 * st * st * J * Y + 3 * st * J * J * K + J * J * J * le, $[1][je] = Ae;
      $[0][rt] = L, $[1][rt] = Z, $[0][rt + 1] = R, $[1][rt + 1] = le;
      var pt = [
        {
          x: we.apply(null, $[0]),
          y: we.apply(null, $[1])
        },
        {
          x: De.apply(null, $[0]),
          y: De.apply(null, $[1])
        }
      ];
      return n.cachesBoundsOfCurve && (n.boundsOfCurveCache[fe] = pt), pt;
    }
    function m(L, Z, W) {
      for (var Y = W[1], me = W[2], K = W[3], R = W[4], le = W[5], fe = W[6], Se = W[7], we = c(fe - L, Se - Z, Y, me, R, le, K), De = 0, Le = we.length; De < Le; De++)
        we[De][1] += L, we[De][2] += Z, we[De][3] += L, we[De][4] += Z, we[De][5] += L, we[De][6] += Z;
      return we;
    }
    function b(L) {
      var Z = 0, W = 0, Y = L.length, me = 0, K = 0, R, le, fe, Se = [], we, De, Le;
      for (le = 0; le < Y; ++le) {
        switch (fe = !1, R = L[le].slice(0), R[0]) {
          case "l":
            R[0] = "L", R[1] += Z, R[2] += W;
          case "L":
            Z = R[1], W = R[2];
            break;
          case "h":
            R[1] += Z;
          case "H":
            R[0] = "L", R[2] = W, Z = R[1];
            break;
          case "v":
            R[1] += W;
          case "V":
            R[0] = "L", W = R[1], R[1] = Z, R[2] = W;
            break;
          case "m":
            R[0] = "M", R[1] += Z, R[2] += W;
          case "M":
            Z = R[1], W = R[2], me = R[1], K = R[2];
            break;
          case "c":
            R[0] = "C", R[1] += Z, R[2] += W, R[3] += Z, R[4] += W, R[5] += Z, R[6] += W;
          case "C":
            De = R[3], Le = R[4], Z = R[5], W = R[6];
            break;
          case "s":
            R[0] = "S", R[1] += Z, R[2] += W, R[3] += Z, R[4] += W;
          case "S":
            we === "C" ? (De = 2 * Z - De, Le = 2 * W - Le) : (De = Z, Le = W), Z = R[3], W = R[4], R[0] = "C", R[5] = R[3], R[6] = R[4], R[3] = R[1], R[4] = R[2], R[1] = De, R[2] = Le, De = R[3], Le = R[4];
            break;
          case "q":
            R[0] = "Q", R[1] += Z, R[2] += W, R[3] += Z, R[4] += W;
          case "Q":
            De = R[1], Le = R[2], Z = R[3], W = R[4];
            break;
          case "t":
            R[0] = "T", R[1] += Z, R[2] += W;
          case "T":
            we === "Q" ? (De = 2 * Z - De, Le = 2 * W - Le) : (De = Z, Le = W), R[0] = "Q", Z = R[1], W = R[2], R[1] = De, R[2] = Le, R[3] = Z, R[4] = W;
            break;
          case "a":
            R[0] = "A", R[6] += Z, R[7] += W;
          case "A":
            fe = !0, Se = Se.concat(m(Z, W, R)), Z = R[6], W = R[7];
            break;
          case "z":
          case "Z":
            Z = me, W = K;
            break;
        }
        fe || Se.push(R), we = R[0];
      }
      return Se;
    }
    function f(L, Z, W, Y) {
      return Math.sqrt((W - L) * (W - L) + (Y - Z) * (Y - Z));
    }
    function k(L) {
      return L * L * L;
    }
    function E(L) {
      return 3 * L * L * (1 - L);
    }
    function _(L) {
      return 3 * L * (1 - L) * (1 - L);
    }
    function T(L) {
      return (1 - L) * (1 - L) * (1 - L);
    }
    function D(L, Z, W, Y, me, K, R, le) {
      return function(fe) {
        var Se = k(fe), we = E(fe), De = _(fe), Le = T(fe);
        return {
          x: R * Se + me * we + W * De + L * Le,
          y: le * Se + K * we + Y * De + Z * Le
        };
      };
    }
    function V(L, Z, W, Y, me, K, R, le) {
      return function(fe) {
        var Se = 1 - fe, we = 3 * Se * Se * (W - L) + 6 * Se * fe * (me - W) + 3 * fe * fe * (R - me), De = 3 * Se * Se * (Y - Z) + 6 * Se * fe * (K - Y) + 3 * fe * fe * (le - K);
        return Math.atan2(De, we);
      };
    }
    function I(L) {
      return L * L;
    }
    function M(L) {
      return 2 * L * (1 - L);
    }
    function Q(L) {
      return (1 - L) * (1 - L);
    }
    function G(L, Z, W, Y, me, K) {
      return function(R) {
        var le = I(R), fe = M(R), Se = Q(R);
        return {
          x: me * le + W * fe + L * Se,
          y: K * le + Y * fe + Z * Se
        };
      };
    }
    function z(L, Z, W, Y, me, K) {
      return function(R) {
        var le = 1 - R, fe = 2 * le * (W - L) + 2 * R * (me - W), Se = 2 * le * (Y - Z) + 2 * R * (K - Y);
        return Math.atan2(Se, fe);
      };
    }
    function re(L, Z, W) {
      var Y = { x: Z, y: W }, me, K = 0, R;
      for (R = 1; R <= 100; R += 1)
        me = L(R / 100), K += f(Y.x, Y.y, me.x, me.y), Y = me;
      return K;
    }
    function he(L, Z) {
      for (var W = 0, Y = 0, me = L.iterator, K = { x: L.x, y: L.y }, R, le, fe = 0.01, Se = L.angleFinder, we; Y < Z && fe > 1e-4; )
        R = me(W), we = W, le = f(K.x, K.y, R.x, R.y), le + Y > Z ? (W -= fe, fe /= 2) : (K = R, W += fe, Y += le);
      return R.angle = Se(we), R;
    }
    function de(L) {
      for (var Z = 0, W = L.length, Y, me = 0, K = 0, R = 0, le = 0, fe = [], Se, we, De, Le = 0; Le < W; Le++) {
        switch (Y = L[Le], we = {
          x: me,
          y: K,
          command: Y[0]
        }, Y[0]) {
          case "M":
            we.length = 0, R = me = Y[1], le = K = Y[2];
            break;
          case "L":
            we.length = f(me, K, Y[1], Y[2]), me = Y[1], K = Y[2];
            break;
          case "C":
            Se = D(
              me,
              K,
              Y[1],
              Y[2],
              Y[3],
              Y[4],
              Y[5],
              Y[6]
            ), De = V(
              me,
              K,
              Y[1],
              Y[2],
              Y[3],
              Y[4],
              Y[5],
              Y[6]
            ), we.iterator = Se, we.angleFinder = De, we.length = re(Se, me, K), me = Y[5], K = Y[6];
            break;
          case "Q":
            Se = G(
              me,
              K,
              Y[1],
              Y[2],
              Y[3],
              Y[4]
            ), De = z(
              me,
              K,
              Y[1],
              Y[2],
              Y[3],
              Y[4]
            ), we.iterator = Se, we.angleFinder = De, we.length = re(Se, me, K), me = Y[3], K = Y[4];
            break;
          case "Z":
          case "z":
            we.destX = R, we.destY = le, we.length = f(me, K, R, le), me = R, K = le;
            break;
        }
        Z += we.length, fe.push(we);
      }
      return fe.push({ length: Z, x: me, y: K }), fe;
    }
    function Ce(L, Z, W) {
      W || (W = de(L));
      for (var Y = 0; Z - W[Y].length > 0 && Y < W.length - 2; )
        Z -= W[Y].length, Y++;
      var me = W[Y], K = Z / me.length, R = me.command, le = L[Y], fe;
      switch (R) {
        case "M":
          return { x: me.x, y: me.y, angle: 0 };
        case "Z":
        case "z":
          return fe = new n.Point(me.x, me.y).lerp(
            new n.Point(me.destX, me.destY),
            K
          ), fe.angle = Math.atan2(me.destY - me.y, me.destX - me.x), fe;
        case "L":
          return fe = new n.Point(me.x, me.y).lerp(
            new n.Point(le[1], le[2]),
            K
          ), fe.angle = Math.atan2(le[2] - me.y, le[1] - me.x), fe;
        case "C":
          return he(me, Z);
        case "Q":
          return he(me, Z);
      }
    }
    function xe(L) {
      var Z = [], W = [], Y, me, K = n.rePathCommand, R = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", le = "(" + R + ")" + n.commaWsp, fe = "([01])" + n.commaWsp + "?", Se = le + "?" + le + "?" + le + fe + fe + le + "?(" + R + ")", we = new RegExp(Se, "g"), De, Le, Ye;
      if (!L || !L.match)
        return Z;
      Ye = L.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
      for (var $ = 0, A, X = Ye.length; $ < X; $++) {
        Y = Ye[$], Le = Y.slice(1).trim(), W.length = 0;
        var te = Y.charAt(0);
        if (A = [te], te.toLowerCase() === "a")
          for (var J; J = we.exec(Le); )
            for (var ae = 1; ae < J.length; ae++)
              W.push(J[ae]);
        else
          for (; De = K.exec(Le); )
            W.push(De[0]);
        for (var ae = 0, ge = W.length; ae < ge; ae++)
          me = parseFloat(W[ae]), isNaN(me) || A.push(me);
        var be = l[te.toLowerCase()], ke = p[te] || te;
        if (A.length - 1 > be)
          for (var ne = 1, Ve = A.length; ne < Ve; ne += be)
            Z.push([te].concat(A.slice(ne, ne + be))), te = ke;
        else
          Z.push(A);
      }
      return Z;
    }
    function Ie(L, Z) {
      var W = [], Y, me = new n.Point(L[0].x, L[0].y), K = new n.Point(L[1].x, L[1].y), R = L.length, le = 1, fe = 0, Se = R > 2;
      for (Z = Z || 0, Se && (le = L[2].x < K.x ? -1 : L[2].x === K.x ? 0 : 1, fe = L[2].y < K.y ? -1 : L[2].y === K.y ? 0 : 1), W.push(["M", me.x - le * Z, me.y - fe * Z]), Y = 1; Y < R; Y++) {
        if (!me.eq(K)) {
          var we = me.midPointFrom(K);
          W.push(["Q", me.x, me.y, we.x, we.y]);
        }
        me = L[Y], Y + 1 < L.length && (K = L[Y + 1]);
      }
      return Se && (le = me.x > L[Y - 2].x ? 1 : me.x === L[Y - 2].x ? 0 : -1, fe = me.y > L[Y - 2].y ? 1 : me.y === L[Y - 2].y ? 0 : -1), W.push(["L", me.x + le * Z, me.y + fe * Z]), W;
    }
    function Be(L, Z, W) {
      return W && (Z = n.util.multiplyTransformMatrices(
        Z,
        [1, 0, 0, 1, -W.x, -W.y]
      )), L.map(function(Y) {
        for (var me = Y.slice(0), K = {}, R = 1; R < Y.length - 1; R += 2)
          K.x = Y[R], K.y = Y[R + 1], K = n.util.transformPoint(K, Z), me[R] = K.x, me[R + 1] = K.y;
        return me;
      });
    }
    n.util.joinPath = function(L) {
      return L.map(function(Z) {
        return Z.join(" ");
      }).join(" ");
    }, n.util.parsePath = xe, n.util.makePathSimpler = b, n.util.getSmoothPathFromPoints = Ie, n.util.getPathSegmentsInfo = de, n.util.getBoundsOfCurve = h, n.util.getPointOnPath = Ce, n.util.transformPath = Be;
  }(), function() {
    var d = Array.prototype.slice;
    function l(h, m) {
      for (var b = d.call(arguments, 2), f = [], k = 0, E = h.length; k < E; k++)
        f[k] = b.length ? h[k][m].apply(h[k], b) : h[k][m].call(h[k]);
      return f;
    }
    function p(h, m) {
      return e(h, m, function(b, f) {
        return b >= f;
      });
    }
    function v(h, m) {
      return e(h, m, function(b, f) {
        return b < f;
      });
    }
    function c(h, m) {
      for (var b = h.length; b--; )
        h[b] = m;
      return h;
    }
    function e(h, m, b) {
      if (!(!h || h.length === 0)) {
        var f = h.length - 1, k = m ? h[f][m] : h[f];
        if (m)
          for (; f--; )
            b(h[f][m], k) && (k = h[f][m]);
        else
          for (; f--; )
            b(h[f], k) && (k = h[f]);
        return k;
      }
    }
    n.util.array = {
      fill: c,
      invoke: l,
      min: v,
      max: p
    };
  }(), function() {
    function d(p, v, c) {
      if (c)
        if (!n.isLikelyNode && v instanceof Element)
          p = v;
        else if (v instanceof Array) {
          p = [];
          for (var e = 0, h = v.length; e < h; e++)
            p[e] = d({}, v[e], c);
        } else if (v && typeof v == "object")
          for (var m in v)
            m === "canvas" || m === "group" ? p[m] = null : v.hasOwnProperty(m) && (p[m] = d({}, v[m], c));
        else
          p = v;
      else
        for (var m in v)
          p[m] = v[m];
      return p;
    }
    function l(p, v) {
      return d({}, p, v);
    }
    n.util.object = {
      extend: d,
      clone: l
    }, n.util.object.extend(n.util, n.Observable);
  }(), function() {
    function d(e) {
      return e.replace(/-+(.)?/g, function(h, m) {
        return m ? m.toUpperCase() : "";
      });
    }
    function l(e, h) {
      return e.charAt(0).toUpperCase() + (h ? e.slice(1) : e.slice(1).toLowerCase());
    }
    function p(e) {
      return e.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function v(e) {
      var h = 0, m, b = [];
      for (h = 0, m; h < e.length; h++)
        (m = c(e, h)) !== !1 && b.push(m);
      return b;
    }
    function c(e, h) {
      var m = e.charCodeAt(h);
      if (isNaN(m))
        return "";
      if (m < 55296 || m > 57343)
        return e.charAt(h);
      if (55296 <= m && m <= 56319) {
        if (e.length <= h + 1)
          throw "High surrogate without following low surrogate";
        var b = e.charCodeAt(h + 1);
        if (56320 > b || b > 57343)
          throw "High surrogate without following low surrogate";
        return e.charAt(h) + e.charAt(h + 1);
      }
      if (h === 0)
        throw "Low surrogate without preceding high surrogate";
      var f = e.charCodeAt(h - 1);
      if (55296 > f || f > 56319)
        throw "Low surrogate without preceding high surrogate";
      return !1;
    }
    n.util.string = {
      camelize: d,
      capitalize: l,
      escapeXml: p,
      graphemeSplit: v
    };
  }(), function() {
    var d = Array.prototype.slice, l = function() {
    }, p = function() {
      for (var m in { toString: 1 })
        if (m === "toString")
          return !1;
      return !0;
    }(), v = function(m, b, f) {
      for (var k in b)
        k in m.prototype && typeof m.prototype[k] == "function" && (b[k] + "").indexOf("callSuper") > -1 ? m.prototype[k] = /* @__PURE__ */ function(E) {
          return function() {
            var _ = this.constructor.superclass;
            this.constructor.superclass = f;
            var T = b[E].apply(this, arguments);
            if (this.constructor.superclass = _, E !== "initialize")
              return T;
          };
        }(k) : m.prototype[k] = b[k], p && (b.toString !== Object.prototype.toString && (m.prototype.toString = b.toString), b.valueOf !== Object.prototype.valueOf && (m.prototype.valueOf = b.valueOf));
    };
    function c() {
    }
    function e(m) {
      for (var b = null, f = this; f.constructor.superclass; ) {
        var k = f.constructor.superclass.prototype[m];
        if (f[m] !== k) {
          b = k;
          break;
        }
        f = f.constructor.superclass.prototype;
      }
      return b ? arguments.length > 1 ? b.apply(this, d.call(arguments, 1)) : b.call(this) : console.log("tried to callSuper " + m + ", method not found in prototype chain", this);
    }
    function h() {
      var m = null, b = d.call(arguments, 0);
      typeof b[0] == "function" && (m = b.shift());
      function f() {
        this.initialize.apply(this, arguments);
      }
      f.superclass = m, f.subclasses = [], m && (c.prototype = m.prototype, f.prototype = new c(), m.subclasses.push(f));
      for (var k = 0, E = b.length; k < E; k++)
        v(f, b[k], m);
      return f.prototype.initialize || (f.prototype.initialize = l), f.prototype.constructor = f, f.prototype.callSuper = e, f;
    }
    n.util.createClass = h;
  }(), function() {
    var d = !!n.document.createElement("div").attachEvent, l = ["touchstart", "touchmove", "touchend"];
    n.util.addListener = function(v, c, e, h) {
      v && v.addEventListener(c, e, d ? !1 : h);
    }, n.util.removeListener = function(v, c, e, h) {
      v && v.removeEventListener(c, e, d ? !1 : h);
    };
    function p(v) {
      var c = v.changedTouches;
      return c && c[0] ? c[0] : v;
    }
    n.util.getPointer = function(v) {
      var c = v.target, e = n.util.getScrollLeftTop(c), h = p(v);
      return {
        x: h.clientX + e.left,
        y: h.clientY + e.top
      };
    }, n.util.isTouchEvent = function(v) {
      return l.indexOf(v.type) > -1 || v.pointerType === "touch";
    };
  }(), function() {
    function d(h, m) {
      var b = h.style;
      if (!b)
        return h;
      if (typeof m == "string")
        return h.style.cssText += ";" + m, m.indexOf("opacity") > -1 ? e(h, m.match(/opacity:\s*(\d?\.?\d*)/)[1]) : h;
      for (var f in m)
        if (f === "opacity")
          e(h, m[f]);
        else {
          var k = f === "float" || f === "cssFloat" ? typeof b.styleFloat > "u" ? "cssFloat" : "styleFloat" : f;
          b.setProperty(k, m[f]);
        }
      return h;
    }
    var l = n.document.createElement("div"), p = typeof l.style.opacity == "string", v = typeof l.style.filter == "string", c = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, e = function(h) {
      return h;
    };
    p ? e = function(h, m) {
      return h.style.opacity = m, h;
    } : v && (e = function(h, m) {
      var b = h.style;
      return h.currentStyle && !h.currentStyle.hasLayout && (b.zoom = 1), c.test(b.filter) ? (m = m >= 0.9999 ? "" : "alpha(opacity=" + m * 100 + ")", b.filter = b.filter.replace(c, m)) : b.filter += " alpha(opacity=" + m * 100 + ")", h;
    }), n.util.setStyle = d;
  }(), function() {
    var d = Array.prototype.slice;
    function l(T) {
      return typeof T == "string" ? n.document.getElementById(T) : T;
    }
    var p, v = function(T) {
      return d.call(T, 0);
    };
    try {
      p = v(n.document.childNodes) instanceof Array;
    } catch {
    }
    p || (v = function(T) {
      for (var D = new Array(T.length), V = T.length; V--; )
        D[V] = T[V];
      return D;
    });
    function c(T, D) {
      var V = n.document.createElement(T);
      for (var I in D)
        I === "class" ? V.className = D[I] : I === "for" ? V.htmlFor = D[I] : V.setAttribute(I, D[I]);
      return V;
    }
    function e(T, D) {
      T && (" " + T.className + " ").indexOf(" " + D + " ") === -1 && (T.className += (T.className ? " " : "") + D);
    }
    function h(T, D, V) {
      return typeof D == "string" && (D = c(D, V)), T.parentNode && T.parentNode.replaceChild(D, T), D.appendChild(T), D;
    }
    function m(T) {
      for (var D = 0, V = 0, I = n.document.documentElement, M = n.document.body || {
        scrollLeft: 0,
        scrollTop: 0
      }; T && (T.parentNode || T.host) && (T = T.parentNode || T.host, T === n.document ? (D = M.scrollLeft || I.scrollLeft || 0, V = M.scrollTop || I.scrollTop || 0) : (D += T.scrollLeft || 0, V += T.scrollTop || 0), !(T.nodeType === 1 && T.style.position === "fixed")); )
        ;
      return { left: D, top: V };
    }
    function b(T) {
      var D, V = T && T.ownerDocument, I = { left: 0, top: 0 }, M = { left: 0, top: 0 }, Q, G = {
        borderLeftWidth: "left",
        borderTopWidth: "top",
        paddingLeft: "left",
        paddingTop: "top"
      };
      if (!V)
        return M;
      for (var z in G)
        M[G[z]] += parseInt(f(T, z), 10) || 0;
      return D = V.documentElement, typeof T.getBoundingClientRect < "u" && (I = T.getBoundingClientRect()), Q = m(T), {
        left: I.left + Q.left - (D.clientLeft || 0) + M.left,
        top: I.top + Q.top - (D.clientTop || 0) + M.top
      };
    }
    var f;
    n.document.defaultView && n.document.defaultView.getComputedStyle ? f = function(T, D) {
      var V = n.document.defaultView.getComputedStyle(T, null);
      return V ? V[D] : void 0;
    } : f = function(T, D) {
      var V = T.style[D];
      return !V && T.currentStyle && (V = T.currentStyle[D]), V;
    }, function() {
      var T = n.document.documentElement.style, D = "userSelect" in T ? "userSelect" : "MozUserSelect" in T ? "MozUserSelect" : "WebkitUserSelect" in T ? "WebkitUserSelect" : "KhtmlUserSelect" in T ? "KhtmlUserSelect" : "";
      function V(M) {
        return typeof M.onselectstart < "u" && (M.onselectstart = n.util.falseFunction), D ? M.style[D] = "none" : typeof M.unselectable == "string" && (M.unselectable = "on"), M;
      }
      function I(M) {
        return typeof M.onselectstart < "u" && (M.onselectstart = null), D ? M.style[D] = "" : typeof M.unselectable == "string" && (M.unselectable = ""), M;
      }
      n.util.makeElementUnselectable = V, n.util.makeElementSelectable = I;
    }();
    function k(T) {
      var D = n.jsdomImplForWrapper(T);
      return D._canvas || D._image;
    }
    function E(T) {
      if (n.isLikelyNode) {
        var D = n.jsdomImplForWrapper(T);
        D && (D._image = null, D._canvas = null, D._currentSrc = null, D._attributes = null, D._classList = null);
      }
    }
    function _(T, D) {
      T.imageSmoothingEnabled = T.imageSmoothingEnabled || T.webkitImageSmoothingEnabled || T.mozImageSmoothingEnabled || T.msImageSmoothingEnabled || T.oImageSmoothingEnabled, T.imageSmoothingEnabled = D;
    }
    n.util.setImageSmoothing = _, n.util.getById = l, n.util.toArray = v, n.util.addClass = e, n.util.makeElement = c, n.util.wrapElement = h, n.util.getScrollLeftTop = m, n.util.getElementOffset = b, n.util.getNodeCanvas = k, n.util.cleanUpJsdomNode = E;
  }(), function() {
    function d(v, c) {
      return v + (/\?/.test(v) ? "&" : "?") + c;
    }
    function l() {
    }
    function p(v, c) {
      c || (c = {});
      var e = c.method ? c.method.toUpperCase() : "GET", h = c.onComplete || function() {
      }, m = new n.window.XMLHttpRequest(), b = c.body || c.parameters;
      return m.onreadystatechange = function() {
        m.readyState === 4 && (h(m), m.onreadystatechange = l);
      }, e === "GET" && (b = null, typeof c.parameters == "string" && (v = d(v, c.parameters))), m.open(e, v, !0), (e === "POST" || e === "PUT") && m.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), m.send(b), m;
    }
    n.util.request = p;
  }(), n.log = console.log, n.warn = console.warn, function() {
    var d = n.util.object.extend, l = n.util.object.clone, p = [];
    n.util.object.extend(p, {
      /**
       * cancel all running animations at the next requestAnimFrame
       * @returns {AnimationContext[]}
       */
      cancelAll: function() {
        var k = this.splice(0);
        return k.forEach(function(E) {
          E.cancel();
        }), k;
      },
      /**
       * cancel all running animations attached to canvas at the next requestAnimFrame
       * @param {fabric.Canvas} canvas
       * @returns {AnimationContext[]}
       */
      cancelByCanvas: function(k) {
        if (!k)
          return [];
        var E = this.filter(function(_) {
          return typeof _.target == "object" && _.target.canvas === k;
        });
        return E.forEach(function(_) {
          _.cancel();
        }), E;
      },
      /**
       * cancel all running animations for target at the next requestAnimFrame
       * @param {*} target
       * @returns {AnimationContext[]}
       */
      cancelByTarget: function(k) {
        var E = this.findAnimationsByTarget(k);
        return E.forEach(function(_) {
          _.cancel();
        }), E;
      },
      /**
       *
       * @param {CancelFunction} cancelFunc the function returned by animate
       * @returns {number}
       */
      findAnimationIndex: function(k) {
        return this.indexOf(this.findAnimation(k));
      },
      /**
       *
       * @param {CancelFunction} cancelFunc the function returned by animate
       * @returns {AnimationContext | undefined} animation's options object
       */
      findAnimation: function(k) {
        return this.find(function(E) {
          return E.cancel === k;
        });
      },
      /**
       *
       * @param {*} target the object that is assigned to the target property of the animation context
       * @returns {AnimationContext[]} array of animation options object associated with target
       */
      findAnimationsByTarget: function(k) {
        return k ? this.filter(function(E) {
          return E.target === k;
        }) : [];
      }
    });
    function v() {
      return !1;
    }
    function c(k, E, _, T) {
      return -_ * Math.cos(k / T * (Math.PI / 2)) + _ + E;
    }
    function e(k) {
      k || (k = {});
      var E = !1, _, T = function() {
        var D = n.runningAnimations.indexOf(_);
        return D > -1 && n.runningAnimations.splice(D, 1)[0];
      };
      return _ = d(l(k), {
        cancel: function() {
          return E = !0, T();
        },
        currentValue: "startValue" in k ? k.startValue : 0,
        completionRate: 0,
        durationRate: 0
      }), n.runningAnimations.push(_), b(function(D) {
        var V = D || +/* @__PURE__ */ new Date(), I = k.duration || 500, M = V + I, Q, G = k.onChange || v, z = k.abort || v, re = k.onComplete || v, he = k.easing || c, de = "startValue" in k ? k.startValue.length > 0 : !1, Ce = "startValue" in k ? k.startValue : 0, xe = "endValue" in k ? k.endValue : 100, Ie = k.byValue || (de ? Ce.map(function(Be, L) {
          return xe[L] - Ce[L];
        }) : xe - Ce);
        k.onStart && k.onStart(), function Be(L) {
          Q = L || +/* @__PURE__ */ new Date();
          var Z = Q > M ? I : Q - V, W = Z / I, Y = de ? Ce.map(function(K, R) {
            return he(Z, Ce[R], Ie[R], I);
          }) : he(Z, Ce, Ie, I), me = Math.abs(de ? (Y[0] - Ce[0]) / Ie[0] : (Y - Ce) / Ie);
          if (_.currentValue = de ? Y.slice() : Y, _.completionRate = me, _.durationRate = W, !E) {
            if (z(Y, me, W)) {
              T();
              return;
            }
            if (Q > M) {
              _.currentValue = de ? xe.slice() : xe, _.completionRate = 1, _.durationRate = 1, G(de ? xe.slice() : xe, 1, 1), re(xe, 1, 1), T();
              return;
            } else
              G(Y, me, W), b(Be);
          }
        }(V);
      }), _.cancel;
    }
    var h = n.window.requestAnimationFrame || n.window.webkitRequestAnimationFrame || n.window.mozRequestAnimationFrame || n.window.oRequestAnimationFrame || n.window.msRequestAnimationFrame || function(k) {
      return n.window.setTimeout(k, 1e3 / 60);
    }, m = n.window.cancelAnimationFrame || n.window.clearTimeout;
    function b() {
      return h.apply(n.window, arguments);
    }
    function f() {
      return m.apply(n.window, arguments);
    }
    n.util.animate = e, n.util.requestAnimFrame = b, n.util.cancelAnimFrame = f, n.runningAnimations = p;
  }(), function() {
    function d(p, v, c) {
      var e = "rgba(" + parseInt(p[0] + c * (v[0] - p[0]), 10) + "," + parseInt(p[1] + c * (v[1] - p[1]), 10) + "," + parseInt(p[2] + c * (v[2] - p[2]), 10);
      return e += "," + (p && v ? parseFloat(p[3] + c * (v[3] - p[3])) : 1), e += ")", e;
    }
    function l(p, v, c, e) {
      var h = new n.Color(p).getSource(), m = new n.Color(v).getSource(), b = e.onComplete, f = e.onChange;
      return e = e || {}, n.util.animate(n.util.object.extend(e, {
        duration: c || 500,
        startValue: h,
        endValue: m,
        byValue: m,
        easing: function(k, E, _, T) {
          var D = e.colorEasing ? e.colorEasing(k, T) : 1 - Math.cos(k / T * (Math.PI / 2));
          return d(E, _, D);
        },
        // has to take in account for color restoring;
        onComplete: function(k, E, _) {
          if (b)
            return b(
              d(m, m, 0),
              E,
              _
            );
        },
        onChange: function(k, E, _) {
          if (f) {
            if (Array.isArray(k))
              return f(
                d(k, k, 0),
                E,
                _
              );
            f(k, E, _);
          }
        }
      }));
    }
    n.util.animateColor = l;
  }(), function() {
    function d(L, Z, W, Y) {
      return L < Math.abs(Z) ? (L = Z, Y = W / 4) : Z === 0 && L === 0 ? Y = W / (2 * Math.PI) * Math.asin(1) : Y = W / (2 * Math.PI) * Math.asin(Z / L), { a: L, c: Z, p: W, s: Y };
    }
    function l(L, Z, W) {
      return L.a * Math.pow(2, 10 * (Z -= 1)) * Math.sin((Z * W - L.s) * (2 * Math.PI) / L.p);
    }
    function p(L, Z, W, Y) {
      return W * ((L = L / Y - 1) * L * L + 1) + Z;
    }
    function v(L, Z, W, Y) {
      return L /= Y / 2, L < 1 ? W / 2 * L * L * L + Z : W / 2 * ((L -= 2) * L * L + 2) + Z;
    }
    function c(L, Z, W, Y) {
      return W * (L /= Y) * L * L * L + Z;
    }
    function e(L, Z, W, Y) {
      return -W * ((L = L / Y - 1) * L * L * L - 1) + Z;
    }
    function h(L, Z, W, Y) {
      return L /= Y / 2, L < 1 ? W / 2 * L * L * L * L + Z : -W / 2 * ((L -= 2) * L * L * L - 2) + Z;
    }
    function m(L, Z, W, Y) {
      return W * (L /= Y) * L * L * L * L + Z;
    }
    function b(L, Z, W, Y) {
      return W * ((L = L / Y - 1) * L * L * L * L + 1) + Z;
    }
    function f(L, Z, W, Y) {
      return L /= Y / 2, L < 1 ? W / 2 * L * L * L * L * L + Z : W / 2 * ((L -= 2) * L * L * L * L + 2) + Z;
    }
    function k(L, Z, W, Y) {
      return -W * Math.cos(L / Y * (Math.PI / 2)) + W + Z;
    }
    function E(L, Z, W, Y) {
      return W * Math.sin(L / Y * (Math.PI / 2)) + Z;
    }
    function _(L, Z, W, Y) {
      return -W / 2 * (Math.cos(Math.PI * L / Y) - 1) + Z;
    }
    function T(L, Z, W, Y) {
      return L === 0 ? Z : W * Math.pow(2, 10 * (L / Y - 1)) + Z;
    }
    function D(L, Z, W, Y) {
      return L === Y ? Z + W : W * (-Math.pow(2, -10 * L / Y) + 1) + Z;
    }
    function V(L, Z, W, Y) {
      return L === 0 ? Z : L === Y ? Z + W : (L /= Y / 2, L < 1 ? W / 2 * Math.pow(2, 10 * (L - 1)) + Z : W / 2 * (-Math.pow(2, -10 * --L) + 2) + Z);
    }
    function I(L, Z, W, Y) {
      return -W * (Math.sqrt(1 - (L /= Y) * L) - 1) + Z;
    }
    function M(L, Z, W, Y) {
      return W * Math.sqrt(1 - (L = L / Y - 1) * L) + Z;
    }
    function Q(L, Z, W, Y) {
      return L /= Y / 2, L < 1 ? -W / 2 * (Math.sqrt(1 - L * L) - 1) + Z : W / 2 * (Math.sqrt(1 - (L -= 2) * L) + 1) + Z;
    }
    function G(L, Z, W, Y) {
      var me = 1.70158, K = 0, R = W;
      if (L === 0)
        return Z;
      if (L /= Y, L === 1)
        return Z + W;
      K || (K = Y * 0.3);
      var le = d(R, W, K, me);
      return -l(le, L, Y) + Z;
    }
    function z(L, Z, W, Y) {
      var me = 1.70158, K = 0, R = W;
      if (L === 0)
        return Z;
      if (L /= Y, L === 1)
        return Z + W;
      K || (K = Y * 0.3);
      var le = d(R, W, K, me);
      return le.a * Math.pow(2, -10 * L) * Math.sin((L * Y - le.s) * (2 * Math.PI) / le.p) + le.c + Z;
    }
    function re(L, Z, W, Y) {
      var me = 1.70158, K = 0, R = W;
      if (L === 0)
        return Z;
      if (L /= Y / 2, L === 2)
        return Z + W;
      K || (K = Y * (0.3 * 1.5));
      var le = d(R, W, K, me);
      return L < 1 ? -0.5 * l(le, L, Y) + Z : le.a * Math.pow(2, -10 * (L -= 1)) * Math.sin((L * Y - le.s) * (2 * Math.PI) / le.p) * 0.5 + le.c + Z;
    }
    function he(L, Z, W, Y, me) {
      return me === void 0 && (me = 1.70158), W * (L /= Y) * L * ((me + 1) * L - me) + Z;
    }
    function de(L, Z, W, Y, me) {
      return me === void 0 && (me = 1.70158), W * ((L = L / Y - 1) * L * ((me + 1) * L + me) + 1) + Z;
    }
    function Ce(L, Z, W, Y, me) {
      return me === void 0 && (me = 1.70158), L /= Y / 2, L < 1 ? W / 2 * (L * L * (((me *= 1.525) + 1) * L - me)) + Z : W / 2 * ((L -= 2) * L * (((me *= 1.525) + 1) * L + me) + 2) + Z;
    }
    function xe(L, Z, W, Y) {
      return W - Ie(Y - L, 0, W, Y) + Z;
    }
    function Ie(L, Z, W, Y) {
      return (L /= Y) < 1 / 2.75 ? W * (7.5625 * L * L) + Z : L < 2 / 2.75 ? W * (7.5625 * (L -= 1.5 / 2.75) * L + 0.75) + Z : L < 2.5 / 2.75 ? W * (7.5625 * (L -= 2.25 / 2.75) * L + 0.9375) + Z : W * (7.5625 * (L -= 2.625 / 2.75) * L + 0.984375) + Z;
    }
    function Be(L, Z, W, Y) {
      return L < Y / 2 ? xe(L * 2, 0, W, Y) * 0.5 + Z : Ie(L * 2 - Y, 0, W, Y) * 0.5 + W * 0.5 + Z;
    }
    n.util.ease = {
      /**
       * Quadratic easing in
       * @memberOf fabric.util.ease
       */
      easeInQuad: function(L, Z, W, Y) {
        return W * (L /= Y) * L + Z;
      },
      /**
       * Quadratic easing out
       * @memberOf fabric.util.ease
       */
      easeOutQuad: function(L, Z, W, Y) {
        return -W * (L /= Y) * (L - 2) + Z;
      },
      /**
       * Quadratic easing in and out
       * @memberOf fabric.util.ease
       */
      easeInOutQuad: function(L, Z, W, Y) {
        return L /= Y / 2, L < 1 ? W / 2 * L * L + Z : -W / 2 * (--L * (L - 2) - 1) + Z;
      },
      /**
       * Cubic easing in
       * @memberOf fabric.util.ease
       */
      easeInCubic: function(L, Z, W, Y) {
        return W * (L /= Y) * L * L + Z;
      },
      easeOutCubic: p,
      easeInOutCubic: v,
      easeInQuart: c,
      easeOutQuart: e,
      easeInOutQuart: h,
      easeInQuint: m,
      easeOutQuint: b,
      easeInOutQuint: f,
      easeInSine: k,
      easeOutSine: E,
      easeInOutSine: _,
      easeInExpo: T,
      easeOutExpo: D,
      easeInOutExpo: V,
      easeInCirc: I,
      easeOutCirc: M,
      easeInOutCirc: Q,
      easeInElastic: G,
      easeOutElastic: z,
      easeInOutElastic: re,
      easeInBack: he,
      easeOutBack: de,
      easeInOutBack: Ce,
      easeInBounce: xe,
      easeOutBounce: Ie,
      easeInOutBounce: Be
    };
  }(), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.util.object.clone, c = l.util.toFixed, e = l.util.parseUnit, h = l.util.multiplyTransformMatrices, m = [
      "path",
      "circle",
      "polygon",
      "polyline",
      "ellipse",
      "rect",
      "line",
      "image",
      "text"
    ], b = ["symbol", "image", "marker", "pattern", "view", "svg"], f = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], k = ["symbol", "g", "a", "svg", "clipPath", "defs"], E = {
      cx: "left",
      x: "left",
      r: "radius",
      cy: "top",
      y: "top",
      display: "visible",
      visibility: "visible",
      transform: "transformMatrix",
      "fill-opacity": "fillOpacity",
      "fill-rule": "fillRule",
      "font-family": "fontFamily",
      "font-size": "fontSize",
      "font-style": "fontStyle",
      "font-weight": "fontWeight",
      "letter-spacing": "charSpacing",
      "paint-order": "paintFirst",
      "stroke-dasharray": "strokeDashArray",
      "stroke-dashoffset": "strokeDashOffset",
      "stroke-linecap": "strokeLineCap",
      "stroke-linejoin": "strokeLineJoin",
      "stroke-miterlimit": "strokeMiterLimit",
      "stroke-opacity": "strokeOpacity",
      "stroke-width": "strokeWidth",
      "text-decoration": "textDecoration",
      "text-anchor": "textAnchor",
      opacity: "opacity",
      "clip-path": "clipPath",
      "clip-rule": "clipRule",
      "vector-effect": "strokeUniform",
      "image-rendering": "imageSmoothing"
    }, _ = {
      stroke: "strokeOpacity",
      fill: "fillOpacity"
    }, T = "font-size", D = "clip-path";
    l.svgValidTagNamesRegEx = M(m), l.svgViewBoxElementsRegEx = M(b), l.svgInvalidAncestorsRegEx = M(f), l.svgValidParentsRegEx = M(k), l.cssRules = {}, l.gradientDefs = {}, l.clipPaths = {};
    function V(K) {
      return K in E ? E[K] : K;
    }
    function I(K, R, le, fe) {
      var Se = Array.isArray(R), we;
      if ((K === "fill" || K === "stroke") && R === "none")
        R = "";
      else {
        if (K === "strokeUniform")
          return R === "non-scaling-stroke";
        if (K === "strokeDashArray")
          R === "none" ? R = null : R = R.replace(/,/g, " ").split(/\s+/).map(parseFloat);
        else if (K === "transformMatrix")
          le && le.transformMatrix ? R = h(
            le.transformMatrix,
            l.parseTransformAttribute(R)
          ) : R = l.parseTransformAttribute(R);
        else if (K === "visible")
          R = R !== "none" && R !== "hidden", le && le.visible === !1 && (R = !1);
        else if (K === "opacity")
          R = parseFloat(R), le && typeof le.opacity < "u" && (R *= le.opacity);
        else if (K === "textAnchor")
          R = R === "start" ? "left" : R === "end" ? "right" : "center";
        else if (K === "charSpacing")
          we = e(R, fe) / fe * 1e3;
        else if (K === "paintFirst") {
          var De = R.indexOf("fill"), Le = R.indexOf("stroke"), R = "fill";
          (De > -1 && Le > -1 && Le < De || De === -1 && Le > -1) && (R = "stroke");
        } else {
          if (K === "href" || K === "xlink:href" || K === "font")
            return R;
          if (K === "imageSmoothing")
            return R === "optimizeQuality";
          we = Se ? R.map(e) : e(R, fe);
        }
      }
      return !Se && isNaN(we) ? R : we;
    }
    function M(K) {
      return new RegExp("^(" + K.join("|") + ")\\b", "i");
    }
    function Q(K) {
      for (var R in _)
        if (!(typeof K[_[R]] > "u" || K[R] === "")) {
          if (typeof K[R] > "u") {
            if (!l.Object.prototype[R])
              continue;
            K[R] = l.Object.prototype[R];
          }
          if (K[R].indexOf("url(") !== 0) {
            var le = new l.Color(K[R]);
            K[R] = le.setAlpha(c(le.getAlpha() * K[_[R]], 2)).toRgba();
          }
        }
      return K;
    }
    function G(K, R) {
      var le, fe = [], Se, we, De;
      for (we = 0, De = R.length; we < De; we++)
        le = R[we], Se = K.getElementsByTagName(le), fe = fe.concat(Array.prototype.slice.call(Se));
      return fe;
    }
    l.parseTransformAttribute = function() {
      function K(ne, Ve) {
        var Ae = l.util.cos(Ve[0]), je = l.util.sin(Ve[0]), rt = 0, st = 0;
        Ve.length === 3 && (rt = Ve[1], st = Ve[2]), ne[0] = Ae, ne[1] = je, ne[2] = -je, ne[3] = Ae, ne[4] = rt - (Ae * rt - je * st), ne[5] = st - (je * rt + Ae * st);
      }
      function R(ne, Ve) {
        var Ae = Ve[0], je = Ve.length === 2 ? Ve[1] : Ve[0];
        ne[0] = Ae, ne[3] = je;
      }
      function le(ne, Ve, Ae) {
        ne[Ae] = Math.tan(l.util.degreesToRadians(Ve[0]));
      }
      function fe(ne, Ve) {
        ne[4] = Ve[0], Ve.length === 2 && (ne[5] = Ve[1]);
      }
      var Se = l.iMatrix, we = l.reNum, De = l.commaWsp, Le = "(?:(skewX)\\s*\\(\\s*(" + we + ")\\s*\\))", Ye = "(?:(skewY)\\s*\\(\\s*(" + we + ")\\s*\\))", $ = "(?:(rotate)\\s*\\(\\s*(" + we + ")(?:" + De + "(" + we + ")" + De + "(" + we + "))?\\s*\\))", A = "(?:(scale)\\s*\\(\\s*(" + we + ")(?:" + De + "(" + we + "))?\\s*\\))", X = "(?:(translate)\\s*\\(\\s*(" + we + ")(?:" + De + "(" + we + "))?\\s*\\))", te = "(?:(matrix)\\s*\\(\\s*(" + we + ")" + De + "(" + we + ")" + De + "(" + we + ")" + De + "(" + we + ")" + De + "(" + we + ")" + De + "(" + we + ")\\s*\\))", J = "(?:" + te + "|" + X + "|" + A + "|" + $ + "|" + Le + "|" + Ye + ")", ae = "(?:" + J + "(?:" + De + "*" + J + ")*)", ge = "^\\s*(?:" + ae + "?)\\s*$", be = new RegExp(ge), ke = new RegExp(J, "g");
      return function(ne) {
        var Ve = Se.concat(), Ae = [];
        if (!ne || ne && !be.test(ne))
          return Ve;
        ne.replace(ke, function(rt) {
          var st = new RegExp(J).exec(rt).filter(function(Lt) {
            return !!Lt;
          }), pt = st[1], vt = st.slice(2).map(parseFloat);
          switch (pt) {
            case "translate":
              fe(Ve, vt);
              break;
            case "rotate":
              vt[0] = l.util.degreesToRadians(vt[0]), K(Ve, vt);
              break;
            case "scale":
              R(Ve, vt);
              break;
            case "skewX":
              le(Ve, vt, 2);
              break;
            case "skewY":
              le(Ve, vt, 1);
              break;
            case "matrix":
              Ve = vt;
              break;
          }
          Ae.push(Ve.concat()), Ve = Se.concat();
        });
        for (var je = Ae[0]; Ae.length > 1; )
          Ae.shift(), je = l.util.multiplyTransformMatrices(je, Ae[0]);
        return je;
      };
    }();
    function z(K, R) {
      var le, fe;
      K.replace(/;\s*$/, "").split(";").forEach(function(Se) {
        var we = Se.split(":");
        le = we[0].trim().toLowerCase(), fe = we[1].trim(), R[le] = fe;
      });
    }
    function re(K, R) {
      var le, fe;
      for (var Se in K)
        typeof K[Se] > "u" || (le = Se.toLowerCase(), fe = K[Se], R[le] = fe);
    }
    function he(K, R) {
      var le = {};
      for (var fe in l.cssRules[R])
        if (de(K, fe.split(" ")))
          for (var Se in l.cssRules[R][fe])
            le[Se] = l.cssRules[R][fe][Se];
      return le;
    }
    function de(K, R) {
      var le, fe = !0;
      return le = xe(K, R.pop()), le && R.length && (fe = Ce(K, R)), le && fe && R.length === 0;
    }
    function Ce(K, R) {
      for (var le, fe = !0; K.parentNode && K.parentNode.nodeType === 1 && R.length; )
        fe && (le = R.pop()), K = K.parentNode, fe = xe(K, le);
      return R.length === 0;
    }
    function xe(K, R) {
      var le = K.nodeName, fe = K.getAttribute("class"), Se = K.getAttribute("id"), we, De;
      if (we = new RegExp("^" + le, "i"), R = R.replace(we, ""), Se && R.length && (we = new RegExp("#" + Se + "(?![a-zA-Z\\-]+)", "i"), R = R.replace(we, "")), fe && R.length)
        for (fe = fe.split(" "), De = fe.length; De--; )
          we = new RegExp("\\." + fe[De] + "(?![a-zA-Z\\-]+)", "i"), R = R.replace(we, "");
      return R.length === 0;
    }
    function Ie(K, R) {
      var le;
      if (K.getElementById && (le = K.getElementById(R)), le)
        return le;
      var fe, Se, we, De = K.getElementsByTagName("*");
      for (Se = 0, we = De.length; Se < we; Se++)
        if (fe = De[Se], R === fe.getAttribute("id"))
          return fe;
    }
    function Be(K) {
      for (var R = G(K, ["use", "svg:use"]), le = 0; R.length && le < R.length; ) {
        var fe = R[le], Se = fe.getAttribute("xlink:href") || fe.getAttribute("href");
        if (Se === null)
          return;
        var we = Se.slice(1), De = fe.getAttribute("x") || 0, Le = fe.getAttribute("y") || 0, Ye = Ie(K, we).cloneNode(!0), $ = (Ye.getAttribute("transform") || "") + " translate(" + De + ", " + Le + ")", A, X = R.length, te, J, ae, ge, be = l.svgNS;
        if (Z(Ye), /^svg$/i.test(Ye.nodeName)) {
          var ke = Ye.ownerDocument.createElementNS(be, "g");
          for (J = 0, ae = Ye.attributes, ge = ae.length; J < ge; J++)
            te = ae.item(J), ke.setAttributeNS(be, te.nodeName, te.nodeValue);
          for (; Ye.firstChild; )
            ke.appendChild(Ye.firstChild);
          Ye = ke;
        }
        for (J = 0, ae = fe.attributes, ge = ae.length; J < ge; J++)
          te = ae.item(J), !(te.nodeName === "x" || te.nodeName === "y" || te.nodeName === "xlink:href" || te.nodeName === "href") && (te.nodeName === "transform" ? $ = te.nodeValue + " " + $ : Ye.setAttribute(te.nodeName, te.nodeValue));
        Ye.setAttribute("transform", $), Ye.setAttribute("instantiated_by_use", "1"), Ye.removeAttribute("id"), A = fe.parentNode, A.replaceChild(Ye, fe), R.length === X && le++;
      }
    }
    var L = new RegExp(
      "^\\s*(" + l.reNum + "+)\\s*,?\\s*(" + l.reNum + "+)\\s*,?\\s*(" + l.reNum + "+)\\s*,?\\s*(" + l.reNum + "+)\\s*$"
    );
    function Z(K) {
      if (!l.svgViewBoxElementsRegEx.test(K.nodeName))
        return {};
      var R = K.getAttribute("viewBox"), le = 1, fe = 1, Se = 0, we = 0, De, Le, Ye, $, A = K.getAttribute("width"), X = K.getAttribute("height"), te = K.getAttribute("x") || 0, J = K.getAttribute("y") || 0, ae = K.getAttribute("preserveAspectRatio") || "", ge = !R || !(R = R.match(L)), be = !A || !X || A === "100%" || X === "100%", ke = ge && be, ne = {}, Ve = "", Ae = 0, je = 0;
      if (ne.width = 0, ne.height = 0, ne.toBeParsed = ke, ge && (te || J) && K.parentNode && K.parentNode.nodeName !== "#document" && (Ve = " translate(" + e(te) + " " + e(J) + ") ", Ye = (K.getAttribute("transform") || "") + Ve, K.setAttribute("transform", Ye), K.removeAttribute("x"), K.removeAttribute("y")), ke)
        return ne;
      if (ge)
        return ne.width = e(A), ne.height = e(X), ne;
      if (Se = -parseFloat(R[1]), we = -parseFloat(R[2]), De = parseFloat(R[3]), Le = parseFloat(R[4]), ne.minX = Se, ne.minY = we, ne.viewBoxWidth = De, ne.viewBoxHeight = Le, be ? (ne.width = De, ne.height = Le) : (ne.width = e(A), ne.height = e(X), le = ne.width / De, fe = ne.height / Le), ae = l.util.parsePreserveAspectRatioAttribute(ae), ae.alignX !== "none" && (ae.meetOrSlice === "meet" && (fe = le = le > fe ? fe : le), ae.meetOrSlice === "slice" && (fe = le = le > fe ? le : fe), Ae = ne.width - De * le, je = ne.height - Le * le, ae.alignX === "Mid" && (Ae /= 2), ae.alignY === "Mid" && (je /= 2), ae.alignX === "Min" && (Ae = 0), ae.alignY === "Min" && (je = 0)), le === 1 && fe === 1 && Se === 0 && we === 0 && te === 0 && J === 0)
        return ne;
      if ((te || J) && K.parentNode.nodeName !== "#document" && (Ve = " translate(" + e(te) + " " + e(J) + ") "), Ye = Ve + " matrix(" + le + " 0 0 " + fe + " " + (Se * le + Ae) + " " + (we * fe + je) + ") ", K.nodeName === "svg") {
        for ($ = K.ownerDocument.createElementNS(l.svgNS, "g"); K.firstChild; )
          $.appendChild(K.firstChild);
        K.appendChild($);
      } else
        $ = K, $.removeAttribute("x"), $.removeAttribute("y"), Ye = $.getAttribute("transform") + Ye;
      return $.setAttribute("transform", Ye), ne;
    }
    function W(K, R) {
      for (; K && (K = K.parentNode); )
        if (K.nodeName && R.test(K.nodeName.replace("svg:", "")) && !K.getAttribute("instantiated_by_use"))
          return !0;
      return !1;
    }
    l.parseSVGDocument = function(K, R, le, fe) {
      if (K) {
        Be(K);
        var Se = l.Object.__uid++, we, De, Le = Z(K), Ye = l.util.toArray(K.getElementsByTagName("*"));
        if (Le.crossOrigin = fe && fe.crossOrigin, Le.svgUid = Se, Ye.length === 0 && l.isLikelyNode) {
          Ye = K.selectNodes('//*[name(.)!="svg"]');
          var $ = [];
          for (we = 0, De = Ye.length; we < De; we++)
            $[we] = Ye[we];
          Ye = $;
        }
        var A = Ye.filter(function(te) {
          return Z(te), l.svgValidTagNamesRegEx.test(te.nodeName.replace("svg:", "")) && !W(te, l.svgInvalidAncestorsRegEx);
        });
        if (!A || A && !A.length) {
          R && R([], {});
          return;
        }
        var X = {};
        Ye.filter(function(te) {
          return te.nodeName.replace("svg:", "") === "clipPath";
        }).forEach(function(te) {
          var J = te.getAttribute("id");
          X[J] = l.util.toArray(te.getElementsByTagName("*")).filter(function(ae) {
            return l.svgValidTagNamesRegEx.test(ae.nodeName.replace("svg:", ""));
          });
        }), l.gradientDefs[Se] = l.getGradientDefs(K), l.cssRules[Se] = l.getCSSRules(K), l.clipPaths[Se] = X, l.parseElements(A, function(te, J) {
          R && (R(te, Le, J, Ye), delete l.gradientDefs[Se], delete l.cssRules[Se], delete l.clipPaths[Se]);
        }, v(Le), le, fe);
      }
    };
    function Y(K, R) {
      var le = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], fe = "xlink:href", Se = R.getAttribute(fe).slice(1), we = Ie(K, Se);
      if (we && we.getAttribute(fe) && Y(K, we), le.forEach(function(Le) {
        we && !R.hasAttribute(Le) && we.hasAttribute(Le) && R.setAttribute(Le, we.getAttribute(Le));
      }), !R.children.length)
        for (var De = we.cloneNode(!0); De.firstChild; )
          R.appendChild(De.firstChild);
      R.removeAttribute(fe);
    }
    var me = new RegExp(
      "(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + l.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + l.reNum + "))?\\s+(.*)"
    );
    p(l, {
      /**
       * Parses a short font declaration, building adding its properties to a style object
       * @static
       * @function
       * @memberOf fabric
       * @param {String} value font declaration
       * @param {Object} oStyle definition
       */
      parseFontDeclaration: function(K, R) {
        var le = K.match(me);
        if (le) {
          var fe = le[1], Se = le[3], we = le[4], De = le[5], Le = le[6];
          fe && (R.fontStyle = fe), Se && (R.fontWeight = isNaN(parseFloat(Se)) ? Se : parseFloat(Se)), we && (R.fontSize = e(we)), Le && (R.fontFamily = Le), De && (R.lineHeight = De === "normal" ? 1 : De);
        }
      },
      /**
       * Parses an SVG document, returning all of the gradient declarations found in it
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
       */
      getGradientDefs: function(K) {
        var R = [
          "linearGradient",
          "radialGradient",
          "svg:linearGradient",
          "svg:radialGradient"
        ], le = G(K, R), fe, Se = 0, we = {};
        for (Se = le.length; Se--; )
          fe = le[Se], fe.getAttribute("xlink:href") && Y(K, fe), we[fe.getAttribute("id")] = fe;
        return we;
      },
      /**
       * Returns an object of attributes' name/value, given element and an array of attribute names;
       * Parses parent "g" nodes recursively upwards.
       * @static
       * @memberOf fabric
       * @param {DOMElement} element Element to parse
       * @param {Array} attributes Array of attributes to parse
       * @return {Object} object containing parsed attributes' names/values
       */
      parseAttributes: function(K, R, le) {
        if (K) {
          var fe, Se = {}, we, De;
          typeof le > "u" && (le = K.getAttribute("svgUid")), K.parentNode && l.svgValidParentsRegEx.test(K.parentNode.nodeName) && (Se = l.parseAttributes(K.parentNode, R, le));
          var Le = R.reduce(function(ae, ge) {
            return fe = K.getAttribute(ge), fe && (ae[ge] = fe), ae;
          }, {}), Ye = p(
            he(K, le),
            l.parseStyleAttribute(K)
          );
          Le = p(
            Le,
            Ye
          ), Ye[D] && K.setAttribute(D, Ye[D]), we = De = Se.fontSize || l.Text.DEFAULT_SVG_FONT_SIZE, Le[T] && (Le[T] = we = e(Le[T], De));
          var $, A, X = {};
          for (var te in Le)
            $ = V(te), A = I($, Le[te], Se, we), X[$] = A;
          X && X.font && l.parseFontDeclaration(X.font, X);
          var J = p(Se, X);
          return l.svgValidParentsRegEx.test(K.nodeName) ? J : Q(J);
        }
      },
      /**
       * Transforms an array of svg elements to corresponding fabric.* instances
       * @static
       * @memberOf fabric
       * @param {Array} elements Array of elements to parse
       * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
       * @param {Object} [options] Options object
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       */
      parseElements: function(K, R, le, fe, Se) {
        new l.ElementsParser(K, R, le, fe, Se).parse();
      },
      /**
       * Parses "style" attribute, retuning an object with values
       * @static
       * @memberOf fabric
       * @param {SVGElement} element Element to parse
       * @return {Object} Objects with values parsed from style attribute of an element
       */
      parseStyleAttribute: function(K) {
        var R = {}, le = K.getAttribute("style");
        return le && (typeof le == "string" ? z(le, R) : re(le, R)), R;
      },
      /**
       * Parses "points" attribute, returning an array of values
       * @static
       * @memberOf fabric
       * @param {String} points points attribute string
       * @return {Array} array of points
       */
      parsePointsAttribute: function(K) {
        if (!K)
          return null;
        K = K.replace(/,/g, " ").trim(), K = K.split(/\s+/);
        var R = [], le, fe;
        for (le = 0, fe = K.length; le < fe; le += 2)
          R.push({
            x: parseFloat(K[le]),
            y: parseFloat(K[le + 1])
          });
        return R;
      },
      /**
       * Returns CSS rules for a given SVG document
       * @static
       * @function
       * @memberOf fabric
       * @param {SVGDocument} doc SVG document to parse
       * @return {Object} CSS rules of this document
       */
      getCSSRules: function(K) {
        var R = K.getElementsByTagName("style"), le, fe, Se = {}, we;
        for (le = 0, fe = R.length; le < fe; le++) {
          var De = R[le].textContent;
          De = De.replace(/\/\*[\s\S]*?\*\//g, ""), De.trim() !== "" && (we = De.split("}"), we = we.filter(function(Le) {
            return Le.trim();
          }), we.forEach(function(Le) {
            var Ye = Le.split("{"), $ = {}, A = Ye[1].trim(), X = A.split(";").filter(function(ge) {
              return ge.trim();
            });
            for (le = 0, fe = X.length; le < fe; le++) {
              var te = X[le].split(":"), J = te[0].trim(), ae = te[1].trim();
              $[J] = ae;
            }
            Le = Ye[0].trim(), Le.split(",").forEach(function(ge) {
              ge = ge.replace(/^svg/i, "").trim(), ge !== "" && (Se[ge] ? l.util.object.extend(Se[ge], $) : Se[ge] = l.util.object.clone($));
            });
          }));
        }
        return Se;
      },
      /**
       * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
       * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
       * @memberOf fabric
       * @param {String} url
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromURL: function(K, R, le, fe) {
        K = K.replace(/^\n\s*/, "").trim(), new l.util.request(K, {
          method: "get",
          onComplete: Se
        });
        function Se(we) {
          var De = we.responseXML;
          if (!De || !De.documentElement)
            return R && R(null), !1;
          l.parseSVGDocument(De.documentElement, function(Le, Ye, $, A) {
            R && R(Le, Ye, $, A);
          }, le, fe);
        }
      },
      /**
       * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
       * @memberOf fabric
       * @param {String} string
       * @param {Function} callback
       * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
       * @param {Object} [options] Object containing options for parsing
       * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
       */
      loadSVGFromString: function(K, R, le, fe) {
        var Se = new l.window.DOMParser(), we = Se.parseFromString(K.trim(), "text/xml");
        l.parseSVGDocument(we.documentElement, function(De, Le, Ye, $) {
          R(De, Le, Ye, $);
        }, le, fe);
      }
    });
  }(i), n.ElementsParser = function(d, l, p, v, c, e) {
    this.elements = d, this.callback = l, this.options = p, this.reviver = v, this.svgUid = p && p.svgUid || 0, this.parsingOptions = c, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = e;
  }, function(d) {
    d.parse = function() {
      this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects();
    }, d.createObjects = function() {
      var l = this;
      this.elements.forEach(function(p, v) {
        p.setAttribute("svgUid", l.svgUid), l.createObject(p, v);
      });
    }, d.findTag = function(l) {
      return n[n.util.string.capitalize(l.tagName.replace("svg:", ""))];
    }, d.createObject = function(l, p) {
      var v = this.findTag(l);
      if (v && v.fromElement)
        try {
          v.fromElement(l, this.createCallback(p, l), this.options);
        } catch (c) {
          n.log(c);
        }
      else
        this.checkIfDone();
    }, d.createCallback = function(l, p) {
      var v = this;
      return function(c) {
        var e;
        v.resolveGradient(c, p, "fill"), v.resolveGradient(c, p, "stroke"), c instanceof n.Image && c._originalElement && (e = c.parsePreserveAspectRatioAttribute(p)), c._removeTransformMatrix(e), v.resolveClipPath(c, p), v.reviver && v.reviver(p, c), v.instances[l] = c, v.checkIfDone();
      };
    }, d.extractPropertyDefinition = function(l, p, v) {
      var c = l[p], e = this.regexUrl;
      if (e.test(c)) {
        e.lastIndex = 0;
        var h = e.exec(c)[1];
        return e.lastIndex = 0, n[v][this.svgUid][h];
      }
    }, d.resolveGradient = function(l, p, v) {
      var c = this.extractPropertyDefinition(l, v, "gradientDefs");
      if (c) {
        var e = p.getAttribute(v + "-opacity"), h = n.Gradient.fromElement(c, l, e, this.options);
        l.set(v, h);
      }
    }, d.createClipPathCallback = function(l, p) {
      return function(v) {
        v._removeTransformMatrix(), v.fillRule = v.clipRule, p.push(v);
      };
    }, d.resolveClipPath = function(l, p) {
      var v = this.extractPropertyDefinition(l, "clipPath", "clipPaths"), c, e, h, m, b, f;
      if (v) {
        m = [], h = n.util.invertTransform(l.calcTransformMatrix());
        for (var k = v[0].parentNode, E = p; E.parentNode && E.getAttribute("clip-path") !== l.clipPath; )
          E = E.parentNode;
        E.parentNode.appendChild(k);
        for (var _ = 0; _ < v.length; _++)
          c = v[_], e = this.findTag(c), e.fromElement(
            c,
            this.createClipPathCallback(l, m),
            this.options
          );
        m.length === 1 ? v = m[0] : v = new n.Group(m), b = n.util.multiplyTransformMatrices(
          h,
          v.calcTransformMatrix()
        ), v.clipPath && this.resolveClipPath(v, E);
        var f = n.util.qrDecompose(b);
        v.flipX = !1, v.flipY = !1, v.set("scaleX", f.scaleX), v.set("scaleY", f.scaleY), v.angle = f.angle, v.skewX = f.skewX, v.skewY = 0, v.setPositionByOrigin({ x: f.translateX, y: f.translateY }, "center", "center"), l.clipPath = v;
      } else
        delete l.clipPath;
    }, d.checkIfDone = function() {
      --this.numElements === 0 && (this.instances = this.instances.filter(function(l) {
        return l != null;
      }), this.callback(this.instances, this.elements));
    };
  }(n.ElementsParser.prototype), function(d) {
    var l = d.fabric || (d.fabric = {});
    if (l.Point) {
      l.warn("fabric.Point is already defined");
      return;
    }
    l.Point = p;
    function p(v, c) {
      this.x = v, this.y = c;
    }
    p.prototype = /** @lends fabric.Point.prototype */
    {
      type: "point",
      constructor: p,
      /**
       * Adds another point to this one and returns another one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point instance with added values
       */
      add: function(v) {
        return new p(this.x + v.x, this.y + v.y);
      },
      /**
       * Adds another point to this one
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      addEquals: function(v) {
        return this.x += v.x, this.y += v.y, this;
      },
      /**
       * Adds value to this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point} new Point with added value
       */
      scalarAdd: function(v) {
        return new p(this.x + v, this.y + v);
      },
      /**
       * Adds value to this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarAddEquals: function(v) {
        return this.x += v, this.y += v, this;
      },
      /**
       * Subtracts another point from this point and returns a new one
       * @param {fabric.Point} that
       * @return {fabric.Point} new Point object with subtracted values
       */
      subtract: function(v) {
        return new p(this.x - v.x, this.y - v.y);
      },
      /**
       * Subtracts another point from this point
       * @param {fabric.Point} that
       * @return {fabric.Point} thisArg
       * @chainable
       */
      subtractEquals: function(v) {
        return this.x -= v.x, this.y -= v.y, this;
      },
      /**
       * Subtracts value from this point and returns a new one
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      scalarSubtract: function(v) {
        return new p(this.x - v, this.y - v);
      },
      /**
       * Subtracts value from this point
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      scalarSubtractEquals: function(v) {
        return this.x -= v, this.y -= v, this;
      },
      /**
       * Multiplies this point by a value and returns a new one
       * TODO: rename in scalarMultiply in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      multiply: function(v) {
        return new p(this.x * v, this.y * v);
      },
      /**
       * Multiplies this point by a value
       * TODO: rename in scalarMultiplyEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      multiplyEquals: function(v) {
        return this.x *= v, this.y *= v, this;
      },
      /**
       * Divides this point by a value and returns a new one
       * TODO: rename in scalarDivide in 2.0
       * @param {Number} scalar
       * @return {fabric.Point}
       */
      divide: function(v) {
        return new p(this.x / v, this.y / v);
      },
      /**
       * Divides this point by a value
       * TODO: rename in scalarDivideEquals in 2.0
       * @param {Number} scalar
       * @return {fabric.Point} thisArg
       * @chainable
       */
      divideEquals: function(v) {
        return this.x /= v, this.y /= v, this;
      },
      /**
       * Returns true if this point is equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      eq: function(v) {
        return this.x === v.x && this.y === v.y;
      },
      /**
       * Returns true if this point is less than another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lt: function(v) {
        return this.x < v.x && this.y < v.y;
      },
      /**
       * Returns true if this point is less than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      lte: function(v) {
        return this.x <= v.x && this.y <= v.y;
      },
      /**
      
      	     * Returns true if this point is greater another one
      	     * @param {fabric.Point} that
      	     * @return {Boolean}
      	     */
      gt: function(v) {
        return this.x > v.x && this.y > v.y;
      },
      /**
       * Returns true if this point is greater than or equal to another one
       * @param {fabric.Point} that
       * @return {Boolean}
       */
      gte: function(v) {
        return this.x >= v.x && this.y >= v.y;
      },
      /**
       * Returns new point which is the result of linear interpolation with this one and another one
       * @param {fabric.Point} that
       * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
       * @return {fabric.Point}
       */
      lerp: function(v, c) {
        return typeof c > "u" && (c = 0.5), c = Math.max(Math.min(1, c), 0), new p(this.x + (v.x - this.x) * c, this.y + (v.y - this.y) * c);
      },
      /**
       * Returns distance from this point and another one
       * @param {fabric.Point} that
       * @return {Number}
       */
      distanceFrom: function(v) {
        var c = this.x - v.x, e = this.y - v.y;
        return Math.sqrt(c * c + e * e);
      },
      /**
       * Returns the point between this point and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      midPointFrom: function(v) {
        return this.lerp(v);
      },
      /**
       * Returns a new point which is the min of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      min: function(v) {
        return new p(Math.min(this.x, v.x), Math.min(this.y, v.y));
      },
      /**
       * Returns a new point which is the max of this and another one
       * @param {fabric.Point} that
       * @return {fabric.Point}
       */
      max: function(v) {
        return new p(Math.max(this.x, v.x), Math.max(this.y, v.y));
      },
      /**
       * Returns string representation of this point
       * @return {String}
       */
      toString: function() {
        return this.x + "," + this.y;
      },
      /**
       * Sets x/y of this point
       * @param {Number} x
       * @param {Number} y
       * @chainable
       */
      setXY: function(v, c) {
        return this.x = v, this.y = c, this;
      },
      /**
       * Sets x of this point
       * @param {Number} x
       * @chainable
       */
      setX: function(v) {
        return this.x = v, this;
      },
      /**
       * Sets y of this point
       * @param {Number} y
       * @chainable
       */
      setY: function(v) {
        return this.y = v, this;
      },
      /**
       * Sets x/y of this point from another point
       * @param {fabric.Point} that
       * @chainable
       */
      setFromPoint: function(v) {
        return this.x = v.x, this.y = v.y, this;
      },
      /**
       * Swaps x/y of this point and another point
       * @param {fabric.Point} that
       */
      swap: function(v) {
        var c = this.x, e = this.y;
        this.x = v.x, this.y = v.y, v.x = c, v.y = e;
      },
      /**
       * return a cloned instance of the point
       * @return {fabric.Point}
       */
      clone: function() {
        return new p(this.x, this.y);
      }
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {});
    if (l.Intersection) {
      l.warn("fabric.Intersection is already defined");
      return;
    }
    function p(v) {
      this.status = v, this.points = [];
    }
    l.Intersection = p, l.Intersection.prototype = /** @lends fabric.Intersection.prototype */
    {
      constructor: p,
      /**
       * Appends a point to intersection
       * @param {fabric.Point} point
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoint: function(v) {
        return this.points.push(v), this;
      },
      /**
       * Appends points to intersection
       * @param {Array} points
       * @return {fabric.Intersection} thisArg
       * @chainable
       */
      appendPoints: function(v) {
        return this.points = this.points.concat(v), this;
      }
    }, l.Intersection.intersectLineLine = function(v, c, e, h) {
      var m, b = (h.x - e.x) * (v.y - e.y) - (h.y - e.y) * (v.x - e.x), f = (c.x - v.x) * (v.y - e.y) - (c.y - v.y) * (v.x - e.x), k = (h.y - e.y) * (c.x - v.x) - (h.x - e.x) * (c.y - v.y);
      if (k !== 0) {
        var E = b / k, _ = f / k;
        0 <= E && E <= 1 && 0 <= _ && _ <= 1 ? (m = new p("Intersection"), m.appendPoint(new l.Point(v.x + E * (c.x - v.x), v.y + E * (c.y - v.y)))) : m = new p();
      } else
        b === 0 || f === 0 ? m = new p("Coincident") : m = new p("Parallel");
      return m;
    }, l.Intersection.intersectLinePolygon = function(v, c, e) {
      var h = new p(), m = e.length, b, f, k, E;
      for (E = 0; E < m; E++)
        b = e[E], f = e[(E + 1) % m], k = p.intersectLineLine(v, c, b, f), h.appendPoints(k.points);
      return h.points.length > 0 && (h.status = "Intersection"), h;
    }, l.Intersection.intersectPolygonPolygon = function(v, c) {
      var e = new p(), h = v.length, m;
      for (m = 0; m < h; m++) {
        var b = v[m], f = v[(m + 1) % h], k = p.intersectLinePolygon(b, f, c);
        e.appendPoints(k.points);
      }
      return e.points.length > 0 && (e.status = "Intersection"), e;
    }, l.Intersection.intersectPolygonRectangle = function(v, c, e) {
      var h = c.min(e), m = c.max(e), b = new l.Point(m.x, h.y), f = new l.Point(h.x, m.y), k = p.intersectLinePolygon(h, b, v), E = p.intersectLinePolygon(b, m, v), _ = p.intersectLinePolygon(m, f, v), T = p.intersectLinePolygon(f, h, v), D = new p();
      return D.appendPoints(k.points), D.appendPoints(E.points), D.appendPoints(_.points), D.appendPoints(T.points), D.points.length > 0 && (D.status = "Intersection"), D;
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {});
    if (l.Color) {
      l.warn("fabric.Color is already defined.");
      return;
    }
    function p(c) {
      c ? this._tryParsingColor(c) : this.setSource([0, 0, 0, 1]);
    }
    l.Color = p, l.Color.prototype = /** @lends fabric.Color.prototype */
    {
      /**
       * @private
       * @param {String|Array} color Color value to parse
       */
      _tryParsingColor: function(c) {
        var e;
        c in p.colorNameMap && (c = p.colorNameMap[c]), c === "transparent" && (e = [255, 255, 255, 0]), e || (e = p.sourceFromHex(c)), e || (e = p.sourceFromRgb(c)), e || (e = p.sourceFromHsl(c)), e || (e = [0, 0, 0, 1]), e && this.setSource(e);
      },
      /**
       * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
       * @private
       * @param {Number} r Red color value
       * @param {Number} g Green color value
       * @param {Number} b Blue color value
       * @return {Array} Hsl color
       */
      _rgbToHsl: function(c, e, h) {
        c /= 255, e /= 255, h /= 255;
        var m, b, f, k = l.util.array.max([c, e, h]), E = l.util.array.min([c, e, h]);
        if (f = (k + E) / 2, k === E)
          m = b = 0;
        else {
          var _ = k - E;
          switch (b = f > 0.5 ? _ / (2 - k - E) : _ / (k + E), k) {
            case c:
              m = (e - h) / _ + (e < h ? 6 : 0);
              break;
            case e:
              m = (h - c) / _ + 2;
              break;
            case h:
              m = (c - e) / _ + 4;
              break;
          }
          m /= 6;
        }
        return [
          Math.round(m * 360),
          Math.round(b * 100),
          Math.round(f * 100)
        ];
      },
      /**
       * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @return {Array}
       */
      getSource: function() {
        return this._source;
      },
      /**
       * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
       * @param {Array} source
       */
      setSource: function(c) {
        this._source = c;
      },
      /**
       * Returns color representation in RGB format
       * @return {String} ex: rgb(0-255,0-255,0-255)
       */
      toRgb: function() {
        var c = this.getSource();
        return "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")";
      },
      /**
       * Returns color representation in RGBA format
       * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
       */
      toRgba: function() {
        var c = this.getSource();
        return "rgba(" + c[0] + "," + c[1] + "," + c[2] + "," + c[3] + ")";
      },
      /**
       * Returns color representation in HSL format
       * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
       */
      toHsl: function() {
        var c = this.getSource(), e = this._rgbToHsl(c[0], c[1], c[2]);
        return "hsl(" + e[0] + "," + e[1] + "%," + e[2] + "%)";
      },
      /**
       * Returns color representation in HSLA format
       * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
       */
      toHsla: function() {
        var c = this.getSource(), e = this._rgbToHsl(c[0], c[1], c[2]);
        return "hsla(" + e[0] + "," + e[1] + "%," + e[2] + "%," + c[3] + ")";
      },
      /**
       * Returns color representation in HEX format
       * @return {String} ex: FF5555
       */
      toHex: function() {
        var c = this.getSource(), e, h, m;
        return e = c[0].toString(16), e = e.length === 1 ? "0" + e : e, h = c[1].toString(16), h = h.length === 1 ? "0" + h : h, m = c[2].toString(16), m = m.length === 1 ? "0" + m : m, e.toUpperCase() + h.toUpperCase() + m.toUpperCase();
      },
      /**
       * Returns color representation in HEXA format
       * @return {String} ex: FF5555CC
       */
      toHexa: function() {
        var c = this.getSource(), e;
        return e = Math.round(c[3] * 255), e = e.toString(16), e = e.length === 1 ? "0" + e : e, this.toHex() + e.toUpperCase();
      },
      /**
       * Gets value of alpha channel for this color
       * @return {Number} 0-1
       */
      getAlpha: function() {
        return this.getSource()[3];
      },
      /**
       * Sets value of alpha channel for this color
       * @param {Number} alpha Alpha value 0-1
       * @return {fabric.Color} thisArg
       */
      setAlpha: function(c) {
        var e = this.getSource();
        return e[3] = c, this.setSource(e), this;
      },
      /**
       * Transforms color to its grayscale representation
       * @return {fabric.Color} thisArg
       */
      toGrayscale: function() {
        var c = this.getSource(), e = parseInt((c[0] * 0.3 + c[1] * 0.59 + c[2] * 0.11).toFixed(0), 10), h = c[3];
        return this.setSource([e, e, e, h]), this;
      },
      /**
       * Transforms color to its black and white representation
       * @param {Number} threshold
       * @return {fabric.Color} thisArg
       */
      toBlackWhite: function(c) {
        var e = this.getSource(), h = (e[0] * 0.3 + e[1] * 0.59 + e[2] * 0.11).toFixed(0), m = e[3];
        return c = c || 127, h = Number(h) < Number(c) ? 0 : 255, this.setSource([h, h, h, m]), this;
      },
      /**
       * Overlays color with another color
       * @param {String|fabric.Color} otherColor
       * @return {fabric.Color} thisArg
       */
      overlayWith: function(c) {
        c instanceof p || (c = new p(c));
        var e = [], h = this.getAlpha(), m = 0.5, b = this.getSource(), f = c.getSource(), k;
        for (k = 0; k < 3; k++)
          e.push(Math.round(b[k] * (1 - m) + f[k] * m));
        return e[3] = h, this.setSource(e), this;
      }
    }, l.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, l.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, l.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, l.Color.colorNameMap = {
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgrey: "#A9A9A9",
      darkgreen: "#006400",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      grey: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgrey: "#D3D3D3",
      lightgreen: "#90EE90",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#FF0000",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FFFF00",
      yellowgreen: "#9ACD32"
    };
    function v(c, e, h) {
      return h < 0 && (h += 1), h > 1 && (h -= 1), h < 1 / 6 ? c + (e - c) * 6 * h : h < 1 / 2 ? e : h < 2 / 3 ? c + (e - c) * (2 / 3 - h) * 6 : c;
    }
    l.Color.fromRgb = function(c) {
      return p.fromSource(p.sourceFromRgb(c));
    }, l.Color.sourceFromRgb = function(c) {
      var e = c.match(p.reRGBa);
      if (e) {
        var h = parseInt(e[1], 10) / (/%$/.test(e[1]) ? 100 : 1) * (/%$/.test(e[1]) ? 255 : 1), m = parseInt(e[2], 10) / (/%$/.test(e[2]) ? 100 : 1) * (/%$/.test(e[2]) ? 255 : 1), b = parseInt(e[3], 10) / (/%$/.test(e[3]) ? 100 : 1) * (/%$/.test(e[3]) ? 255 : 1);
        return [
          parseInt(h, 10),
          parseInt(m, 10),
          parseInt(b, 10),
          e[4] ? parseFloat(e[4]) : 1
        ];
      }
    }, l.Color.fromRgba = p.fromRgb, l.Color.fromHsl = function(c) {
      return p.fromSource(p.sourceFromHsl(c));
    }, l.Color.sourceFromHsl = function(c) {
      var e = c.match(p.reHSLa);
      if (e) {
        var h = (parseFloat(e[1]) % 360 + 360) % 360 / 360, m = parseFloat(e[2]) / (/%$/.test(e[2]) ? 100 : 1), b = parseFloat(e[3]) / (/%$/.test(e[3]) ? 100 : 1), f, k, E;
        if (m === 0)
          f = k = E = b;
        else {
          var _ = b <= 0.5 ? b * (m + 1) : b + m - b * m, T = b * 2 - _;
          f = v(T, _, h + 1 / 3), k = v(T, _, h), E = v(T, _, h - 1 / 3);
        }
        return [
          Math.round(f * 255),
          Math.round(k * 255),
          Math.round(E * 255),
          e[4] ? parseFloat(e[4]) : 1
        ];
      }
    }, l.Color.fromHsla = p.fromHsl, l.Color.fromHex = function(c) {
      return p.fromSource(p.sourceFromHex(c));
    }, l.Color.sourceFromHex = function(c) {
      if (c.match(p.reHex)) {
        var e = c.slice(c.indexOf("#") + 1), h = e.length === 3 || e.length === 4, m = e.length === 8 || e.length === 4, b = h ? e.charAt(0) + e.charAt(0) : e.substring(0, 2), f = h ? e.charAt(1) + e.charAt(1) : e.substring(2, 4), k = h ? e.charAt(2) + e.charAt(2) : e.substring(4, 6), E = m ? h ? e.charAt(3) + e.charAt(3) : e.substring(6, 8) : "FF";
        return [
          parseInt(b, 16),
          parseInt(f, 16),
          parseInt(k, 16),
          parseFloat((parseInt(E, 16) / 255).toFixed(2))
        ];
      }
    }, l.Color.fromSource = function(c) {
      var e = new p();
      return e.setSource(c), e;
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], v = ["ns", "nesw", "ew", "nwse"], c = {}, e = "left", h = "top", m = "right", b = "bottom", f = "center", k = {
      top: b,
      bottom: h,
      left: m,
      right: e,
      center: f
    }, E = l.util.radiansToDegrees, _ = Math.sign || function($) {
      return ($ > 0) - ($ < 0) || +$;
    };
    function T($, A) {
      var X = $.angle + E(Math.atan2(A.y, A.x)) + 360;
      return Math.round(X % 360 / 45);
    }
    function D($, A) {
      var X = A.transform.target, te = X.canvas, J = l.util.object.clone(A);
      J.target = X, te && te.fire("object:" + $, J), X.fire($, A);
    }
    function V($, A) {
      var X = A.canvas, te = X.uniScaleKey, J = $[te];
      return X.uniformScaling && !J || !X.uniformScaling && J;
    }
    function I($) {
      return $.originX === f && $.originY === f;
    }
    function M($, A, X) {
      var te = $.lockScalingX, J = $.lockScalingY;
      return !!(te && J || !A && (te || J) && X || te && A === "x" || J && A === "y");
    }
    function Q($, A, X) {
      var te = "not-allowed", J = V($, X), ae = "";
      if (A.x !== 0 && A.y === 0 ? ae = "x" : A.x === 0 && A.y !== 0 && (ae = "y"), M(X, ae, J))
        return te;
      var ge = T(X, A);
      return p[ge] + "-resize";
    }
    function G($, A, X) {
      var te = "not-allowed";
      if (A.x !== 0 && X.lockSkewingY || A.y !== 0 && X.lockSkewingX)
        return te;
      var J = T(X, A) % 4;
      return v[J] + "-resize";
    }
    function z($, A, X) {
      return $[X.canvas.altActionKey] ? c.skewCursorStyleHandler($, A, X) : c.scaleCursorStyleHandler($, A, X);
    }
    function re($, A, X) {
      var te = $[X.canvas.altActionKey];
      if (A.x === 0)
        return te ? "skewX" : "scaleY";
      if (A.y === 0)
        return te ? "skewY" : "scaleX";
    }
    function he($, A, X) {
      return X.lockRotation ? "not-allowed" : A.cursorStyle;
    }
    function de($, A, X, te) {
      return {
        e: $,
        transform: A,
        pointer: {
          x: X,
          y: te
        }
      };
    }
    function Ce($) {
      return function(A, X, te, J) {
        var ae = X.target, ge = ae.getCenterPoint(), be = ae.translateToOriginPoint(ge, X.originX, X.originY), ke = $(A, X, te, J);
        return ae.setPositionByOrigin(be, X.originX, X.originY), ke;
      };
    }
    function xe($, A) {
      return function(X, te, J, ae) {
        var ge = A(X, te, J, ae);
        return ge && D($, de(X, te, J, ae)), ge;
      };
    }
    function Ie($, A, X, te, J) {
      var ae = $.target, ge = ae.controls[$.corner], be = ae.canvas.getZoom(), ke = ae.padding / be, ne = ae.toLocalPoint(new l.Point(te, J), A, X);
      return ne.x >= ke && (ne.x -= ke), ne.x <= -ke && (ne.x += ke), ne.y >= ke && (ne.y -= ke), ne.y <= ke && (ne.y += ke), ne.x -= ge.offsetX, ne.y -= ge.offsetY, ne;
    }
    function Be($) {
      return $.flipX !== $.flipY;
    }
    function L($, A, X, te, J) {
      if ($[A] !== 0) {
        var ae = $._getTransformedDimensions()[te], ge = J / ae * $[X];
        $.set(X, ge);
      }
    }
    function Z($, A, X, te) {
      var J = A.target, ae = J._getTransformedDimensions(0, J.skewY), ge = Ie(A, A.originX, A.originY, X, te), be = Math.abs(ge.x * 2) - ae.x, ke = J.skewX, ne;
      be < 2 ? ne = 0 : (ne = E(
        Math.atan2(be / J.scaleX, ae.y / J.scaleY)
      ), A.originX === e && A.originY === b && (ne = -ne), A.originX === m && A.originY === h && (ne = -ne), Be(J) && (ne = -ne));
      var Ve = ke !== ne;
      if (Ve) {
        var Ae = J._getTransformedDimensions().y;
        J.set("skewX", ne), L(J, "skewY", "scaleY", "y", Ae);
      }
      return Ve;
    }
    function W($, A, X, te) {
      var J = A.target, ae = J._getTransformedDimensions(J.skewX, 0), ge = Ie(A, A.originX, A.originY, X, te), be = Math.abs(ge.y * 2) - ae.y, ke = J.skewY, ne;
      be < 2 ? ne = 0 : (ne = E(
        Math.atan2(be / J.scaleY, ae.x / J.scaleX)
      ), A.originX === e && A.originY === b && (ne = -ne), A.originX === m && A.originY === h && (ne = -ne), Be(J) && (ne = -ne));
      var Ve = ke !== ne;
      if (Ve) {
        var Ae = J._getTransformedDimensions().x;
        J.set("skewY", ne), L(J, "skewX", "scaleX", "x", Ae);
      }
      return Ve;
    }
    function Y($, A, X, te) {
      var J = A.target, ae = J.skewX, ge, be = A.originY;
      if (J.lockSkewingX)
        return !1;
      if (ae === 0) {
        var ke = Ie(A, f, f, X, te);
        ke.x > 0 ? ge = e : ge = m;
      } else
        ae > 0 && (ge = be === h ? e : m), ae < 0 && (ge = be === h ? m : e), Be(J) && (ge = ge === e ? m : e);
      A.originX = ge;
      var ne = xe("skewing", Ce(Z));
      return ne($, A, X, te);
    }
    function me($, A, X, te) {
      var J = A.target, ae = J.skewY, ge, be = A.originX;
      if (J.lockSkewingY)
        return !1;
      if (ae === 0) {
        var ke = Ie(A, f, f, X, te);
        ke.y > 0 ? ge = h : ge = b;
      } else
        ae > 0 && (ge = be === e ? h : b), ae < 0 && (ge = be === e ? b : h), Be(J) && (ge = ge === h ? b : h);
      A.originY = ge;
      var ne = xe("skewing", Ce(W));
      return ne($, A, X, te);
    }
    function K($, A, X, te) {
      var J = A, ae = J.target, ge = ae.translateToOriginPoint(ae.getCenterPoint(), J.originX, J.originY);
      if (ae.lockRotation)
        return !1;
      var be = Math.atan2(J.ey - ge.y, J.ex - ge.x), ke = Math.atan2(te - ge.y, X - ge.x), ne = E(ke - be + J.theta), Ve = !0;
      if (ae.snapAngle > 0) {
        var Ae = ae.snapAngle, je = ae.snapThreshold || Ae, rt = Math.ceil(ne / Ae) * Ae, st = Math.floor(ne / Ae) * Ae;
        Math.abs(ne - st) < je ? ne = st : Math.abs(ne - rt) < je && (ne = rt);
      }
      return ne < 0 && (ne = 360 + ne), ne %= 360, Ve = ae.angle !== ne, ae.angle = ne, Ve;
    }
    function R($, A, X, te, J) {
      J = J || {};
      var ae = A.target, ge = ae.lockScalingX, be = ae.lockScalingY, ke = J.by, ne, Ve, Ae, je, rt = V($, ae), st = M(ae, ke, rt), pt, vt, Lt = A.gestureScale;
      if (st)
        return !1;
      if (Lt)
        Ve = A.scaleX * Lt, Ae = A.scaleY * Lt;
      else {
        if (ne = Ie(A, A.originX, A.originY, X, te), pt = ke !== "y" ? _(ne.x) : 1, vt = ke !== "x" ? _(ne.y) : 1, A.signX || (A.signX = pt), A.signY || (A.signY = vt), ae.lockScalingFlip && (A.signX !== pt || A.signY !== vt))
          return !1;
        if (je = ae._getTransformedDimensions(), rt && !ke) {
          var cn = Math.abs(ne.x) + Math.abs(ne.y), Ut = A.original, Zi = Math.abs(je.x * Ut.scaleX / ae.scaleX) + Math.abs(je.y * Ut.scaleY / ae.scaleY), Vn = cn / Zi;
          Ve = Ut.scaleX * Vn, Ae = Ut.scaleY * Vn;
        } else
          Ve = Math.abs(ne.x * ae.scaleX / je.x), Ae = Math.abs(ne.y * ae.scaleY / je.y);
        I(A) && (Ve *= 2, Ae *= 2), A.signX !== pt && ke !== "y" && (A.originX = k[A.originX], Ve *= -1, A.signX = pt), A.signY !== vt && ke !== "x" && (A.originY = k[A.originY], Ae *= -1, A.signY = vt);
      }
      var Qs = ae.scaleX, pn = ae.scaleY;
      return ke ? (ke === "x" && ae.set("scaleX", Ve), ke === "y" && ae.set("scaleY", Ae)) : (!ge && ae.set("scaleX", Ve), !be && ae.set("scaleY", Ae)), Qs !== ae.scaleX || pn !== ae.scaleY;
    }
    function le($, A, X, te) {
      return R($, A, X, te);
    }
    function fe($, A, X, te) {
      return R($, A, X, te, { by: "x" });
    }
    function Se($, A, X, te) {
      return R($, A, X, te, { by: "y" });
    }
    function we($, A, X, te) {
      return $[A.target.canvas.altActionKey] ? c.skewHandlerX($, A, X, te) : c.scalingY($, A, X, te);
    }
    function De($, A, X, te) {
      return $[A.target.canvas.altActionKey] ? c.skewHandlerY($, A, X, te) : c.scalingX($, A, X, te);
    }
    function Le($, A, X, te) {
      var J = A.target, ae = Ie(A, A.originX, A.originY, X, te), ge = J.strokeWidth / (J.strokeUniform ? J.scaleX : 1), be = I(A) ? 2 : 1, ke = J.width, ne = Math.abs(ae.x * be / J.scaleX) - ge;
      return J.set("width", Math.max(ne, 0)), ke !== ne;
    }
    function Ye($, A, X, te) {
      var J = A.target, ae = X - A.offsetX, ge = te - A.offsetY, be = !J.get("lockMovementX") && J.left !== ae, ke = !J.get("lockMovementY") && J.top !== ge;
      return be && J.set("left", ae), ke && J.set("top", ge), (be || ke) && D("moving", de($, A, X, te)), be || ke;
    }
    c.scaleCursorStyleHandler = Q, c.skewCursorStyleHandler = G, c.scaleSkewCursorStyleHandler = z, c.rotationWithSnapping = xe("rotating", Ce(K)), c.scalingEqually = xe("scaling", Ce(le)), c.scalingX = xe("scaling", Ce(fe)), c.scalingY = xe("scaling", Ce(Se)), c.scalingYOrSkewingX = we, c.scalingXOrSkewingY = De, c.changeWidth = xe("resizing", Ce(Le)), c.skewHandlerX = Y, c.skewHandlerY = me, c.dragHandler = Ye, c.scaleOrSkewActionName = re, c.rotationStyleHandler = he, c.fireEvent = D, c.wrapWithFixedAnchor = Ce, c.wrapWithFireEvent = xe, c.getLocalPoint = Ie, l.controlsUtils = c;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.degreesToRadians, v = l.controlsUtils;
    function c(h, m, b, f, k) {
      f = f || {};
      var E = this.sizeX || f.cornerSize || k.cornerSize, _ = this.sizeY || f.cornerSize || k.cornerSize, T = typeof f.transparentCorners < "u" ? f.transparentCorners : k.transparentCorners, D = T ? "stroke" : "fill", V = !T && (f.cornerStrokeColor || k.cornerStrokeColor), I = m, M = b, Q;
      h.save(), h.fillStyle = f.cornerColor || k.cornerColor, h.strokeStyle = f.cornerStrokeColor || k.cornerStrokeColor, E > _ ? (Q = E, h.scale(1, _ / E), M = b * E / _) : _ > E ? (Q = _, h.scale(E / _, 1), I = m * _ / E) : Q = E, h.lineWidth = 1, h.beginPath(), h.arc(I, M, Q / 2, 0, 2 * Math.PI, !1), h[D](), V && h.stroke(), h.restore();
    }
    function e(h, m, b, f, k) {
      f = f || {};
      var E = this.sizeX || f.cornerSize || k.cornerSize, _ = this.sizeY || f.cornerSize || k.cornerSize, T = typeof f.transparentCorners < "u" ? f.transparentCorners : k.transparentCorners, D = T ? "stroke" : "fill", V = !T && (f.cornerStrokeColor || k.cornerStrokeColor), I = E / 2, M = _ / 2;
      h.save(), h.fillStyle = f.cornerColor || k.cornerColor, h.strokeStyle = f.cornerStrokeColor || k.cornerStrokeColor, h.lineWidth = 1, h.translate(m, b), h.rotate(p(k.angle)), h[D + "Rect"](-I, -M, E, _), V && h.strokeRect(-I, -M, E, _), h.restore();
    }
    v.renderCircleControl = c, v.renderSquareControl = e;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {});
    function p(v) {
      for (var c in v)
        this[c] = v[c];
    }
    l.Control = p, l.Control.prototype = /** @lends fabric.Control.prototype */
    {
      /**
       * keep track of control visibility.
       * mainly for backward compatibility.
       * if you do not want to see a control, you can remove it
       * from the controlset.
       * @type {Boolean}
       * @default true
       */
      visible: !0,
      /**
       * Name of the action that the control will likely execute.
       * This is optional. FabricJS uses to identify what the user is doing for some
       * extra optimizations. If you are writing a custom control and you want to know
       * somewhere else in the code what is going on, you can use this string here.
       * you can also provide a custom getActionName if your control run multiple actions
       * depending on some external state.
       * default to scale since is the most common, used on 4 corners by default
       * @type {String}
       * @default 'scale'
       */
      actionName: "scale",
      /**
       * Drawing angle of the control.
       * NOT used for now, but name marked as needed for internal logic
       * example: to reuse the same drawing function for different rotated controls
       * @type {Number}
       * @default 0
       */
      angle: 0,
      /**
       * Relative position of the control. X
       * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities
       * of the bounding box.
       * @type {Number}
       * @default 0
       */
      x: 0,
      /**
       * Relative position of the control. Y
       * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities
       * of the bounding box.
       * @type {Number}
       * @default 0
       */
      y: 0,
      /**
       * Horizontal offset of the control from the defined position. In pixels
       * Positive offset moves the control to the right, negative to the left.
       * It used when you want to have position of control that does not scale with
       * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on
       * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will
       * stay 30 pixels no matter how the object is big. Another example is having 2
       * controls in the corner, that stay in the same position when the object scale.
       * of the bounding box.
       * @type {Number}
       * @default 0
       */
      offsetX: 0,
      /**
       * Vertical offset of the control from the defined position. In pixels
       * Positive offset moves the control to the bottom, negative to the top.
       * @type {Number}
       * @default 0
       */
      offsetY: 0,
      /**
       * Sets the length of the control. If null, defaults to object's cornerSize.
       * Expects both sizeX and sizeY to be set when set.
       * @type {?Number}
       * @default null
       */
      sizeX: null,
      /**
       * Sets the height of the control. If null, defaults to object's cornerSize.
       * Expects both sizeX and sizeY to be set when set.
       * @type {?Number}
       * @default null
       */
      sizeY: null,
      /**
       * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.
       * Expects both touchSizeX and touchSizeY to be set when set.
       * @type {?Number}
       * @default null
       */
      touchSizeX: null,
      /**
       * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.
       * Expects both touchSizeX and touchSizeY to be set when set.
       * @type {?Number}
       * @default null
       */
      touchSizeY: null,
      /**
       * Css cursor style to display when the control is hovered.
       * if the method `cursorStyleHandler` is provided, this property is ignored.
       * @type {String}
       * @default 'crosshair'
       */
      cursorStyle: "crosshair",
      /**
       * If controls has an offsetY or offsetX, draw a line that connects
       * the control to the bounding box
       * @type {Boolean}
       * @default false
       */
      withConnection: !1,
      /**
       * The control actionHandler, provide one to handle action ( control being moved )
       * @param {Event} eventData the native mouse event
       * @param {Object} transformData properties of the current transform
       * @param {Number} x x position of the cursor
       * @param {Number} y y position of the cursor
       * @return {Boolean} true if the action/event modified the object
       */
      actionHandler: function() {
      },
      /**
       * The control handler for mouse down, provide one to handle mouse down on control
       * @param {Event} eventData the native mouse event
       * @param {Object} transformData properties of the current transform
       * @param {Number} x x position of the cursor
       * @param {Number} y y position of the cursor
       * @return {Boolean} true if the action/event modified the object
       */
      mouseDownHandler: function() {
      },
      /**
       * The control mouseUpHandler, provide one to handle an effect on mouse up.
       * @param {Event} eventData the native mouse event
       * @param {Object} transformData properties of the current transform
       * @param {Number} x x position of the cursor
       * @param {Number} y y position of the cursor
       * @return {Boolean} true if the action/event modified the object
       */
      mouseUpHandler: function() {
      },
      /**
       * Returns control actionHandler
       * @param {Event} eventData the native mouse event
       * @param {fabric.Object} fabricObject on which the control is displayed
       * @param {fabric.Control} control control for which the action handler is being asked
       * @return {Function} the action handler
       */
      getActionHandler: function() {
        return this.actionHandler;
      },
      /**
       * Returns control mouseDown handler
       * @param {Event} eventData the native mouse event
       * @param {fabric.Object} fabricObject on which the control is displayed
       * @param {fabric.Control} control control for which the action handler is being asked
       * @return {Function} the action handler
       */
      getMouseDownHandler: function() {
        return this.mouseDownHandler;
      },
      /**
       * Returns control mouseUp handler
       * @param {Event} eventData the native mouse event
       * @param {fabric.Object} fabricObject on which the control is displayed
       * @param {fabric.Control} control control for which the action handler is being asked
       * @return {Function} the action handler
       */
      getMouseUpHandler: function() {
        return this.mouseUpHandler;
      },
      /**
       * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate
       * function you can pass one in the constructor
       * the cursorStyle property
       * @param {Event} eventData the native mouse event
       * @param {fabric.Control} control the current control ( likely this)
       * @param {fabric.Object} object on which the control is displayed
       * @return {String}
       */
      cursorStyleHandler: function(v, c) {
        return c.cursorStyle;
      },
      /**
       * Returns the action name. The basic implementation just return the actionName property.
       * @param {Event} eventData the native mouse event
       * @param {fabric.Control} control the current control ( likely this)
       * @param {fabric.Object} object on which the control is displayed
       * @return {String}
       */
      getActionName: function(v, c) {
        return c.actionName;
      },
      /**
       * Returns controls visibility
       * @param {fabric.Object} object on which the control is displayed
       * @param {String} controlKey key where the control is memorized on the
       * @return {Boolean}
       */
      getVisibility: function(v, c) {
        var e = v._controlsVisibility;
        return e && typeof e[c] < "u" ? e[c] : this.visible;
      },
      /**
       * Sets controls visibility
       * @param {Boolean} visibility for the object
       * @return {Void}
       */
      setVisibility: function(v) {
        this.visible = v;
      },
      positionHandler: function(v, c) {
        var e = l.util.transformPoint({
          x: this.x * v.x + this.offsetX,
          y: this.y * v.y + this.offsetY
        }, c);
        return e;
      },
      /**
       * Returns the coords for this control based on object values.
       * @param {Number} objectAngle angle from the fabric object holding the control
       * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if
       *   isTouch is true)
       * @param {Number} centerX x coordinate where the control center should be
       * @param {Number} centerY y coordinate where the control center should be
       * @param {boolean} isTouch true if touch corner, false if normal corner
       */
      calcCornerCoords: function(v, c, e, h, m) {
        var b, f, k, E, _ = m ? this.touchSizeX : this.sizeX, T = m ? this.touchSizeY : this.sizeY;
        if (_ && T && _ !== T) {
          var D = Math.atan2(T, _), V = Math.sqrt(_ * _ + T * T) / 2, I = D - l.util.degreesToRadians(v), M = Math.PI / 2 - D - l.util.degreesToRadians(v);
          b = V * l.util.cos(I), f = V * l.util.sin(I), k = V * l.util.cos(M), E = V * l.util.sin(M);
        } else {
          var Q = _ && T ? _ : c;
          V = Q * 0.7071067812;
          var I = l.util.degreesToRadians(45 - v);
          b = k = V * l.util.cos(I), f = E = V * l.util.sin(I);
        }
        return {
          tl: {
            x: e - E,
            y: h - k
          },
          tr: {
            x: e + b,
            y: h - f
          },
          bl: {
            x: e - b,
            y: h + f
          },
          br: {
            x: e + E,
            y: h + k
          }
        };
      },
      /**
      * Render function for the control.
      * When this function runs the context is unscaled. unrotate. Just retina scaled.
      * all the functions will have to translate to the point left,top before starting Drawing
      * if they want to draw a control where the position is detected.
      * left and top are the result of the positionHandler function
      * @param {RenderingContext2D} ctx the context where the control will be drawn
      * @param {Number} left position of the canvas where we are about to render the control.
      * @param {Number} top position of the canvas where we are about to render the control.
      * @param {Object} styleOverride
      * @param {fabric.Object} fabricObject the object where the control is about to be rendered
      */
      render: function(v, c, e, h, m) {
        switch (h = h || {}, h.cornerStyle || m.cornerStyle) {
          case "circle":
            l.controlsUtils.renderCircleControl.call(this, v, c, e, h, m);
            break;
          default:
            l.controlsUtils.renderSquareControl.call(this, v, c, e, h, m);
        }
      }
    };
  }(i), function() {
    function d(e, h) {
      var m = e.getAttribute("style"), b = e.getAttribute("offset") || 0, f, k, E, _;
      if (b = parseFloat(b) / (/%$/.test(b) ? 100 : 1), b = b < 0 ? 0 : b > 1 ? 1 : b, m) {
        var T = m.split(/\s*;\s*/);
        for (T[T.length - 1] === "" && T.pop(), _ = T.length; _--; ) {
          var D = T[_].split(/\s*:\s*/), V = D[0].trim(), I = D[1].trim();
          V === "stop-color" ? f = I : V === "stop-opacity" && (E = I);
        }
      }
      return f || (f = e.getAttribute("stop-color") || "rgb(0,0,0)"), E || (E = e.getAttribute("stop-opacity")), f = new n.Color(f), k = f.getAlpha(), E = isNaN(parseFloat(E)) ? 1 : parseFloat(E), E *= k * h, {
        offset: b,
        color: f.toRgb(),
        opacity: E
      };
    }
    function l(e) {
      return {
        x1: e.getAttribute("x1") || 0,
        y1: e.getAttribute("y1") || 0,
        x2: e.getAttribute("x2") || "100%",
        y2: e.getAttribute("y2") || 0
      };
    }
    function p(e) {
      return {
        x1: e.getAttribute("fx") || e.getAttribute("cx") || "50%",
        y1: e.getAttribute("fy") || e.getAttribute("cy") || "50%",
        r1: 0,
        x2: e.getAttribute("cx") || "50%",
        y2: e.getAttribute("cy") || "50%",
        r2: e.getAttribute("r") || "50%"
      };
    }
    var v = n.util.object.clone;
    n.Gradient = n.util.createClass(
      /** @lends fabric.Gradient.prototype */
      {
        /**
         * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
         * @type Number
         * @default 0
         */
        offsetX: 0,
        /**
         * Vertical offset for aligning gradients coming from SVG when outside pathgroups
         * @type Number
         * @default 0
         */
        offsetY: 0,
        /**
         * A transform matrix to apply to the gradient before painting.
         * Imported from svg gradients, is not applied with the current transform in the center.
         * Before this transform is applied, the origin point is at the top left corner of the object
         * plus the addition of offsetY and offsetX.
         * @type Number[]
         * @default null
         */
        gradientTransform: null,
        /**
         * coordinates units for coords.
         * If `pixels`, the number of coords are in the same unit of width / height.
         * If set as `percentage` the coords are still a number, but 1 means 100% of width
         * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
         * allowed values pixels or percentage.
         * @type String
         * @default 'pixels'
         */
        gradientUnits: "pixels",
        /**
         * Gradient type linear or radial
         * @type String
         * @default 'pixels'
         */
        type: "linear",
        /**
         * Constructor
         * @param {Object} options Options object with type, coords, gradientUnits and colorStops
         * @param {Object} [options.type] gradient type linear or radial
         * @param {Object} [options.gradientUnits] gradient units
         * @param {Object} [options.offsetX] SVG import compatibility
         * @param {Object} [options.offsetY] SVG import compatibility
         * @param {Object[]} options.colorStops contains the colorstops.
         * @param {Object} options.coords contains the coords of the gradient
         * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
         * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
         * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
         * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
         * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
         * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
         * @return {fabric.Gradient} thisArg
         */
        initialize: function(e) {
          e || (e = {}), e.coords || (e.coords = {});
          var h, m = this;
          Object.keys(e).forEach(function(b) {
            m[b] = e[b];
          }), this.id ? this.id += "_" + n.Object.__uid++ : this.id = n.Object.__uid++, h = {
            x1: e.coords.x1 || 0,
            y1: e.coords.y1 || 0,
            x2: e.coords.x2 || 0,
            y2: e.coords.y2 || 0
          }, this.type === "radial" && (h.r1 = e.coords.r1 || 0, h.r2 = e.coords.r2 || 0), this.coords = h, this.colorStops = e.colorStops.slice();
        },
        /**
         * Adds another colorStop
         * @param {Object} colorStop Object with offset and color
         * @return {fabric.Gradient} thisArg
         */
        addColorStop: function(e) {
          for (var h in e) {
            var m = new n.Color(e[h]);
            this.colorStops.push({
              offset: parseFloat(h),
              color: m.toRgb(),
              opacity: m.getAlpha()
            });
          }
          return this;
        },
        /**
         * Returns object representation of a gradient
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object}
         */
        toObject: function(e) {
          var h = {
            type: this.type,
            coords: this.coords,
            colorStops: this.colorStops,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            gradientUnits: this.gradientUnits,
            gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
          };
          return n.util.populateWithProperties(this, h, e), h;
        },
        /* _TO_SVG_START_ */
        /**
         * Returns SVG representation of an gradient
         * @param {Object} object Object to create a gradient for
         * @return {String} SVG representation of an gradient (linear/radial)
         */
        toSVG: function(e, k) {
          var m = v(this.coords, !0), b, f, k = k || {}, E, _, T = v(this.colorStops, !0), D = m.r1 > m.r2, V = this.gradientTransform ? this.gradientTransform.concat() : n.iMatrix.concat(), I = -this.offsetX, M = -this.offsetY, Q = !!k.additionalTransform, G = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox";
          if (T.sort(function(Ce, xe) {
            return Ce.offset - xe.offset;
          }), G === "objectBoundingBox" ? (I /= e.width, M /= e.height) : (I += e.width / 2, M += e.height / 2), e.type === "path" && this.gradientUnits !== "percentage" && (I -= e.pathOffset.x, M -= e.pathOffset.y), V[4] -= I, V[5] -= M, _ = 'id="SVGID_' + this.id + '" gradientUnits="' + G + '"', _ += ' gradientTransform="' + (Q ? k.additionalTransform + " " : "") + n.util.matrixToSVG(V) + '" ', this.type === "linear" ? E = [
            "<linearGradient ",
            _,
            ' x1="',
            m.x1,
            '" y1="',
            m.y1,
            '" x2="',
            m.x2,
            '" y2="',
            m.y2,
            `">
`
          ] : this.type === "radial" && (E = [
            "<radialGradient ",
            _,
            ' cx="',
            D ? m.x1 : m.x2,
            '" cy="',
            D ? m.y1 : m.y2,
            '" r="',
            D ? m.r1 : m.r2,
            '" fx="',
            D ? m.x2 : m.x1,
            '" fy="',
            D ? m.y2 : m.y1,
            `">
`
          ]), this.type === "radial") {
            if (D)
              for (T = T.concat(), T.reverse(), b = 0, f = T.length; b < f; b++)
                T[b].offset = 1 - T[b].offset;
            var z = Math.min(m.r1, m.r2);
            if (z > 0) {
              var re = Math.max(m.r1, m.r2), he = z / re;
              for (b = 0, f = T.length; b < f; b++)
                T[b].offset += he * (1 - T[b].offset);
            }
          }
          for (b = 0, f = T.length; b < f; b++) {
            var de = T[b];
            E.push(
              "<stop ",
              'offset="',
              de.offset * 100 + "%",
              '" style="stop-color:',
              de.color,
              typeof de.opacity < "u" ? ";stop-opacity: " + de.opacity : ";",
              `"/>
`
            );
          }
          return E.push(this.type === "linear" ? `</linearGradient>
` : `</radialGradient>
`), E.join("");
        },
        /* _TO_SVG_END_ */
        /**
         * Returns an instance of CanvasGradient
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @return {CanvasGradient}
         */
        toLive: function(e) {
          var h, m = n.util.object.clone(this.coords), b, f;
          if (this.type) {
            for (this.type === "linear" ? h = e.createLinearGradient(
              m.x1,
              m.y1,
              m.x2,
              m.y2
            ) : this.type === "radial" && (h = e.createRadialGradient(
              m.x1,
              m.y1,
              m.r1,
              m.x2,
              m.y2,
              m.r2
            )), b = 0, f = this.colorStops.length; b < f; b++) {
              var k = this.colorStops[b].color, E = this.colorStops[b].opacity, _ = this.colorStops[b].offset;
              typeof E < "u" && (k = new n.Color(k).setAlpha(E).toRgba()), h.addColorStop(_, k);
            }
            return h;
          }
        }
      }
    ), n.util.object.extend(n.Gradient, {
      /* _FROM_SVG_START_ */
      /**
       * Returns {@link fabric.Gradient} instance from an SVG element
       * @static
       * @memberOf fabric.Gradient
       * @param {SVGGradientElement} el SVG gradient element
       * @param {fabric.Object} instance
       * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
       * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients
       * that uses gradientUnits as 'userSpaceOnUse' and percentages.
       * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
       * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
       * @param {Object.number} width width part of the svg tag if viewBox is not specified
       * @param {Object.number} height height part of the svg tag if viewBox is not specified
       * @return {fabric.Gradient} Gradient instance
       * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
       * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
       */
      fromElement: function(e, h, m, b) {
        var f = parseFloat(m) / (/%$/.test(m) ? 100 : 1);
        f = f < 0 ? 0 : f > 1 ? 1 : f, isNaN(f) && (f = 1);
        var k = e.getElementsByTagName("stop"), E, _ = e.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", T = e.getAttribute("gradientTransform") || "", D = [], V, I, M = 0, Q = 0, G;
        for (e.nodeName === "linearGradient" || e.nodeName === "LINEARGRADIENT" ? (E = "linear", V = l(e)) : (E = "radial", V = p(e)), I = k.length; I--; )
          D.push(d(k[I], f));
        G = n.parseTransformAttribute(T), c(h, V, b, _), _ === "pixels" && (M = -h.left, Q = -h.top);
        var z = new n.Gradient({
          id: e.getAttribute("id"),
          type: E,
          coords: V,
          colorStops: D,
          gradientUnits: _,
          gradientTransform: G,
          offsetX: M,
          offsetY: Q
        });
        return z;
      }
      /* _FROM_SVG_END_ */
    });
    function c(e, h, m, b) {
      var f, k;
      Object.keys(h).forEach(function(E) {
        f = h[E], f === "Infinity" ? k = 1 : f === "-Infinity" ? k = 0 : (k = parseFloat(h[E], 10), typeof f == "string" && /^(\d+\.\d+)%|(\d+)%$/.test(f) && (k *= 0.01, b === "pixels" && ((E === "x1" || E === "x2" || E === "r2") && (k *= m.viewBoxWidth || m.width), (E === "y1" || E === "y2") && (k *= m.viewBoxHeight || m.height)))), h[E] = k;
      });
    }
  }(), function() {
    var d = n.util.toFixed;
    n.Pattern = n.util.createClass(
      /** @lends fabric.Pattern.prototype */
      {
        /**
         * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
         * @type String
         * @default
         */
        repeat: "repeat",
        /**
         * Pattern horizontal offset from object's left/top corner
         * @type Number
         * @default
         */
        offsetX: 0,
        /**
         * Pattern vertical offset from object's left/top corner
         * @type Number
         * @default
         */
        offsetY: 0,
        /**
         * crossOrigin value (one of "", "anonymous", "use-credentials")
         * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
         * @type String
         * @default
         */
        crossOrigin: "",
        /**
         * transform matrix to change the pattern, imported from svgs.
         * @type Array
         * @default
         */
        patternTransform: null,
        /**
         * Constructor
         * @param {Object} [options] Options object
         * @param {Function} [callback] function to invoke after callback init.
         * @return {fabric.Pattern} thisArg
         */
        initialize: function(l, p) {
          if (l || (l = {}), this.id = n.Object.__uid++, this.setOptions(l), !l.source || l.source && typeof l.source != "string") {
            p && p(this);
            return;
          } else {
            var v = this;
            this.source = n.util.createImage(), n.util.loadImage(l.source, function(c, e) {
              v.source = c, p && p(v, e);
            }, null, this.crossOrigin);
          }
        },
        /**
         * Returns object representation of a pattern
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of a pattern instance
         */
        toObject: function(l) {
          var p = n.Object.NUM_FRACTION_DIGITS, v, c;
          return typeof this.source.src == "string" ? v = this.source.src : typeof this.source == "object" && this.source.toDataURL && (v = this.source.toDataURL()), c = {
            type: "pattern",
            source: v,
            repeat: this.repeat,
            crossOrigin: this.crossOrigin,
            offsetX: d(this.offsetX, p),
            offsetY: d(this.offsetY, p),
            patternTransform: this.patternTransform ? this.patternTransform.concat() : null
          }, n.util.populateWithProperties(this, c, l), c;
        },
        /* _TO_SVG_START_ */
        /**
         * Returns SVG representation of a pattern
         * @param {fabric.Object} object
         * @return {String} SVG representation of a pattern
         */
        toSVG: function(l) {
          var p = typeof this.source == "function" ? this.source() : this.source, v = p.width / l.width, c = p.height / l.height, e = this.offsetX / l.width, h = this.offsetY / l.height, m = "";
          return (this.repeat === "repeat-x" || this.repeat === "no-repeat") && (c = 1, h && (c += Math.abs(h))), (this.repeat === "repeat-y" || this.repeat === "no-repeat") && (v = 1, e && (v += Math.abs(e))), p.src ? m = p.src : p.toDataURL && (m = p.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + e + '" y="' + h + '" width="' + v + '" height="' + c + `">
<image x="0" y="0" width="` + p.width + '" height="' + p.height + '" xlink:href="' + m + `"></image>
</pattern>
`;
        },
        /* _TO_SVG_END_ */
        setOptions: function(l) {
          for (var p in l)
            this[p] = l[p];
        },
        /**
         * Returns an instance of CanvasPattern
         * @param {CanvasRenderingContext2D} ctx Context to create pattern
         * @return {CanvasPattern}
         */
        toLive: function(l) {
          var p = this.source;
          return !p || typeof p.src < "u" && (!p.complete || p.naturalWidth === 0 || p.naturalHeight === 0) ? "" : l.createPattern(p, this.repeat);
        }
      }
    );
  }(), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.toFixed;
    if (l.Shadow) {
      l.warn("fabric.Shadow is already defined.");
      return;
    }
    l.Shadow = l.util.createClass(
      /** @lends fabric.Shadow.prototype */
      {
        /**
         * Shadow color
         * @type String
         * @default
         */
        color: "rgb(0,0,0)",
        /**
         * Shadow blur
         * @type Number
         */
        blur: 0,
        /**
         * Shadow horizontal offset
         * @type Number
         * @default
         */
        offsetX: 0,
        /**
         * Shadow vertical offset
         * @type Number
         * @default
         */
        offsetY: 0,
        /**
         * Whether the shadow should affect stroke operations
         * @type Boolean
         * @default
         */
        affectStroke: !1,
        /**
         * Indicates whether toObject should include default values
         * @type Boolean
         * @default
         */
        includeDefaultValues: !0,
        /**
         * When `false`, the shadow will scale with the object.
         * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
         * default to false
         * @type Boolean
         * @default
         */
        nonScaling: !1,
        /**
         * Constructor
         * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
         * @return {fabric.Shadow} thisArg
         */
        initialize: function(v) {
          typeof v == "string" && (v = this._parseShadow(v));
          for (var c in v)
            this[c] = v[c];
          this.id = l.Object.__uid++;
        },
        /**
         * @private
         * @param {String} shadow Shadow value to parse
         * @return {Object} Shadow object with color, offsetX, offsetY and blur
         */
        _parseShadow: function(v) {
          var c = v.trim(), e = l.Shadow.reOffsetsAndBlur.exec(c) || [], h = c.replace(l.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)";
          return {
            color: h.trim(),
            offsetX: parseFloat(e[1], 10) || 0,
            offsetY: parseFloat(e[2], 10) || 0,
            blur: parseFloat(e[3], 10) || 0
          };
        },
        /**
         * Returns a string representation of an instance
         * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
         * @return {String} Returns CSS3 text-shadow declaration
         */
        toString: function() {
          return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
        },
        /* _TO_SVG_START_ */
        /**
         * Returns SVG representation of a shadow
         * @param {fabric.Object} object
         * @return {String} SVG representation of a shadow
         */
        toSVG: function(v) {
          var c = 40, e = 40, h = l.Object.NUM_FRACTION_DIGITS, m = l.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            l.util.degreesToRadians(-v.angle)
          ), b = 20, f = new l.Color(this.color);
          return v.width && v.height && (c = p((Math.abs(m.x) + this.blur) / v.width, h) * 100 + b, e = p((Math.abs(m.y) + this.blur) / v.height, h) * 100 + b), v.flipX && (m.x *= -1), v.flipY && (m.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + e + '%" height="' + (100 + 2 * e) + '%" x="-' + c + '%" width="' + (100 + 2 * c) + `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="` + p(this.blur ? this.blur / 2 : 0, h) + `"></feGaussianBlur>
	<feOffset dx="` + p(m.x, h) + '" dy="' + p(m.y, h) + `" result="oBlur" ></feOffset>
	<feFlood flood-color="` + f.toRgb() + '" flood-opacity="' + f.getAlpha() + `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`;
        },
        /* _TO_SVG_END_ */
        /**
         * Returns object representation of a shadow
         * @return {Object} Object representation of a shadow instance
         */
        toObject: function() {
          if (this.includeDefaultValues)
            return {
              color: this.color,
              blur: this.blur,
              offsetX: this.offsetX,
              offsetY: this.offsetY,
              affectStroke: this.affectStroke,
              nonScaling: this.nonScaling
            };
          var v = {}, c = l.Shadow.prototype;
          return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function(e) {
            this[e] !== c[e] && (v[e] = this[e]);
          }, this), v;
        }
      }
    ), l.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/;
  }(i), function() {
    if (n.StaticCanvas) {
      n.warn("fabric.StaticCanvas is already defined.");
      return;
    }
    var d = n.util.object.extend, l = n.util.getElementOffset, p = n.util.removeFromArray, v = n.util.toFixed, c = n.util.transformPoint, e = n.util.invertTransform, h = n.util.getNodeCanvas, m = n.util.createCanvasElement, b = new Error("Could not initialize `canvas` element");
    n.StaticCanvas = n.util.createClass(
      n.CommonMethods,
      /** @lends fabric.StaticCanvas.prototype */
      {
        /**
         * Constructor
         * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
         * @param {Object} [options] Options object
         * @return {Object} thisArg
         */
        initialize: function(f, k) {
          k || (k = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(f, k);
        },
        /**
         * Background color of canvas instance.
         * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
         * @type {(String|fabric.Pattern)}
         * @default
         */
        backgroundColor: "",
        /**
         * Background image of canvas instance.
         * since 2.4.0 image caching is active, please when putting an image as background, add to the
         * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
         * vale. As an alternative you can disable image objectCaching
         * @type fabric.Image
         * @default
         */
        backgroundImage: null,
        /**
         * Overlay color of canvas instance.
         * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
         * @since 1.3.9
         * @type {(String|fabric.Pattern)}
         * @default
         */
        overlayColor: "",
        /**
         * Overlay image of canvas instance.
         * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
         * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
         * vale. As an alternative you can disable image objectCaching
         * @type fabric.Image
         * @default
         */
        overlayImage: null,
        /**
         * Indicates whether toObject/toDatalessObject should include default values
         * if set to false, takes precedence over the object value.
         * @type Boolean
         * @default
         */
        includeDefaultValues: !0,
        /**
         * Indicates whether objects' state should be saved
         * @type Boolean
         * @default
         */
        stateful: !1,
        /**
         * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
         * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
         * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
         * since the renders are quequed and executed one per frame.
         * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
         * Left default to true to do not break documentation and old app, fiddles.
         * @type Boolean
         * @default
         */
        renderOnAddRemove: !0,
        /**
         * Indicates whether object controls (borders/controls) are rendered above overlay image
         * @type Boolean
         * @default
         */
        controlsAboveOverlay: !1,
        /**
         * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
         * @type Boolean
         * @default
         */
        allowTouchScrolling: !1,
        /**
         * Indicates whether this canvas will use image smoothing, this is on by default in browsers
         * @type Boolean
         * @default
         */
        imageSmoothingEnabled: !0,
        /**
         * The transformation (a Canvas 2D API transform matrix) which focuses the viewport
         * @type Array
         * @example <caption>Default transform</caption>
         * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
         * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>
         * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];
         * @default
         */
        viewportTransform: n.iMatrix.concat(),
        /**
         * if set to false background image is not affected by viewport transform
         * @since 1.6.3
         * @type Boolean
         * @default
         */
        backgroundVpt: !0,
        /**
         * if set to false overlya image is not affected by viewport transform
         * @since 1.6.3
         * @type Boolean
         * @default
         */
        overlayVpt: !0,
        /**
         * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
         * @type Boolean
         * @default
         */
        enableRetinaScaling: !0,
        /**
         * Describe canvas element extension over design
         * properties are tl,tr,bl,br.
         * if canvas is not zoomed/panned those points are the four corner of canvas
         * if canvas is viewportTransformed you those points indicate the extension
         * of canvas element in plain untrasformed coordinates
         * The coordinates get updated with @method calcViewportBoundaries.
         * @memberOf fabric.StaticCanvas.prototype
         */
        vptCoords: {},
        /**
         * Based on vptCoords and object.aCoords, skip rendering of objects that
         * are not included in current viewport.
         * May greatly help in applications with crowded canvas and use of zoom/pan
         * If One of the corner of the bounding box of the object is on the canvas
         * the objects get rendered.
         * @memberOf fabric.StaticCanvas.prototype
         * @type Boolean
         * @default
         */
        skipOffscreen: !0,
        /**
         * a fabricObject that, without stroke define a clipping area with their shape. filled in black
         * the clipPath object gets used when the canvas has rendered, and the context is placed in the
         * top left corner of the canvas.
         * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
         * @type fabric.Object
         */
        clipPath: void 0,
        /**
         * @private
         * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
         * @param {Object} [options] Options object
         */
        _initStatic: function(f, k) {
          var E = this.requestRenderAllBound;
          this._objects = [], this._createLowerCanvas(f), this._initOptions(k), this.interactive || this._initRetinaScaling(), k.overlayImage && this.setOverlayImage(k.overlayImage, E), k.backgroundImage && this.setBackgroundImage(k.backgroundImage, E), k.backgroundColor && this.setBackgroundColor(k.backgroundColor, E), k.overlayColor && this.setOverlayColor(k.overlayColor, E), this.calcOffset();
        },
        /**
         * @private
         */
        _isRetinaScaling: function() {
          return n.devicePixelRatio > 1 && this.enableRetinaScaling;
        },
        /**
         * @private
         * @return {Number} retinaScaling if applied, otherwise 1;
         */
        getRetinaScaling: function() {
          return this._isRetinaScaling() ? Math.max(1, n.devicePixelRatio) : 1;
        },
        /**
         * @private
         */
        _initRetinaScaling: function() {
          if (this._isRetinaScaling()) {
            var f = n.devicePixelRatio;
            this.__initRetinaScaling(f, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(f, this.upperCanvasEl, this.contextTop);
          }
        },
        __initRetinaScaling: function(f, k, E) {
          k.setAttribute("width", this.width * f), k.setAttribute("height", this.height * f), E.scale(f, f);
        },
        /**
         * Calculates canvas element offset relative to the document
         * This method is also attached as "resize" event handler of window
         * @return {fabric.Canvas} instance
         * @chainable
         */
        calcOffset: function() {
          return this._offset = l(this.lowerCanvasEl), this;
        },
        /**
         * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
         * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
         * @param {Function} callback callback to invoke when image is loaded and set as an overlay
         * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
         * @return {fabric.Canvas} thisArg
         * @chainable
         * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
         * @example <caption>Normal overlayImage with left/top = 0</caption>
         * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
         *   // Needed to position overlayImage at 0/0
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>overlayImage with different properties</caption>
         * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
         *   opacity: 0.5,
         *   angle: 45,
         *   left: 400,
         *   top: 400,
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
         * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {
         *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
         *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
         * });
         * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
         * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
         *   width: canvas.width,
         *   height: canvas.height,
         *   // Needed to position overlayImage at 0/0
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>overlayImage loaded from cross-origin</caption>
         * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
         *   opacity: 0.5,
         *   angle: 45,
         *   left: 400,
         *   top: 400,
         *   originX: 'left',
         *   originY: 'top',
         *   crossOrigin: 'anonymous'
         * });
         */
        setOverlayImage: function(f, k, E) {
          return this.__setBgOverlayImage("overlayImage", f, k, E);
        },
        /**
         * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
         * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
         * @param {Function} callback Callback to invoke when image is loaded and set as background
         * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
         * @return {fabric.Canvas} thisArg
         * @chainable
         * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
         * @example <caption>Normal backgroundImage with left/top = 0</caption>
         * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
         *   // Needed to position backgroundImage at 0/0
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>backgroundImage with different properties</caption>
         * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
         *   opacity: 0.5,
         *   angle: 45,
         *   left: 400,
         *   top: 400,
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
         * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {
         *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
         *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
         * });
         * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
         * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
         *   width: canvas.width,
         *   height: canvas.height,
         *   // Needed to position backgroundImage at 0/0
         *   originX: 'left',
         *   originY: 'top'
         * });
         * @example <caption>backgroundImage loaded from cross-origin</caption>
         * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
         *   opacity: 0.5,
         *   angle: 45,
         *   left: 400,
         *   top: 400,
         *   originX: 'left',
         *   originY: 'top',
         *   crossOrigin: 'anonymous'
         * });
         */
        // TODO: fix stretched examples
        setBackgroundImage: function(f, k, E) {
          return this.__setBgOverlayImage("backgroundImage", f, k, E);
        },
        /**
         * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
         * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
         * @param {Function} callback Callback to invoke when foreground color is set
         * @return {fabric.Canvas} thisArg
         * @chainable
         * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
         * @example <caption>Normal overlayColor - color value</caption>
         * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
         * @example <caption>fabric.Pattern used as overlayColor</caption>
         * canvas.setOverlayColor({
         *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
         * }, canvas.renderAll.bind(canvas));
         * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
         * canvas.setOverlayColor({
         *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
         *   repeat: 'repeat',
         *   offsetX: 200,
         *   offsetY: 100
         * }, canvas.renderAll.bind(canvas));
         */
        setOverlayColor: function(f, k) {
          return this.__setBgOverlayColor("overlayColor", f, k);
        },
        /**
         * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
         * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
         * @param {Function} callback Callback to invoke when background color is set
         * @return {fabric.Canvas} thisArg
         * @chainable
         * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
         * @example <caption>Normal backgroundColor - color value</caption>
         * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
         * @example <caption>fabric.Pattern used as backgroundColor</caption>
         * canvas.setBackgroundColor({
         *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
         * }, canvas.renderAll.bind(canvas));
         * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
         * canvas.setBackgroundColor({
         *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
         *   repeat: 'repeat',
         *   offsetX: 200,
         *   offsetY: 100
         * }, canvas.renderAll.bind(canvas));
         */
        setBackgroundColor: function(f, k) {
          return this.__setBgOverlayColor("backgroundColor", f, k);
        },
        /**
         * @private
         * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
         * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
         * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
         * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.
         * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
         */
        __setBgOverlayImage: function(f, k, E, _) {
          return typeof k == "string" ? n.util.loadImage(k, function(T, D) {
            if (T) {
              var V = new n.Image(T, _);
              this[f] = V, V.canvas = this;
            }
            E && E(T, D);
          }, this, _ && _.crossOrigin) : (_ && k.setOptions(_), this[f] = k, k && (k.canvas = this), E && E(k, !1)), this;
        },
        /**
         * @private
         * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
         * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
         * @param {(Object|String|null)} color Object with pattern information, color value or null
         * @param {Function} [callback] Callback is invoked when color is set
         */
        __setBgOverlayColor: function(f, k, E) {
          return this[f] = k, this._initGradient(k, f), this._initPattern(k, f, E), this;
        },
        /**
         * @private
         */
        _createCanvasElement: function() {
          var f = m();
          if (!f || (f.style || (f.style = {}), typeof f.getContext > "u"))
            throw b;
          return f;
        },
        /**
         * @private
         * @param {Object} [options] Options object
         */
        _initOptions: function(f) {
          var k = this.lowerCanvasEl;
          this._setOptions(f), this.width = this.width || parseInt(k.width, 10) || 0, this.height = this.height || parseInt(k.height, 10) || 0, this.lowerCanvasEl.style && (k.width = this.width, k.height = this.height, k.style.width = this.width + "px", k.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice());
        },
        /**
         * Creates a bottom canvas
         * @private
         * @param {HTMLElement} [canvasEl]
         */
        _createLowerCanvas: function(f) {
          f && f.getContext ? this.lowerCanvasEl = f : this.lowerCanvasEl = n.util.getById(f) || this._createCanvasElement(), n.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d");
        },
        /**
         * Returns canvas width (in px)
         * @return {Number}
         */
        getWidth: function() {
          return this.width;
        },
        /**
         * Returns canvas height (in px)
         * @return {Number}
         */
        getHeight: function() {
          return this.height;
        },
        /**
         * Sets width of this canvas instance
         * @param {Number|String} value                         Value to set width to
         * @param {Object}        [options]                     Options object
         * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
         * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        setWidth: function(f, k) {
          return this.setDimensions({ width: f }, k);
        },
        /**
         * Sets height of this canvas instance
         * @param {Number|String} value                         Value to set height to
         * @param {Object}        [options]                     Options object
         * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
         * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        setHeight: function(f, k) {
          return this.setDimensions({ height: f }, k);
        },
        /**
         * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
         * @param {Object}        dimensions                    Object with width/height properties
         * @param {Number|String} [dimensions.width]            Width of canvas element
         * @param {Number|String} [dimensions.height]           Height of canvas element
         * @param {Object}        [options]                     Options object
         * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
         * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        setDimensions: function(f, k) {
          var E;
          k = k || {};
          for (var _ in f)
            E = f[_], k.cssOnly || (this._setBackstoreDimension(_, f[_]), E += "px", this.hasLostContext = !0), k.backstoreOnly || this._setCssDimension(_, E);
          return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), k.cssOnly || this.requestRenderAll(), this;
        },
        /**
         * Helper for setting width/height
         * @private
         * @param {String} prop property (width|height)
         * @param {Number} value value to set property to
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        _setBackstoreDimension: function(f, k) {
          return this.lowerCanvasEl[f] = k, this.upperCanvasEl && (this.upperCanvasEl[f] = k), this.cacheCanvasEl && (this.cacheCanvasEl[f] = k), this[f] = k, this;
        },
        /**
         * Helper for setting css width/height
         * @private
         * @param {String} prop property (width|height)
         * @param {String} value value to set property to
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        _setCssDimension: function(f, k) {
          return this.lowerCanvasEl.style[f] = k, this.upperCanvasEl && (this.upperCanvasEl.style[f] = k), this.wrapperEl && (this.wrapperEl.style[f] = k), this;
        },
        /**
         * Returns canvas zoom level
         * @return {Number}
         */
        getZoom: function() {
          return this.viewportTransform[0];
        },
        /**
         * Sets viewport transformation of this canvas instance
         * @param {Array} vpt a Canvas 2D API transform matrix
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        setViewportTransform: function(f) {
          var k = this._activeObject, E = this.backgroundImage, _ = this.overlayImage, T, D, V;
          for (this.viewportTransform = f, D = 0, V = this._objects.length; D < V; D++)
            T = this._objects[D], T.group || T.setCoords(!0);
          return k && k.setCoords(), E && E.setCoords(!0), _ && _.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * Sets zoom level of this canvas instance, the zoom centered around point
         * meaning that following zoom to point with the same point will have the visual
         * effect of the zoom originating from that point. The point won't move.
         * It has nothing to do with canvas center or visual center of the viewport.
         * @param {fabric.Point} point to zoom with respect to
         * @param {Number} value to set zoom to, less than 1 zooms out
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        zoomToPoint: function(f, k) {
          var E = f, _ = this.viewportTransform.slice(0);
          f = c(f, e(this.viewportTransform)), _[0] = k, _[3] = k;
          var T = c(f, _);
          return _[4] += E.x - T.x, _[5] += E.y - T.y, this.setViewportTransform(_);
        },
        /**
         * Sets zoom level of this canvas instance
         * @param {Number} value to set zoom to, less than 1 zooms out
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        setZoom: function(f) {
          return this.zoomToPoint(new n.Point(0, 0), f), this;
        },
        /**
         * Pan viewport so as to place point at top left corner of canvas
         * @param {fabric.Point} point to move to
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        absolutePan: function(f) {
          var k = this.viewportTransform.slice(0);
          return k[4] = -f.x, k[5] = -f.y, this.setViewportTransform(k);
        },
        /**
         * Pans viewpoint relatively
         * @param {fabric.Point} point (position vector) to move by
         * @return {fabric.Canvas} instance
         * @chainable true
         */
        relativePan: function(f) {
          return this.absolutePan(new n.Point(
            -f.x - this.viewportTransform[4],
            -f.y - this.viewportTransform[5]
          ));
        },
        /**
         * Returns &lt;canvas> element corresponding to this instance
         * @return {HTMLCanvasElement}
         */
        getElement: function() {
          return this.lowerCanvasEl;
        },
        /**
         * @private
         * @param {fabric.Object} obj Object that was added
         */
        _onObjectAdded: function(f) {
          this.stateful && f.setupState(), f._set("canvas", this), f.setCoords(), this.fire("object:added", { target: f }), f.fire("added");
        },
        /**
         * @private
         * @param {fabric.Object} obj Object that was removed
         */
        _onObjectRemoved: function(f) {
          this.fire("object:removed", { target: f }), f.fire("removed"), delete f.canvas;
        },
        /**
         * Clears specified context of canvas element
         * @param {CanvasRenderingContext2D} ctx Context to clear
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        clearContext: function(f) {
          return f.clearRect(0, 0, this.width, this.height), this;
        },
        /**
         * Returns context of canvas where objects are drawn
         * @return {CanvasRenderingContext2D}
         */
        getContext: function() {
          return this.contextContainer;
        },
        /**
         * Clears all contexts (background, main, top) of an instance
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        clear: function() {
          return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * Renders the canvas
         * @return {fabric.Canvas} instance
         * @chainable
         */
        renderAll: function() {
          var f = this.contextContainer;
          return this.renderCanvas(f, this._objects), this;
        },
        /**
         * Function created to be instance bound at initialization
         * used in requestAnimationFrame rendering
         * Let the fabricJS call it. If you call it manually you could have more
         * animationFrame stacking on to of each other
         * for an imperative rendering, use canvas.renderAll
         * @private
         * @return {fabric.Canvas} instance
         * @chainable
         */
        renderAndReset: function() {
          this.isRendering = 0, this.renderAll();
        },
        /**
         * Append a renderAll request to next animation frame.
         * unless one is already in progress, in that case nothing is done
         * a boolean flag will avoid appending more.
         * @return {fabric.Canvas} instance
         * @chainable
         */
        requestRenderAll: function() {
          return this.isRendering || (this.isRendering = n.util.requestAnimFrame(this.renderAndResetBound)), this;
        },
        /**
         * Calculate the position of the 4 corner of canvas with current viewportTransform.
         * helps to determinate when an object is in the current rendering viewport using
         * object absolute coordinates ( aCoords )
         * @return {Object} points.tl
         * @chainable
         */
        calcViewportBoundaries: function() {
          var f = {}, k = this.width, E = this.height, _ = e(this.viewportTransform);
          return f.tl = c({ x: 0, y: 0 }, _), f.br = c({ x: k, y: E }, _), f.tr = new n.Point(f.br.x, f.tl.y), f.bl = new n.Point(f.tl.x, f.br.y), this.vptCoords = f, f;
        },
        cancelRequestedRender: function() {
          this.isRendering && (n.util.cancelAnimFrame(this.isRendering), this.isRendering = 0);
        },
        /**
         * Renders background, objects, overlay and controls.
         * @param {CanvasRenderingContext2D} ctx
         * @param {Array} objects to render
         * @return {fabric.Canvas} instance
         * @chainable
         */
        renderCanvas: function(f, k) {
          var E = this.viewportTransform, _ = this.clipPath;
          this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(f), n.util.setImageSmoothing(f, this.imageSmoothingEnabled), this.fire("before:render", { ctx: f }), this._renderBackground(f), f.save(), f.transform(E[0], E[1], E[2], E[3], E[4], E[5]), this._renderObjects(f, k), f.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(f), _ && (_.canvas = this, _.shouldCache(), _._transformDone = !0, _.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(f)), this._renderOverlay(f), this.controlsAboveOverlay && this.interactive && this.drawControls(f), this.fire("after:render", { ctx: f });
        },
        /**
         * Paint the cached clipPath on the lowerCanvasEl
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        drawClipPathOnCanvas: function(f) {
          var k = this.viewportTransform, E = this.clipPath;
          f.save(), f.transform(k[0], k[1], k[2], k[3], k[4], k[5]), f.globalCompositeOperation = "destination-in", E.transform(f), f.scale(1 / E.zoomX, 1 / E.zoomY), f.drawImage(E._cacheCanvas, -E.cacheTranslationX, -E.cacheTranslationY), f.restore();
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Array} objects to render
         */
        _renderObjects: function(f, k) {
          var E, _;
          for (E = 0, _ = k.length; E < _; ++E)
            k[E] && k[E].render(f);
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {string} property 'background' or 'overlay'
         */
        _renderBackgroundOrOverlay: function(f, k) {
          var E = this[k + "Color"], _ = this[k + "Image"], T = this.viewportTransform, D = this[k + "Vpt"];
          if (!(!E && !_)) {
            if (E) {
              f.save(), f.beginPath(), f.moveTo(0, 0), f.lineTo(this.width, 0), f.lineTo(this.width, this.height), f.lineTo(0, this.height), f.closePath(), f.fillStyle = E.toLive ? E.toLive(f, this) : E, D && f.transform(T[0], T[1], T[2], T[3], T[4], T[5]), f.transform(1, 0, 0, 1, E.offsetX || 0, E.offsetY || 0);
              var V = E.gradientTransform || E.patternTransform;
              V && f.transform(V[0], V[1], V[2], V[3], V[4], V[5]), f.fill(), f.restore();
            }
            _ && (f.save(), D && f.transform(T[0], T[1], T[2], T[3], T[4], T[5]), _.render(f), f.restore());
          }
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderBackground: function(f) {
          this._renderBackgroundOrOverlay(f, "background");
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderOverlay: function(f) {
          this._renderBackgroundOrOverlay(f, "overlay");
        },
        /**
         * Returns coordinates of a center of canvas.
         * Returned value is an object with top and left properties
         * @return {Object} object with "top" and "left" number values
         * @deprecated migrate to `getCenterPoint`
         */
        getCenter: function() {
          return {
            top: this.height / 2,
            left: this.width / 2
          };
        },
        /**
         * Returns coordinates of a center of canvas.
         * @return {fabric.Point} 
         */
        getCenterPoint: function() {
          return new n.Point(this.width / 2, this.height / 2);
        },
        /**
         * Centers object horizontally in the canvas
         * @param {fabric.Object} object Object to center horizontally
         * @return {fabric.Canvas} thisArg
         */
        centerObjectH: function(f) {
          return this._centerObject(f, new n.Point(this.getCenterPoint().x, f.getCenterPoint().y));
        },
        /**
         * Centers object vertically in the canvas
         * @param {fabric.Object} object Object to center vertically
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        centerObjectV: function(f) {
          return this._centerObject(f, new n.Point(f.getCenterPoint().x, this.getCenterPoint().y));
        },
        /**
         * Centers object vertically and horizontally in the canvas
         * @param {fabric.Object} object Object to center vertically and horizontally
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        centerObject: function(f) {
          var k = this.getCenterPoint();
          return this._centerObject(f, k);
        },
        /**
         * Centers object vertically and horizontally in the viewport
         * @param {fabric.Object} object Object to center vertically and horizontally
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        viewportCenterObject: function(f) {
          var k = this.getVpCenter();
          return this._centerObject(f, k);
        },
        /**
         * Centers object horizontally in the viewport, object.top is unchanged
         * @param {fabric.Object} object Object to center vertically and horizontally
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        viewportCenterObjectH: function(f) {
          var k = this.getVpCenter();
          return this._centerObject(f, new n.Point(k.x, f.getCenterPoint().y)), this;
        },
        /**
         * Centers object Vertically in the viewport, object.top is unchanged
         * @param {fabric.Object} object Object to center vertically and horizontally
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        viewportCenterObjectV: function(f) {
          var k = this.getVpCenter();
          return this._centerObject(f, new n.Point(f.getCenterPoint().x, k.y));
        },
        /**
         * Calculate the point in canvas that correspond to the center of actual viewport.
         * @return {fabric.Point} vpCenter, viewport center
         * @chainable
         */
        getVpCenter: function() {
          var f = this.getCenterPoint(), k = e(this.viewportTransform);
          return c(f, k);
        },
        /**
         * @private
         * @param {fabric.Object} object Object to center
         * @param {fabric.Point} center Center point
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        _centerObject: function(f, k) {
          return f.setPositionByOrigin(k, "center", "center"), f.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * Returns dataless JSON representation of canvas
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {String} json string
         */
        toDatalessJSON: function(f) {
          return this.toDatalessObject(f);
        },
        /**
         * Returns object representation of canvas
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(f) {
          return this._toObjectMethod("toObject", f);
        },
        /**
         * Returns dataless object representation of canvas
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toDatalessObject: function(f) {
          return this._toObjectMethod("toDatalessObject", f);
        },
        /**
         * @private
         */
        _toObjectMethod: function(f, k) {
          var E = this.clipPath, _ = {
            version: n.version,
            objects: this._toObjects(f, k)
          };
          return E && !E.excludeFromExport && (_.clipPath = this._toObject(this.clipPath, f, k)), d(_, this.__serializeBgOverlay(f, k)), n.util.populateWithProperties(this, _, k), _;
        },
        /**
         * @private
         */
        _toObjects: function(f, k) {
          return this._objects.filter(function(E) {
            return !E.excludeFromExport;
          }).map(function(E) {
            return this._toObject(E, f, k);
          }, this);
        },
        /**
         * @private
         */
        _toObject: function(f, k, E) {
          var _;
          this.includeDefaultValues || (_ = f.includeDefaultValues, f.includeDefaultValues = !1);
          var T = f[k](E);
          return this.includeDefaultValues || (f.includeDefaultValues = _), T;
        },
        /**
         * @private
         */
        __serializeBgOverlay: function(f, k) {
          var E = {}, _ = this.backgroundImage, T = this.overlayImage, D = this.backgroundColor, V = this.overlayColor;
          return D && D.toObject ? D.excludeFromExport || (E.background = D.toObject(k)) : D && (E.background = D), V && V.toObject ? V.excludeFromExport || (E.overlay = V.toObject(k)) : V && (E.overlay = V), _ && !_.excludeFromExport && (E.backgroundImage = this._toObject(_, f, k)), T && !T.excludeFromExport && (E.overlayImage = this._toObject(T, f, k)), E;
        },
        /* _TO_SVG_START_ */
        /**
         * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
         * a zoomed canvas will then produce zoomed SVG output.
         * @type Boolean
         * @default
         */
        svgViewportTransformation: !0,
        /**
         * Returns SVG representation of canvas
         * @function
         * @param {Object} [options] Options object for SVG output
         * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
         * @param {Object} [options.viewBox] SVG viewbox object
         * @param {Number} [options.viewBox.x] x-coordinate of viewbox
         * @param {Number} [options.viewBox.y] y-coordinate of viewbox
         * @param {Number} [options.viewBox.width] Width of viewbox
         * @param {Number} [options.viewBox.height] Height of viewbox
         * @param {String} [options.encoding=UTF-8] Encoding of SVG output
         * @param {String} [options.width] desired width of svg with or without units
         * @param {String} [options.height] desired height of svg with or without units
         * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
         * @return {String} SVG string
         * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
         * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
         * @example <caption>Normal SVG output</caption>
         * var svg = canvas.toSVG();
         * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
         * var svg = canvas.toSVG({suppressPreamble: true});
         * @example <caption>SVG output with viewBox attribute</caption>
         * var svg = canvas.toSVG({
         *   viewBox: {
         *     x: 100,
         *     y: 100,
         *     width: 200,
         *     height: 300
         *   }
         * });
         * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
         * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
         * @example <caption>Modify SVG output with reviver function</caption>
         * var svg = canvas.toSVG(null, function(svg) {
         *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
         * });
         */
        toSVG: function(f, k) {
          f || (f = {}), f.reviver = k;
          var E = [];
          return this._setSVGPreamble(E, f), this._setSVGHeader(E, f), this.clipPath && E.push('<g clip-path="url(#' + this.clipPath.clipPathId + `)" >
`), this._setSVGBgOverlayColor(E, "background"), this._setSVGBgOverlayImage(E, "backgroundImage", k), this._setSVGObjects(E, k), this.clipPath && E.push(`</g>
`), this._setSVGBgOverlayColor(E, "overlay"), this._setSVGBgOverlayImage(E, "overlayImage", k), E.push("</svg>"), E.join("");
        },
        /**
         * @private
         */
        _setSVGPreamble: function(f, k) {
          k.suppressPreamble || f.push(
            '<?xml version="1.0" encoding="',
            k.encoding || "UTF-8",
            `" standalone="no" ?>
`,
            '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
            `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`
          );
        },
        /**
         * @private
         */
        _setSVGHeader: function(f, k) {
          var E = k.width || this.width, _ = k.height || this.height, T, D = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', V = n.Object.NUM_FRACTION_DIGITS;
          k.viewBox ? D = 'viewBox="' + k.viewBox.x + " " + k.viewBox.y + " " + k.viewBox.width + " " + k.viewBox.height + '" ' : this.svgViewportTransformation && (T = this.viewportTransform, D = 'viewBox="' + v(-T[4] / T[0], V) + " " + v(-T[5] / T[3], V) + " " + v(this.width / T[0], V) + " " + v(this.height / T[3], V) + '" '), f.push(
            "<svg ",
            'xmlns="http://www.w3.org/2000/svg" ',
            'xmlns:xlink="http://www.w3.org/1999/xlink" ',
            'version="1.1" ',
            'width="',
            E,
            '" ',
            'height="',
            _,
            '" ',
            D,
            `xml:space="preserve">
`,
            "<desc>Created with Fabric.js ",
            n.version,
            `</desc>
`,
            `<defs>
`,
            this.createSVGFontFacesMarkup(),
            this.createSVGRefElementsMarkup(),
            this.createSVGClipPathMarkup(k),
            `</defs>
`
          );
        },
        createSVGClipPathMarkup: function(f) {
          var k = this.clipPath;
          return k ? (k.clipPathId = "CLIPPATH_" + n.Object.__uid++, '<clipPath id="' + k.clipPathId + `" >
` + this.clipPath.toClipPathSVG(f.reviver) + `</clipPath>
`) : "";
        },
        /**
         * Creates markup containing SVG referenced elements like patterns, gradients etc.
         * @return {String}
         */
        createSVGRefElementsMarkup: function() {
          var f = this, k = ["background", "overlay"].map(function(E) {
            var _ = f[E + "Color"];
            if (_ && _.toLive) {
              var T = f[E + "Vpt"], D = f.viewportTransform, V = {
                width: f.width / (T ? D[0] : 1),
                height: f.height / (T ? D[3] : 1)
              };
              return _.toSVG(
                V,
                { additionalTransform: T ? n.util.matrixToSVG(D) : "" }
              );
            }
          });
          return k.join("");
        },
        /**
         * Creates markup containing SVG font faces,
         * font URLs for font faces must be collected by developers
         * and are not extracted from the DOM by fabricjs
         * @param {Array} objects Array of fabric objects
         * @return {String}
         */
        createSVGFontFacesMarkup: function() {
          var f = "", k = {}, E, _, T, D, V, I, M, Q, G, z = n.fontPaths, re = [];
          for (this._objects.forEach(function de(Ce) {
            re.push(Ce), Ce._objects && Ce._objects.forEach(de);
          }), Q = 0, G = re.length; Q < G; Q++)
            if (E = re[Q], _ = E.fontFamily, !(E.type.indexOf("text") === -1 || k[_] || !z[_]) && (k[_] = !0, !!E.styles)) {
              T = E.styles;
              for (V in T) {
                D = T[V];
                for (M in D)
                  I = D[M], _ = I.fontFamily, !k[_] && z[_] && (k[_] = !0);
              }
            }
          for (var he in k)
            f += [
              `		@font-face {
`,
              "			font-family: '",
              he,
              `';
`,
              "			src: url('",
              z[he],
              `');
`,
              `		}
`
            ].join("");
          return f && (f = [
            '	<style type="text/css">',
            `<![CDATA[
`,
            f,
            "]]>",
            `</style>
`
          ].join("")), f;
        },
        /**
         * @private
         */
        _setSVGObjects: function(f, k) {
          var E, _, T, D = this._objects;
          for (_ = 0, T = D.length; _ < T; _++)
            E = D[_], !E.excludeFromExport && this._setSVGObject(f, E, k);
        },
        /**
         * @private
         */
        _setSVGObject: function(f, k, E) {
          f.push(k.toSVG(E));
        },
        /**
         * @private
         */
        _setSVGBgOverlayImage: function(f, k, E) {
          this[k] && !this[k].excludeFromExport && this[k].toSVG && f.push(this[k].toSVG(E));
        },
        /**
         * @private
         */
        _setSVGBgOverlayColor: function(f, k) {
          var E = this[k + "Color"], _ = this.viewportTransform, T = this.width, D = this.height;
          if (E)
            if (E.toLive) {
              var V = E.repeat, I = n.util.invertTransform(_), M = this[k + "Vpt"], Q = M ? n.util.matrixToSVG(I) : "";
              f.push(
                '<rect transform="' + Q + " translate(",
                T / 2,
                ",",
                D / 2,
                ')"',
                ' x="',
                E.offsetX - T / 2,
                '" y="',
                E.offsetY - D / 2,
                '" ',
                'width="',
                V === "repeat-y" || V === "no-repeat" ? E.source.width : T,
                '" height="',
                V === "repeat-x" || V === "no-repeat" ? E.source.height : D,
                '" fill="url(#SVGID_' + E.id + ')"',
                `></rect>
`
              );
            } else
              f.push(
                '<rect x="0" y="0" width="100%" height="100%" ',
                'fill="',
                E,
                '"',
                `></rect>
`
              );
        },
        /* _TO_SVG_END_ */
        /**
         * Moves an object or the objects of a multiple selection
         * to the bottom of the stack of drawn objects
         * @param {fabric.Object} object Object to send to back
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        sendToBack: function(f) {
          if (!f)
            return this;
          var k = this._activeObject, E, _, T;
          if (f === k && f.type === "activeSelection")
            for (T = k._objects, E = T.length; E--; )
              _ = T[E], p(this._objects, _), this._objects.unshift(_);
          else
            p(this._objects, f), this._objects.unshift(f);
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * Moves an object or the objects of a multiple selection
         * to the top of the stack of drawn objects
         * @param {fabric.Object} object Object to send
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        bringToFront: function(f) {
          if (!f)
            return this;
          var k = this._activeObject, E, _, T;
          if (f === k && f.type === "activeSelection")
            for (T = k._objects, E = 0; E < T.length; E++)
              _ = T[E], p(this._objects, _), this._objects.push(_);
          else
            p(this._objects, f), this._objects.push(f);
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * Moves an object or a selection down in stack of drawn objects
         * An optional parameter, intersecting allows to move the object in behind
         * the first intersecting object. Where intersection is calculated with
         * bounding box. If no intersection is found, there will not be change in the
         * stack.
         * @param {fabric.Object} object Object to send
         * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        sendBackwards: function(f, k) {
          if (!f)
            return this;
          var E = this._activeObject, _, T, D, V, I, M = 0;
          if (f === E && f.type === "activeSelection")
            for (I = E._objects, _ = 0; _ < I.length; _++)
              T = I[_], D = this._objects.indexOf(T), D > 0 + M && (V = D - 1, p(this._objects, T), this._objects.splice(V, 0, T)), M++;
          else
            D = this._objects.indexOf(f), D !== 0 && (V = this._findNewLowerIndex(f, D, k), p(this._objects, f), this._objects.splice(V, 0, f));
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * @private
         */
        _findNewLowerIndex: function(f, k, E) {
          var _, T;
          if (E)
            for (_ = k, T = k - 1; T >= 0; --T) {
              var D = f.intersectsWithObject(this._objects[T]) || f.isContainedWithinObject(this._objects[T]) || this._objects[T].isContainedWithinObject(f);
              if (D) {
                _ = T;
                break;
              }
            }
          else
            _ = k - 1;
          return _;
        },
        /**
         * Moves an object or a selection up in stack of drawn objects
         * An optional parameter, intersecting allows to move the object in front
         * of the first intersecting object. Where intersection is calculated with
         * bounding box. If no intersection is found, there will not be change in the
         * stack.
         * @param {fabric.Object} object Object to send
         * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        bringForward: function(f, k) {
          if (!f)
            return this;
          var E = this._activeObject, _, T, D, V, I, M = 0;
          if (f === E && f.type === "activeSelection")
            for (I = E._objects, _ = I.length; _--; )
              T = I[_], D = this._objects.indexOf(T), D < this._objects.length - 1 - M && (V = D + 1, p(this._objects, T), this._objects.splice(V, 0, T)), M++;
          else
            D = this._objects.indexOf(f), D !== this._objects.length - 1 && (V = this._findNewUpperIndex(f, D, k), p(this._objects, f), this._objects.splice(V, 0, f));
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        /**
         * @private
         */
        _findNewUpperIndex: function(f, k, E) {
          var _, T, D;
          if (E)
            for (_ = k, T = k + 1, D = this._objects.length; T < D; ++T) {
              var V = f.intersectsWithObject(this._objects[T]) || f.isContainedWithinObject(this._objects[T]) || this._objects[T].isContainedWithinObject(f);
              if (V) {
                _ = T;
                break;
              }
            }
          else
            _ = k + 1;
          return _;
        },
        /**
         * Moves an object to specified level in stack of drawn objects
         * @param {fabric.Object} object Object to send
         * @param {Number} index Position to move to
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        moveTo: function(f, k) {
          return p(this._objects, f), this._objects.splice(k, 0, f), this.renderOnAddRemove && this.requestRenderAll();
        },
        /**
         * Clears a canvas element and dispose objects
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        dispose: function() {
          return this.isRendering && (n.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function(f) {
            f.dispose && f.dispose();
          }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), n.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), n.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this;
        },
        /**
         * Returns a string representation of an instance
         * @return {String} string representation of an instance
         */
        toString: function() {
          return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>";
        }
      }
    ), d(n.StaticCanvas.prototype, n.Observable), d(n.StaticCanvas.prototype, n.Collection), d(n.StaticCanvas.prototype, n.DataURLExporter), d(
      n.StaticCanvas,
      /** @lends fabric.StaticCanvas */
      {
        /**
         * @static
         * @type String
         * @default
         */
        EMPTY_JSON: '{"objects": [], "background": "white"}',
        /**
         * Provides a way to check support of some of the canvas methods
         * (either those of HTMLCanvasElement itself, or rendering context)
         *
         * @param {String} methodName Method to check support for;
         *                            Could be one of "setLineDash"
         * @return {Boolean | null} `true` if method is supported (or at least exists),
         *                          `null` if canvas element or context can not be initialized
         */
        supports: function(f) {
          var k = m();
          if (!k || !k.getContext)
            return null;
          var E = k.getContext("2d");
          if (!E)
            return null;
          switch (f) {
            case "setLineDash":
              return typeof E.setLineDash < "u";
            default:
              return null;
          }
        }
      }
    ), n.StaticCanvas.prototype.toJSON = n.StaticCanvas.prototype.toObject, n.isLikelyNode && (n.StaticCanvas.prototype.createPNGStream = function() {
      var f = h(this.lowerCanvasEl);
      return f && f.createPNGStream();
    }, n.StaticCanvas.prototype.createJPEGStream = function(f) {
      var k = h(this.lowerCanvasEl);
      return k && k.createJPEGStream(f);
    });
  }(), n.BaseBrush = n.util.createClass(
    /** @lends fabric.BaseBrush.prototype */
    {
      /**
       * Color of a brush
       * @type String
       * @default
       */
      color: "rgb(0, 0, 0)",
      /**
       * Width of a brush, has to be a Number, no string literals
       * @type Number
       * @default
       */
      width: 1,
      /**
       * Shadow object representing shadow of this shape.
       * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
       * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
       * @type fabric.Shadow
       * @default
       */
      shadow: null,
      /**
       * Line endings style of a brush (one of "butt", "round", "square")
       * @type String
       * @default
       */
      strokeLineCap: "round",
      /**
       * Corner style of a brush (one of "bevel", "round", "miter")
       * @type String
       * @default
       */
      strokeLineJoin: "round",
      /**
       * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
       * @type Number
       * @default
       */
      strokeMiterLimit: 10,
      /**
       * Stroke Dash Array.
       * @type Array
       * @default
       */
      strokeDashArray: null,
      /**
       * When `true`, the free drawing is limited to the whiteboard size. Default to false.
       * @type Boolean
       * @default false
      */
      limitedToCanvasSize: !1,
      /**
       * Sets brush styles
       * @private
       * @param {CanvasRenderingContext2D} ctx
       */
      _setBrushStyles: function(d) {
        d.strokeStyle = this.color, d.lineWidth = this.width, d.lineCap = this.strokeLineCap, d.miterLimit = this.strokeMiterLimit, d.lineJoin = this.strokeLineJoin, d.setLineDash(this.strokeDashArray || []);
      },
      /**
       * Sets the transformation on given context
       * @param {RenderingContext2d} ctx context to render on
       * @private
       */
      _saveAndTransform: function(d) {
        var l = this.canvas.viewportTransform;
        d.save(), d.transform(l[0], l[1], l[2], l[3], l[4], l[5]);
      },
      /**
       * Sets brush shadow styles
       * @private
       */
      _setShadow: function() {
        if (this.shadow) {
          var d = this.canvas, l = this.shadow, p = d.contextTop, v = d.getZoom();
          d && d._isRetinaScaling() && (v *= n.devicePixelRatio), p.shadowColor = l.color, p.shadowBlur = l.blur * v, p.shadowOffsetX = l.offsetX * v, p.shadowOffsetY = l.offsetY * v;
        }
      },
      needsFullRender: function() {
        var d = new n.Color(this.color);
        return d.getAlpha() < 1 || !!this.shadow;
      },
      /**
       * Removes brush shadow styles
       * @private
       */
      _resetShadow: function() {
        var d = this.canvas.contextTop;
        d.shadowColor = "", d.shadowBlur = d.shadowOffsetX = d.shadowOffsetY = 0;
      },
      /**
       * Check is pointer is outside canvas boundaries
       * @param {Object} pointer
       * @private
      */
      _isOutSideCanvas: function(d) {
        return d.x < 0 || d.x > this.canvas.getWidth() || d.y < 0 || d.y > this.canvas.getHeight();
      }
    }
  ), function() {
    n.PencilBrush = n.util.createClass(
      n.BaseBrush,
      /** @lends fabric.PencilBrush.prototype */
      {
        /**
         * Discard points that are less than `decimate` pixel distant from each other
         * @type Number
         * @default 0.4
         */
        decimate: 0.4,
        /**
         * Draws a straight line between last recorded point to current pointer
         * Used for `shift` functionality
         *
         * @type boolean
         * @default false
         */
        drawStraightLine: !1,
        /**
         * The event modifier key that makes the brush draw a straight line.
         * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.
         * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}
         */
        straightLineKey: "shiftKey",
        /**
         * Constructor
         * @param {fabric.Canvas} canvas
         * @return {fabric.PencilBrush} Instance of a pencil brush
         */
        initialize: function(d) {
          this.canvas = d, this._points = [];
        },
        needsFullRender: function() {
          return this.callSuper("needsFullRender") || this._hasStraightLine;
        },
        /**
         * Invoked inside on mouse down and mouse move
         * @param {Object} pointer
         */
        _drawSegment: function(d, l, p) {
          var v = l.midPointFrom(p);
          return d.quadraticCurveTo(l.x, l.y, v.x, v.y), v;
        },
        /**
         * Invoked on mouse down
         * @param {Object} pointer
         */
        onMouseDown: function(d, l) {
          this.canvas._isMainEvent(l.e) && (this.drawStraightLine = l.e[this.straightLineKey], this._prepareForDrawing(d), this._captureDrawingPath(d), this._render());
        },
        /**
         * Invoked on mouse move
         * @param {Object} pointer
         */
        onMouseMove: function(d, l) {
          if (this.canvas._isMainEvent(l.e) && (this.drawStraightLine = l.e[this.straightLineKey], !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d)) && this._captureDrawingPath(d) && this._points.length > 1))
            if (this.needsFullRender())
              this.canvas.clearContext(this.canvas.contextTop), this._render();
            else {
              var p = this._points, v = p.length, c = this.canvas.contextTop;
              this._saveAndTransform(c), this.oldEnd && (c.beginPath(), c.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(c, p[v - 2], p[v - 1], !0), c.stroke(), c.restore();
            }
        },
        /**
         * Invoked on mouse up
         */
        onMouseUp: function(d) {
          return this.canvas._isMainEvent(d.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0;
        },
        /**
         * @private
         * @param {Object} pointer Actual mouse position related to the canvas.
         */
        _prepareForDrawing: function(d) {
          var l = new n.Point(d.x, d.y);
          this._reset(), this._addPoint(l), this.canvas.contextTop.moveTo(l.x, l.y);
        },
        /**
         * @private
         * @param {fabric.Point} point Point to be added to points array
         */
        _addPoint: function(d) {
          return this._points.length > 1 && d.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(d), !0);
        },
        /**
         * Clear points array and set contextTop canvas style.
         * @private
         */
        _reset: function() {
          this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1;
        },
        /**
         * @private
         * @param {Object} pointer Actual mouse position related to the canvas.
         */
        _captureDrawingPath: function(d) {
          var l = new n.Point(d.x, d.y);
          return this._addPoint(l);
        },
        /**
         * Draw a smooth path on the topCanvas using quadraticCurveTo
         * @private
         * @param {CanvasRenderingContext2D} [ctx]
         */
        _render: function(d) {
          var l, p, v = this._points[0], c = this._points[1];
          if (d = d || this.canvas.contextTop, this._saveAndTransform(d), d.beginPath(), this._points.length === 2 && v.x === c.x && v.y === c.y) {
            var e = this.width / 1e3;
            v = new n.Point(v.x, v.y), c = new n.Point(c.x, c.y), v.x -= e, c.x += e;
          }
          for (d.moveTo(v.x, v.y), l = 1, p = this._points.length; l < p; l++)
            this._drawSegment(d, v, c), v = this._points[l], c = this._points[l + 1];
          d.lineTo(v.x, v.y), d.stroke(), d.restore();
        },
        /**
         * Converts points to SVG path
         * @param {Array} points Array of points
         * @return {(string|number)[][]} SVG path commands
         */
        convertPointsToSVGPath: function(d) {
          var l = this.width / 1e3;
          return n.util.getSmoothPathFromPoints(d, l);
        },
        /**
         * @private
         * @param {(string|number)[][]} pathData SVG path commands
         * @returns {boolean}
         */
        _isEmptySVGPath: function(d) {
          var l = n.util.joinPath(d);
          return l === "M 0 0 Q 0 0 0 0 L 0 0";
        },
        /**
         * Creates fabric.Path object to add on canvas
         * @param {(string|number)[][]} pathData Path data
         * @return {fabric.Path} Path to add on canvas
         */
        createPath: function(d) {
          var l = new n.Path(d, {
            fill: null,
            stroke: this.color,
            strokeWidth: this.width,
            strokeLineCap: this.strokeLineCap,
            strokeMiterLimit: this.strokeMiterLimit,
            strokeLineJoin: this.strokeLineJoin,
            strokeDashArray: this.strokeDashArray
          });
          return this.shadow && (this.shadow.affectStroke = !0, l.shadow = new n.Shadow(this.shadow)), l;
        },
        /**
         * Decimate points array with the decimate value
         */
        decimatePoints: function(d, l) {
          if (d.length <= 2)
            return d;
          var p = this.canvas.getZoom(), v = Math.pow(l / p, 2), c, e = d.length - 1, h = d[0], m = [h], b;
          for (c = 1; c < e - 1; c++)
            b = Math.pow(h.x - d[c].x, 2) + Math.pow(h.y - d[c].y, 2), b >= v && (h = d[c], m.push(h));
          return m.push(d[e]), m;
        },
        /**
         * On mouseup after drawing the path on contextTop canvas
         * we use the points captured to create an new fabric path object
         * and add it to the fabric canvas.
         */
        _finalizeAndAddPath: function() {
          var d = this.canvas.contextTop;
          d.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate));
          var l = this.convertPointsToSVGPath(this._points);
          if (this._isEmptySVGPath(l)) {
            this.canvas.requestRenderAll();
            return;
          }
          var p = this.createPath(l);
          this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: p }), this.canvas.add(p), this.canvas.requestRenderAll(), p.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: p });
        }
      }
    );
  }(), n.CircleBrush = n.util.createClass(
    n.BaseBrush,
    /** @lends fabric.CircleBrush.prototype */
    {
      /**
       * Width of a brush
       * @type Number
       * @default
       */
      width: 10,
      /**
       * Constructor
       * @param {fabric.Canvas} canvas
       * @return {fabric.CircleBrush} Instance of a circle brush
       */
      initialize: function(d) {
        this.canvas = d, this.points = [];
      },
      /**
       * Invoked inside on mouse down and mouse move
       * @param {Object} pointer
       */
      drawDot: function(d) {
        var l = this.addPoint(d), p = this.canvas.contextTop;
        this._saveAndTransform(p), this.dot(p, l), p.restore();
      },
      dot: function(d, l) {
        d.fillStyle = l.fill, d.beginPath(), d.arc(l.x, l.y, l.radius, 0, Math.PI * 2, !1), d.closePath(), d.fill();
      },
      /**
       * Invoked on mouse down
       */
      onMouseDown: function(d) {
        this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(d);
      },
      /**
       * Render the full state of the brush
       * @private
       */
      _render: function() {
        var d = this.canvas.contextTop, l, p, v = this.points;
        for (this._saveAndTransform(d), l = 0, p = v.length; l < p; l++)
          this.dot(d, v[l]);
        d.restore();
      },
      /**
       * Invoked on mouse move
       * @param {Object} pointer
       */
      onMouseMove: function(d) {
        this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(d), this._render()) : this.drawDot(d));
      },
      /**
       * Invoked on mouse up
       */
      onMouseUp: function() {
        var d = this.canvas.renderOnAddRemove, l, p;
        this.canvas.renderOnAddRemove = !1;
        var v = [];
        for (l = 0, p = this.points.length; l < p; l++) {
          var c = this.points[l], e = new n.Circle({
            radius: c.radius,
            left: c.x,
            top: c.y,
            originX: "center",
            originY: "center",
            fill: c.fill
          });
          this.shadow && (e.shadow = new n.Shadow(this.shadow)), v.push(e);
        }
        var h = new n.Group(v);
        h.canvas = this.canvas, this.canvas.fire("before:path:created", { path: h }), this.canvas.add(h), this.canvas.fire("path:created", { path: h }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = d, this.canvas.requestRenderAll();
      },
      /**
       * @param {Object} pointer
       * @return {fabric.Point} Just added pointer point
       */
      addPoint: function(d) {
        var l = new n.Point(d.x, d.y), p = n.util.getRandomInt(
          Math.max(0, this.width - 20),
          this.width + 20
        ) / 2, v = new n.Color(this.color).setAlpha(n.util.getRandomInt(0, 100) / 100).toRgba();
        return l.radius = p, l.fill = v, this.points.push(l), l;
      }
    }
  ), n.SprayBrush = n.util.createClass(
    n.BaseBrush,
    /** @lends fabric.SprayBrush.prototype */
    {
      /**
       * Width of a spray
       * @type Number
       * @default
       */
      width: 10,
      /**
       * Density of a spray (number of dots per chunk)
       * @type Number
       * @default
       */
      density: 20,
      /**
       * Width of spray dots
       * @type Number
       * @default
       */
      dotWidth: 1,
      /**
       * Width variance of spray dots
       * @type Number
       * @default
       */
      dotWidthVariance: 1,
      /**
       * Whether opacity of a dot should be random
       * @type Boolean
       * @default
       */
      randomOpacity: !1,
      /**
       * Whether overlapping dots (rectangles) should be removed (for performance reasons)
       * @type Boolean
       * @default
       */
      optimizeOverlapping: !0,
      /**
       * Constructor
       * @param {fabric.Canvas} canvas
       * @return {fabric.SprayBrush} Instance of a spray brush
       */
      initialize: function(d) {
        this.canvas = d, this.sprayChunks = [];
      },
      /**
       * Invoked on mouse down
       * @param {Object} pointer
       */
      onMouseDown: function(d) {
        this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(d), this.render(this.sprayChunkPoints);
      },
      /**
       * Invoked on mouse move
       * @param {Object} pointer
       */
      onMouseMove: function(d) {
        this.limitedToCanvasSize === !0 && this._isOutSideCanvas(d) || (this.addSprayChunk(d), this.render(this.sprayChunkPoints));
      },
      /**
       * Invoked on mouse up
       */
      onMouseUp: function() {
        var d = this.canvas.renderOnAddRemove;
        this.canvas.renderOnAddRemove = !1;
        for (var l = [], p = 0, v = this.sprayChunks.length; p < v; p++)
          for (var c = this.sprayChunks[p], e = 0, h = c.length; e < h; e++) {
            var m = new n.Rect({
              width: c[e].width,
              height: c[e].width,
              left: c[e].x + 1,
              top: c[e].y + 1,
              originX: "center",
              originY: "center",
              fill: this.color
            });
            l.push(m);
          }
        this.optimizeOverlapping && (l = this._getOptimizedRects(l));
        var b = new n.Group(l);
        this.shadow && b.set("shadow", new n.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: b }), this.canvas.add(b), this.canvas.fire("path:created", { path: b }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = d, this.canvas.requestRenderAll();
      },
      /**
       * @private
       * @param {Array} rects
       */
      _getOptimizedRects: function(d) {
        var l = {}, p, v, c;
        for (v = 0, c = d.length; v < c; v++)
          p = d[v].left + "" + d[v].top, l[p] || (l[p] = d[v]);
        var e = [];
        for (p in l)
          e.push(l[p]);
        return e;
      },
      /**
       * Render new chunk of spray brush
       */
      render: function(d) {
        var l = this.canvas.contextTop, p, v;
        for (l.fillStyle = this.color, this._saveAndTransform(l), p = 0, v = d.length; p < v; p++) {
          var c = d[p];
          typeof c.opacity < "u" && (l.globalAlpha = c.opacity), l.fillRect(c.x, c.y, c.width, c.width);
        }
        l.restore();
      },
      /**
       * Render all spray chunks
       */
      _render: function() {
        var d = this.canvas.contextTop, l, p;
        for (d.fillStyle = this.color, this._saveAndTransform(d), l = 0, p = this.sprayChunks.length; l < p; l++)
          this.render(this.sprayChunks[l]);
        d.restore();
      },
      /**
       * @param {Object} pointer
       */
      addSprayChunk: function(d) {
        this.sprayChunkPoints = [];
        var l, p, v, c = this.width / 2, e;
        for (e = 0; e < this.density; e++) {
          l = n.util.getRandomInt(d.x - c, d.x + c), p = n.util.getRandomInt(d.y - c, d.y + c), this.dotWidthVariance ? v = n.util.getRandomInt(
            // bottom clamp width to 1
            Math.max(1, this.dotWidth - this.dotWidthVariance),
            this.dotWidth + this.dotWidthVariance
          ) : v = this.dotWidth;
          var h = new n.Point(l, p);
          h.width = v, this.randomOpacity && (h.opacity = n.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(h);
        }
        this.sprayChunks.push(this.sprayChunkPoints);
      }
    }
  ), n.PatternBrush = n.util.createClass(
    n.PencilBrush,
    /** @lends fabric.PatternBrush.prototype */
    {
      getPatternSrc: function() {
        var d = 20, l = 5, p = n.util.createCanvasElement(), v = p.getContext("2d");
        return p.width = p.height = d + l, v.fillStyle = this.color, v.beginPath(), v.arc(d / 2, d / 2, d / 2, 0, Math.PI * 2, !1), v.closePath(), v.fill(), p;
      },
      getPatternSrcFunction: function() {
        return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"');
      },
      /**
       * Creates "pattern" instance property
       * @param {CanvasRenderingContext2D} ctx
       */
      getPattern: function(d) {
        return d.createPattern(this.source || this.getPatternSrc(), "repeat");
      },
      /**
       * Sets brush styles
       * @param {CanvasRenderingContext2D} ctx
       */
      _setBrushStyles: function(d) {
        this.callSuper("_setBrushStyles", d), d.strokeStyle = this.getPattern(d);
      },
      /**
       * Creates path
       */
      createPath: function(d) {
        var l = this.callSuper("createPath", d), p = l._getLeftTopCoords().scalarAdd(l.strokeWidth / 2);
        return l.stroke = new n.Pattern({
          source: this.source || this.getPatternSrcFunction(),
          offsetX: -p.x,
          offsetY: -p.y
        }), l;
      }
    }
  ), function() {
    var d = n.util.getPointer, l = n.util.degreesToRadians, p = n.util.isTouchEvent;
    n.Canvas = n.util.createClass(
      n.StaticCanvas,
      /** @lends fabric.Canvas.prototype */
      {
        /**
         * Constructor
         * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
         * @param {Object} [options] Options object
         * @return {Object} thisArg
         */
        initialize: function(c, e) {
          e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(c, e), this._initInteractive(), this._createCacheCanvas();
        },
        /**
         * When true, objects can be transformed by one side (unproportionally)
         * when dragged on the corners that normally would not do that.
         * @type Boolean
         * @default
         * @since fabric 4.0 // changed name and default value
         */
        uniformScaling: !0,
        /**
         * Indicates which key switches uniform scaling.
         * values: 'altKey', 'shiftKey', 'ctrlKey'.
         * If `null` or 'none' or any other string that is not a modifier key
         * feature is disabled.
         * totally wrong named. this sounds like `uniform scaling`
         * if Canvas.uniformScaling is true, pressing this will set it to false
         * and viceversa.
         * @since 1.6.2
         * @type String
         * @default
         */
        uniScaleKey: "shiftKey",
        /**
         * When true, objects use center point as the origin of scale transformation.
         * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
         * @since 1.3.4
         * @type Boolean
         * @default
         */
        centeredScaling: !1,
        /**
         * When true, objects use center point as the origin of rotate transformation.
         * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
         * @since 1.3.4
         * @type Boolean
         * @default
         */
        centeredRotation: !1,
        /**
         * Indicates which key enable centered Transform
         * values: 'altKey', 'shiftKey', 'ctrlKey'.
         * If `null` or 'none' or any other string that is not a modifier key
         * feature is disabled feature disabled.
         * @since 1.6.2
         * @type String
         * @default
         */
        centeredKey: "altKey",
        /**
         * Indicates which key enable alternate action on corner
         * values: 'altKey', 'shiftKey', 'ctrlKey'.
         * If `null` or 'none' or any other string that is not a modifier key
         * feature is disabled feature disabled.
         * @since 1.6.2
         * @type String
         * @default
         */
        altActionKey: "shiftKey",
        /**
         * Indicates that canvas is interactive. This property should not be changed.
         * @type Boolean
         * @default
         */
        interactive: !0,
        /**
         * Indicates whether group selection should be enabled
         * @type Boolean
         * @default
         */
        selection: !0,
        /**
         * Indicates which key or keys enable multiple click selection
         * Pass value as a string or array of strings
         * values: 'altKey', 'shiftKey', 'ctrlKey'.
         * If `null` or empty or containing any other string that is not a modifier key
         * feature is disabled.
         * @since 1.6.2
         * @type String|Array
         * @default
         */
        selectionKey: "shiftKey",
        /**
         * Indicates which key enable alternative selection
         * in case of target overlapping with active object
         * values: 'altKey', 'shiftKey', 'ctrlKey'.
         * For a series of reason that come from the general expectations on how
         * things should work, this feature works only for preserveObjectStacking true.
         * If `null` or 'none' or any other string that is not a modifier key
         * feature is disabled.
         * @since 1.6.5
         * @type null|String
         * @default
         */
        altSelectionKey: null,
        /**
         * Color of selection
         * @type String
         * @default
         */
        selectionColor: "rgba(100, 100, 255, 0.3)",
        // blue
        /**
         * Default dash array pattern
         * If not empty the selection border is dashed
         * @type Array
         */
        selectionDashArray: [],
        /**
         * Color of the border of selection (usually slightly darker than color of selection itself)
         * @type String
         * @default
         */
        selectionBorderColor: "rgba(255, 255, 255, 0.3)",
        /**
         * Width of a line used in object/group selection
         * @type Number
         * @default
         */
        selectionLineWidth: 1,
        /**
         * Select only shapes that are fully contained in the dragged selection rectangle.
         * @type Boolean
         * @default
         */
        selectionFullyContained: !1,
        /**
         * Default cursor value used when hovering over an object on canvas
         * @type String
         * @default
         */
        hoverCursor: "move",
        /**
         * Default cursor value used when moving an object on canvas
         * @type String
         * @default
         */
        moveCursor: "move",
        /**
         * Default cursor value used for the entire canvas
         * @type String
         * @default
         */
        defaultCursor: "default",
        /**
         * Cursor value used during free drawing
         * @type String
         * @default
         */
        freeDrawingCursor: "crosshair",
        /**
         * Cursor value used for disabled elements ( corners with disabled action )
         * @type String
         * @since 2.0.0
         * @default
         */
        notAllowedCursor: "not-allowed",
        /**
         * Default element class that's given to wrapper (div) element of canvas
         * @type String
         * @default
         */
        containerClass: "canvas-container",
        /**
         * When true, object detection happens on per-pixel basis rather than on per-bounding-box
         * @type Boolean
         * @default
         */
        perPixelTargetFind: !1,
        /**
         * Number of pixels around target pixel to tolerate (consider active) during object detection
         * @type Number
         * @default
         */
        targetFindTolerance: 0,
        /**
         * When true, target detection is skipped. Target detection will return always undefined.
         * click selection won't work anymore, events will fire with no targets.
         * if something is selected before setting it to true, it will be deselected at the first click.
         * area selection will still work. check the `selection` property too.
         * if you deactivate both, you should look into staticCanvas.
         * @type Boolean
         * @default
         */
        skipTargetFind: !1,
        /**
         * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
         * After mousedown, mousemove creates a shape,
         * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
         * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
         * @type Boolean
         * @default
         */
        isDrawingMode: !1,
        /**
         * Indicates whether objects should remain in current stack position when selected.
         * When false objects are brought to top and rendered as part of the selection group
         * @type Boolean
         * @default
         */
        preserveObjectStacking: !1,
        /**
         * Indicates the angle that an object will lock to while rotating.
         * @type Number
         * @since 1.6.7
         * @default
         */
        snapAngle: 0,
        /**
         * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
         * When `null`, the snapThreshold will default to the snapAngle.
         * @type null|Number
         * @since 1.6.7
         * @default
         */
        snapThreshold: null,
        /**
         * Indicates if the right click on canvas can output the context menu or not
         * @type Boolean
         * @since 1.6.5
         * @default
         */
        stopContextMenu: !1,
        /**
         * Indicates if the canvas can fire right click events
         * @type Boolean
         * @since 1.6.5
         * @default
         */
        fireRightClick: !1,
        /**
         * Indicates if the canvas can fire middle click events
         * @type Boolean
         * @since 1.7.8
         * @default
         */
        fireMiddleClick: !1,
        /**
         * Keep track of the subTargets for Mouse Events
         * @type fabric.Object[]
         */
        targets: [],
        /**
         * When the option is enabled, PointerEvent is used instead of MouseEvent.
         * @type Boolean
         * @default
         */
        enablePointerEvents: !1,
        /**
         * Keep track of the hovered target
         * @type fabric.Object
         * @private
         */
        _hoveredTarget: null,
        /**
         * hold the list of nested targets hovered
         * @type fabric.Object[]
         * @private
         */
        _hoveredTargets: [],
        /**
         * @private
         */
        _initInteractive: function() {
          this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = n.PencilBrush && new n.PencilBrush(this), this.calcOffset();
        },
        /**
         * Divides objects in two groups, one to render immediately
         * and one to render as activeGroup.
         * @return {Array} objects to render immediately and pushes the other in the activeGroup.
         */
        _chooseObjectsToRender: function() {
          var c = this.getActiveObjects(), e, h, m;
          if (c.length > 0 && !this.preserveObjectStacking) {
            h = [], m = [];
            for (var b = 0, f = this._objects.length; b < f; b++)
              e = this._objects[b], c.indexOf(e) === -1 ? h.push(e) : m.push(e);
            c.length > 1 && (this._activeObject._objects = m), h.push.apply(h, m);
          } else
            h = this._objects;
          return h;
        },
        /**
         * Renders both the top canvas and the secondary container canvas.
         * @return {fabric.Canvas} instance
         * @chainable
         */
        renderAll: function() {
          this.contextTopDirty && !this._groupSelector && !this.isDrawingMode && (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1);
          var c = this.contextContainer;
          return this.renderCanvas(c, this._chooseObjectsToRender()), this;
        },
        renderTopLayer: function(c) {
          c.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(c), this.contextTopDirty = !0), c.restore();
        },
        /**
         * Method to render only the top canvas.
         * Also used to render the group selection box.
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        renderTop: function() {
          var c = this.contextTop;
          return this.clearContext(c), this.renderTopLayer(c), this.fire("after:render"), this;
        },
        /**
         * @private
         */
        _normalizePointer: function(c, e) {
          var h = c.calcTransformMatrix(), m = n.util.invertTransform(h), b = this.restorePointerVpt(e);
          return n.util.transformPoint(b, m);
        },
        /**
         * Returns true if object is transparent at a certain location
         * @param {fabric.Object} target Object to check
         * @param {Number} x Left coordinate
         * @param {Number} y Top coordinate
         * @return {Boolean}
         */
        isTargetTransparent: function(c, e, h) {
          if (c.shouldCache() && c._cacheCanvas && c !== this._activeObject) {
            var m = this._normalizePointer(c, { x: e, y: h }), b = Math.max(c.cacheTranslationX + m.x * c.zoomX, 0), f = Math.max(c.cacheTranslationY + m.y * c.zoomY, 0), T = n.util.isTransparent(
              c._cacheContext,
              Math.round(b),
              Math.round(f),
              this.targetFindTolerance
            );
            return T;
          }
          var k = this.contextCache, E = c.selectionBackgroundColor, _ = this.viewportTransform;
          c.selectionBackgroundColor = "", this.clearContext(k), k.save(), k.transform(_[0], _[1], _[2], _[3], _[4], _[5]), c.render(k), k.restore(), c.selectionBackgroundColor = E;
          var T = n.util.isTransparent(
            k,
            e,
            h,
            this.targetFindTolerance
          );
          return T;
        },
        /**
         * takes an event and determines if selection key has been pressed
         * @private
         * @param {Event} e Event object
         */
        _isSelectionKeyPressed: function(c) {
          var e = !1;
          return Array.isArray(this.selectionKey) ? e = !!this.selectionKey.find(function(h) {
            return c[h] === !0;
          }) : e = c[this.selectionKey], e;
        },
        /**
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */
        _shouldClearSelection: function(c, e) {
          var h = this.getActiveObjects(), m = this._activeObject;
          return !e || e && m && h.length > 1 && h.indexOf(e) === -1 && m !== e && !this._isSelectionKeyPressed(c) || e && !e.evented || e && !e.selectable && m && m !== e;
        },
        /**
         * centeredScaling from object can't override centeredScaling from canvas.
         * this should be fixed, since object setting should take precedence over canvas.
         * also this should be something that will be migrated in the control properties.
         * as ability to define the origin of the transformation that the control provide.
         * @private
         * @param {fabric.Object} target
         * @param {String} action
         * @param {Boolean} altKey
         */
        _shouldCenterTransform: function(c, e, h) {
          if (c) {
            var m;
            return e === "scale" || e === "scaleX" || e === "scaleY" || e === "resizing" ? m = this.centeredScaling || c.centeredScaling : e === "rotate" && (m = this.centeredRotation || c.centeredRotation), m ? !h : h;
          }
        },
        /**
         * should disappear before release 4.0
         * @private
         */
        _getOriginFromCorner: function(c, e) {
          var h = {
            x: c.originX,
            y: c.originY
          };
          return e === "ml" || e === "tl" || e === "bl" ? h.x = "right" : (e === "mr" || e === "tr" || e === "br") && (h.x = "left"), e === "tl" || e === "mt" || e === "tr" ? h.y = "bottom" : (e === "bl" || e === "mb" || e === "br") && (h.y = "top"), h;
        },
        /**
         * @private
         * @param {Boolean} alreadySelected true if target is already selected
         * @param {String} corner a string representing the corner ml, mr, tl ...
         * @param {Event} e Event object
         * @param {fabric.Object} [target] inserted back to help overriding. Unused
         */
        _getActionFromCorner: function(c, e, h, m) {
          if (!e || !c)
            return "drag";
          var b = m.controls[e];
          return b.getActionName(h, b, m);
        },
        /**
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */
        _setupCurrentTransform: function(c, e, h) {
          if (e) {
            var m = this.getPointer(c), b = e.__corner, f = e.controls[b], k = h && b ? f.getActionHandler(c, e, f) : n.controlsUtils.dragHandler, E = this._getActionFromCorner(h, b, c, e), _ = this._getOriginFromCorner(e, b), T = c[this.centeredKey], D = {
              target: e,
              action: E,
              actionHandler: k,
              corner: b,
              scaleX: e.scaleX,
              scaleY: e.scaleY,
              skewX: e.skewX,
              skewY: e.skewY,
              // used by transation
              offsetX: m.x - e.left,
              offsetY: m.y - e.top,
              originX: _.x,
              originY: _.y,
              ex: m.x,
              ey: m.y,
              lastX: m.x,
              lastY: m.y,
              // unsure they are useful anymore.
              // left: target.left,
              // top: target.top,
              theta: l(e.angle),
              // end of unsure
              width: e.width * e.scaleX,
              shiftKey: c.shiftKey,
              altKey: T,
              original: n.util.saveObjectTransform(e)
            };
            this._shouldCenterTransform(e, E, T) && (D.originX = "center", D.originY = "center"), D.original.originX = _.x, D.original.originY = _.y, this._currentTransform = D, this._beforeTransform(c);
          }
        },
        /**
         * Set the cursor type of the canvas element
         * @param {String} value Cursor type of the canvas element.
         * @see http://www.w3.org/TR/css3-ui/#cursor
         */
        setCursor: function(c) {
          this.upperCanvasEl.style.cursor = c;
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx to draw the selection on
         */
        _drawSelection: function(c) {
          var e = this._groupSelector, h = new n.Point(e.ex, e.ey), m = n.util.transformPoint(h, this.viewportTransform), b = new n.Point(e.ex + e.left, e.ey + e.top), f = n.util.transformPoint(b, this.viewportTransform), k = Math.min(m.x, f.x), E = Math.min(m.y, f.y), _ = Math.max(m.x, f.x), T = Math.max(m.y, f.y), D = this.selectionLineWidth / 2;
          this.selectionColor && (c.fillStyle = this.selectionColor, c.fillRect(k, E, _ - k, T - E)), !(!this.selectionLineWidth || !this.selectionBorderColor) && (c.lineWidth = this.selectionLineWidth, c.strokeStyle = this.selectionBorderColor, k += D, E += D, _ -= D, T -= D, n.Object.prototype._setLineDash.call(this, c, this.selectionDashArray), c.strokeRect(k, E, _ - k, T - E));
        },
        /**
         * Method that determines what object we are clicking on
         * the skipGroup parameter is for internal use, is needed for shift+click action
         * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
         * or the outside part of the corner.
         * @param {Event} e mouse event
         * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
         * @return {fabric.Object} the target found
         */
        findTarget: function(c, e) {
          if (!this.skipTargetFind) {
            var h = !0, m = this.getPointer(c, h), b = this._activeObject, f = this.getActiveObjects(), k, E, _ = p(c), T = f.length > 1 && !e || f.length === 1;
            if (this.targets = [], T && b._findTargetCorner(m, _) || f.length > 1 && !e && b === this._searchPossibleTargets([b], m))
              return b;
            if (f.length === 1 && b === this._searchPossibleTargets([b], m))
              if (this.preserveObjectStacking)
                k = b, E = this.targets, this.targets = [];
              else
                return b;
            var D = this._searchPossibleTargets(this._objects, m);
            return c[this.altSelectionKey] && D && k && D !== k && (D = k, this.targets = E), D;
          }
        },
        /**
         * Checks point is inside the object.
         * @param {Object} [pointer] x,y object of point coordinates we want to check.
         * @param {fabric.Object} obj Object to test against
         * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
         * @return {Boolean} true if point is contained within an area of given object
         * @private
         */
        _checkTarget: function(c, e, h) {
          if (e && e.visible && e.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
          // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
          e.containsPoint(c))
            if ((this.perPixelTargetFind || e.perPixelTargetFind) && !e.isEditing) {
              var m = this.isTargetTransparent(e, h.x, h.y);
              if (!m)
                return !0;
            } else
              return !0;
        },
        /**
         * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
         * @param {Array} [objects] objects array to look into
         * @param {Object} [pointer] x,y object of point coordinates we want to check.
         * @return {fabric.Object} object that contains pointer
         * @private
         */
        _searchPossibleTargets: function(c, e) {
          for (var h, m = c.length, b; m--; ) {
            var f = c[m], k = f.group ? this._normalizePointer(f.group, e) : e;
            if (this._checkTarget(k, f, e)) {
              h = c[m], h.subTargetCheck && h instanceof n.Group && (b = this._searchPossibleTargets(h._objects, e), b && this.targets.push(b));
              break;
            }
          }
          return h;
        },
        /**
         * Returns pointer coordinates without the effect of the viewport
         * @param {Object} pointer with "x" and "y" number values
         * @return {Object} object with "x" and "y" number values
         */
        restorePointerVpt: function(c) {
          return n.util.transformPoint(
            c,
            n.util.invertTransform(this.viewportTransform)
          );
        },
        /**
         * Returns pointer coordinates relative to canvas.
         * Can return coordinates with or without viewportTransform.
         * ignoreZoom false gives back coordinates that represent
         * the point clicked on canvas element.
         * ignoreZoom true gives back coordinates after being processed
         * by the viewportTransform ( sort of coordinates of what is displayed
         * on the canvas where you are clicking.
         * ignoreZoom true = HTMLElement coordinates relative to top,left
         * ignoreZoom false, default = fabric space coordinates, the same used for shape position
         * To interact with your shapes top and left you want to use ignoreZoom true
         * most of the time, while ignoreZoom false will give you coordinates
         * compatible with the object.oCoords system.
         * of the time.
         * @param {Event} e
         * @param {Boolean} ignoreZoom
         * @return {Object} object with "x" and "y" number values
         */
        getPointer: function(c, e) {
          if (this._absolutePointer && !e)
            return this._absolutePointer;
          if (this._pointer && e)
            return this._pointer;
          var h = d(c), m = this.upperCanvasEl, b = m.getBoundingClientRect(), f = b.width || 0, k = b.height || 0, E;
          (!f || !k) && ("top" in b && "bottom" in b && (k = Math.abs(b.top - b.bottom)), "right" in b && "left" in b && (f = Math.abs(b.right - b.left))), this.calcOffset(), h.x = h.x - this._offset.left, h.y = h.y - this._offset.top, e || (h = this.restorePointerVpt(h));
          var _ = this.getRetinaScaling();
          return _ !== 1 && (h.x /= _, h.y /= _), f === 0 || k === 0 ? E = { width: 1, height: 1 } : E = {
            width: m.width / f,
            height: m.height / k
          }, {
            x: h.x * E.width,
            y: h.y * E.height
          };
        },
        /**
         * @private
         * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
         */
        _createUpperCanvas: function() {
          var c = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), e = this.lowerCanvasEl, h = this.upperCanvasEl;
          h ? h.className = "" : (h = this._createCanvasElement(), this.upperCanvasEl = h), n.util.addClass(h, "upper-canvas " + c), this.wrapperEl.appendChild(h), this._copyCanvasStyle(e, h), this._applyCanvasStyle(h), this.contextTop = h.getContext("2d");
        },
        /**
         * Returns context of top canvas where interactions are drawn
         * @returns {CanvasRenderingContext2D}
         */
        getTopContext: function() {
          return this.contextTop;
        },
        /**
         * @private
         */
        _createCacheCanvas: function() {
          this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d");
        },
        /**
         * @private
         */
        _initWrapperElement: function() {
          this.wrapperEl = n.util.wrapElement(this.lowerCanvasEl, "div", {
            class: this.containerClass
          }), n.util.setStyle(this.wrapperEl, {
            width: this.width + "px",
            height: this.height + "px",
            position: "relative"
          }), n.util.makeElementUnselectable(this.wrapperEl);
        },
        /**
         * @private
         * @param {HTMLElement} element canvas element to apply styles on
         */
        _applyCanvasStyle: function(c) {
          var e = this.width || c.width, h = this.height || c.height;
          n.util.setStyle(c, {
            position: "absolute",
            width: e + "px",
            height: h + "px",
            left: 0,
            top: 0,
            "touch-action": this.allowTouchScrolling ? "manipulation" : "none",
            "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none"
          }), c.width = e, c.height = h, n.util.makeElementUnselectable(c);
        },
        /**
         * Copy the entire inline style from one element (fromEl) to another (toEl)
         * @private
         * @param {Element} fromEl Element style is copied from
         * @param {Element} toEl Element copied style is applied to
         */
        _copyCanvasStyle: function(c, e) {
          e.style.cssText = c.style.cssText;
        },
        /**
         * Returns context of canvas where object selection is drawn
         * @return {CanvasRenderingContext2D}
         */
        getSelectionContext: function() {
          return this.contextTop;
        },
        /**
         * Returns &lt;canvas> element on which object selection is drawn
         * @return {HTMLCanvasElement}
         */
        getSelectionElement: function() {
          return this.upperCanvasEl;
        },
        /**
         * Returns currently active object
         * @return {fabric.Object} active object
         */
        getActiveObject: function() {
          return this._activeObject;
        },
        /**
         * Returns an array with the current selected objects
         * @return {fabric.Object} active object
         */
        getActiveObjects: function() {
          var c = this._activeObject;
          return c ? c.type === "activeSelection" && c._objects ? c._objects.slice(0) : [c] : [];
        },
        /**
         * @private
         * @param {fabric.Object} obj Object that was removed
         */
        _onObjectRemoved: function(c) {
          c === this._activeObject && (this.fire("before:selection:cleared", { target: c }), this._discardActiveObject(), this.fire("selection:cleared", { target: c }), c.fire("deselected")), c === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", c);
        },
        /**
         * @private
         * Compares the old activeObject with the current one and fires correct events
         * @param {fabric.Object} obj old activeObject
         */
        _fireSelectionEvents: function(c, e) {
          var h = !1, m = this.getActiveObjects(), b = [], f = [];
          c.forEach(function(k) {
            m.indexOf(k) === -1 && (h = !0, k.fire("deselected", {
              e,
              target: k
            }), f.push(k));
          }), m.forEach(function(k) {
            c.indexOf(k) === -1 && (h = !0, k.fire("selected", {
              e,
              target: k
            }), b.push(k));
          }), c.length > 0 && m.length > 0 ? h && this.fire("selection:updated", {
            e,
            selected: b,
            deselected: f
          }) : m.length > 0 ? this.fire("selection:created", {
            e,
            selected: b
          }) : c.length > 0 && this.fire("selection:cleared", {
            e,
            deselected: f
          });
        },
        /**
         * Sets given object as the only active object on canvas
         * @param {fabric.Object} object Object to set as an active one
         * @param {Event} [e] Event (passed along when firing "object:selected")
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        setActiveObject: function(c, e) {
          var h = this.getActiveObjects();
          return this._setActiveObject(c, e), this._fireSelectionEvents(h, e), this;
        },
        /**
         * This is a private method for now.
         * This is supposed to be equivalent to setActiveObject but without firing
         * any event. There is commitment to have this stay this way.
         * This is the functional part of setActiveObject.
         * @private
         * @param {Object} object to set as active
         * @param {Event} [e] Event (passed along when firing "object:selected")
         * @return {Boolean} true if the selection happened
         */
        _setActiveObject: function(c, e) {
          return this._activeObject === c || !this._discardActiveObject(e, c) || c.onSelect({ e }) ? !1 : (this._activeObject = c, !0);
        },
        /**
         * This is a private method for now.
         * This is supposed to be equivalent to discardActiveObject but without firing
         * any events. There is commitment to have this stay this way.
         * This is the functional part of discardActiveObject.
         * @param {Event} [e] Event (passed along when firing "object:deselected")
         * @param {Object} object to set as active
         * @return {Boolean} true if the selection happened
         * @private
         */
        _discardActiveObject: function(c, e) {
          var h = this._activeObject;
          if (h) {
            if (h.onDeselect({ e: c, object: e }))
              return !1;
            this._activeObject = null;
          }
          return !0;
        },
        /**
         * Discards currently active object and fire events. If the function is called by fabric
         * as a consequence of a mouse event, the event is passed as a parameter and
         * sent to the fire function for the custom events. When used as a method the
         * e param does not have any application.
         * @param {event} e
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        discardActiveObject: function(c) {
          var e = this.getActiveObjects(), h = this.getActiveObject();
          return e.length && this.fire("before:selection:cleared", { target: h, e: c }), this._discardActiveObject(c), this._fireSelectionEvents(e, c), this;
        },
        /**
         * Clears a canvas element and removes all event listeners
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        dispose: function() {
          var c = this.wrapperEl;
          return this.removeListeners(), c.removeChild(this.upperCanvasEl), c.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach((function(e) {
            n.util.cleanUpJsdomNode(this[e]), this[e] = void 0;
          }).bind(this)), c.parentNode && c.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, n.StaticCanvas.prototype.dispose.call(this), this;
        },
        /**
         * Clears all contexts (background, main, top) of an instance
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        clear: function() {
          return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear");
        },
        /**
         * Draws objects' controls (borders/controls)
         * @param {CanvasRenderingContext2D} ctx Context to render controls on
         */
        drawControls: function(c) {
          var e = this._activeObject;
          e && e._renderControls(c);
        },
        /**
         * @private
         */
        _toObject: function(c, e, h) {
          var m = this._realizeGroupTransformOnObject(c), b = this.callSuper("_toObject", c, e, h);
          return this._unwindGroupTransformOnObject(c, m), b;
        },
        /**
         * Realises an object's group transformation on it
         * @private
         * @param {fabric.Object} [instance] the object to transform (gets mutated)
         * @returns the original values of instance which were changed
         */
        _realizeGroupTransformOnObject: function(c) {
          if (c.group && c.group.type === "activeSelection" && this._activeObject === c.group) {
            var e = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"], h = {};
            return e.forEach(function(m) {
              h[m] = c[m];
            }), n.util.addTransformToObject(c, this._activeObject.calcOwnMatrix()), h;
          } else
            return null;
        },
        /**
         * Restores the changed properties of instance
         * @private
         * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
         * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
         */
        _unwindGroupTransformOnObject: function(c, e) {
          e && c.set(e);
        },
        /**
         * @private
         */
        _setSVGObject: function(c, e, h) {
          var m = this._realizeGroupTransformOnObject(e);
          this.callSuper("_setSVGObject", c, e, h), this._unwindGroupTransformOnObject(e, m);
        },
        setViewportTransform: function(c) {
          this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), n.StaticCanvas.prototype.setViewportTransform.call(this, c);
        }
      }
    );
    for (var v in n.StaticCanvas)
      v !== "prototype" && (n.Canvas[v] = n.StaticCanvas[v]);
  }(), function() {
    var d = n.util.addListener, l = n.util.removeListener, p = 3, v = 2, c = 1, e = { passive: !1 };
    function h(m, b) {
      return m.button && m.button === b - 1;
    }
    n.util.object.extend(
      n.Canvas.prototype,
      /** @lends fabric.Canvas.prototype */
      {
        /**
         * Contains the id of the touch event that owns the fabric transform
         * @type Number
         * @private
         */
        mainTouchId: null,
        /**
         * Adds mouse listeners to canvas
         * @private
         */
        _initEventListeners: function() {
          this.removeListeners(), this._bindEvents(), this.addOrRemove(d, "add");
        },
        /**
         * return an event prefix pointer or mouse.
         * @private
         */
        _getEventPrefix: function() {
          return this.enablePointerEvents ? "pointer" : "mouse";
        },
        addOrRemove: function(m, b) {
          var f = this.upperCanvasEl, k = this._getEventPrefix();
          m(n.window, "resize", this._onResize), m(f, k + "down", this._onMouseDown), m(f, k + "move", this._onMouseMove, e), m(f, k + "out", this._onMouseOut), m(f, k + "enter", this._onMouseEnter), m(f, "wheel", this._onMouseWheel), m(f, "contextmenu", this._onContextMenu), m(f, "dblclick", this._onDoubleClick), m(f, "dragover", this._onDragOver), m(f, "dragenter", this._onDragEnter), m(f, "dragleave", this._onDragLeave), m(f, "drop", this._onDrop), this.enablePointerEvents || m(f, "touchstart", this._onTouchStart, e), typeof eventjs < "u" && b in eventjs && (eventjs[b](f, "gesture", this._onGesture), eventjs[b](f, "drag", this._onDrag), eventjs[b](f, "orientation", this._onOrientationChange), eventjs[b](f, "shake", this._onShake), eventjs[b](f, "longpress", this._onLongPress));
        },
        /**
         * Removes all event listeners
         */
        removeListeners: function() {
          this.addOrRemove(l, "remove");
          var m = this._getEventPrefix();
          l(n.document, m + "up", this._onMouseUp), l(n.document, "touchend", this._onTouchEnd, e), l(n.document, m + "move", this._onMouseMove, e), l(n.document, "touchmove", this._onMouseMove, e);
        },
        /**
         * @private
         */
        _bindEvents: function() {
          this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on Event.js gesture
         * @param {Event} [self] Inner Event object
         */
        _onGesture: function(m, b) {
          this.__onTransformGesture && this.__onTransformGesture(m, b);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on Event.js drag
         * @param {Event} [self] Inner Event object
         */
        _onDrag: function(m, b) {
          this.__onDrag && this.__onDrag(m, b);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on wheel event
         */
        _onMouseWheel: function(m) {
          this.__onMouseWheel(m);
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onMouseOut: function(m) {
          var b = this._hoveredTarget;
          this.fire("mouse:out", { target: b, e: m }), this._hoveredTarget = null, b && b.fire("mouseout", { e: m });
          var f = this;
          this._hoveredTargets.forEach(function(k) {
            f.fire("mouse:out", { target: b, e: m }), k && b.fire("mouseout", { e: m });
          }), this._hoveredTargets = [];
        },
        /**
         * @private
         * @param {Event} e Event object fired on mouseenter
         */
        _onMouseEnter: function(m) {
          !this._currentTransform && !this.findTarget(m) && (this.fire("mouse:over", { target: null, e: m }), this._hoveredTarget = null, this._hoveredTargets = []);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on Event.js orientation change
         * @param {Event} [self] Inner Event object
         */
        _onOrientationChange: function(m, b) {
          this.__onOrientationChange && this.__onOrientationChange(m, b);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on Event.js shake
         * @param {Event} [self] Inner Event object
         */
        _onShake: function(m, b) {
          this.__onShake && this.__onShake(m, b);
        },
        /**
         * @private
         * @param {Event} [e] Event object fired on Event.js shake
         * @param {Event} [self] Inner Event object
         */
        _onLongPress: function(m, b) {
          this.__onLongPress && this.__onLongPress(m, b);
        },
        /**
         * prevent default to allow drop event to be fired
         * @private
         * @param {Event} [e] Event object fired on Event.js shake
         */
        _onDragOver: function(m) {
          m.preventDefault();
          var b = this._simpleEventHandler("dragover", m);
          this._fireEnterLeaveEvents(b, m);
        },
        /**
         * `drop:before` is a an event that allow you to schedule logic
         * before the `drop` event. Prefer `drop` event always, but if you need
         * to run some drop-disabling logic on an event, since there is no way
         * to handle event handlers ordering, use `drop:before`
         * @param {Event} e
         */
        _onDrop: function(m) {
          return this._simpleEventHandler("drop:before", m), this._simpleEventHandler("drop", m);
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onContextMenu: function(m) {
          return this.stopContextMenu && (m.stopPropagation(), m.preventDefault()), !1;
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onDoubleClick: function(m) {
          this._cacheTransformEventData(m), this._handleEvent(m, "dblclick"), this._resetTransformEventData(m);
        },
        /**
         * Return a the id of an event.
         * returns either the pointerId or the identifier or 0 for the mouse event
         * @private
         * @param {Event} evt Event object
         */
        getPointerId: function(m) {
          var b = m.changedTouches;
          return b ? b[0] && b[0].identifier : this.enablePointerEvents ? m.pointerId : -1;
        },
        /**
         * Determines if an event has the id of the event that is considered main
         * @private
         * @param {evt} event Event object
         */
        _isMainEvent: function(m) {
          return m.isPrimary === !0 ? !0 : m.isPrimary === !1 ? !1 : m.type === "touchend" && m.touches.length === 0 ? !0 : m.changedTouches ? m.changedTouches[0].identifier === this.mainTouchId : !0;
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onTouchStart: function(m) {
          m.preventDefault(), this.mainTouchId === null && (this.mainTouchId = this.getPointerId(m)), this.__onMouseDown(m), this._resetTransformEventData();
          var b = this.upperCanvasEl, f = this._getEventPrefix();
          d(n.document, "touchend", this._onTouchEnd, e), d(n.document, "touchmove", this._onMouseMove, e), l(b, f + "down", this._onMouseDown);
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onMouseDown: function(m) {
          this.__onMouseDown(m), this._resetTransformEventData();
          var b = this.upperCanvasEl, f = this._getEventPrefix();
          l(b, f + "move", this._onMouseMove, e), d(n.document, f + "up", this._onMouseUp), d(n.document, f + "move", this._onMouseMove, e);
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onTouchEnd: function(m) {
          if (!(m.touches.length > 0)) {
            this.__onMouseUp(m), this._resetTransformEventData(), this.mainTouchId = null;
            var b = this._getEventPrefix();
            l(n.document, "touchend", this._onTouchEnd, e), l(n.document, "touchmove", this._onMouseMove, e);
            var f = this;
            this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function() {
              d(f.upperCanvasEl, b + "down", f._onMouseDown), f._willAddMouseDown = 0;
            }, 400);
          }
        },
        /**
         * @private
         * @param {Event} e Event object fired on mouseup
         */
        _onMouseUp: function(m) {
          this.__onMouseUp(m), this._resetTransformEventData();
          var b = this.upperCanvasEl, f = this._getEventPrefix();
          this._isMainEvent(m) && (l(n.document, f + "up", this._onMouseUp), l(n.document, f + "move", this._onMouseMove, e), d(b, f + "move", this._onMouseMove, e));
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousemove
         */
        _onMouseMove: function(m) {
          !this.allowTouchScrolling && m.preventDefault && m.preventDefault(), this.__onMouseMove(m);
        },
        /**
         * @private
         */
        _onResize: function() {
          this.calcOffset();
        },
        /**
         * Decides whether the canvas should be redrawn in mouseup and mousedown events.
         * @private
         * @param {Object} target
         */
        _shouldRender: function(m) {
          var b = this._activeObject;
          return !!b != !!m || b && m && b !== m ? !0 : (b && b.isEditing, !1);
        },
        /**
         * Method that defines the actions when mouse is released on canvas.
         * The method resets the currentTransform parameters, store the image corner
         * position in the image object and render the canvas on top.
         * @private
         * @param {Event} e Event object fired on mouseup
         */
        __onMouseUp: function(m) {
          var b, f = this._currentTransform, k = this._groupSelector, E = !1, _ = !k || k.left === 0 && k.top === 0;
          if (this._cacheTransformEventData(m), b = this._target, this._handleEvent(m, "up:before"), h(m, p)) {
            this.fireRightClick && this._handleEvent(m, "up", p, _);
            return;
          }
          if (h(m, v)) {
            this.fireMiddleClick && this._handleEvent(m, "up", v, _), this._resetTransformEventData();
            return;
          }
          if (this.isDrawingMode && this._isCurrentlyDrawing) {
            this._onMouseUpInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m)) {
            if (f && (this._finalizeCurrentTransform(m), E = f.actionPerformed), !_) {
              var T = b === this._activeObject;
              this._maybeGroupObjects(m), E || (E = this._shouldRender(b) || !T && b === this._activeObject);
            }
            var D, V;
            if (b) {
              if (D = b._findTargetCorner(
                this.getPointer(m, !0),
                n.util.isTouchEvent(m)
              ), b.selectable && b !== this._activeObject && b.activeOn === "up")
                this.setActiveObject(b, m), E = !0;
              else {
                var I = b.controls[D], M = I && I.getMouseUpHandler(m, b, I);
                M && (V = this.getPointer(m), M(m, f, V.x, V.y));
              }
              b.isMoving = !1;
            }
            if (f && (f.target !== b || f.corner !== D)) {
              var Q = f.target && f.target.controls[f.corner], G = Q && Q.getMouseUpHandler(m, b, I);
              V = V || this.getPointer(m), G && G(m, f, V.x, V.y);
            }
            this._setCursorFromEvent(m, b), this._handleEvent(m, "up", c, _), this._groupSelector = null, this._currentTransform = null, b && (b.__corner = 0), E ? this.requestRenderAll() : _ || this.renderTop();
          }
        },
        /**
         * @private
         * Handle event firing for target and subtargets
         * @param {Event} e event from mouse
         * @param {String} eventType event to fire (up, down or move)
         * @return {Fabric.Object} target return the the target found, for internal reasons.
         */
        _simpleEventHandler: function(m, b) {
          var f = this.findTarget(b), k = this.targets, E = {
            e: b,
            target: f,
            subTargets: k
          };
          if (this.fire(m, E), f && f.fire(m, E), !k)
            return f;
          for (var _ = 0; _ < k.length; _++)
            k[_].fire(m, E);
          return f;
        },
        /**
         * @private
         * Handle event firing for target and subtargets
         * @param {Event} e event from mouse
         * @param {String} eventType event to fire (up, down or move)
         * @param {fabric.Object} targetObj receiving event
         * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
         * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
         */
        _handleEvent: function(m, b, f, k) {
          var E = this._target, _ = this.targets || [], T = {
            e: m,
            target: E,
            subTargets: _,
            button: f || c,
            isClick: k || !1,
            pointer: this._pointer,
            absolutePointer: this._absolutePointer,
            transform: this._currentTransform
          };
          b === "up" && (T.currentTarget = this.findTarget(m), T.currentSubTargets = this.targets), this.fire("mouse:" + b, T), E && E.fire("mouse" + b, T);
          for (var D = 0; D < _.length; D++)
            _[D].fire("mouse" + b, T);
        },
        /**
         * @private
         * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
         */
        _finalizeCurrentTransform: function(m) {
          var b = this._currentTransform, f = b.target, k = {
            e: m,
            target: f,
            transform: b,
            action: b.action
          };
          f._scaling && (f._scaling = !1), f.setCoords(), (b.actionPerformed || this.stateful && f.hasStateChanged()) && this._fire("modified", k);
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        _onMouseDownInDrawingMode: function(m) {
          this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(m).requestRenderAll();
          var b = this.getPointer(m);
          this.freeDrawingBrush.onMouseDown(b, { e: m, pointer: b }), this._handleEvent(m, "down");
        },
        /**
         * @private
         * @param {Event} e Event object fired on mousemove
         */
        _onMouseMoveInDrawingMode: function(m) {
          if (this._isCurrentlyDrawing) {
            var b = this.getPointer(m);
            this.freeDrawingBrush.onMouseMove(b, { e: m, pointer: b });
          }
          this.setCursor(this.freeDrawingCursor), this._handleEvent(m, "move");
        },
        /**
         * @private
         * @param {Event} e Event object fired on mouseup
         */
        _onMouseUpInDrawingMode: function(m) {
          var b = this.getPointer(m);
          this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: m, pointer: b }), this._handleEvent(m, "up");
        },
        /**
         * Method that defines the actions when mouse is clicked on canvas.
         * The method inits the currentTransform parameters and renders all the
         * canvas so the current image can be placed on the top canvas and the rest
         * in on the container one.
         * @private
         * @param {Event} e Event object fired on mousedown
         */
        __onMouseDown: function(m) {
          this._cacheTransformEventData(m), this._handleEvent(m, "down:before");
          var b = this._target;
          if (h(m, p)) {
            this.fireRightClick && this._handleEvent(m, "down", p);
            return;
          }
          if (h(m, v)) {
            this.fireMiddleClick && this._handleEvent(m, "down", v);
            return;
          }
          if (this.isDrawingMode) {
            this._onMouseDownInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m) && !this._currentTransform) {
            var f = this._pointer;
            this._previousPointer = f;
            var k = this._shouldRender(b), E = this._shouldGroup(m, b);
            if (this._shouldClearSelection(m, b) ? this.discardActiveObject(m) : E && (this._handleGrouping(m, b), b = this._activeObject), this.selection && (!b || !b.selectable && !b.isEditing && b !== this._activeObject) && (this._groupSelector = {
              ex: this._absolutePointer.x,
              ey: this._absolutePointer.y,
              top: 0,
              left: 0
            }), b) {
              var _ = b === this._activeObject;
              b.selectable && b.activeOn === "down" && this.setActiveObject(b, m);
              var T = b._findTargetCorner(
                this.getPointer(m, !0),
                n.util.isTouchEvent(m)
              );
              if (b.__corner = T, b === this._activeObject && (T || !E)) {
                this._setupCurrentTransform(m, b, _);
                var D = b.controls[T], f = this.getPointer(m), V = D && D.getMouseDownHandler(m, b, D);
                V && V(m, this._currentTransform, f.x, f.y);
              }
            }
            this._handleEvent(m, "down"), (k || E) && this.requestRenderAll();
          }
        },
        /**
         * reset cache form common information needed during event processing
         * @private
         */
        _resetTransformEventData: function() {
          this._target = null, this._pointer = null, this._absolutePointer = null;
        },
        /**
         * Cache common information needed during event processing
         * @private
         * @param {Event} e Event object fired on event
         */
        _cacheTransformEventData: function(m) {
          this._resetTransformEventData(), this._pointer = this.getPointer(m, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(m) || null;
        },
        /**
         * @private
         */
        _beforeTransform: function(m) {
          var b = this._currentTransform;
          this.stateful && b.target.saveState(), this.fire("before:transform", {
            e: m,
            transform: b
          });
        },
        /**
         * Method that defines the actions when mouse is hovering the canvas.
         * The currentTransform parameter will define whether the user is rotating/scaling/translating
         * an image or neither of them (only hovering). A group selection is also possible and would cancel
         * all any other type of action.
         * In case of an image transformation only the top canvas will be rendered.
         * @private
         * @param {Event} e Event object fired on mousemove
         */
        __onMouseMove: function(m) {
          this._handleEvent(m, "move:before"), this._cacheTransformEventData(m);
          var b, f;
          if (this.isDrawingMode) {
            this._onMouseMoveInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m)) {
            var k = this._groupSelector;
            k ? (f = this._absolutePointer, k.left = f.x - k.ex, k.top = f.y - k.ey, this.renderTop()) : this._currentTransform ? this._transformObject(m) : (b = this.findTarget(m) || null, this._setCursorFromEvent(m, b), this._fireOverOutEvents(b, m)), this._handleEvent(m, "move"), this._resetTransformEventData();
          }
        },
        /**
         * Manage the mouseout, mouseover events for the fabric object on the canvas
         * @param {Fabric.Object} target the target where the target from the mousemove event
         * @param {Event} e Event object fired on mousemove
         * @private
         */
        _fireOverOutEvents: function(m, b) {
          var f = this._hoveredTarget, k = this._hoveredTargets, E = this.targets, _ = Math.max(k.length, E.length);
          this.fireSyntheticInOutEvents(m, b, {
            oldTarget: f,
            evtOut: "mouseout",
            canvasEvtOut: "mouse:out",
            evtIn: "mouseover",
            canvasEvtIn: "mouse:over"
          });
          for (var T = 0; T < _; T++)
            this.fireSyntheticInOutEvents(E[T], b, {
              oldTarget: k[T],
              evtOut: "mouseout",
              evtIn: "mouseover"
            });
          this._hoveredTarget = m, this._hoveredTargets = this.targets.concat();
        },
        /**
         * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
         * @param {Fabric.Object} target the target where the target from the onDrag event
         * @param {Event} e Event object fired on ondrag
         * @private
         */
        _fireEnterLeaveEvents: function(m, b) {
          var f = this._draggedoverTarget, k = this._hoveredTargets, E = this.targets, _ = Math.max(k.length, E.length);
          this.fireSyntheticInOutEvents(m, b, {
            oldTarget: f,
            evtOut: "dragleave",
            evtIn: "dragenter"
          });
          for (var T = 0; T < _; T++)
            this.fireSyntheticInOutEvents(E[T], b, {
              oldTarget: k[T],
              evtOut: "dragleave",
              evtIn: "dragenter"
            });
          this._draggedoverTarget = m;
        },
        /**
         * Manage the synthetic in/out events for the fabric objects on the canvas
         * @param {Fabric.Object} target the target where the target from the supported events
         * @param {Event} e Event object fired
         * @param {Object} config configuration for the function to work
         * @param {String} config.targetName property on the canvas where the old target is stored
         * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
         * @param {String} config.evtOut name of the event to fire for out
         * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
         * @param {String} config.evtIn name of the event to fire for in
         * @private
         */
        fireSyntheticInOutEvents: function(m, b, f) {
          var k, E, _ = f.oldTarget, T, D, V = _ !== m, I = f.canvasEvtIn, M = f.canvasEvtOut;
          V && (k = { e: b, target: m, previousTarget: _ }, E = { e: b, target: _, nextTarget: m }), D = m && V, T = _ && V, T && (M && this.fire(M, E), _.fire(f.evtOut, E)), D && (I && this.fire(I, k), m.fire(f.evtIn, k));
        },
        /**
         * Method that defines actions when an Event Mouse Wheel
         * @param {Event} e Event object fired on mouseup
         */
        __onMouseWheel: function(m) {
          this._cacheTransformEventData(m), this._handleEvent(m, "wheel"), this._resetTransformEventData();
        },
        /**
         * @private
         * @param {Event} e Event fired on mousemove
         */
        _transformObject: function(m) {
          var b = this.getPointer(m), f = this._currentTransform;
          f.reset = !1, f.shiftKey = m.shiftKey, f.altKey = m[this.centeredKey], this._performTransformAction(m, f, b), f.actionPerformed && this.requestRenderAll();
        },
        /**
         * @private
         */
        _performTransformAction: function(m, b, f) {
          var k = f.x, E = f.y, _ = b.action, T = !1, D = b.actionHandler;
          D && (T = D(m, b, k, E)), _ === "drag" && T && (b.target.isMoving = !0, this.setCursor(b.target.moveCursor || this.moveCursor)), b.actionPerformed = b.actionPerformed || T;
        },
        /**
         * @private
         */
        _fire: n.controlsUtils.fireEvent,
        /**
         * Sets the cursor depending on where the canvas is being hovered.
         * Note: very buggy in Opera
         * @param {Event} e Event object
         * @param {Object} target Object that the mouse is hovering, if so.
         */
        _setCursorFromEvent: function(m, b) {
          if (!b)
            return this.setCursor(this.defaultCursor), !1;
          var f = b.hoverCursor || this.hoverCursor, k = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, E = (!k || !k.contains(b)) && b._findTargetCorner(this.getPointer(m, !0));
          E ? this.setCursor(this.getCornerCursor(E, b, m)) : (b.subTargetCheck && this.targets.concat().reverse().map(function(_) {
            f = _.hoverCursor || f;
          }), this.setCursor(f));
        },
        /**
         * @private
         */
        getCornerCursor: function(m, b, f) {
          var k = b.controls[m];
          return k.cursorStyleHandler(f, k, b);
        }
      }
    );
  }(), function() {
    var d = Math.min, l = Math.max;
    n.util.object.extend(
      n.Canvas.prototype,
      /** @lends fabric.Canvas.prototype */
      {
        /**
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         * @return {Boolean}
         */
        _shouldGroup: function(p, v) {
          var c = this._activeObject;
          return c && this._isSelectionKeyPressed(p) && v && v.selectable && this.selection && (c !== v || c.type === "activeSelection") && !v.onSelect({ e: p });
        },
        /**
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */
        _handleGrouping: function(p, v) {
          var c = this._activeObject;
          c.__corner || v === c && (v = this.findTarget(p, !0), !v || !v.selectable) || (c && c.type === "activeSelection" ? this._updateActiveSelection(v, p) : this._createActiveSelection(v, p));
        },
        /**
         * @private
         */
        _updateActiveSelection: function(p, v) {
          var c = this._activeObject, e = c._objects.slice(0);
          c.contains(p) ? (c.removeWithUpdate(p), this._hoveredTarget = p, this._hoveredTargets = this.targets.concat(), c.size() === 1 && this._setActiveObject(c.item(0), v)) : (c.addWithUpdate(p), this._hoveredTarget = c, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(e, v);
        },
        /**
         * @private
         */
        _createActiveSelection: function(p, v) {
          var c = this.getActiveObjects(), e = this._createGroup(p);
          this._hoveredTarget = e, this._setActiveObject(e, v), this._fireSelectionEvents(c, v);
        },
        /**
         * @private
         * @param {Object} target
         */
        _createGroup: function(p) {
          var v = this._objects, c = v.indexOf(this._activeObject) < v.indexOf(p), e = c ? [this._activeObject, p] : [p, this._activeObject];
          return this._activeObject.isEditing && this._activeObject.exitEditing(), new n.ActiveSelection(e, {
            canvas: this
          });
        },
        /**
         * @private
         * @param {Event} e mouse event
         */
        _groupSelectedObjects: function(p) {
          var v = this._collectObjects(p), c;
          v.length === 1 ? this.setActiveObject(v[0], p) : v.length > 1 && (c = new n.ActiveSelection(v.reverse(), {
            canvas: this
          }), this.setActiveObject(c, p));
        },
        /**
         * @private
         */
        _collectObjects: function(p) {
          for (var v = [], c, e = this._groupSelector.ex, h = this._groupSelector.ey, m = e + this._groupSelector.left, b = h + this._groupSelector.top, f = new n.Point(d(e, m), d(h, b)), k = new n.Point(l(e, m), l(h, b)), E = !this.selectionFullyContained, _ = e === m && h === b, T = this._objects.length; T-- && (c = this._objects[T], !(!(!c || !c.selectable || !c.visible) && (E && c.intersectsWithRect(f, k, !0) || c.isContainedWithinRect(f, k, !0) || E && c.containsPoint(f, null, !0) || E && c.containsPoint(k, null, !0)) && (v.push(c), _))); )
            ;
          return v.length > 1 && (v = v.filter(function(D) {
            return !D.onSelect({ e: p });
          })), v;
        },
        /**
         * @private
         */
        _maybeGroupObjects: function(p) {
          this.selection && this._groupSelector && this._groupSelectedObjects(p), this.setCursor(this.defaultCursor), this._groupSelector = null;
        }
      }
    );
  }(), function() {
    n.util.object.extend(
      n.StaticCanvas.prototype,
      /** @lends fabric.StaticCanvas.prototype */
      {
        /**
         * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
         * @param {Object} [options] Options object
         * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
         * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
         * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
         * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
         * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
         * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
         * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
         * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
         * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
         * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
         * @example <caption>Generate jpeg dataURL with lower quality</caption>
         * var dataURL = canvas.toDataURL({
         *   format: 'jpeg',
         *   quality: 0.8
         * });
         * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
         * var dataURL = canvas.toDataURL({
         *   format: 'png',
         *   left: 100,
         *   top: 100,
         *   width: 200,
         *   height: 200
         * });
         * @example <caption>Generate double scaled png dataURL</caption>
         * var dataURL = canvas.toDataURL({
         *   format: 'png',
         *   multiplier: 2
         * });
         */
        toDataURL: function(d) {
          d || (d = {});
          var l = d.format || "png", p = d.quality || 1, v = (d.multiplier || 1) * (d.enableRetinaScaling ? this.getRetinaScaling() : 1), c = this.toCanvasElement(v, d);
          return n.util.toDataURL(c, l, p);
        },
        /**
         * Create a new HTMLCanvas element painted with the current canvas content.
         * No need to resize the actual one or repaint it.
         * Will transfer object ownership to a new canvas, paint it, and set everything back.
         * This is an intermediary step used to get to a dataUrl but also it is useful to
         * create quick image copies of a canvas without passing for the dataUrl string
         * @param {Number} [multiplier] a zoom factor.
         * @param {Object} [cropping] Cropping informations
         * @param {Number} [cropping.left] Cropping left offset.
         * @param {Number} [cropping.top] Cropping top offset.
         * @param {Number} [cropping.width] Cropping width.
         * @param {Number} [cropping.height] Cropping height.
         */
        toCanvasElement: function(d, l) {
          d = d || 1, l = l || {};
          var p = (l.width || this.width) * d, v = (l.height || this.height) * d, c = this.getZoom(), e = this.width, h = this.height, m = c * d, b = this.viewportTransform, f = (b[4] - (l.left || 0)) * d, k = (b[5] - (l.top || 0)) * d, E = this.interactive, _ = [m, 0, 0, m, f, k], T = this.enableRetinaScaling, D = n.util.createCanvasElement(), V = this.contextTop;
          return D.width = p, D.height = v, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = _, this.width = p, this.height = v, this.calcViewportBoundaries(), this.renderCanvas(D.getContext("2d"), this._objects), this.viewportTransform = b, this.width = e, this.height = h, this.calcViewportBoundaries(), this.interactive = E, this.enableRetinaScaling = T, this.contextTop = V, D;
        }
      }
    );
  }(), n.util.object.extend(
    n.StaticCanvas.prototype,
    /** @lends fabric.StaticCanvas.prototype */
    {
      /**
       * Populates canvas with data from the specified JSON.
       * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
       * @param {String|Object} json JSON string or object
       * @param {Function} callback Callback, invoked when json is parsed
       *                            and corresponding objects (e.g: {@link fabric.Image})
       *                            are initialized
       * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
       * @return {fabric.Canvas} instance
       * @chainable
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
       * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
       * @example <caption>loadFromJSON</caption>
       * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
       * @example <caption>loadFromJSON with reviver</caption>
       * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
       *   // `o` = json object
       *   // `object` = fabric.Object instance
       *   // ... do some stuff ...
       * });
       */
      loadFromJSON: function(d, l, p) {
        if (d) {
          var v = typeof d == "string" ? JSON.parse(d) : n.util.object.clone(d), c = this, e = v.clipPath, h = this.renderOnAddRemove;
          return this.renderOnAddRemove = !1, delete v.clipPath, this._enlivenObjects(v.objects, function(m) {
            c.clear(), c._setBgOverlay(v, function() {
              e ? c._enlivenObjects([e], function(b) {
                c.clipPath = b[0], c.__setupCanvas.call(c, v, m, h, l);
              }) : c.__setupCanvas.call(c, v, m, h, l);
            });
          }, p), this;
        }
      },
      /**
       * @private
       * @param {Object} serialized Object with background and overlay information
       * @param {Array} restored canvas objects
       * @param {Function} cached renderOnAddRemove callback
       * @param {Function} callback Invoked after all background and overlay images/patterns loaded
       */
      __setupCanvas: function(d, l, p, v) {
        var c = this;
        l.forEach(function(e, h) {
          c.insertAt(e, h);
        }), this.renderOnAddRemove = p, delete d.objects, delete d.backgroundImage, delete d.overlayImage, delete d.background, delete d.overlay, this._setOptions(d), this.renderAll(), v && v();
      },
      /**
       * @private
       * @param {Object} serialized Object with background and overlay information
       * @param {Function} callback Invoked after all background and overlay images/patterns loaded
       */
      _setBgOverlay: function(d, l) {
        var p = {
          backgroundColor: !1,
          overlayColor: !1,
          backgroundImage: !1,
          overlayImage: !1
        };
        if (!d.backgroundImage && !d.overlayImage && !d.background && !d.overlay) {
          l && l();
          return;
        }
        var v = function() {
          p.backgroundImage && p.overlayImage && p.backgroundColor && p.overlayColor && l && l();
        };
        this.__setBgOverlay("backgroundImage", d.backgroundImage, p, v), this.__setBgOverlay("overlayImage", d.overlayImage, p, v), this.__setBgOverlay("backgroundColor", d.background, p, v), this.__setBgOverlay("overlayColor", d.overlay, p, v);
      },
      /**
       * @private
       * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
       * @param {(Object|String)} value Value to set
       * @param {Object} loaded Set loaded property to true if property is set
       * @param {Object} callback Callback function to invoke after property is set
       */
      __setBgOverlay: function(d, l, p, v) {
        var c = this;
        if (!l) {
          p[d] = !0, v && v();
          return;
        }
        d === "backgroundImage" || d === "overlayImage" ? n.util.enlivenObjects([l], function(e) {
          c[d] = e[0], p[d] = !0, v && v();
        }) : this["set" + n.util.string.capitalize(d, !0)](l, function() {
          p[d] = !0, v && v();
        });
      },
      /**
       * @private
       * @param {Array} objects
       * @param {Function} callback
       * @param {Function} [reviver]
       */
      _enlivenObjects: function(d, l, p) {
        if (!d || d.length === 0) {
          l && l([]);
          return;
        }
        n.util.enlivenObjects(d, function(v) {
          l && l(v);
        }, null, p);
      },
      /**
       * @private
       * @param {String} format
       * @param {Function} callback
       */
      _toDataURL: function(d, l) {
        this.clone(function(p) {
          l(p.toDataURL(d));
        });
      },
      /**
       * @private
       * @param {String} format
       * @param {Number} multiplier
       * @param {Function} callback
       */
      _toDataURLWithMultiplier: function(d, l, p) {
        this.clone(function(v) {
          p(v.toDataURLWithMultiplier(d, l));
        });
      },
      /**
       * Clones canvas instance
       * @param {Object} [callback] Receives cloned instance as a first argument
       * @param {Array} [properties] Array of properties to include in the cloned canvas and children
       */
      clone: function(d, l) {
        var p = JSON.stringify(this.toJSON(l));
        this.cloneWithoutData(function(v) {
          v.loadFromJSON(p, function() {
            d && d(v);
          });
        });
      },
      /**
       * Clones canvas instance without cloning existing data.
       * This essentially copies canvas dimensions, clipping properties, etc.
       * but leaves data empty (so that you can populate it with your own)
       * @param {Object} [callback] Receives cloned instance as a first argument
       */
      cloneWithoutData: function(d) {
        var l = n.util.createCanvasElement();
        l.width = this.width, l.height = this.height;
        var p = new n.Canvas(l);
        this.backgroundImage ? (p.setBackgroundImage(this.backgroundImage.src, function() {
          p.renderAll(), d && d(p);
        }), p.backgroundImageOpacity = this.backgroundImageOpacity, p.backgroundImageStretch = this.backgroundImageStretch) : d && d(p);
      }
    }
  ), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.util.object.clone, c = l.util.toFixed, e = l.util.string.capitalize, h = l.util.degreesToRadians, m = !l.isLikelyNode, b = 2;
    l.Object || (l.Object = l.util.createClass(
      l.CommonMethods,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Type of an object (rect, circle, path, etc.).
         * Note that this property is meant to be read-only and not meant to be modified.
         * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
         * @type String
         * @default
         */
        type: "object",
        /**
         * Horizontal origin of transformation of an object (one of "left", "right", "center")
         * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
         * @type String
         * @default
         */
        originX: "left",
        /**
         * Vertical origin of transformation of an object (one of "top", "bottom", "center")
         * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
         * @type String
         * @default
         */
        originY: "top",
        /**
         * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
         * @type Number
         * @default
         */
        top: 0,
        /**
         * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
         * @type Number
         * @default
         */
        left: 0,
        /**
         * Object width
         * @type Number
         * @default
         */
        width: 0,
        /**
         * Object height
         * @type Number
         * @default
         */
        height: 0,
        /**
         * Object scale factor (horizontal)
         * @type Number
         * @default
         */
        scaleX: 1,
        /**
         * Object scale factor (vertical)
         * @type Number
         * @default
         */
        scaleY: 1,
        /**
         * When true, an object is rendered as flipped horizontally
         * @type Boolean
         * @default
         */
        flipX: !1,
        /**
         * When true, an object is rendered as flipped vertically
         * @type Boolean
         * @default
         */
        flipY: !1,
        /**
         * Opacity of an object
         * @type Number
         * @default
         */
        opacity: 1,
        /**
         * Angle of rotation of an object (in degrees)
         * @type Number
         * @default
         */
        angle: 0,
        /**
         * Angle of skew on x axes of an object (in degrees)
         * @type Number
         * @default
         */
        skewX: 0,
        /**
         * Angle of skew on y axes of an object (in degrees)
         * @type Number
         * @default
         */
        skewY: 0,
        /**
         * Size of object's controlling corners (in pixels)
         * @type Number
         * @default
         */
        cornerSize: 13,
        /**
         * Size of object's controlling corners when touch interaction is detected
         * @type Number
         * @default
         */
        touchCornerSize: 24,
        /**
         * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
         * @type Boolean
         * @default
         */
        transparentCorners: !0,
        /**
         * Default cursor value used when hovering over this object on canvas
         * @type String
         * @default
         */
        hoverCursor: null,
        /**
         * Default cursor value used when moving this object on canvas
         * @type String
         * @default
         */
        moveCursor: null,
        /**
         * Padding between object and its controlling borders (in pixels)
         * @type Number
         * @default
         */
        padding: 0,
        /**
         * Color of controlling borders of an object (when it's active)
         * @type String
         * @default
         */
        borderColor: "rgb(178,204,255)",
        /**
         * Array specifying dash pattern of an object's borders (hasBorder must be true)
         * @since 1.6.2
         * @type Array
         */
        borderDashArray: null,
        /**
         * Color of controlling corners of an object (when it's active)
         * @type String
         * @default
         */
        cornerColor: "rgb(178,204,255)",
        /**
         * Color of controlling corners of an object (when it's active and transparentCorners false)
         * @since 1.6.2
         * @type String
         * @default
         */
        cornerStrokeColor: null,
        /**
         * Specify style of control, 'rect' or 'circle'
         * @since 1.6.2
         * @type String
         */
        cornerStyle: "rect",
        /**
         * Array specifying dash pattern of an object's control (hasBorder must be true)
         * @since 1.6.2
         * @type Array
         */
        cornerDashArray: null,
        /**
         * When true, this object will use center point as the origin of transformation
         * when being scaled via the controls.
         * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
         * @since 1.3.4
         * @type Boolean
         * @default
         */
        centeredScaling: !1,
        /**
         * When true, this object will use center point as the origin of transformation
         * when being rotated via the controls.
         * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
         * @since 1.3.4
         * @type Boolean
         * @default
         */
        centeredRotation: !0,
        /**
         * Color of object's fill
         * takes css colors https://www.w3.org/TR/css-color-3/
         * @type String
         * @default
         */
        fill: "rgb(0,0,0)",
        /**
         * Fill rule used to fill an object
         * accepted values are nonzero, evenodd
         * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
         * @type String
         * @default
         */
        fillRule: "nonzero",
        /**
         * Composite rule used for canvas globalCompositeOperation
         * @type String
         * @default
         */
        globalCompositeOperation: "source-over",
        /**
         * Background color of an object.
         * takes css colors https://www.w3.org/TR/css-color-3/
         * @type String
         * @default
         */
        backgroundColor: "",
        /**
         * Selection Background color of an object. colored layer behind the object when it is active.
         * does not mix good with globalCompositeOperation methods.
         * @type String
         * @default
         */
        selectionBackgroundColor: "",
        /**
         * When defined, an object is rendered via stroke and this property specifies its color
         * takes css colors https://www.w3.org/TR/css-color-3/
         * @type String
         * @default
         */
        stroke: null,
        /**
         * Width of a stroke used to render this object
         * @type Number
         * @default
         */
        strokeWidth: 1,
        /**
         * Array specifying dash pattern of an object's stroke (stroke must be defined)
         * @type Array
         */
        strokeDashArray: null,
        /**
         * Line offset of an object's stroke
         * @type Number
         * @default
         */
        strokeDashOffset: 0,
        /**
         * Line endings style of an object's stroke (one of "butt", "round", "square")
         * @type String
         * @default
         */
        strokeLineCap: "butt",
        /**
         * Corner style of an object's stroke (one of "bevel", "round", "miter")
         * @type String
         * @default
         */
        strokeLineJoin: "miter",
        /**
         * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
         * @type Number
         * @default
         */
        strokeMiterLimit: 4,
        /**
         * Shadow object representing shadow of this shape
         * @type fabric.Shadow
         * @default
         */
        shadow: null,
        /**
         * Opacity of object's controlling borders when object is active and moving
         * @type Number
         * @default
         */
        borderOpacityWhenMoving: 0.4,
        /**
         * Scale factor of object's controlling borders
         * bigger number will make a thicker border
         * border is 1, so this is basically a border thickness
         * since there is no way to change the border itself.
         * @type Number
         * @default
         */
        borderScaleFactor: 1,
        /**
         * Minimum allowed scale value of an object
         * @type Number
         * @default
         */
        minScaleLimit: 0,
        /**
         * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
         * But events still fire on it.
         * @type Boolean
         * @default
         */
        selectable: !0,
        /**
         * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
         * @type Boolean
         * @default
         */
        evented: !0,
        /**
         * When set to `false`, an object is not rendered on canvas
         * @type Boolean
         * @default
         */
        visible: !0,
        /**
         * When set to `false`, object's controls are not displayed and can not be used to manipulate object
         * @type Boolean
         * @default
         */
        hasControls: !0,
        /**
         * When set to `false`, object's controlling borders are not rendered
         * @type Boolean
         * @default
         */
        hasBorders: !0,
        /**
         * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
         * @type Boolean
         * @default
         */
        perPixelTargetFind: !1,
        /**
         * When `false`, default object's values are not included in its serialization
         * @type Boolean
         * @default
         */
        includeDefaultValues: !0,
        /**
         * When `true`, object horizontal movement is locked
         * @type Boolean
         * @default
         */
        lockMovementX: !1,
        /**
         * When `true`, object vertical movement is locked
         * @type Boolean
         * @default
         */
        lockMovementY: !1,
        /**
         * When `true`, object rotation is locked
         * @type Boolean
         * @default
         */
        lockRotation: !1,
        /**
         * When `true`, object horizontal scaling is locked
         * @type Boolean
         * @default
         */
        lockScalingX: !1,
        /**
         * When `true`, object vertical scaling is locked
         * @type Boolean
         * @default
         */
        lockScalingY: !1,
        /**
         * When `true`, object horizontal skewing is locked
         * @type Boolean
         * @default
         */
        lockSkewingX: !1,
        /**
         * When `true`, object vertical skewing is locked
         * @type Boolean
         * @default
         */
        lockSkewingY: !1,
        /**
         * When `true`, object cannot be flipped by scaling into negative values
         * @type Boolean
         * @default
         */
        lockScalingFlip: !1,
        /**
         * When `true`, object is not exported in OBJECT/JSON
         * @since 1.6.3
         * @type Boolean
         * @default
         */
        excludeFromExport: !1,
        /**
         * When `true`, object is cached on an additional canvas.
         * When `false`, object is not cached unless necessary ( clipPath )
         * default to true
         * @since 1.7.0
         * @type Boolean
         * @default true
         */
        objectCaching: m,
        /**
         * When `true`, object properties are checked for cache invalidation. In some particular
         * situation you may want this to be disabled ( spray brush, very big, groups)
         * or if your application does not allow you to modify properties for groups child you want
         * to disable it for groups.
         * default to false
         * since 1.7.0
         * @type Boolean
         * @default false
         */
        statefullCache: !1,
        /**
         * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
         * too much and will be redrawn with correct details at the end of scaling.
         * this setting is performance and application dependant.
         * default to true
         * since 1.7.0
         * @type Boolean
         * @default true
         */
        noScaleCache: !0,
        /**
         * When `false`, the stoke width will scale with the object.
         * When `true`, the stroke will always match the exact pixel size entered for stroke width.
         * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods
         * default to false
         * @since 2.6.0
         * @type Boolean
         * @default false
         * @type Boolean
         * @default false
         */
        strokeUniform: !1,
        /**
         * When set to `true`, object's cache will be rerendered next render call.
         * since 1.7.0
         * @type Boolean
         * @default true
         */
        dirty: !0,
        /**
         * keeps the value of the last hovered corner during mouse move.
         * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
         * It should be private, but there is no harm in using it as
         * a read-only property.
         * @type number|string|any
         * @default 0
         */
        __corner: 0,
        /**
         * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
         * @type String
         * @default
         */
        paintFirst: "fill",
        /**
         * When 'down', object is set to active on mousedown/touchstart
         * When 'up', object is set to active on mouseup/touchend
         * Experimental. Let's see if this breaks anything before supporting officially
         * @private
         * since 4.4.0
         * @type String
         * @default 'down'
         */
        activeOn: "down",
        /**
         * List of properties to consider when checking if state
         * of an object is changed (fabric.Object#hasStateChanged)
         * as well as for history (undo/redo) purposes
         * @type Array
         */
        stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),
        /**
         * List of properties to consider when checking if cache needs refresh
         * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
         * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
         * and refreshed at the next render
         * @type Array
         */
        cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),
        /**
         * List of properties to consider for animating colors.
         * @type Array
         */
        colorProperties: "fill stroke backgroundColor".split(" "),
        /**
         * a fabricObject that, without stroke define a clipping area with their shape. filled in black
         * the clipPath object gets used when the object has rendered, and the context is placed in the center
         * of the object cacheCanvas.
         * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
         * @type fabric.Object
         */
        clipPath: void 0,
        /**
         * Meaningful ONLY when the object is used as clipPath.
         * if true, the clipPath will make the object clip to the outside of the clipPath
         * since 2.4.0
         * @type boolean
         * @default false
         */
        inverted: !1,
        /**
         * Meaningful ONLY when the object is used as clipPath.
         * if true, the clipPath will have its top and left relative to canvas, and will
         * not be influenced by the object transform. This will make the clipPath relative
         * to the canvas, but clipping just a particular object.
         * WARNING this is beta, this feature may change or be renamed.
         * since 2.4.0
         * @type boolean
         * @default false
         */
        absolutePositioned: !1,
        /**
         * Constructor
         * @param {Object} [options] Options object
         */
        initialize: function(f) {
          f && this.setOptions(f);
        },
        /**
         * Create a the canvas used to keep the cached copy of the object
         * @private
         */
        _createCacheCanvas: function() {
          this._cacheProperties = {}, this._cacheCanvas = l.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
        },
        /**
         * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
         * and each side do not cross fabric.cacheSideLimit
         * those numbers are configurable so that you can get as much detail as you want
         * making bargain with performances.
         * @param {Object} dims
         * @param {Object} dims.width width of canvas
         * @param {Object} dims.height height of canvas
         * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
         * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
         * @return {Object}.width width of canvas
         * @return {Object}.height height of canvas
         * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
         * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
         */
        _limitCacheSize: function(f) {
          var k = l.perfLimitSizeTotal, E = f.width, _ = f.height, T = l.maxCacheSideLimit, D = l.minCacheSideLimit;
          if (E <= T && _ <= T && E * _ <= k)
            return E < D && (f.width = D), _ < D && (f.height = D), f;
          var V = E / _, I = l.util.limitDimsByArea(V, k), M = l.util.capValue, Q = M(D, I.x, T), G = M(D, I.y, T);
          return E > Q && (f.zoomX /= E / Q, f.width = Q, f.capped = !0), _ > G && (f.zoomY /= _ / G, f.height = G, f.capped = !0), f;
        },
        /**
         * Return the dimension and the zoom level needed to create a cache canvas
         * big enough to host the object to be cached.
         * @private
         * @return {Object}.x width of object to be cached
         * @return {Object}.y height of object to be cached
         * @return {Object}.width width of canvas
         * @return {Object}.height height of canvas
         * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
         * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
         */
        _getCacheCanvasDimensions: function() {
          var f = this.getTotalObjectScaling(), k = this._getTransformedDimensions(0, 0), E = k.x * f.scaleX / this.scaleX, _ = k.y * f.scaleY / this.scaleY;
          return {
            // for sure this ALIASING_LIMIT is slightly creating problem
            // in situation in which the cache canvas gets an upper limit
            // also objectScale contains already scaleX and scaleY
            width: E + b,
            height: _ + b,
            zoomX: f.scaleX,
            zoomY: f.scaleY,
            x: E,
            y: _
          };
        },
        /**
         * Update width and height of the canvas for cache
         * returns true or false if canvas needed resize.
         * @private
         * @return {Boolean} true if the canvas has been resized
         */
        _updateCacheCanvas: function() {
          var f = this.canvas;
          if (this.noScaleCache && f && f._currentTransform) {
            var k = f._currentTransform.target, E = f._currentTransform.action;
            if (this === k && E.slice && E.slice(0, 5) === "scale")
              return !1;
          }
          var _ = this._cacheCanvas, T = this._limitCacheSize(this._getCacheCanvasDimensions()), D = l.minCacheSideLimit, V = T.width, I = T.height, M, Q, G = T.zoomX, z = T.zoomY, re = V !== this.cacheWidth || I !== this.cacheHeight, he = this.zoomX !== G || this.zoomY !== z, de = re || he, Ce = 0, xe = 0, Ie = !1;
          if (re) {
            var Be = this._cacheCanvas.width, L = this._cacheCanvas.height, Z = V > Be || I > L, W = (V < Be * 0.9 || I < L * 0.9) && Be > D && L > D;
            Ie = Z || W, Z && !T.capped && (V > D || I > D) && (Ce = V * 0.1, xe = I * 0.1);
          }
          return this instanceof l.Text && this.path && (de = !0, Ie = !0, Ce += this.getHeightOfLine(0) * this.zoomX, xe += this.getHeightOfLine(0) * this.zoomY), de ? (Ie ? (_.width = Math.ceil(V + Ce), _.height = Math.ceil(I + xe)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, _.width, _.height)), M = T.x / 2, Q = T.y / 2, this.cacheTranslationX = Math.round(_.width / 2 - M) + M, this.cacheTranslationY = Math.round(_.height / 2 - Q) + Q, this.cacheWidth = V, this.cacheHeight = I, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(G, z), this.zoomX = G, this.zoomY = z, !0) : !1;
        },
        /**
         * Sets object's properties from options
         * @param {Object} [options] Options object
         */
        setOptions: function(f) {
          this._setOptions(f), this._initGradient(f.fill, "fill"), this._initGradient(f.stroke, "stroke"), this._initPattern(f.fill, "fill"), this._initPattern(f.stroke, "stroke");
        },
        /**
         * Transforms context when rendering an object
         * @param {CanvasRenderingContext2D} ctx Context
         */
        transform: function(f) {
          var k = this.group && !this.group._transformDone || this.group && this.canvas && f === this.canvas.contextTop, E = this.calcTransformMatrix(!k);
          f.transform(E[0], E[1], E[2], E[3], E[4], E[5]);
        },
        /**
         * Returns an object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of an instance
         */
        toObject: function(f) {
          var k = l.Object.NUM_FRACTION_DIGITS, E = {
            type: this.type,
            version: l.version,
            originX: this.originX,
            originY: this.originY,
            left: c(this.left, k),
            top: c(this.top, k),
            width: c(this.width, k),
            height: c(this.height, k),
            fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,
            stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,
            strokeWidth: c(this.strokeWidth, k),
            strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap: this.strokeLineCap,
            strokeDashOffset: this.strokeDashOffset,
            strokeLineJoin: this.strokeLineJoin,
            strokeUniform: this.strokeUniform,
            strokeMiterLimit: c(this.strokeMiterLimit, k),
            scaleX: c(this.scaleX, k),
            scaleY: c(this.scaleY, k),
            angle: c(this.angle, k),
            flipX: this.flipX,
            flipY: this.flipY,
            opacity: c(this.opacity, k),
            shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,
            visible: this.visible,
            backgroundColor: this.backgroundColor,
            fillRule: this.fillRule,
            paintFirst: this.paintFirst,
            globalCompositeOperation: this.globalCompositeOperation,
            skewX: c(this.skewX, k),
            skewY: c(this.skewY, k)
          };
          return this.clipPath && !this.clipPath.excludeFromExport && (E.clipPath = this.clipPath.toObject(f), E.clipPath.inverted = this.clipPath.inverted, E.clipPath.absolutePositioned = this.clipPath.absolutePositioned), l.util.populateWithProperties(this, E, f), this.includeDefaultValues || (E = this._removeDefaultValues(E)), E;
        },
        /**
         * Returns (dataless) object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of an instance
         */
        toDatalessObject: function(f) {
          return this.toObject(f);
        },
        /**
         * @private
         * @param {Object} object
         */
        _removeDefaultValues: function(f) {
          var k = l.util.getKlass(f.type).prototype, E = k.stateProperties;
          return E.forEach(function(_) {
            _ === "left" || _ === "top" || (f[_] === k[_] && delete f[_], Array.isArray(f[_]) && Array.isArray(k[_]) && f[_].length === 0 && k[_].length === 0 && delete f[_]);
          }), f;
        },
        /**
         * Returns a string representation of an instance
         * @return {String}
         */
        toString: function() {
          return "#<fabric." + e(this.type) + ">";
        },
        /**
         * Return the object scale factor counting also the group scaling
         * @return {Object} object with scaleX and scaleY properties
         */
        getObjectScaling: function() {
          if (!this.group)
            return {
              scaleX: this.scaleX,
              scaleY: this.scaleY
            };
          var f = l.util.qrDecompose(this.calcTransformMatrix());
          return { scaleX: Math.abs(f.scaleX), scaleY: Math.abs(f.scaleY) };
        },
        /**
         * Return the object scale factor counting also the group scaling, zoom and retina
         * @return {Object} object with scaleX and scaleY properties
         */
        getTotalObjectScaling: function() {
          var f = this.getObjectScaling(), k = f.scaleX, E = f.scaleY;
          if (this.canvas) {
            var _ = this.canvas.getZoom(), T = this.canvas.getRetinaScaling();
            k *= _ * T, E *= _ * T;
          }
          return { scaleX: k, scaleY: E };
        },
        /**
         * Return the object opacity counting also the group property
         * @return {Number}
         */
        getObjectOpacity: function() {
          var f = this.opacity;
          return this.group && (f *= this.group.getObjectOpacity()), f;
        },
        /**
         * @private
         * @param {String} key
         * @param {*} value
         * @return {fabric.Object} thisArg
         */
        _set: function(f, k) {
          var E = f === "scaleX" || f === "scaleY", _ = this[f] !== k, T = !1;
          return E && (k = this._constrainScale(k)), f === "scaleX" && k < 0 ? (this.flipX = !this.flipX, k *= -1) : f === "scaleY" && k < 0 ? (this.flipY = !this.flipY, k *= -1) : f === "shadow" && k && !(k instanceof l.Shadow) ? k = new l.Shadow(k) : f === "dirty" && this.group && this.group.set("dirty", k), this[f] = k, _ && (T = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(f) > -1 ? (this.dirty = !0, T && this.group.set("dirty", !0)) : T && this.stateProperties.indexOf(f) > -1 && this.group.set("dirty", !0)), this;
        },
        /**
         * This callback function is called by the parent group of an object every
         * time a non-delegated property changes on the group. It is passed the key
         * and value as parameters. Not adding in this function's signature to avoid
         * Travis build error about unused variables.
         */
        setOnGroup: function() {
        },
        /**
         * Retrieves viewportTransform from Object's canvas if possible
         * @method getViewportTransform
         * @memberOf fabric.Object.prototype
         * @return {Array}
         */
        getViewportTransform: function() {
          return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : l.iMatrix.concat();
        },
        /*
         * @private
         * return if the object would be visible in rendering
         * @memberOf fabric.Object.prototype
         * @return {Boolean}
         */
        isNotVisible: function() {
          return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
        },
        /**
         * Renders an object on a specified context
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        render: function(f) {
          this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (f.save(), this._setupCompositeOperation(f), this.drawSelectionBackground(f), this.transform(f), this._setOpacity(f), this._setShadow(f, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(f)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(f), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), f.restore());
        },
        renderCache: function(f) {
          f = f || {}, (!this._cacheCanvas || !this._cacheContext) && this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, f.forClipping), this.dirty = !1);
        },
        /**
         * Remove cacheCanvas and its dimensions from the objects
         */
        _removeCacheCanvas: function() {
          this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0;
        },
        /**
         * return true if the object will draw a stroke
         * Does not consider text styles. This is just a shortcut used at rendering time
         * We want it to be an approximation and be fast.
         * wrote to avoid extra caching, it has to return true when stroke happens,
         * can guess when it will not happen at 100% chance, does not matter if it misses
         * some use case where the stroke is invisible.
         * @since 3.0.0
         * @returns Boolean
         */
        hasStroke: function() {
          return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
        },
        /**
         * return true if the object will draw a fill
         * Does not consider text styles. This is just a shortcut used at rendering time
         * We want it to be an approximation and be fast.
         * wrote to avoid extra caching, it has to return true when fill happens,
         * can guess when it will not happen at 100% chance, does not matter if it misses
         * some use case where the fill is invisible.
         * @since 3.0.0
         * @returns Boolean
         */
        hasFill: function() {
          return this.fill && this.fill !== "transparent";
        },
        /**
         * When set to `true`, force the object to have its own cache, even if it is inside a group
         * it may be needed when your object behave in a particular way on the cache and always needs
         * its own isolated canvas to render correctly.
         * Created to be overridden
         * since 1.7.12
         * @returns Boolean
         */
        needsItsOwnCache: function() {
          return !!(this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow == "object" || this.clipPath);
        },
        /**
         * Decide if the object should cache or not. Create its own cache level
         * objectCaching is a global flag, wins over everything
         * needsItsOwnCache should be used when the object drawing method requires
         * a cache step. None of the fabric classes requires it.
         * Generally you do not cache objects in groups because the group outside is cached.
         * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
         * @return {Boolean}
         */
        shouldCache: function() {
          return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching;
        },
        /**
         * Check if this object or a child object will cast a shadow
         * used by Group.shouldCache to know if child has a shadow recursively
         * @return {Boolean}
         */
        willDrawShadow: function() {
          return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
        },
        /**
         * Execute the drawing operation for an object clipPath
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {fabric.Object} clipPath
         */
        drawClipPathOnCache: function(f, k) {
          if (f.save(), k.inverted ? f.globalCompositeOperation = "destination-out" : f.globalCompositeOperation = "destination-in", k.absolutePositioned) {
            var E = l.util.invertTransform(this.calcTransformMatrix());
            f.transform(E[0], E[1], E[2], E[3], E[4], E[5]);
          }
          k.transform(f), f.scale(1 / k.zoomX, 1 / k.zoomY), f.drawImage(k._cacheCanvas, -k.cacheTranslationX, -k.cacheTranslationY), f.restore();
        },
        /**
         * Execute the drawing operation for an object on a specified context
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        drawObject: function(f, k) {
          var E = this.fill, _ = this.stroke;
          k ? (this.fill = "black", this.stroke = "", this._setClippingProperties(f)) : this._renderBackground(f), this._render(f), this._drawClipPath(f, this.clipPath), this.fill = E, this.stroke = _;
        },
        /**
         * Prepare clipPath state and cache and draw it on instance's cache
         * @param {CanvasRenderingContext2D} ctx
         * @param {fabric.Object} clipPath
         */
        _drawClipPath: function(f, k) {
          k && (k.canvas = this.canvas, k.shouldCache(), k._transformDone = !0, k.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(f, k));
        },
        /**
         * Paint the cached copy of the object on the target context.
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        drawCacheOnCanvas: function(f) {
          f.scale(1 / this.zoomX, 1 / this.zoomY), f.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
        },
        /**
         * Check if cache is dirty
         * @param {Boolean} skipCanvas skip canvas checks because this object is painted
         * on parent canvas.
         */
        isCacheDirty: function(f) {
          if (this.isNotVisible())
            return !1;
          if (this._cacheCanvas && this._cacheContext && !f && this._updateCacheCanvas())
            return !0;
          if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
            if (this._cacheCanvas && this._cacheContext && !f) {
              var k = this.cacheWidth / this.zoomX, E = this.cacheHeight / this.zoomY;
              this._cacheContext.clearRect(-k / 2, -E / 2, k, E);
            }
            return !0;
          }
          return !1;
        },
        /**
         * Draws a background for the object big as its untransformed dimensions
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderBackground: function(f) {
          if (this.backgroundColor) {
            var k = this._getNonTransformedDimensions();
            f.fillStyle = this.backgroundColor, f.fillRect(
              -k.x / 2,
              -k.y / 2,
              k.x,
              k.y
            ), this._removeShadow(f);
          }
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _setOpacity: function(f) {
          this.group && !this.group._transformDone ? f.globalAlpha = this.getObjectOpacity() : f.globalAlpha *= this.opacity;
        },
        _setStrokeStyles: function(f, k) {
          var E = k.stroke;
          E && (f.lineWidth = k.strokeWidth, f.lineCap = k.strokeLineCap, f.lineDashOffset = k.strokeDashOffset, f.lineJoin = k.strokeLineJoin, f.miterLimit = k.strokeMiterLimit, E.toLive ? E.gradientUnits === "percentage" || E.gradientTransform || E.patternTransform ? this._applyPatternForTransformedGradient(f, E) : (f.strokeStyle = E.toLive(f, this), this._applyPatternGradientTransform(f, E)) : f.strokeStyle = k.stroke);
        },
        _setFillStyles: function(f, k) {
          var E = k.fill;
          E && (E.toLive ? (f.fillStyle = E.toLive(f, this), this._applyPatternGradientTransform(f, k.fill)) : f.fillStyle = E);
        },
        _setClippingProperties: function(f) {
          f.globalAlpha = 1, f.strokeStyle = "transparent", f.fillStyle = "#000000";
        },
        /**
         * @private
         * Sets line dash
         * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
         * @param {Array} dashArray array representing dashes
         */
        _setLineDash: function(f, k) {
          !k || k.length === 0 || (1 & k.length && k.push.apply(k, k), f.setLineDash(k));
        },
        /**
         * Renders controls and borders for the object
         * the context here is not transformed
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Object} [styleOverride] properties to override the object style
         */
        _renderControls: function(f, k) {
          var E = this.getViewportTransform(), _ = this.calcTransformMatrix(), T, D, V;
          k = k || {}, D = typeof k.hasBorders < "u" ? k.hasBorders : this.hasBorders, V = typeof k.hasControls < "u" ? k.hasControls : this.hasControls, _ = l.util.multiplyTransformMatrices(E, _), T = l.util.qrDecompose(_), f.save(), f.translate(T.translateX, T.translateY), f.lineWidth = 1 * this.borderScaleFactor, this.group || (f.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (T.angle -= 180), f.rotate(h(this.group ? T.angle : this.angle)), k.forActiveSelection || this.group ? D && this.drawBordersInGroup(f, T, k) : D && this.drawBorders(f, k), V && this.drawControls(f, k), f.restore();
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _setShadow: function(f) {
          if (this.shadow) {
            var k = this.shadow, E = this.canvas, _, T = E && E.viewportTransform[0] || 1, D = E && E.viewportTransform[3] || 1;
            k.nonScaling ? _ = { scaleX: 1, scaleY: 1 } : _ = this.getObjectScaling(), E && E._isRetinaScaling() && (T *= l.devicePixelRatio, D *= l.devicePixelRatio), f.shadowColor = k.color, f.shadowBlur = k.blur * l.browserShadowBlurConstant * (T + D) * (_.scaleX + _.scaleY) / 4, f.shadowOffsetX = k.offsetX * T * _.scaleX, f.shadowOffsetY = k.offsetY * D * _.scaleY;
          }
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _removeShadow: function(f) {
          this.shadow && (f.shadowColor = "", f.shadowBlur = f.shadowOffsetX = f.shadowOffsetY = 0);
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Object} filler fabric.Pattern or fabric.Gradient
         * @return {Object} offset.offsetX offset for text rendering
         * @return {Object} offset.offsetY offset for text rendering
         */
        _applyPatternGradientTransform: function(f, k) {
          if (!k || !k.toLive)
            return { offsetX: 0, offsetY: 0 };
          var E = k.gradientTransform || k.patternTransform, _ = -this.width / 2 + k.offsetX || 0, T = -this.height / 2 + k.offsetY || 0;
          return k.gradientUnits === "percentage" ? f.transform(this.width, 0, 0, this.height, _, T) : f.transform(1, 0, 0, 1, _, T), E && f.transform(E[0], E[1], E[2], E[3], E[4], E[5]), { offsetX: _, offsetY: T };
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderPaintInOrder: function(f) {
          this.paintFirst === "stroke" ? (this._renderStroke(f), this._renderFill(f)) : (this._renderFill(f), this._renderStroke(f));
        },
        /**
         * @private
         * function that actually render something on the context.
         * empty here to allow Obects to work on tests to benchmark fabric functionalites
         * not related to rendering
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function() {
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderFill: function(f) {
          this.fill && (f.save(), this._setFillStyles(f, this), this.fillRule === "evenodd" ? f.fill("evenodd") : f.fill(), f.restore());
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderStroke: function(f) {
          if (!(!this.stroke || this.strokeWidth === 0)) {
            if (this.shadow && !this.shadow.affectStroke && this._removeShadow(f), f.save(), this.strokeUniform && this.group) {
              var k = this.getObjectScaling();
              f.scale(1 / k.scaleX, 1 / k.scaleY);
            } else
              this.strokeUniform && f.scale(1 / this.scaleX, 1 / this.scaleY);
            this._setLineDash(f, this.strokeDashArray), this._setStrokeStyles(f, this), f.stroke(), f.restore();
          }
        },
        /**
         * This function try to patch the missing gradientTransform on canvas gradients.
         * transforming a context to transform the gradient, is going to transform the stroke too.
         * we want to transform the gradient but not the stroke operation, so we create
         * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
         * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
         * is limited.
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {fabric.Gradient} filler a fabric gradient instance
         */
        _applyPatternForTransformedGradient: function(f, k) {
          var E = this._limitCacheSize(this._getCacheCanvasDimensions()), _ = l.util.createCanvasElement(), T, D = this.canvas.getRetinaScaling(), V = E.x / this.scaleX / D, I = E.y / this.scaleY / D;
          _.width = V, _.height = I, T = _.getContext("2d"), T.beginPath(), T.moveTo(0, 0), T.lineTo(V, 0), T.lineTo(V, I), T.lineTo(0, I), T.closePath(), T.translate(V / 2, I / 2), T.scale(
            E.zoomX / this.scaleX / D,
            E.zoomY / this.scaleY / D
          ), this._applyPatternGradientTransform(T, k), T.fillStyle = k.toLive(f), T.fill(), f.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), f.scale(
            D * this.scaleX / E.zoomX,
            D * this.scaleY / E.zoomY
          ), f.strokeStyle = T.createPattern(_, "no-repeat");
        },
        /**
         * This function is an helper for svg import. it returns the center of the object in the svg
         * untransformed coordinates
         * @private
         * @return {Object} center point from element coordinates
         */
        _findCenterFromElement: function() {
          return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
        },
        /**
         * This function is an helper for svg import. it decompose the transformMatrix
         * and assign properties to object.
         * untransformed coordinates
         * @private
         * @chainable
         */
        _assignTransformMatrixProps: function() {
          if (this.transformMatrix) {
            var f = l.util.qrDecompose(this.transformMatrix);
            this.flipX = !1, this.flipY = !1, this.set("scaleX", f.scaleX), this.set("scaleY", f.scaleY), this.angle = f.angle, this.skewX = f.skewX, this.skewY = 0;
          }
        },
        /**
         * This function is an helper for svg import. it removes the transform matrix
         * and set to object properties that fabricjs can handle
         * @private
         * @param {Object} preserveAspectRatioOptions
         * @return {thisArg}
         */
        _removeTransformMatrix: function(f) {
          var k = this._findCenterFromElement();
          this.transformMatrix && (this._assignTransformMatrixProps(), k = l.util.transformPoint(k, this.transformMatrix)), this.transformMatrix = null, f && (this.scaleX *= f.scaleX, this.scaleY *= f.scaleY, this.cropX = f.cropX, this.cropY = f.cropY, k.x += f.offsetLeft, k.y += f.offsetTop, this.width = f.width, this.height = f.height), this.setPositionByOrigin(k, "center", "center");
        },
        /**
         * Clones an instance, using a callback method will work for every object.
         * @param {Function} callback Callback is invoked with a clone as a first argument
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         */
        clone: function(f, k) {
          var E = this.toObject(k);
          this.constructor.fromObject ? this.constructor.fromObject(E, f) : l.Object._fromObject("Object", E, f);
        },
        /**
         * Creates an instance of fabric.Image out of an object
         * makes use of toCanvasElement.
         * Once this method was based on toDataUrl and loadImage, so it also had a quality
         * and format option. toCanvasElement is faster and produce no loss of quality.
         * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
         * toCanvasElement and then toBlob from the obtained canvas is also a good option.
         * This method is sync now, but still support the callback because we did not want to break.
         * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
         * @param {Function} callback callback, invoked with an instance as a first argument
         * @param {Object} [options] for clone as image, passed to toDataURL
         * @param {Number} [options.multiplier=1] Multiplier to scale by
         * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
         * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
         * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
         * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
         * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
         * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
         * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
         * @return {fabric.Object} thisArg
         */
        cloneAsImage: function(f, k) {
          var E = this.toCanvasElement(k);
          return f && f(new l.Image(E)), this;
        },
        /**
         * Converts an object into a HTMLCanvas element
         * @param {Object} options Options object
         * @param {Number} [options.multiplier=1] Multiplier to scale by
         * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
         * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
         * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
         * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
         * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
         * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
         * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
         * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
         */
        toCanvasElement: function(f) {
          f || (f = {});
          var k = l.util, E = k.saveObjectTransform(this), _ = this.group, T = this.shadow, D = Math.abs, V = (f.multiplier || 1) * (f.enableRetinaScaling ? l.devicePixelRatio : 1);
          delete this.group, f.withoutTransform && k.resetObjectTransform(this), f.withoutShadow && (this.shadow = null);
          var I = l.util.createCanvasElement(), M = this.getBoundingRect(!0, !0), Q = this.shadow, G, z = { x: 0, y: 0 }, re, he, de;
          Q && (re = Q.blur, Q.nonScaling ? G = { scaleX: 1, scaleY: 1 } : G = this.getObjectScaling(), z.x = 2 * Math.round(D(Q.offsetX) + re) * D(G.scaleX), z.y = 2 * Math.round(D(Q.offsetY) + re) * D(G.scaleY)), he = M.width + z.x, de = M.height + z.y, I.width = Math.ceil(he), I.height = Math.ceil(de);
          var Ce = new l.StaticCanvas(I, {
            enableRetinaScaling: !1,
            renderOnAddRemove: !1,
            skipOffscreen: !1
          });
          f.format === "jpeg" && (Ce.backgroundColor = "#fff"), this.setPositionByOrigin(new l.Point(Ce.width / 2, Ce.height / 2), "center", "center");
          var xe = this.canvas;
          Ce.add(this);
          var Ie = Ce.toCanvasElement(V || 1, f);
          return this.shadow = T, this.set("canvas", xe), _ && (this.group = _), this.set(E).setCoords(), Ce._objects = [], Ce.dispose(), Ce = null, Ie;
        },
        /**
         * Converts an object into a data-url-like string
         * @param {Object} options Options object
         * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
         * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
         * @param {Number} [options.multiplier=1] Multiplier to scale by
         * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
         * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
         * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
         * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
         * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
         * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
         * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
         * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
         */
        toDataURL: function(f) {
          return f || (f = {}), l.util.toDataURL(this.toCanvasElement(f), f.format || "png", f.quality || 1);
        },
        /**
         * Returns true if specified type is identical to the type of an instance
         * @param {String} type Type to check against
         * @return {Boolean}
         */
        isType: function(f) {
          return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === f;
        },
        /**
         * Returns complexity of an instance
         * @return {Number} complexity of this instance (is 1 unless subclassed)
         */
        complexity: function() {
          return 1;
        },
        /**
         * Returns a JSON representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} JSON
         */
        toJSON: function(f) {
          return this.toObject(f);
        },
        /**
         * Sets "angle" of an instance with centered rotation
         * @param {Number} angle Angle value (in degrees)
         * @return {fabric.Object} thisArg
         * @chainable
         */
        rotate: function(f) {
          var k = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation;
          return k && this._setOriginToCenter(), this.set("angle", f), k && this._resetOrigin(), this;
        },
        /**
         * Centers object horizontally on canvas to which it was added last.
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        centerH: function() {
          return this.canvas && this.canvas.centerObjectH(this), this;
        },
        /**
         * Centers object horizontally on current viewport of canvas to which it was added last.
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        viewportCenterH: function() {
          return this.canvas && this.canvas.viewportCenterObjectH(this), this;
        },
        /**
         * Centers object vertically on canvas to which it was added last.
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        centerV: function() {
          return this.canvas && this.canvas.centerObjectV(this), this;
        },
        /**
         * Centers object vertically on current viewport of canvas to which it was added last.
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        viewportCenterV: function() {
          return this.canvas && this.canvas.viewportCenterObjectV(this), this;
        },
        /**
         * Centers object vertically and horizontally on canvas to which is was added last
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        center: function() {
          return this.canvas && this.canvas.centerObject(this), this;
        },
        /**
         * Centers object on current viewport of canvas to which it was added last.
         * You might need to call `setCoords` on an object after centering, to update controls area.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        viewportCenter: function() {
          return this.canvas && this.canvas.viewportCenterObject(this), this;
        },
        /**
         * Returns coordinates of a pointer relative to an object
         * @param {Event} e Event to operate upon
         * @param {Object} [pointer] Pointer to operate upon (instead of event)
         * @return {Object} Coordinates of a pointer (x, y)
         */
        getLocalPointer: function(f, k) {
          k = k || this.canvas.getPointer(f);
          var E = new l.Point(k.x, k.y), _ = this._getLeftTopCoords();
          return this.angle && (E = l.util.rotatePoint(
            E,
            _,
            h(-this.angle)
          )), {
            x: E.x - _.x,
            y: E.y - _.y
          };
        },
        /**
         * Sets canvas globalCompositeOperation for specific object
         * custom composition operation for the particular object can be specified using globalCompositeOperation property
         * @param {CanvasRenderingContext2D} ctx Rendering canvas context
         */
        _setupCompositeOperation: function(f) {
          this.globalCompositeOperation && (f.globalCompositeOperation = this.globalCompositeOperation);
        },
        /**
         * cancel instance's running animations
         * override if necessary to dispose artifacts such as `clipPath`
         */
        dispose: function() {
          l.runningAnimations && l.runningAnimations.cancelByTarget(this);
        }
      }
    ), l.util.createAccessors && l.util.createAccessors(l.Object), p(l.Object.prototype, l.Observable), l.Object.NUM_FRACTION_DIGITS = 2, l.Object.ENLIVEN_PROPS = ["clipPath"], l.Object._fromObject = function(f, k, E, _) {
      var T = l[f];
      k = v(k, !0), l.util.enlivenPatterns([k.fill, k.stroke], function(D) {
        typeof D[0] < "u" && (k.fill = D[0]), typeof D[1] < "u" && (k.stroke = D[1]), l.util.enlivenObjectEnlivables(k, k, function() {
          var V = _ ? new T(k[_], k) : new T(k);
          E && E(V);
        });
      });
    }, l.Object.__uid = 0);
  }(i), function() {
    var d = n.util.degreesToRadians, l = {
      left: -0.5,
      center: 0,
      right: 0.5
    }, p = {
      top: -0.5,
      center: 0,
      bottom: 0.5
    };
    n.util.object.extend(
      n.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Translates the coordinates from a set of origin to another (based on the object's dimensions)
         * @param {fabric.Point} point The point which corresponds to the originX and originY params
         * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
         * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
         * @return {fabric.Point}
         */
        translateToGivenOrigin: function(v, c, e, h, m) {
          var b = v.x, f = v.y, k, E, _;
          return typeof c == "string" ? c = l[c] : c -= 0.5, typeof h == "string" ? h = l[h] : h -= 0.5, k = h - c, typeof e == "string" ? e = p[e] : e -= 0.5, typeof m == "string" ? m = p[m] : m -= 0.5, E = m - e, (k || E) && (_ = this._getTransformedDimensions(), b = v.x + k * _.x, f = v.y + E * _.y), new n.Point(b, f);
        },
        /**
         * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
         * @param {fabric.Point} point The point which corresponds to the originX and originY params
         * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
         * @return {fabric.Point}
         */
        translateToCenterPoint: function(v, c, e) {
          var h = this.translateToGivenOrigin(v, c, e, "center", "center");
          return this.angle ? n.util.rotatePoint(h, v, d(this.angle)) : h;
        },
        /**
         * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
         * @param {fabric.Point} center The point which corresponds to center of the object
         * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
         * @return {fabric.Point}
         */
        translateToOriginPoint: function(v, c, e) {
          var h = this.translateToGivenOrigin(v, "center", "center", c, e);
          return this.angle ? n.util.rotatePoint(h, v, d(this.angle)) : h;
        },
        /**
         * Returns the real center coordinates of the object
         * @return {fabric.Point}
         */
        getCenterPoint: function() {
          var v = new n.Point(this.left, this.top);
          return this.translateToCenterPoint(v, this.originX, this.originY);
        },
        /**
         * Returns the coordinates of the object based on center coordinates
         * @param {fabric.Point} point The point which corresponds to the originX and originY params
         * @return {fabric.Point}
         */
        // getOriginPoint: function(center) {
        //   return this.translateToOriginPoint(center, this.originX, this.originY);
        // },
        /**
         * Returns the coordinates of the object as if it has a different origin
         * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
         * @return {fabric.Point}
         */
        getPointByOrigin: function(v, c) {
          var e = this.getCenterPoint();
          return this.translateToOriginPoint(e, v, c);
        },
        /**
         * Returns the point in local coordinates
         * @param {fabric.Point} point The point relative to the global coordinate system
         * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
         * @return {fabric.Point}
         */
        toLocalPoint: function(v, c, e) {
          var h = this.getCenterPoint(), m, b;
          return typeof c < "u" && typeof e < "u" ? m = this.translateToGivenOrigin(h, "center", "center", c, e) : m = new n.Point(this.left, this.top), b = new n.Point(v.x, v.y), this.angle && (b = n.util.rotatePoint(b, h, -d(this.angle))), b.subtractEquals(m);
        },
        /**
         * Returns the point in global coordinates
         * @param {fabric.Point} The point relative to the local coordinate system
         * @return {fabric.Point}
         */
        // toGlobalPoint: function(point) {
        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
        // },
        /**
         * Sets the position of the object taking into consideration the object's origin
         * @param {fabric.Point} pos The new position of the object
         * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
         * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
         * @return {void}
         */
        setPositionByOrigin: function(v, c, e) {
          var h = this.translateToCenterPoint(v, c, e), m = this.translateToOriginPoint(h, this.originX, this.originY);
          this.set("left", m.x), this.set("top", m.y);
        },
        /**
         * @param {String} to One of 'left', 'center', 'right'
         */
        adjustPosition: function(v) {
          var c = d(this.angle), e = this.getScaledWidth(), h = n.util.cos(c) * e, m = n.util.sin(c) * e, b, f;
          typeof this.originX == "string" ? b = l[this.originX] : b = this.originX - 0.5, typeof v == "string" ? f = l[v] : f = v - 0.5, this.left += h * (f - b), this.top += m * (f - b), this.setCoords(), this.originX = v;
        },
        /**
         * Sets the origin/position of the object to it's center point
         * @private
         * @return {void}
         */
        _setOriginToCenter: function() {
          this._originalOriginX = this.originX, this._originalOriginY = this.originY;
          var v = this.getCenterPoint();
          this.originX = "center", this.originY = "center", this.left = v.x, this.top = v.y;
        },
        /**
         * Resets the origin/position of the object to it's original origin
         * @private
         * @return {void}
         */
        _resetOrigin: function() {
          var v = this.translateToOriginPoint(
            this.getCenterPoint(),
            this._originalOriginX,
            this._originalOriginY
          );
          this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = v.x, this.top = v.y, this._originalOriginX = null, this._originalOriginY = null;
        },
        /**
         * @private
         */
        _getLeftTopCoords: function() {
          return this.translateToOriginPoint(this.getCenterPoint(), "left", "top");
        }
      }
    );
  }(), function() {
    function d(e) {
      return [
        new n.Point(e.tl.x, e.tl.y),
        new n.Point(e.tr.x, e.tr.y),
        new n.Point(e.br.x, e.br.y),
        new n.Point(e.bl.x, e.bl.y)
      ];
    }
    var l = n.util, p = l.degreesToRadians, v = l.multiplyTransformMatrices, c = l.transformPoint;
    l.object.extend(
      n.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Describe object's corner position in canvas element coordinates.
         * properties are depending on control keys and padding the main controls.
         * each property is an object with x, y and corner.
         * The `corner` property contains in a similar manner the 4 points of the
         * interactive area of the corner.
         * The coordinates depends from the controls positionHandler and are used
         * to draw and locate controls
         * @memberOf fabric.Object.prototype
         */
        oCoords: null,
        /**
         * Describe object's corner position in canvas object absolute coordinates
         * properties are tl,tr,bl,br and describe the four main corner.
         * each property is an object with x, y, instance of Fabric.Point.
         * The coordinates depends from this properties: width, height, scaleX, scaleY
         * skewX, skewY, angle, strokeWidth, top, left.
         * Those coordinates are useful to understand where an object is. They get updated
         * with oCoords but they do not need to be updated when zoom or panning change.
         * The coordinates get updated with @method setCoords.
         * You can calculate them without updating with @method calcACoords();
         * @memberOf fabric.Object.prototype
         */
        aCoords: null,
        /**
         * Describe object's corner position in canvas element coordinates.
         * includes padding. Used of object detection.
         * set and refreshed with setCoords.
         * @memberOf fabric.Object.prototype
         */
        lineCoords: null,
        /**
         * storage for object transform matrix
         */
        ownMatrixCache: null,
        /**
         * storage for object full transform matrix
         */
        matrixCache: null,
        /**
         * custom controls interface
         * controls are added by default_controls.js
         */
        controls: {},
        /**
         * return correct set of coordinates for intersection
         * this will return either aCoords or lineCoords.
         * @param {Boolean} absolute will return aCoords if true or lineCoords
         * @return {Object} {tl, tr, br, bl} points
         */
        _getCoords: function(e, h) {
          return h ? e ? this.calcACoords() : this.calcLineCoords() : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0), e ? this.aCoords : this.lineCoords);
        },
        /**
         * return correct set of coordinates for intersection
         * this will return either aCoords or lineCoords.
         * The coords are returned in an array.
         * @return {Array} [tl, tr, br, bl] of points
         */
        getCoords: function(e, h) {
          return d(this._getCoords(e, h));
        },
        /**
         * Checks if object intersects with an area formed by 2 points
         * @param {Object} pointTL top-left point of area
         * @param {Object} pointBR bottom-right point of area
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if object intersects with an area formed by 2 points
         */
        intersectsWithRect: function(e, h, m, b) {
          var f = this.getCoords(m, b), k = n.Intersection.intersectPolygonRectangle(
            f,
            e,
            h
          );
          return k.status === "Intersection";
        },
        /**
         * Checks if object intersects with another object
         * @param {Object} other Object to test
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if object intersects with another object
         */
        intersectsWithObject: function(e, h, m) {
          var b = n.Intersection.intersectPolygonPolygon(
            this.getCoords(h, m),
            e.getCoords(h, m)
          );
          return b.status === "Intersection" || e.isContainedWithinObject(this, h, m) || this.isContainedWithinObject(e, h, m);
        },
        /**
         * Checks if object is fully contained within area of another object
         * @param {Object} other Object to test
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if object is fully contained within area of another object
         */
        isContainedWithinObject: function(e, h, m) {
          for (var b = this.getCoords(h, m), f = h ? e.aCoords : e.lineCoords, k = 0, E = e._getImageLines(f); k < 4; k++)
            if (!e.containsPoint(b[k], E))
              return !1;
          return !0;
        },
        /**
         * Checks if object is fully contained within area formed by 2 points
         * @param {Object} pointTL top-left point of area
         * @param {Object} pointBR bottom-right point of area
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if object is fully contained within area formed by 2 points
         */
        isContainedWithinRect: function(e, h, m, b) {
          var f = this.getBoundingRect(m, b);
          return f.left >= e.x && f.left + f.width <= h.x && f.top >= e.y && f.top + f.height <= h.y;
        },
        /**
         * Checks if point is inside the object
         * @param {fabric.Point} point Point to check against
         * @param {Object} [lines] object returned from @method _getImageLines
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if point is inside the object
         */
        containsPoint: function(e, k, m, b) {
          var f = this._getCoords(m, b), k = k || this._getImageLines(f), E = this._findCrossPoints(e, k);
          return E !== 0 && E % 2 === 1;
        },
        /**
         * Checks if object is contained within the canvas with current viewportTransform
         * the check is done stopping at first point that appears on screen
         * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
         * @return {Boolean} true if object is fully or partially contained within canvas
         */
        isOnScreen: function(e) {
          if (!this.canvas)
            return !1;
          var h = this.canvas.vptCoords.tl, m = this.canvas.vptCoords.br, b = this.getCoords(!0, e);
          return b.some(function(f) {
            return f.x <= m.x && f.x >= h.x && f.y <= m.y && f.y >= h.y;
          }) || this.intersectsWithRect(h, m, !0, e) ? !0 : this._containsCenterOfCanvas(h, m, e);
        },
        /**
         * Checks if the object contains the midpoint between canvas extremities
         * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
         * @private
         * @param {Fabric.Point} pointTL Top Left point
         * @param {Fabric.Point} pointBR Top Right point
         * @param {Boolean} calculate use coordinates of current position instead of .oCoords
         * @return {Boolean} true if the object contains the point
         */
        _containsCenterOfCanvas: function(e, h, m) {
          var b = { x: (e.x + h.x) / 2, y: (e.y + h.y) / 2 };
          return !!this.containsPoint(b, null, !0, m);
        },
        /**
         * Checks if object is partially contained within the canvas with current viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
         * @return {Boolean} true if object is partially contained within canvas
         */
        isPartiallyOnScreen: function(e) {
          if (!this.canvas)
            return !1;
          var h = this.canvas.vptCoords.tl, m = this.canvas.vptCoords.br;
          if (this.intersectsWithRect(h, m, !0, e))
            return !0;
          var b = this.getCoords(!0, e).every(function(f) {
            return (f.x >= m.x || f.x <= h.x) && (f.y >= m.y || f.y <= h.y);
          });
          return b && this._containsCenterOfCanvas(h, m, e);
        },
        /**
         * Method that returns an object with the object edges in it, given the coordinates of the corners
         * @private
         * @param {Object} oCoords Coordinates of the object corners
         */
        _getImageLines: function(e) {
          var h = {
            topline: {
              o: e.tl,
              d: e.tr
            },
            rightline: {
              o: e.tr,
              d: e.br
            },
            bottomline: {
              o: e.br,
              d: e.bl
            },
            leftline: {
              o: e.bl,
              d: e.tl
            }
          };
          return h;
        },
        /**
         * Helper method to determine how many cross points are between the 4 object edges
         * and the horizontal line determined by a point on canvas
         * @private
         * @param {fabric.Point} point Point to check
         * @param {Object} lines Coordinates of the object being evaluated
         */
        // remove yi, not used but left code here just in case.
        _findCrossPoints: function(e, h) {
          var m, b, f, k, E, _ = 0, T;
          for (var D in h)
            if (T = h[D], !(T.o.y < e.y && T.d.y < e.y) && !(T.o.y >= e.y && T.d.y >= e.y) && (T.o.x === T.d.x && T.o.x >= e.x ? E = T.o.x : (m = 0, b = (T.d.y - T.o.y) / (T.d.x - T.o.x), f = e.y - m * e.x, k = T.o.y - b * T.o.x, E = -(f - k) / (m - b)), E >= e.x && (_ += 1), _ === 2))
              break;
          return _;
        },
        /**
         * Returns coordinates of object's bounding rectangle (left, top, width, height)
         * the box is intended as aligned to axis of canvas.
         * @param {Boolean} [absolute] use coordinates without viewportTransform
         * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
         * @return {Object} Object with left, top, width, height properties
         */
        getBoundingRect: function(e, h) {
          var m = this.getCoords(e, h);
          return l.makeBoundingBoxFromPoints(m);
        },
        /**
         * Returns width of an object's bounding box counting transformations
         * before 2.0 it was named getWidth();
         * @return {Number} width value
         */
        getScaledWidth: function() {
          return this._getTransformedDimensions().x;
        },
        /**
         * Returns height of an object bounding box counting transformations
         * before 2.0 it was named getHeight();
         * @return {Number} height value
         */
        getScaledHeight: function() {
          return this._getTransformedDimensions().y;
        },
        /**
         * Makes sure the scale is valid and modifies it if necessary
         * @private
         * @param {Number} value
         * @return {Number}
         */
        _constrainScale: function(e) {
          return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
        },
        /**
         * Scales an object (equally by x and y)
         * @param {Number} value Scale factor
         * @return {fabric.Object} thisArg
         * @chainable
         */
        scale: function(e) {
          return this._set("scaleX", e), this._set("scaleY", e), this.setCoords();
        },
        /**
         * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
         * @param {Number} value New width value
         * @param {Boolean} absolute ignore viewport
         * @return {fabric.Object} thisArg
         * @chainable
         */
        scaleToWidth: function(e, h) {
          var m = this.getBoundingRect(h).width / this.getScaledWidth();
          return this.scale(e / this.width / m);
        },
        /**
         * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
         * @param {Number} value New height value
         * @param {Boolean} absolute ignore viewport
         * @return {fabric.Object} thisArg
         * @chainable
         */
        scaleToHeight: function(e, h) {
          var m = this.getBoundingRect(h).height / this.getScaledHeight();
          return this.scale(e / this.height / m);
        },
        calcLineCoords: function() {
          var e = this.getViewportTransform(), h = this.padding, m = p(this.angle), b = l.cos(m), f = l.sin(m), k = b * h, E = f * h, _ = k + E, T = k - E, D = this.calcACoords(), V = {
            tl: c(D.tl, e),
            tr: c(D.tr, e),
            bl: c(D.bl, e),
            br: c(D.br, e)
          };
          return h && (V.tl.x -= T, V.tl.y -= _, V.tr.x += _, V.tr.y -= T, V.bl.x -= _, V.bl.y += T, V.br.x += T, V.br.y += _), V;
        },
        calcOCoords: function() {
          var e = this._calcRotateMatrix(), h = this._calcTranslateMatrix(), m = this.getViewportTransform(), b = v(m, h), f = v(b, e), f = v(f, [1 / m[0], 0, 0, 1 / m[3], 0, 0]), k = this._calculateCurrentDimensions(), E = {};
          return this.forEachControl(function(_, T, D) {
            E[T] = _.positionHandler(k, f, D);
          }), E;
        },
        calcACoords: function() {
          var e = this._calcRotateMatrix(), h = this._calcTranslateMatrix(), m = v(h, e), b = this._getTransformedDimensions(), f = b.x / 2, k = b.y / 2;
          return {
            // corners
            tl: c({ x: -f, y: -k }, m),
            tr: c({ x: f, y: -k }, m),
            bl: c({ x: -f, y: k }, m),
            br: c({ x: f, y: k }, m)
          };
        },
        /**
         * Sets corner and controls position coordinates based on current angle, width and height, left and top.
         * oCoords are used to find the corners
         * aCoords are used to quickly find an object on the canvas
         * lineCoords are used to quickly find object during pointer events.
         * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}
         *
         * @param {Boolean} [skipCorners] skip calculation of oCoords.
         * @return {fabric.Object} thisArg
         * @chainable
         */
        setCoords: function(e) {
          return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), e ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this);
        },
        /**
         * calculate rotation matrix of an object
         * @return {Array} rotation matrix for the object
         */
        _calcRotateMatrix: function() {
          return l.calcRotateMatrix(this);
        },
        /**
         * calculate the translation matrix for an object transform
         * @return {Array} rotation matrix for the object
         */
        _calcTranslateMatrix: function() {
          var e = this.getCenterPoint();
          return [1, 0, 0, 1, e.x, e.y];
        },
        transformMatrixKey: function(e) {
          var h = "_", m = "";
          return !e && this.group && (m = this.group.transformMatrixKey(e) + h), m + this.top + h + this.left + h + this.scaleX + h + this.scaleY + h + this.skewX + h + this.skewY + h + this.angle + h + this.originX + h + this.originY + h + this.width + h + this.height + h + this.strokeWidth + this.flipX + this.flipY;
        },
        /**
         * calculate transform matrix that represents the current transformations from the
         * object's properties.
         * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
         * There are some situation in which this is useful to avoid the fake rotation.
         * @return {Array} transform matrix for the object
         */
        calcTransformMatrix: function(e) {
          var h = this.calcOwnMatrix();
          if (e || !this.group)
            return h;
          var m = this.transformMatrixKey(e), b = this.matrixCache || (this.matrixCache = {});
          return b.key === m ? b.value : (this.group && (h = v(this.group.calcTransformMatrix(!1), h)), b.key = m, b.value = h, h);
        },
        /**
         * calculate transform matrix that represents the current transformations from the
         * object's properties, this matrix does not include the group transformation
         * @return {Array} transform matrix for the object
         */
        calcOwnMatrix: function() {
          var e = this.transformMatrixKey(!0), h = this.ownMatrixCache || (this.ownMatrixCache = {});
          if (h.key === e)
            return h.value;
          var m = this._calcTranslateMatrix(), b = {
            angle: this.angle,
            translateX: m[4],
            translateY: m[5],
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: this.skewX,
            skewY: this.skewY,
            flipX: this.flipX,
            flipY: this.flipY
          };
          return h.key = e, h.value = l.composeMatrix(b), h.value;
        },
        /*
         * Calculate object dimensions from its properties
         * @private
         * @return {Object} .x width dimension
         * @return {Object} .y height dimension
         */
        _getNonTransformedDimensions: function() {
          var e = this.strokeWidth, h = this.width + e, m = this.height + e;
          return { x: h, y: m };
        },
        /*
         * Calculate object bounding box dimensions from its properties scale, skew.
         * @param {Number} skewX, a value to override current skewX
         * @param {Number} skewY, a value to override current skewY
         * @private
         * @return {Object} .x width dimension
         * @return {Object} .y height dimension
         */
        _getTransformedDimensions: function(e, h) {
          typeof e > "u" && (e = this.skewX), typeof h > "u" && (h = this.skewY);
          var m, b, f, k = e === 0 && h === 0;
          if (this.strokeUniform ? (b = this.width, f = this.height) : (m = this._getNonTransformedDimensions(), b = m.x, f = m.y), k)
            return this._finalizeDimensions(b * this.scaleX, f * this.scaleY);
          var E = l.sizeAfterTransform(b, f, {
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: e,
            skewY: h
          });
          return this._finalizeDimensions(E.x, E.y);
        },
        /*
         * Calculate object bounding box dimensions from its properties scale, skew.
         * @param Number width width of the bbox
         * @param Number height height of the bbox
         * @private
         * @return {Object} .x finalized width dimension
         * @return {Object} .y finalized height dimension
         */
        _finalizeDimensions: function(e, h) {
          return this.strokeUniform ? { x: e + this.strokeWidth, y: h + this.strokeWidth } : { x: e, y: h };
        },
        /*
         * Calculate object dimensions for controls box, including padding and canvas zoom.
         * and active selection
         * private
         */
        _calculateCurrentDimensions: function() {
          var e = this.getViewportTransform(), h = this._getTransformedDimensions(), m = c(h, e, !0);
          return m.scalarAdd(2 * this.padding);
        }
      }
    );
  }(), n.util.object.extend(
    n.Object.prototype,
    /** @lends fabric.Object.prototype */
    {
      /**
       * Moves an object to the bottom of the stack of drawn objects
       * @return {fabric.Object} thisArg
       * @chainable
       */
      sendToBack: function() {
        return this.group ? n.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this;
      },
      /**
       * Moves an object to the top of the stack of drawn objects
       * @return {fabric.Object} thisArg
       * @chainable
       */
      bringToFront: function() {
        return this.group ? n.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this;
      },
      /**
       * Moves an object down in stack of drawn objects
       * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
       * @return {fabric.Object} thisArg
       * @chainable
       */
      sendBackwards: function(d) {
        return this.group ? n.StaticCanvas.prototype.sendBackwards.call(this.group, this, d) : this.canvas && this.canvas.sendBackwards(this, d), this;
      },
      /**
       * Moves an object up in stack of drawn objects
       * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
       * @return {fabric.Object} thisArg
       * @chainable
       */
      bringForward: function(d) {
        return this.group ? n.StaticCanvas.prototype.bringForward.call(this.group, this, d) : this.canvas && this.canvas.bringForward(this, d), this;
      },
      /**
       * Moves an object to specified level in stack of drawn objects
       * @param {Number} index New position of object
       * @return {fabric.Object} thisArg
       * @chainable
       */
      moveTo: function(d) {
        return this.group && this.group.type !== "activeSelection" ? n.StaticCanvas.prototype.moveTo.call(this.group, this, d) : this.canvas && this.canvas.moveTo(this, d), this;
      }
    }
  ), function() {
    function d(p, v) {
      if (v) {
        if (v.toLive)
          return p + ": url(#SVGID_" + v.id + "); ";
        var c = new n.Color(v), e = p + ": " + c.toRgb() + "; ", h = c.getAlpha();
        return h !== 1 && (e += p + "-opacity: " + h.toString() + "; "), e;
      } else
        return p + ": none; ";
    }
    var l = n.util.toFixed;
    n.util.object.extend(
      n.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Returns styles-string for svg-export
         * @param {Boolean} skipShadow a boolean to skip shadow filter output
         * @return {String}
         */
        getSvgStyles: function(p) {
          var v = this.fillRule ? this.fillRule : "nonzero", c = this.strokeWidth ? this.strokeWidth : "0", e = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", h = this.strokeDashOffset ? this.strokeDashOffset : "0", m = this.strokeLineCap ? this.strokeLineCap : "butt", b = this.strokeLineJoin ? this.strokeLineJoin : "miter", f = this.strokeMiterLimit ? this.strokeMiterLimit : "4", k = typeof this.opacity < "u" ? this.opacity : "1", E = this.visible ? "" : " visibility: hidden;", _ = p ? "" : this.getSvgFilter(), T = d("fill", this.fill), D = d("stroke", this.stroke);
          return [
            D,
            "stroke-width: ",
            c,
            "; ",
            "stroke-dasharray: ",
            e,
            "; ",
            "stroke-linecap: ",
            m,
            "; ",
            "stroke-dashoffset: ",
            h,
            "; ",
            "stroke-linejoin: ",
            b,
            "; ",
            "stroke-miterlimit: ",
            f,
            "; ",
            T,
            "fill-rule: ",
            v,
            "; ",
            "opacity: ",
            k,
            ";",
            _,
            E
          ].join("");
        },
        /**
         * Returns styles-string for svg-export
         * @param {Object} style the object from which to retrieve style properties
         * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
         * @return {String}
         */
        getSvgSpanStyles: function(p, v) {
          var c = "; ", h = p.fontFamily ? "font-family: " + (p.fontFamily.indexOf("'") === -1 && p.fontFamily.indexOf('"') === -1 ? "'" + p.fontFamily + "'" : p.fontFamily) + c : "", e = p.strokeWidth ? "stroke-width: " + p.strokeWidth + c : "", h = h, m = p.fontSize ? "font-size: " + p.fontSize + "px" + c : "", b = p.fontStyle ? "font-style: " + p.fontStyle + c : "", f = p.fontWeight ? "font-weight: " + p.fontWeight + c : "", k = p.fill ? d("fill", p.fill) : "", E = p.stroke ? d("stroke", p.stroke) : "", _ = this.getSvgTextDecoration(p), T = p.deltaY ? "baseline-shift: " + -p.deltaY + "; " : "";
          return _ && (_ = "text-decoration: " + _ + c), [
            E,
            e,
            h,
            m,
            b,
            f,
            _,
            k,
            T,
            v ? "white-space: pre; " : ""
          ].join("");
        },
        /**
         * Returns text-decoration property for svg-export
         * @param {Object} style the object from which to retrieve style properties
         * @return {String}
         */
        getSvgTextDecoration: function(p) {
          return ["overline", "underline", "line-through"].filter(function(v) {
            return p[v.replace("-", "")];
          }).join(" ");
        },
        /**
         * Returns filter for svg shadow
         * @return {String}
         */
        getSvgFilter: function() {
          return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "";
        },
        /**
         * Returns id attribute for svg output
         * @return {String}
         */
        getSvgCommons: function() {
          return [
            this.id ? 'id="' + this.id + '" ' : "",
            this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""
          ].join("");
        },
        /**
         * Returns transform-string for svg-export
         * @param {Boolean} use the full transform or the single object one.
         * @return {String}
         */
        getSvgTransform: function(p, v) {
          var c = p ? this.calcTransformMatrix() : this.calcOwnMatrix(), e = 'transform="' + n.util.matrixToSVG(c);
          return e + (v || "") + '" ';
        },
        _setSVGBg: function(p) {
          if (this.backgroundColor) {
            var v = n.Object.NUM_FRACTION_DIGITS;
            p.push(
              "		<rect ",
              this._getFillAttributes(this.backgroundColor),
              ' x="',
              l(-this.width / 2, v),
              '" y="',
              l(-this.height / 2, v),
              '" width="',
              l(this.width, v),
              '" height="',
              l(this.height, v),
              `"></rect>
`
            );
          }
        },
        /**
         * Returns svg representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toSVG: function(p) {
          return this._createBaseSVGMarkup(this._toSVG(p), { reviver: p });
        },
        /**
         * Returns svg clipPath representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toClipPathSVG: function(p) {
          return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(p), { reviver: p });
        },
        /**
         * @private
         */
        _createBaseClipPathSVGMarkup: function(p, v) {
          v = v || {};
          var c = v.reviver, e = v.additionalTransform || "", h = [
            this.getSvgTransform(!0, e),
            this.getSvgCommons()
          ].join(""), m = p.indexOf("COMMON_PARTS");
          return p[m] = h, c ? c(p.join("")) : p.join("");
        },
        /**
         * @private
         */
        _createBaseSVGMarkup: function(p, v) {
          v = v || {};
          var c = v.noStyle, e = v.reviver, h = c ? "" : 'style="' + this.getSvgStyles() + '" ', m = v.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", b = this.clipPath, f = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", k = b && b.absolutePositioned, E = this.stroke, _ = this.fill, T = this.shadow, D, V = [], I, M = p.indexOf("COMMON_PARTS"), Q = v.additionalTransform;
          return b && (b.clipPathId = "CLIPPATH_" + n.Object.__uid++, I = '<clipPath id="' + b.clipPathId + `" >
` + b.toClipPathSVG(e) + `</clipPath>
`), k && V.push(
            "<g ",
            m,
            this.getSvgCommons(),
            ` >
`
          ), V.push(
            "<g ",
            this.getSvgTransform(!1),
            k ? "" : m + this.getSvgCommons(),
            ` >
`
          ), D = [
            h,
            f,
            c ? "" : this.addPaintOrder(),
            " ",
            Q ? 'transform="' + Q + '" ' : ""
          ].join(""), p[M] = D, _ && _.toLive && V.push(_.toSVG(this)), E && E.toLive && V.push(E.toSVG(this)), T && V.push(T.toSVG(this)), b && V.push(I), V.push(p.join("")), V.push(`</g>
`), k && V.push(`</g>
`), e ? e(V.join("")) : V.join("");
        },
        addPaintOrder: function() {
          return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "";
        }
      }
    );
  }(), function() {
    var d = n.util.object.extend, l = "stateProperties";
    function p(c, e, h) {
      var m = {}, b = !0;
      h.forEach(function(f) {
        m[f] = c[f];
      }), d(c[e], m, b);
    }
    function v(c, e, h) {
      if (c === e)
        return !0;
      if (Array.isArray(c)) {
        if (!Array.isArray(e) || c.length !== e.length)
          return !1;
        for (var m = 0, b = c.length; m < b; m++)
          if (!v(c[m], e[m]))
            return !1;
        return !0;
      } else if (c && typeof c == "object") {
        var f = Object.keys(c), k;
        if (!e || typeof e != "object" || !h && f.length !== Object.keys(e).length)
          return !1;
        for (var m = 0, b = f.length; m < b; m++)
          if (k = f[m], !(k === "canvas" || k === "group") && !v(c[k], e[k]))
            return !1;
        return !0;
      }
    }
    n.util.object.extend(
      n.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Returns true if object state (one of its state properties) was changed
         * @param {String} [propertySet] optional name for the set of property we want to save
         * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
         */
        hasStateChanged: function(c) {
          c = c || l;
          var e = "_" + c;
          return Object.keys(this[e]).length < this[c].length ? !0 : !v(this[e], this, !0);
        },
        /**
         * Saves state of an object
         * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
         * @return {fabric.Object} thisArg
         */
        saveState: function(c) {
          var e = c && c.propertySet || l, h = "_" + e;
          return this[h] ? (p(this, h, this[e]), c && c.stateProperties && p(this, h, c.stateProperties), this) : this.setupState(c);
        },
        /**
         * Setups state of an object
         * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
         * @return {fabric.Object} thisArg
         */
        setupState: function(c) {
          c = c || {};
          var e = c.propertySet || l;
          return c.propertySet = e, this["_" + e] = {}, this.saveState(c), this;
        }
      }
    );
  }(), function() {
    var d = n.util.degreesToRadians;
    n.util.object.extend(
      n.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Determines which corner has been clicked
         * @private
         * @param {Object} pointer The pointer indicating the mouse position
         * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
         */
        _findTargetCorner: function(l, p) {
          if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this)
            return !1;
          var v = l.x, c = l.y, e, h, m = Object.keys(this.oCoords), b = m.length - 1, f;
          for (this.__corner = 0; b >= 0; b--)
            if (f = m[b], !!this.isControlVisible(f) && (h = this._getImageLines(p ? this.oCoords[f].touchCorner : this.oCoords[f].corner), e = this._findCrossPoints({ x: v, y: c }, h), e !== 0 && e % 2 === 1))
              return this.__corner = f, f;
          return !1;
        },
        /**
         * Calls a function for each control. The function gets called,
         * with the control, the object that is calling the iterator and the control's key
         * @param {Function} fn function to iterate over the controls over
         */
        forEachControl: function(l) {
          for (var p in this.controls)
            l(this.controls[p], p, this);
        },
        /**
         * Sets the coordinates of the draggable boxes in the corners of
         * the image used to scale/rotate it.
         * note: if we would switch to ROUND corner area, all of this would disappear.
         * everything would resolve to a single point and a pythagorean theorem for the distance
         * @private
         */
        _setCornerCoords: function() {
          var l = this.oCoords;
          for (var p in l) {
            var v = this.controls[p];
            l[p].corner = v.calcCornerCoords(
              this.angle,
              this.cornerSize,
              l[p].x,
              l[p].y,
              !1
            ), l[p].touchCorner = v.calcCornerCoords(
              this.angle,
              this.touchCornerSize,
              l[p].x,
              l[p].y,
              !0
            );
          }
        },
        /**
         * Draws a colored layer behind the object, inside its selection borders.
         * Requires public options: padding, selectionBackgroundColor
         * this function is called when the context is transformed
         * has checks to be skipped when the object is on a staticCanvas
         * @param {CanvasRenderingContext2D} ctx Context to draw on
         * @return {fabric.Object} thisArg
         * @chainable
         */
        drawSelectionBackground: function(l) {
          if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this)
            return this;
          l.save();
          var p = this.getCenterPoint(), v = this._calculateCurrentDimensions(), c = this.canvas.viewportTransform;
          return l.translate(p.x, p.y), l.scale(1 / c[0], 1 / c[3]), l.rotate(d(this.angle)), l.fillStyle = this.selectionBackgroundColor, l.fillRect(-v.x / 2, -v.y / 2, v.x, v.y), l.restore(), this;
        },
        /**
         * Draws borders of an object's bounding box.
         * Requires public properties: width, height
         * Requires public options: padding, borderColor
         * @param {CanvasRenderingContext2D} ctx Context to draw on
         * @param {Object} styleOverride object to override the object style
         * @return {fabric.Object} thisArg
         * @chainable
         */
        drawBorders: function(l, p) {
          p = p || {};
          var v = this._calculateCurrentDimensions(), c = this.borderScaleFactor, e = v.x + c, h = v.y + c, m = typeof p.hasControls < "u" ? p.hasControls : this.hasControls, b = !1;
          return l.save(), l.strokeStyle = p.borderColor || this.borderColor, this._setLineDash(l, p.borderDashArray || this.borderDashArray), l.strokeRect(
            -e / 2,
            -h / 2,
            e,
            h
          ), m && (l.beginPath(), this.forEachControl(function(f, k, E) {
            f.withConnection && f.getVisibility(E, k) && (b = !0, l.moveTo(f.x * e, f.y * h), l.lineTo(
              f.x * e + f.offsetX,
              f.y * h + f.offsetY
            ));
          }), b && l.stroke()), l.restore(), this;
        },
        /**
         * Draws borders of an object's bounding box when it is inside a group.
         * Requires public properties: width, height
         * Requires public options: padding, borderColor
         * @param {CanvasRenderingContext2D} ctx Context to draw on
         * @param {object} options object representing current object parameters
         * @param {Object} styleOverride object to override the object style
         * @return {fabric.Object} thisArg
         * @chainable
         */
        drawBordersInGroup: function(l, p, v) {
          v = v || {};
          var c = n.util.sizeAfterTransform(this.width, this.height, p), e = this.strokeWidth, h = this.strokeUniform, m = this.borderScaleFactor, b = c.x + e * (h ? this.canvas.getZoom() : p.scaleX) + m, f = c.y + e * (h ? this.canvas.getZoom() : p.scaleY) + m;
          return l.save(), this._setLineDash(l, v.borderDashArray || this.borderDashArray), l.strokeStyle = v.borderColor || this.borderColor, l.strokeRect(
            -b / 2,
            -f / 2,
            b,
            f
          ), l.restore(), this;
        },
        /**
         * Draws corners of an object's bounding box.
         * Requires public properties: width, height
         * Requires public options: cornerSize, padding
         * @param {CanvasRenderingContext2D} ctx Context to draw on
         * @param {Object} styleOverride object to override the object style
         * @return {fabric.Object} thisArg
         * @chainable
         */
        drawControls: function(l, p) {
          p = p || {}, l.save();
          var v = this.canvas.getRetinaScaling(), c, e;
          return l.setTransform(v, 0, 0, v, 0, 0), l.strokeStyle = l.fillStyle = p.cornerColor || this.cornerColor, this.transparentCorners || (l.strokeStyle = p.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(l, p.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (c = this.group.calcTransformMatrix()), this.forEachControl(function(h, m, b) {
            e = b.oCoords[m], h.getVisibility(b, m) && (c && (e = n.util.transformPoint(e, c)), h.render(l, e.x, e.y, p, b));
          }), l.restore(), this;
        },
        /**
         * Returns true if the specified control is visible, false otherwise.
         * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
         * @returns {Boolean} true if the specified control is visible, false otherwise
         */
        isControlVisible: function(l) {
          return this.controls[l] && this.controls[l].getVisibility(this, l);
        },
        /**
         * Sets the visibility of the specified control.
         * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
         * @param {Boolean} visible true to set the specified control visible, false otherwise
         * @return {fabric.Object} thisArg
         * @chainable
         */
        setControlVisible: function(l, p) {
          return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[l] = p, this;
        },
        /**
         * Sets the visibility state of object controls.
         * @param {Object} [options] Options object
         * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
         * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
         * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
         * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
         * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
         * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
         * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
         * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
         * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
         * @return {fabric.Object} thisArg
         * @chainable
         */
        setControlsVisibility: function(l) {
          l || (l = {});
          for (var p in l)
            this.setControlVisible(p, l[p]);
          return this;
        },
        /**
         * This callback function is called every time _discardActiveObject or _setActiveObject
         * try to to deselect this object. If the function returns true, the process is cancelled
         * @param {Object} [options] options sent from the upper functions
         * @param {Event} [options.e] event if the process is generated by an event
         */
        onDeselect: function() {
        },
        /**
         * This callback function is called every time _discardActiveObject or _setActiveObject
         * try to to select this object. If the function returns true, the process is cancelled
         * @param {Object} [options] options sent from the upper functions
         * @param {Event} [options.e] event if the process is generated by an event
         */
        onSelect: function() {
        }
      }
    );
  }(), n.util.object.extend(
    n.StaticCanvas.prototype,
    /** @lends fabric.StaticCanvas.prototype */
    {
      /**
       * Animation duration (in ms) for fx* methods
       * @type Number
       * @default
       */
      FX_DURATION: 500,
      /**
       * Centers object horizontally with animation.
       * @param {fabric.Object} object Object to center
       * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
       * @param {Function} [callbacks.onComplete] Invoked on completion
       * @param {Function} [callbacks.onChange] Invoked on every step of animation
       * @return {fabric.AnimationContext} context
       */
      fxCenterObjectH: function(d, l) {
        l = l || {};
        var p = function() {
        }, v = l.onComplete || p, c = l.onChange || p, e = this;
        return n.util.animate({
          target: this,
          startValue: d.left,
          endValue: this.getCenterPoint().x,
          duration: this.FX_DURATION,
          onChange: function(h) {
            d.set("left", h), e.requestRenderAll(), c();
          },
          onComplete: function() {
            d.setCoords(), v();
          }
        });
      },
      /**
       * Centers object vertically with animation.
       * @param {fabric.Object} object Object to center
       * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
       * @param {Function} [callbacks.onComplete] Invoked on completion
       * @param {Function} [callbacks.onChange] Invoked on every step of animation
       * @return {fabric.AnimationContext} context
       */
      fxCenterObjectV: function(d, l) {
        l = l || {};
        var p = function() {
        }, v = l.onComplete || p, c = l.onChange || p, e = this;
        return n.util.animate({
          target: this,
          startValue: d.top,
          endValue: this.getCenterPoint().y,
          duration: this.FX_DURATION,
          onChange: function(h) {
            d.set("top", h), e.requestRenderAll(), c();
          },
          onComplete: function() {
            d.setCoords(), v();
          }
        });
      },
      /**
       * Same as `fabric.Canvas#remove` but animated
       * @param {fabric.Object} object Object to remove
       * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
       * @param {Function} [callbacks.onComplete] Invoked on completion
       * @param {Function} [callbacks.onChange] Invoked on every step of animation
       * @return {fabric.AnimationContext} context
       */
      fxRemove: function(d, l) {
        l = l || {};
        var p = function() {
        }, v = l.onComplete || p, c = l.onChange || p, e = this;
        return n.util.animate({
          target: this,
          startValue: d.opacity,
          endValue: 0,
          duration: this.FX_DURATION,
          onChange: function(h) {
            d.set("opacity", h), e.requestRenderAll(), c();
          },
          onComplete: function() {
            e.remove(d), v();
          }
        });
      }
    }
  ), n.util.object.extend(
    n.Object.prototype,
    /** @lends fabric.Object.prototype */
    {
      /**
       * Animates object's properties
       * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
       * @param {Number|Object} value Value to animate property to (if string was given first) or options object
       * @return {fabric.Object} thisArg
       * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
       * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)
       *
       * As object — multiple properties
       *
       * object.animate({ left: ..., top: ... });
       * object.animate({ left: ..., top: ... }, { duration: ... });
       *
       * As string — one property
       *
       * object.animate('left', ...);
       * object.animate('left', { duration: ... });
       *
       */
      animate: function() {
        if (arguments[0] && typeof arguments[0] == "object") {
          var d = [], l, p, v = [];
          for (l in arguments[0])
            d.push(l);
          for (var c = 0, e = d.length; c < e; c++)
            l = d[c], p = c !== e - 1, v.push(this._animate(l, arguments[0][l], arguments[1], p));
          return v;
        } else
          return this._animate.apply(this, arguments);
      },
      /**
       * @private
       * @param {String} property Property to animate
       * @param {String} to Value to animate to
       * @param {Object} [options] Options object
       * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
       */
      _animate: function(d, l, p, v) {
        var c = this, e;
        l = l.toString(), p ? p = n.util.object.clone(p) : p = {}, ~d.indexOf(".") && (e = d.split("."));
        var h = c.colorProperties.indexOf(d) > -1 || e && c.colorProperties.indexOf(e[1]) > -1, m = e ? this.get(e[0])[e[1]] : this.get(d);
        "from" in p || (p.from = m), h || (~l.indexOf("=") ? l = m + parseFloat(l.replace("=", "")) : l = parseFloat(l));
        var b = {
          target: this,
          startValue: p.from,
          endValue: l,
          byValue: p.by,
          easing: p.easing,
          duration: p.duration,
          abort: p.abort && function(f, k, E) {
            return p.abort.call(c, f, k, E);
          },
          onChange: function(f, k, E) {
            e ? c[e[0]][e[1]] = f : c.set(d, f), !v && p.onChange && p.onChange(f, k, E);
          },
          onComplete: function(f, k, E) {
            v || (c.setCoords(), p.onComplete && p.onComplete(f, k, E));
          }
        };
        return h ? n.util.animateColor(b.startValue, b.endValue, b.duration, b) : n.util.animate(b);
      }
    }
  ), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.util.object.clone, c = { x1: 1, x2: 1, y1: 1, y2: 1 };
    if (l.Line) {
      l.warn("fabric.Line is already defined");
      return;
    }
    l.Line = l.util.createClass(
      l.Object,
      /** @lends fabric.Line.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "line",
        /**
         * x value or first line edge
         * @type Number
         * @default
         */
        x1: 0,
        /**
         * y value or first line edge
         * @type Number
         * @default
         */
        y1: 0,
        /**
         * x value or second line edge
         * @type Number
         * @default
         */
        x2: 0,
        /**
         * y value or second line edge
         * @type Number
         * @default
         */
        y2: 0,
        cacheProperties: l.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"),
        /**
         * Constructor
         * @param {Array} [points] Array of points
         * @param {Object} [options] Options object
         * @return {fabric.Line} thisArg
         */
        initialize: function(h, m) {
          h || (h = [0, 0, 0, 0]), this.callSuper("initialize", m), this.set("x1", h[0]), this.set("y1", h[1]), this.set("x2", h[2]), this.set("y2", h[3]), this._setWidthHeight(m);
        },
        /**
         * @private
         * @param {Object} [options] Options
         */
        _setWidthHeight: function(h) {
          h || (h = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in h ? h.left : this._getLeftToOriginX(), this.top = "top" in h ? h.top : this._getTopToOriginY();
        },
        /**
         * @private
         * @param {String} key
         * @param {*} value
         */
        _set: function(h, m) {
          return this.callSuper("_set", h, m), typeof c[h] < "u" && this._setWidthHeight(), this;
        },
        /**
         * @private
         * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
         */
        _getLeftToOriginX: e(
          {
            // property names
            origin: "originX",
            axis1: "x1",
            axis2: "x2",
            dimension: "width"
          },
          {
            // possible values of origin
            nearest: "left",
            center: "center",
            farthest: "right"
          }
        ),
        /**
         * @private
         * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
         */
        _getTopToOriginY: e(
          {
            // property names
            origin: "originY",
            axis1: "y1",
            axis2: "y2",
            dimension: "height"
          },
          {
            // possible values of origin
            nearest: "top",
            center: "center",
            farthest: "bottom"
          }
        ),
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(h) {
          h.beginPath();
          var m = this.calcLinePoints();
          h.moveTo(m.x1, m.y1), h.lineTo(m.x2, m.y2), h.lineWidth = this.strokeWidth;
          var b = h.strokeStyle;
          h.strokeStyle = this.stroke || h.fillStyle, this.stroke && this._renderStroke(h), h.strokeStyle = b;
        },
        /**
         * This function is an helper for svg import. it returns the center of the object in the svg
         * untransformed coordinates
         * @private
         * @return {Object} center point from element coordinates
         */
        _findCenterFromElement: function() {
          return {
            x: (this.x1 + this.x2) / 2,
            y: (this.y1 + this.y2) / 2
          };
        },
        /**
         * Returns object representation of an instance
         * @method toObject
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(h) {
          return p(this.callSuper("toObject", h), this.calcLinePoints());
        },
        /*
         * Calculate object dimensions from its properties
         * @private
         */
        _getNonTransformedDimensions: function() {
          var h = this.callSuper("_getNonTransformedDimensions");
          return this.strokeLineCap === "butt" && (this.width === 0 && (h.y -= this.strokeWidth), this.height === 0 && (h.x -= this.strokeWidth)), h;
        },
        /**
         * Recalculates line points given width and height
         * @private
         */
        calcLinePoints: function() {
          var h = this.x1 <= this.x2 ? -1 : 1, m = this.y1 <= this.y2 ? -1 : 1, b = h * this.width * 0.5, f = m * this.height * 0.5, k = h * this.width * -0.5, E = m * this.height * -0.5;
          return {
            x1: b,
            x2: k,
            y1: f,
            y2: E
          };
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var h = this.calcLinePoints();
          return [
            "<line ",
            "COMMON_PARTS",
            'x1="',
            h.x1,
            '" y1="',
            h.y1,
            '" x2="',
            h.x2,
            '" y2="',
            h.y2,
            `" />
`
          ];
        }
        /* _TO_SVG_END_ */
      }
    ), l.Line.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), l.Line.fromElement = function(h, m, b) {
      b = b || {};
      var f = l.parseAttributes(h, l.Line.ATTRIBUTE_NAMES), k = [
        f.x1 || 0,
        f.y1 || 0,
        f.x2 || 0,
        f.y2 || 0
      ];
      m(new l.Line(k, p(f, b)));
    }, l.Line.fromObject = function(h, m) {
      function b(k) {
        delete k.points, m && m(k);
      }
      var f = v(h, !0);
      f.points = [h.x1, h.y1, h.x2, h.y2], l.Object._fromObject("Line", f, b, "points");
    };
    function e(h, m) {
      var b = h.origin, f = h.axis1, k = h.axis2, E = h.dimension, _ = m.nearest, T = m.center, D = m.farthest;
      return function() {
        switch (this.get(b)) {
          case _:
            return Math.min(this.get(f), this.get(k));
          case T:
            return Math.min(this.get(f), this.get(k)) + 0.5 * this.get(E);
          case D:
            return Math.max(this.get(f), this.get(k));
        }
      };
    }
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.degreesToRadians;
    if (l.Circle) {
      l.warn("fabric.Circle is already defined.");
      return;
    }
    l.Circle = l.util.createClass(
      l.Object,
      /** @lends fabric.Circle.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "circle",
        /**
         * Radius of this circle
         * @type Number
         * @default
         */
        radius: 0,
        /**
         * degrees of start of the circle.
         * probably will change to degrees in next major version
         * @type Number 0 - 359
         * @default 0
         */
        startAngle: 0,
        /**
         * End angle of the circle
         * probably will change to degrees in next major version
         * @type Number 1 - 360
         * @default 360
         */
        endAngle: 360,
        cacheProperties: l.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"),
        /**
         * @private
         * @param {String} key
         * @param {*} value
         * @return {fabric.Circle} thisArg
         */
        _set: function(c, e) {
          return this.callSuper("_set", c, e), c === "radius" && this.setRadius(e), this;
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(c) {
          return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(c));
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var c, e = 0, h = 0, m = (this.endAngle - this.startAngle) % 360;
          if (m === 0)
            c = [
              "<circle ",
              "COMMON_PARTS",
              'cx="' + e + '" cy="' + h + '" ',
              'r="',
              this.radius,
              `" />
`
            ];
          else {
            var b = p(this.startAngle), f = p(this.endAngle), k = this.radius, E = l.util.cos(b) * k, _ = l.util.sin(b) * k, T = l.util.cos(f) * k, D = l.util.sin(f) * k, V = m > 180 ? "1" : "0";
            c = [
              '<path d="M ' + E + " " + _,
              " A " + k + " " + k,
              " 0 ",
              +V + " 1",
              " " + T + " " + D,
              '" ',
              "COMMON_PARTS",
              ` />
`
            ];
          }
          return c;
        },
        /* _TO_SVG_END_ */
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx context to render on
         */
        _render: function(c) {
          c.beginPath(), c.arc(
            0,
            0,
            this.radius,
            p(this.startAngle),
            p(this.endAngle),
            !1
          ), this._renderPaintInOrder(c);
        },
        /**
         * Returns horizontal radius of an object (according to how an object is scaled)
         * @return {Number}
         */
        getRadiusX: function() {
          return this.get("radius") * this.get("scaleX");
        },
        /**
         * Returns vertical radius of an object (according to how an object is scaled)
         * @return {Number}
         */
        getRadiusY: function() {
          return this.get("radius") * this.get("scaleY");
        },
        /**
         * Sets radius of an object (and updates width accordingly)
         * @return {fabric.Circle} thisArg
         */
        setRadius: function(c) {
          return this.radius = c, this.set("width", c * 2).set("height", c * 2);
        }
      }
    ), l.Circle.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), l.Circle.fromElement = function(c, e) {
      var h = l.parseAttributes(c, l.Circle.ATTRIBUTE_NAMES);
      if (!v(h))
        throw new Error("value of `r` attribute is required and can not be negative");
      h.left = (h.left || 0) - h.radius, h.top = (h.top || 0) - h.radius, e(new l.Circle(h));
    };
    function v(c) {
      return "radius" in c && c.radius >= 0;
    }
    l.Circle.fromObject = function(c, e) {
      l.Object._fromObject("Circle", c, e);
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {});
    if (l.Triangle) {
      l.warn("fabric.Triangle is already defined");
      return;
    }
    l.Triangle = l.util.createClass(
      l.Object,
      /** @lends fabric.Triangle.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "triangle",
        /**
         * Width is set to 100 to compensate the old initialize code that was setting it to 100
         * @type Number
         * @default
         */
        width: 100,
        /**
         * Height is set to 100 to compensate the old initialize code that was setting it to 100
         * @type Number
         * @default
         */
        height: 100,
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(p) {
          var v = this.width / 2, c = this.height / 2;
          p.beginPath(), p.moveTo(-v, c), p.lineTo(0, -c), p.lineTo(v, c), p.closePath(), this._renderPaintInOrder(p);
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var p = this.width / 2, v = this.height / 2, c = [
            -p + " " + v,
            "0 " + -v,
            p + " " + v
          ].join(",");
          return [
            "<polygon ",
            "COMMON_PARTS",
            'points="',
            c,
            '" />'
          ];
        }
        /* _TO_SVG_END_ */
      }
    ), l.Triangle.fromObject = function(p, v) {
      return l.Object._fromObject("Triangle", p, v);
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = Math.PI * 2;
    if (l.Ellipse) {
      l.warn("fabric.Ellipse is already defined.");
      return;
    }
    l.Ellipse = l.util.createClass(
      l.Object,
      /** @lends fabric.Ellipse.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "ellipse",
        /**
         * Horizontal radius
         * @type Number
         * @default
         */
        rx: 0,
        /**
         * Vertical radius
         * @type Number
         * @default
         */
        ry: 0,
        cacheProperties: l.Object.prototype.cacheProperties.concat("rx", "ry"),
        /**
         * Constructor
         * @param {Object} [options] Options object
         * @return {fabric.Ellipse} thisArg
         */
        initialize: function(v) {
          this.callSuper("initialize", v), this.set("rx", v && v.rx || 0), this.set("ry", v && v.ry || 0);
        },
        /**
         * @private
         * @param {String} key
         * @param {*} value
         * @return {fabric.Ellipse} thisArg
         */
        _set: function(v, c) {
          switch (this.callSuper("_set", v, c), v) {
            case "rx":
              this.rx = c, this.set("width", c * 2);
              break;
            case "ry":
              this.ry = c, this.set("height", c * 2);
              break;
          }
          return this;
        },
        /**
         * Returns horizontal radius of an object (according to how an object is scaled)
         * @return {Number}
         */
        getRx: function() {
          return this.get("rx") * this.get("scaleX");
        },
        /**
         * Returns Vertical radius of an object (according to how an object is scaled)
         * @return {Number}
         */
        getRy: function() {
          return this.get("ry") * this.get("scaleY");
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(v) {
          return this.callSuper("toObject", ["rx", "ry"].concat(v));
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          return [
            "<ellipse ",
            "COMMON_PARTS",
            'cx="0" cy="0" ',
            'rx="',
            this.rx,
            '" ry="',
            this.ry,
            `" />
`
          ];
        },
        /* _TO_SVG_END_ */
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx context to render on
         */
        _render: function(v) {
          v.beginPath(), v.save(), v.transform(1, 0, 0, this.ry / this.rx, 0, 0), v.arc(
            0,
            0,
            this.rx,
            0,
            p,
            !1
          ), v.restore(), this._renderPaintInOrder(v);
        }
      }
    ), l.Ellipse.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), l.Ellipse.fromElement = function(v, c) {
      var e = l.parseAttributes(v, l.Ellipse.ATTRIBUTE_NAMES);
      e.left = (e.left || 0) - e.rx, e.top = (e.top || 0) - e.ry, c(new l.Ellipse(e));
    }, l.Ellipse.fromObject = function(v, c) {
      l.Object._fromObject("Ellipse", v, c);
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend;
    if (l.Rect) {
      l.warn("fabric.Rect is already defined");
      return;
    }
    l.Rect = l.util.createClass(
      l.Object,
      /** @lends fabric.Rect.prototype */
      {
        /**
         * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
         * as well as for history (undo/redo) purposes
         * @type Array
         */
        stateProperties: l.Object.prototype.stateProperties.concat("rx", "ry"),
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "rect",
        /**
         * Horizontal border radius
         * @type Number
         * @default
         */
        rx: 0,
        /**
         * Vertical border radius
         * @type Number
         * @default
         */
        ry: 0,
        cacheProperties: l.Object.prototype.cacheProperties.concat("rx", "ry"),
        /**
         * Constructor
         * @param {Object} [options] Options object
         * @return {Object} thisArg
         */
        initialize: function(v) {
          this.callSuper("initialize", v), this._initRxRy();
        },
        /**
         * Initializes rx/ry attributes
         * @private
         */
        _initRxRy: function() {
          this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry);
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(v) {
          var c = this.rx ? Math.min(this.rx, this.width / 2) : 0, e = this.ry ? Math.min(this.ry, this.height / 2) : 0, h = this.width, m = this.height, b = -this.width / 2, f = -this.height / 2, k = c !== 0 || e !== 0, E = 1 - 0.5522847498;
          v.beginPath(), v.moveTo(b + c, f), v.lineTo(b + h - c, f), k && v.bezierCurveTo(b + h - E * c, f, b + h, f + E * e, b + h, f + e), v.lineTo(b + h, f + m - e), k && v.bezierCurveTo(b + h, f + m - E * e, b + h - E * c, f + m, b + h - c, f + m), v.lineTo(b + c, f + m), k && v.bezierCurveTo(b + E * c, f + m, b, f + m - E * e, b, f + m - e), v.lineTo(b, f + e), k && v.bezierCurveTo(b, f + E * e, b + E * c, f, b + c, f), v.closePath(), this._renderPaintInOrder(v);
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(v) {
          return this.callSuper("toObject", ["rx", "ry"].concat(v));
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var v = -this.width / 2, c = -this.height / 2;
          return [
            "<rect ",
            "COMMON_PARTS",
            'x="',
            v,
            '" y="',
            c,
            '" rx="',
            this.rx,
            '" ry="',
            this.ry,
            '" width="',
            this.width,
            '" height="',
            this.height,
            `" />
`
          ];
        }
        /* _TO_SVG_END_ */
      }
    ), l.Rect.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), l.Rect.fromElement = function(v, c, e) {
      if (!v)
        return c(null);
      e = e || {};
      var h = l.parseAttributes(v, l.Rect.ATTRIBUTE_NAMES);
      h.left = h.left || 0, h.top = h.top || 0, h.height = h.height || 0, h.width = h.width || 0;
      var m = new l.Rect(p(e ? l.util.object.clone(e) : {}, h));
      m.visible = m.visible && m.width > 0 && m.height > 0, c(m);
    }, l.Rect.fromObject = function(v, c) {
      return l.Object._fromObject("Rect", v, c);
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.util.array.min, c = l.util.array.max, e = l.util.toFixed, h = l.util.projectStrokeOnPoints;
    if (l.Polyline) {
      l.warn("fabric.Polyline is already defined");
      return;
    }
    l.Polyline = l.util.createClass(
      l.Object,
      /** @lends fabric.Polyline.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "polyline",
        /**
         * Points array
         * @type Array
         * @default
         */
        points: null,
        /**
         * WARNING: Feature in progress
         * Calculate the exact bounding box taking in account strokeWidth on acute angles
         * this will be turned to true by default on fabric 6.0
         * maybe will be left in as an optimization since calculations may be slow
         * @deprecated
         * @type Boolean
         * @default false
         */
        exactBoundingBox: !1,
        cacheProperties: l.Object.prototype.cacheProperties.concat("points"),
        /**
         * Constructor
         * @param {Array} points Array of points (where each point is an object with x and y)
         * @param {Object} [options] Options object
         * @return {fabric.Polyline} thisArg
         * @example
         * var poly = new fabric.Polyline([
         *     { x: 10, y: 10 },
         *     { x: 50, y: 30 },
         *     { x: 40, y: 70 },
         *     { x: 60, y: 50 },
         *     { x: 100, y: 150 },
         *     { x: 40, y: 100 }
         *   ], {
         *   stroke: 'red',
         *   left: 100,
         *   top: 100
         * });
         */
        initialize: function(m, b) {
          b = b || {}, this.points = m || [], this.callSuper("initialize", b), this._setPositionDimensions(b);
        },
        /**
         * @private
         */
        _projectStrokeOnPoints: function() {
          return h(this.points, this, !0);
        },
        _setPositionDimensions: function(m) {
          var b = this._calcDimensions(m), f, k = this.exactBoundingBox ? this.strokeWidth : 0;
          this.width = b.width - k, this.height = b.height - k, m.fromSVG || (f = this.translateToGivenOrigin(
            {
              // this looks bad, but is one way to keep it optional for now.
              x: b.left - this.strokeWidth / 2 + k / 2,
              y: b.top - this.strokeWidth / 2 + k / 2
            },
            "left",
            "top",
            this.originX,
            this.originY
          )), typeof m.left > "u" && (this.left = m.fromSVG ? b.left : f.x), typeof m.top > "u" && (this.top = m.fromSVG ? b.top : f.y), this.pathOffset = {
            x: b.left + this.width / 2 + k / 2,
            y: b.top + this.height / 2 + k / 2
          };
        },
        /**
         * Calculate the polygon min and max point from points array,
         * returning an object with left, top, width, height to measure the
         * polygon size
         * @return {Object} object.left X coordinate of the polygon leftmost point
         * @return {Object} object.top Y coordinate of the polygon topmost point
         * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
         * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
         * @private
         */
        _calcDimensions: function() {
          var m = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, b = v(m, "x") || 0, f = v(m, "y") || 0, k = c(m, "x") || 0, E = c(m, "y") || 0, _ = k - b, T = E - f;
          return {
            left: b,
            top: f,
            width: _,
            height: T
          };
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of an instance
         */
        toObject: function(m) {
          return p(this.callSuper("toObject", m), {
            points: this.points.concat()
          });
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          for (var m = [], b = this.pathOffset.x, f = this.pathOffset.y, k = l.Object.NUM_FRACTION_DIGITS, E = 0, _ = this.points.length; E < _; E++)
            m.push(
              e(this.points[E].x - b, k),
              ",",
              e(this.points[E].y - f, k),
              " "
            );
          return [
            "<" + this.type + " ",
            "COMMON_PARTS",
            'points="',
            m.join(""),
            `" />
`
          ];
        },
        /* _TO_SVG_END_ */
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        commonRender: function(m) {
          var b, f = this.points.length, k = this.pathOffset.x, E = this.pathOffset.y;
          if (!f || isNaN(this.points[f - 1].y))
            return !1;
          m.beginPath(), m.moveTo(this.points[0].x - k, this.points[0].y - E);
          for (var _ = 0; _ < f; _++)
            b = this.points[_], m.lineTo(b.x - k, b.y - E);
          return !0;
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(m) {
          this.commonRender(m) && this._renderPaintInOrder(m);
        },
        /**
         * Returns complexity of an instance
         * @return {Number} complexity of this instance
         */
        complexity: function() {
          return this.get("points").length;
        }
      }
    ), l.Polyline.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat(), l.Polyline.fromElementGenerator = function(m) {
      return function(b, f, k) {
        if (!b)
          return f(null);
        k || (k = {});
        var E = l.parsePointsAttribute(b.getAttribute("points")), _ = l.parseAttributes(b, l[m].ATTRIBUTE_NAMES);
        _.fromSVG = !0, f(new l[m](E, p(_, k)));
      };
    }, l.Polyline.fromElement = l.Polyline.fromElementGenerator("Polyline"), l.Polyline.fromObject = function(m, b) {
      return l.Object._fromObject("Polyline", m, b, "points");
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.projectStrokeOnPoints;
    if (l.Polygon) {
      l.warn("fabric.Polygon is already defined");
      return;
    }
    l.Polygon = l.util.createClass(
      l.Polyline,
      /** @lends fabric.Polygon.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "polygon",
        /**
         * @private
         */
        _projectStrokeOnPoints: function() {
          return p(this.points, this);
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(v) {
          this.commonRender(v) && (v.closePath(), this._renderPaintInOrder(v));
        }
      }
    ), l.Polygon.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat(), l.Polygon.fromElement = l.Polyline.fromElementGenerator("Polygon"), l.Polygon.fromObject = function(v, c) {
      l.Object._fromObject("Polygon", v, c, "points");
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.array.min, v = l.util.array.max, c = l.util.object.extend, e = l.util.object.clone, h = l.util.toFixed;
    if (l.Path) {
      l.warn("fabric.Path is already defined");
      return;
    }
    l.Path = l.util.createClass(
      l.Object,
      /** @lends fabric.Path.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "path",
        /**
         * Array of path points
         * @type Array
         * @default
         */
        path: null,
        cacheProperties: l.Object.prototype.cacheProperties.concat("path", "fillRule"),
        stateProperties: l.Object.prototype.stateProperties.concat("path"),
        /**
         * Constructor
         * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
         * @param {Object} [options] Options object
         * @return {fabric.Path} thisArg
         */
        initialize: function(m, b) {
          b = e(b || {}), delete b.path, this.callSuper("initialize", b), this._setPath(m || [], b);
        },
        /**
        * @private
        * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
        * @param {Object} [options] Options object
        */
        _setPath: function(m, b) {
          this.path = l.util.makePathSimpler(
            Array.isArray(m) ? m : l.util.parsePath(m)
          ), l.Polyline.prototype._setPositionDimensions.call(this, b || {});
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx context to render path on
         */
        _renderPathCommands: function(m) {
          var b, f = 0, k = 0, E = 0, _ = 0, T = 0, D = 0, V = -this.pathOffset.x, I = -this.pathOffset.y;
          m.beginPath();
          for (var M = 0, Q = this.path.length; M < Q; ++M)
            switch (b = this.path[M], b[0]) {
              case "L":
                E = b[1], _ = b[2], m.lineTo(E + V, _ + I);
                break;
              case "M":
                E = b[1], _ = b[2], f = E, k = _, m.moveTo(E + V, _ + I);
                break;
              case "C":
                E = b[5], _ = b[6], T = b[3], D = b[4], m.bezierCurveTo(
                  b[1] + V,
                  b[2] + I,
                  T + V,
                  D + I,
                  E + V,
                  _ + I
                );
                break;
              case "Q":
                m.quadraticCurveTo(
                  b[1] + V,
                  b[2] + I,
                  b[3] + V,
                  b[4] + I
                ), E = b[3], _ = b[4], T = b[1], D = b[2];
                break;
              case "z":
              case "Z":
                E = f, _ = k, m.closePath();
                break;
            }
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx context to render path on
         */
        _render: function(m) {
          this._renderPathCommands(m), this._renderPaintInOrder(m);
        },
        /**
         * Returns string representation of an instance
         * @return {String} string representation of an instance
         */
        toString: function() {
          return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>";
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(m) {
          return c(this.callSuper("toObject", m), {
            path: this.path.map(function(b) {
              return b.slice();
            })
          });
        },
        /**
         * Returns dataless object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toDatalessObject: function(m) {
          var b = this.toObject(["sourcePath"].concat(m));
          return b.sourcePath && delete b.path, b;
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var m = l.util.joinPath(this.path);
          return [
            "<path ",
            "COMMON_PARTS",
            'd="',
            m,
            '" stroke-linecap="round" ',
            `/>
`
          ];
        },
        _getOffsetTransform: function() {
          var m = l.Object.NUM_FRACTION_DIGITS;
          return " translate(" + h(-this.pathOffset.x, m) + ", " + h(-this.pathOffset.y, m) + ")";
        },
        /**
         * Returns svg clipPath representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toClipPathSVG: function(m) {
          var b = this._getOffsetTransform();
          return "	" + this._createBaseClipPathSVGMarkup(
            this._toSVG(),
            { reviver: m, additionalTransform: b }
          );
        },
        /**
         * Returns svg representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toSVG: function(m) {
          var b = this._getOffsetTransform();
          return this._createBaseSVGMarkup(this._toSVG(), { reviver: m, additionalTransform: b });
        },
        /* _TO_SVG_END_ */
        /**
         * Returns number representation of an instance complexity
         * @return {Number} complexity of this instance
         */
        complexity: function() {
          return this.path.length;
        },
        /**
         * @private
         */
        _calcDimensions: function() {
          for (var m = [], b = [], f, k = 0, E = 0, _ = 0, T = 0, D, V = 0, I = this.path.length; V < I; ++V) {
            switch (f = this.path[V], f[0]) {
              case "L":
                _ = f[1], T = f[2], D = [];
                break;
              case "M":
                _ = f[1], T = f[2], k = _, E = T, D = [];
                break;
              case "C":
                D = l.util.getBoundsOfCurve(
                  _,
                  T,
                  f[1],
                  f[2],
                  f[3],
                  f[4],
                  f[5],
                  f[6]
                ), _ = f[5], T = f[6];
                break;
              case "Q":
                D = l.util.getBoundsOfCurve(
                  _,
                  T,
                  f[1],
                  f[2],
                  f[1],
                  f[2],
                  f[3],
                  f[4]
                ), _ = f[3], T = f[4];
                break;
              case "z":
              case "Z":
                _ = k, T = E;
                break;
            }
            D.forEach(function(de) {
              m.push(de.x), b.push(de.y);
            }), m.push(_), b.push(T);
          }
          var M = p(m) || 0, Q = p(b) || 0, G = v(m) || 0, z = v(b) || 0, re = G - M, he = z - Q;
          return {
            left: M,
            top: Q,
            width: re,
            height: he
          };
        }
      }
    ), l.Path.fromObject = function(m, b) {
      if (typeof m.sourcePath == "string") {
        var f = m.sourcePath;
        l.loadSVGFromURL(f, function(k) {
          var E = k[0];
          E.setOptions(m), m.clipPath ? l.util.enlivenObjects([m.clipPath], function(_) {
            E.clipPath = _[0], b && b(E);
          }) : b && b(E);
        });
      } else
        l.Object._fromObject("Path", m, b, "path");
    }, l.Path.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat(["d"]), l.Path.fromElement = function(m, b, f) {
      var k = l.parseAttributes(m, l.Path.ATTRIBUTE_NAMES);
      k.fromSVG = !0, b(new l.Path(k.d, c(k, f)));
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.array.min, v = l.util.array.max;
    l.Group || (l.Group = l.util.createClass(
      l.Object,
      l.Collection,
      /** @lends fabric.Group.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "group",
        /**
         * Width of stroke
         * @type Number
         * @default
         */
        strokeWidth: 0,
        /**
         * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
         * @type Boolean
         * @default
         */
        subTargetCheck: !1,
        /**
         * Groups are container, do not render anything on theyr own, ence no cache properties
         * @type Array
         * @default
         */
        cacheProperties: [],
        /**
         * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
         * available setting this boolean to true.
         * @type Boolean
         * @since 2.0.0
         * @default
         */
        useSetOnGroup: !1,
        /**
         * Constructor
         * @param {Object} objects Group objects
         * @param {Object} [options] Options object
         * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
         * @return {Object} thisArg
         */
        initialize: function(c, e, h) {
          e = e || {}, this._objects = [], h && this.callSuper("initialize", e), this._objects = c || [];
          for (var m = this._objects.length; m--; )
            this._objects[m].group = this;
          if (h)
            this._updateObjectsACoords();
          else {
            var b = e && e.centerPoint;
            e.originX !== void 0 && (this.originX = e.originX), e.originY !== void 0 && (this.originY = e.originY), b || this._calcBounds(), this._updateObjectsCoords(b), delete e.centerPoint, this.callSuper("initialize", e);
          }
          this.setCoords();
        },
        /**
         * @private
         */
        _updateObjectsACoords: function() {
          for (var c = !0, e = this._objects.length; e--; )
            this._objects[e].setCoords(c);
        },
        /**
         * @private
         * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
         */
        _updateObjectsCoords: function(e) {
          for (var e = e || this.getCenterPoint(), h = this._objects.length; h--; )
            this._updateObjectCoords(this._objects[h], e);
        },
        /**
         * @private
         * @param {Object} object
         * @param {fabric.Point} center, current center of group.
         */
        _updateObjectCoords: function(c, e) {
          var h = c.left, m = c.top, b = !0;
          c.set({
            left: h - e.x,
            top: m - e.y
          }), c.group = this, c.setCoords(b);
        },
        /**
         * Returns string represenation of a group
         * @return {String}
         */
        toString: function() {
          return "#<fabric.Group: (" + this.complexity() + ")>";
        },
        /**
         * Adds an object to a group; Then recalculates group's dimension, position.
         * @param {Object} object
         * @return {fabric.Group} thisArg
         * @chainable
         */
        addWithUpdate: function(c) {
          var e = !!this.group;
          return this._restoreObjectsState(), l.util.resetObjectTransform(this), c && (e && l.util.removeTransformFromObject(c, this.group.calcTransformMatrix()), this._objects.push(c), c.group = this, c._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, e ? this.group.addWithUpdate() : this.setCoords(), this;
        },
        /**
         * Removes an object from a group; Then recalculates group's dimension, position.
         * @param {Object} object
         * @return {fabric.Group} thisArg
         * @chainable
         */
        removeWithUpdate: function(c) {
          return this._restoreObjectsState(), l.util.resetObjectTransform(this), this.remove(c), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this;
        },
        /**
         * @private
         */
        _onObjectAdded: function(c) {
          this.dirty = !0, c.group = this, c._set("canvas", this.canvas);
        },
        /**
         * @private
         */
        _onObjectRemoved: function(c) {
          this.dirty = !0, delete c.group;
        },
        /**
         * @private
         */
        _set: function(c, e) {
          var h = this._objects.length;
          if (this.useSetOnGroup)
            for (; h--; )
              this._objects[h].setOnGroup(c, e);
          if (c === "canvas")
            for (; h--; )
              this._objects[h]._set(c, e);
          l.Object.prototype._set.call(this, c, e);
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(c) {
          var e = this.includeDefaultValues, h = this._objects.filter(function(b) {
            return !b.excludeFromExport;
          }).map(function(b) {
            var f = b.includeDefaultValues;
            b.includeDefaultValues = e;
            var k = b.toObject(c);
            return b.includeDefaultValues = f, k;
          }), m = l.Object.prototype.toObject.call(this, c);
          return m.objects = h, m;
        },
        /**
         * Returns object representation of an instance, in dataless mode.
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toDatalessObject: function(c) {
          var e, h = this.sourcePath;
          if (h)
            e = h;
          else {
            var m = this.includeDefaultValues;
            e = this._objects.map(function(f) {
              var k = f.includeDefaultValues;
              f.includeDefaultValues = m;
              var E = f.toDatalessObject(c);
              return f.includeDefaultValues = k, E;
            });
          }
          var b = l.Object.prototype.toDatalessObject.call(this, c);
          return b.objects = e, b;
        },
        /**
         * Renders instance on a given context
         * @param {CanvasRenderingContext2D} ctx context to render instance on
         */
        render: function(c) {
          this._transformDone = !0, this.callSuper("render", c), this._transformDone = !1;
        },
        /**
         * Decide if the object should cache or not. Create its own cache level
         * needsItsOwnCache should be used when the object drawing method requires
         * a cache step. None of the fabric classes requires it.
         * Generally you do not cache objects in groups because the group is already cached.
         * @return {Boolean}
         */
        shouldCache: function() {
          var c = l.Object.prototype.shouldCache.call(this);
          if (c) {
            for (var e = 0, h = this._objects.length; e < h; e++)
              if (this._objects[e].willDrawShadow())
                return this.ownCaching = !1, !1;
          }
          return c;
        },
        /**
         * Check if this object or a child object will cast a shadow
         * @return {Boolean}
         */
        willDrawShadow: function() {
          if (l.Object.prototype.willDrawShadow.call(this))
            return !0;
          for (var c = 0, e = this._objects.length; c < e; c++)
            if (this._objects[c].willDrawShadow())
              return !0;
          return !1;
        },
        /**
         * Check if this group or its parent group are caching, recursively up
         * @return {Boolean}
         */
        isOnACache: function() {
          return this.ownCaching || this.group && this.group.isOnACache();
        },
        /**
         * Execute the drawing operation for an object on a specified context
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        drawObject: function(c) {
          for (var e = 0, h = this._objects.length; e < h; e++)
            this._objects[e].render(c);
          this._drawClipPath(c, this.clipPath);
        },
        /**
         * Check if cache is dirty
         */
        isCacheDirty: function(c) {
          if (this.callSuper("isCacheDirty", c))
            return !0;
          if (!this.statefullCache)
            return !1;
          for (var e = 0, h = this._objects.length; e < h; e++)
            if (this._objects[e].isCacheDirty(!0)) {
              if (this._cacheCanvas) {
                var m = this.cacheWidth / this.zoomX, b = this.cacheHeight / this.zoomY;
                this._cacheContext.clearRect(-m / 2, -b / 2, m, b);
              }
              return !0;
            }
          return !1;
        },
        /**
         * Restores original state of each of group objects (original state is that which was before group was created).
         * if the nested boolean is true, the original state will be restored just for the
         * first group and not for all the group chain
         * @private
         * @param {Boolean} nested tell the function to restore object state up to the parent group and not more
         * @return {fabric.Group} thisArg
         * @chainable
         */
        _restoreObjectsState: function() {
          var c = this.calcOwnMatrix();
          return this._objects.forEach(function(e) {
            l.util.addTransformToObject(e, c), delete e.group, e.setCoords();
          }), this;
        },
        /**
         * Destroys a group (restoring state of its objects)
         * @return {fabric.Group} thisArg
         * @chainable
         */
        destroy: function() {
          return this._objects.forEach(function(c) {
            c.set("dirty", !0);
          }), this._restoreObjectsState();
        },
        dispose: function() {
          this.callSuper("dispose"), this.forEachObject(function(c) {
            c.dispose && c.dispose();
          }), this._objects = [];
        },
        /**
         * make a group an active selection, remove the group from canvas
         * the group has to be on canvas for this to work.
         * @return {fabric.ActiveSelection} thisArg
         * @chainable
         */
        toActiveSelection: function() {
          if (this.canvas) {
            var c = this._objects, e = this.canvas;
            this._objects = [];
            var h = this.toObject();
            delete h.objects;
            var m = new l.ActiveSelection([]);
            return m.set(h), m.type = "activeSelection", e.remove(this), c.forEach(function(b) {
              b.group = m, b.dirty = !0, e.add(b);
            }), m.canvas = e, m._objects = c, e._activeObject = m, m.setCoords(), m;
          }
        },
        /**
         * Destroys a group (restoring state of its objects)
         * @return {fabric.Group} thisArg
         * @chainable
         */
        ungroupOnCanvas: function() {
          return this._restoreObjectsState();
        },
        /**
         * Sets coordinates of all objects inside group
         * @return {fabric.Group} thisArg
         * @chainable
         */
        setObjectsCoords: function() {
          var c = !0;
          return this.forEachObject(function(e) {
            e.setCoords(c);
          }), this;
        },
        /**
         * @private
         */
        _calcBounds: function(c) {
          for (var e = [], h = [], m, b, f, k = ["tr", "br", "bl", "tl"], E = 0, _ = this._objects.length, T, D = k.length; E < _; ++E) {
            for (m = this._objects[E], f = m.calcACoords(), T = 0; T < D; T++)
              b = k[T], e.push(f[b].x), h.push(f[b].y);
            m.aCoords = f;
          }
          this._getBounds(e, h, c);
        },
        /**
         * @private
         */
        _getBounds: function(c, e, h) {
          var m = new l.Point(p(c), p(e)), b = new l.Point(v(c), v(e)), f = m.y || 0, k = m.x || 0, E = b.x - m.x || 0, _ = b.y - m.y || 0;
          this.width = E, this.height = _, h || this.setPositionByOrigin({ x: k, y: f }, "left", "top");
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        _toSVG: function(c) {
          for (var e = ["<g ", "COMMON_PARTS", ` >
`], h = 0, m = this._objects.length; h < m; h++)
            e.push("		", this._objects[h].toSVG(c));
          return e.push(`</g>
`), e;
        },
        /**
         * Returns styles-string for svg-export, specific version for group
         * @return {String}
         */
        getSvgStyles: function() {
          var c = typeof this.opacity < "u" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", e = this.visible ? "" : " visibility: hidden;";
          return [
            c,
            this.getSvgFilter(),
            e
          ].join("");
        },
        /**
         * Returns svg clipPath representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toClipPathSVG: function(c) {
          for (var e = [], h = 0, m = this._objects.length; h < m; h++)
            e.push("	", this._objects[h].toClipPathSVG(c));
          return this._createBaseClipPathSVGMarkup(e, { reviver: c });
        }
        /* _TO_SVG_END_ */
      }
    ), l.Group.fromObject = function(c, e) {
      var h = c.objects, m = l.util.object.clone(c, !0);
      if (delete m.objects, typeof h == "string") {
        l.loadSVGFromURL(h, function(b) {
          var f = l.util.groupSVGElements(b, c, h), k = m.clipPath;
          delete m.clipPath, f.set(m), k ? l.util.enlivenObjects([k], function(E) {
            f.clipPath = E[0], e && e(f);
          }) : e && e(f);
        });
        return;
      }
      l.util.enlivenObjects(h, function(b) {
        l.util.enlivenObjectEnlivables(c, m, function() {
          e && e(new l.Group(b, m, !0));
        });
      });
    });
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {});
    l.ActiveSelection || (l.ActiveSelection = l.util.createClass(
      l.Group,
      /** @lends fabric.ActiveSelection.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "activeSelection",
        /**
         * Constructor
         * @param {Object} objects ActiveSelection objects
         * @param {Object} [options] Options object
         * @return {Object} thisArg
         */
        initialize: function(p, v) {
          v = v || {}, this._objects = p || [];
          for (var c = this._objects.length; c--; )
            this._objects[c].group = this;
          v.originX && (this.originX = v.originX), v.originY && (this.originY = v.originY), this._calcBounds(), this._updateObjectsCoords(), l.Object.prototype.initialize.call(this, v), this.setCoords();
        },
        /**
         * Change te activeSelection to a normal group,
         * High level function that automatically adds it to canvas as
         * active object. no events fired.
         * @since 2.0.0
         * @return {fabric.Group}
         */
        toGroup: function() {
          var p = this._objects.concat();
          this._objects = [];
          var v = l.Object.prototype.toObject.call(this), c = new l.Group([]);
          if (delete v.type, c.set(v), p.forEach(function(h) {
            h.canvas.remove(h), h.group = c;
          }), c._objects = p, !this.canvas)
            return c;
          var e = this.canvas;
          return e.add(c), e._activeObject = c, c.setCoords(), c;
        },
        /**
         * If returns true, deselection is cancelled.
         * @since 2.0.0
         * @return {Boolean} [cancel]
         */
        onDeselect: function() {
          return this.destroy(), !1;
        },
        /**
         * Returns string representation of a group
         * @return {String}
         */
        toString: function() {
          return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
        },
        /**
         * Decide if the object should cache or not. Create its own cache level
         * objectCaching is a global flag, wins over everything
         * needsItsOwnCache should be used when the object drawing method requires
         * a cache step. None of the fabric classes requires it.
         * Generally you do not cache objects in groups because the group outside is cached.
         * @return {Boolean}
         */
        shouldCache: function() {
          return !1;
        },
        /**
         * Check if this group or its parent group are caching, recursively up
         * @return {Boolean}
         */
        isOnACache: function() {
          return !1;
        },
        /**
         * Renders controls and borders for the object
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Object} [styleOverride] properties to override the object style
         * @param {Object} [childrenOverride] properties to override the children overrides
         */
        _renderControls: function(p, v, c) {
          p.save(), p.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", p, v), c = c || {}, typeof c.hasControls > "u" && (c.hasControls = !1), c.forActiveSelection = !0;
          for (var e = 0, h = this._objects.length; e < h; e++)
            this._objects[e]._renderControls(p, c);
          p.restore();
        }
      }
    ), l.ActiveSelection.fromObject = function(p, v) {
      l.util.enlivenObjects(p.objects, function(c) {
        delete p.objects, v && v(new l.ActiveSelection(c, p, !0));
      });
    });
  }(i), function(d) {
    var l = n.util.object.extend;
    if (d.fabric || (d.fabric = {}), d.fabric.Image) {
      n.warn("fabric.Image is already defined.");
      return;
    }
    n.Image = n.util.createClass(
      n.Object,
      /** @lends fabric.Image.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "image",
        /**
         * Width of a stroke.
         * For image quality a stroke multiple of 2 gives better results.
         * @type Number
         * @default
         */
        strokeWidth: 0,
        /**
         * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
         * This allows for relative urls as image src.
         * @since 2.7.0
         * @type Boolean
         * @default
         */
        srcFromAttribute: !1,
        /**
         * private
         * contains last value of scaleX to detect
         * if the Image got resized after the last Render
         * @type Number
         */
        _lastScaleX: 1,
        /**
         * private
         * contains last value of scaleY to detect
         * if the Image got resized after the last Render
         * @type Number
         */
        _lastScaleY: 1,
        /**
         * private
         * contains last value of scaling applied by the apply filter chain
         * @type Number
         */
        _filterScalingX: 1,
        /**
         * private
         * contains last value of scaling applied by the apply filter chain
         * @type Number
         */
        _filterScalingY: 1,
        /**
         * minimum scale factor under which any resizeFilter is triggered to resize the image
         * 0 will disable the automatic resize. 1 will trigger automatically always.
         * number bigger than 1 are not implemented yet.
         * @type Number
         */
        minimumScaleTrigger: 0.5,
        /**
         * List of properties to consider when checking if
         * state of an object is changed ({@link fabric.Object#hasStateChanged})
         * as well as for history (undo/redo) purposes
         * @type Array
         */
        stateProperties: n.Object.prototype.stateProperties.concat("cropX", "cropY"),
        /**
         * List of properties to consider when checking if cache needs refresh
         * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
         * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
         * and refreshed at the next render
         * @type Array
         */
        cacheProperties: n.Object.prototype.cacheProperties.concat("cropX", "cropY"),
        /**
         * key used to retrieve the texture representing this image
         * @since 2.0.0
         * @type String
         * @default
         */
        cacheKey: "",
        /**
         * Image crop in pixels from original image size.
         * @since 2.0.0
         * @type Number
         * @default
         */
        cropX: 0,
        /**
         * Image crop in pixels from original image size.
         * @since 2.0.0
         * @type Number
         * @default
         */
        cropY: 0,
        /**
         * Indicates whether this canvas will use image smoothing when painting this image.
         * Also influence if the cacheCanvas for this image uses imageSmoothing
         * @since 4.0.0-beta.11
         * @type Boolean
         * @default
         */
        imageSmoothing: !0,
        /**
         * Constructor
         * Image can be initialized with any canvas drawable or a string.
         * The string should be a url and will be loaded as an image.
         * Canvas and Image element work out of the box, while videos require extra code to work.
         * Please check video element events for seeking.
         * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element
         * @param {Object} [options] Options object
         * @param {function} [callback] callback function to call after eventual filters applied.
         * @return {fabric.Image} thisArg
         */
        initialize: function(p, v) {
          v || (v = {}), this.filters = [], this.cacheKey = "texture" + n.Object.__uid++, this.callSuper("initialize", v), this._initElement(p, v);
        },
        /**
         * Returns image element which this instance if based on
         * @return {HTMLImageElement} Image element
         */
        getElement: function() {
          return this._element || {};
        },
        /**
         * Sets image element for this instance to a specified one.
         * If filters defined they are applied to new image.
         * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
         * @param {HTMLImageElement} element
         * @param {Object} [options] Options object
         * @return {fabric.Image} thisArg
         * @chainable
         */
        setElement: function(p, v) {
          return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = p, this._originalElement = p, this._initConfig(v), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this;
        },
        /**
         * Delete a single texture if in webgl mode
         */
        removeTexture: function(p) {
          var v = n.filterBackend;
          v && v.evictCachesForKey && v.evictCachesForKey(p);
        },
        /**
         * Delete textures, reference to elements and eventually JSDOM cleanup
         */
        dispose: function() {
          this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((function(p) {
            n.util.cleanUpJsdomNode(this[p]), this[p] = void 0;
          }).bind(this));
        },
        /**
         * Get the crossOrigin value (of the corresponding image element)
         */
        getCrossOrigin: function() {
          return this._originalElement && (this._originalElement.crossOrigin || null);
        },
        /**
         * Returns original size of an image
         * @return {Object} Object with "width" and "height" properties
         */
        getOriginalSize: function() {
          var p = this.getElement();
          return {
            width: p.naturalWidth || p.width,
            height: p.naturalHeight || p.height
          };
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _stroke: function(p) {
          if (!(!this.stroke || this.strokeWidth === 0)) {
            var v = this.width / 2, c = this.height / 2;
            p.beginPath(), p.moveTo(-v, -c), p.lineTo(v, -c), p.lineTo(v, c), p.lineTo(-v, c), p.lineTo(-v, -c), p.closePath();
          }
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of an instance
         */
        toObject: function(p) {
          var v = [];
          this.filters.forEach(function(e) {
            e && v.push(e.toObject());
          });
          var c = l(
            this.callSuper(
              "toObject",
              ["cropX", "cropY"].concat(p)
            ),
            {
              src: this.getSrc(),
              crossOrigin: this.getCrossOrigin(),
              filters: v
            }
          );
          return this.resizeFilter && (c.resizeFilter = this.resizeFilter.toObject()), c;
        },
        /**
         * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.
         * @return {Boolean}
         */
        hasCrop: function() {
          return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
        },
        /* _TO_SVG_START_ */
        /**
         * Returns svg representation of an instance
         * @return {Array} an array of strings with the specific svg representation
         * of the instance
         */
        _toSVG: function() {
          var p = [], v = [], c, e = this._element, h = -this.width / 2, m = -this.height / 2, b = "", f = "";
          if (!e)
            return [];
          if (this.hasCrop()) {
            var k = n.Object.__uid++;
            p.push(
              '<clipPath id="imageCrop_' + k + `">
`,
              '	<rect x="' + h + '" y="' + m + '" width="' + this.width + '" height="' + this.height + `" />
`,
              `</clipPath>
`
            ), b = ' clip-path="url(#imageCrop_' + k + ')" ';
          }
          if (this.imageSmoothing || (f = '" image-rendering="optimizeSpeed'), v.push(
            "	<image ",
            "COMMON_PARTS",
            'xlink:href="',
            this.getSvgSrc(!0),
            '" x="',
            h - this.cropX,
            '" y="',
            m - this.cropY,
            // we're essentially moving origin of transformation from top/left corner to the center of the shape
            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
            // so that object's center aligns with container's left/top
            '" width="',
            e.width || e.naturalWidth,
            '" height="',
            e.height || e.height,
            f,
            '"',
            b,
            `></image>
`
          ), this.stroke || this.strokeDashArray) {
            var E = this.fill;
            this.fill = null, c = [
              "	<rect ",
              'x="',
              h,
              '" y="',
              m,
              '" width="',
              this.width,
              '" height="',
              this.height,
              '" style="',
              this.getSvgStyles(),
              `"/>
`
            ], this.fill = E;
          }
          return this.paintFirst !== "fill" ? p = p.concat(c, v) : p = p.concat(v, c), p;
        },
        /* _TO_SVG_END_ */
        /**
         * Returns source of an image
         * @param {Boolean} filtered indicates if the src is needed for svg
         * @return {String} Source of an image
         */
        getSrc: function(p) {
          var v = p ? this._element : this._originalElement;
          return v ? v.toDataURL ? v.toDataURL() : this.srcFromAttribute ? v.getAttribute("src") : v.src : this.src || "";
        },
        /**
         * Sets source of an image
         * @param {String} src Source string (URL)
         * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
         * @param {Object} [options] Options object
         * @param {String} [options.crossOrigin] crossOrigin value (one of "", "anonymous", "use-credentials")
         * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
         * @return {fabric.Image} thisArg
         * @chainable
         */
        setSrc: function(p, v, c) {
          return n.util.loadImage(p, function(e, h) {
            this.setElement(e, c), this._setWidthHeight(), v && v(this, h);
          }, this, c && c.crossOrigin), this;
        },
        /**
         * Returns string representation of an instance
         * @return {String} String representation of an instance
         */
        toString: function() {
          return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
        },
        applyResizeFilters: function() {
          var p = this.resizeFilter, v = this.minimumScaleTrigger, c = this.getTotalObjectScaling(), e = c.scaleX, h = c.scaleY, m = this._filteredEl || this._originalElement;
          if (this.group && this.set("dirty", !0), !p || e > v && h > v) {
            this._element = m, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = e, this._lastScaleY = h;
            return;
          }
          n.filterBackend || (n.filterBackend = n.initFilterBackend());
          var b = n.util.createCanvasElement(), f = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, k = m.width, E = m.height;
          b.width = k, b.height = E, this._element = b, this._lastScaleX = p.scaleX = e, this._lastScaleY = p.scaleY = h, n.filterBackend.applyFilters(
            [p],
            m,
            k,
            E,
            this._element,
            f
          ), this._filterScalingX = b.width / this._originalElement.width, this._filterScalingY = b.height / this._originalElement.height;
        },
        /**
         * Applies filters assigned to this image (from "filters" array) or from filter param
         * @method applyFilters
         * @param {Array} filters to be applied
         * @param {Boolean} forResizing specify if the filter operation is a resize operation
         * @return {thisArg} return the fabric.Image object
         * @chainable
         */
        applyFilters: function(p) {
          if (p = p || this.filters || [], p = p.filter(function(m) {
            return m && !m.isNeutralState();
          }), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), p.length === 0)
            return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this;
          var v = this._originalElement, c = v.naturalWidth || v.width, e = v.naturalHeight || v.height;
          if (this._element === this._originalElement) {
            var h = n.util.createCanvasElement();
            h.width = c, h.height = e, this._element = h, this._filteredEl = h;
          } else
            this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, c, e), this._lastScaleX = 1, this._lastScaleY = 1;
          return n.filterBackend || (n.filterBackend = n.initFilterBackend()), n.filterBackend.applyFilters(
            p,
            this._originalElement,
            c,
            e,
            this._element,
            this.cacheKey
          ), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this;
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(p) {
          n.util.setImageSmoothing(p, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(p), this._renderPaintInOrder(p);
        },
        /**
         * Paint the cached copy of the object on the target context.
         * it will set the imageSmoothing for the draw operation
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        drawCacheOnCanvas: function(p) {
          n.util.setImageSmoothing(p, this.imageSmoothing), n.Object.prototype.drawCacheOnCanvas.call(this, p);
        },
        /**
         * Decide if the object should cache or not. Create its own cache level
         * needsItsOwnCache should be used when the object drawing method requires
         * a cache step. None of the fabric classes requires it.
         * Generally you do not cache objects in groups because the group outside is cached.
         * This is the special image version where we would like to avoid caching where possible.
         * Essentially images do not benefit from caching. They may require caching, and in that
         * case we do it. Also caching an image usually ends in a loss of details.
         * A full performance audit should be done.
         * @return {Boolean}
         */
        shouldCache: function() {
          return this.needsItsOwnCache();
        },
        _renderFill: function(p) {
          var v = this._element;
          if (v) {
            var c = this._filterScalingX, e = this._filterScalingY, h = this.width, m = this.height, b = Math.min, f = Math.max, k = f(this.cropX, 0), E = f(this.cropY, 0), _ = v.naturalWidth || v.width, T = v.naturalHeight || v.height, D = k * c, V = E * e, I = b(h * c, _ - D), M = b(m * e, T - V), Q = -h / 2, G = -m / 2, z = b(h, _ / c - k), re = b(m, T / e - E);
            v && p.drawImage(v, D, V, I, M, Q, G, z, re);
          }
        },
        /**
         * needed to check if image needs resize
         * @private
         */
        _needsResize: function() {
          var p = this.getTotalObjectScaling();
          return p.scaleX !== this._lastScaleX || p.scaleY !== this._lastScaleY;
        },
        /**
         * @private
         */
        _resetWidthHeight: function() {
          this.set(this.getOriginalSize());
        },
        /**
         * The Image class's initialization method. This method is automatically
         * called by the constructor.
         * @private
         * @param {HTMLImageElement|String} element The element representing the image
         * @param {Object} [options] Options object
         */
        _initElement: function(p, v) {
          this.setElement(n.util.getById(p), v), n.util.addClass(this.getElement(), n.Image.CSS_CANVAS);
        },
        /**
         * @private
         * @param {Object} [options] Options object
         */
        _initConfig: function(p) {
          p || (p = {}), this.setOptions(p), this._setWidthHeight(p);
        },
        /**
         * @private
         * @param {Array} filters to be initialized
         * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
         */
        _initFilters: function(p, v) {
          p && p.length ? n.util.enlivenObjects(p, function(c) {
            v && v(c);
          }, "fabric.Image.filters") : v && v();
        },
        /**
         * @private
         * Set the width and the height of the image object, using the element or the
         * options.
         * @param {Object} [options] Object with width/height properties
         */
        _setWidthHeight: function(p) {
          p || (p = {});
          var v = this.getElement();
          this.width = p.width || v.naturalWidth || v.width || 0, this.height = p.height || v.naturalHeight || v.height || 0;
        },
        /**
         * Calculate offset for center and scale factor for the image in order to respect
         * the preserveAspectRatio attribute
         * @private
         * @return {Object}
         */
        parsePreserveAspectRatioAttribute: function() {
          var p = n.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), v = this._element.width, c = this._element.height, e = 1, h = 1, m = 0, b = 0, f = 0, k = 0, E, _ = this.width, T = this.height, D = { width: _, height: T };
          return p && (p.alignX !== "none" || p.alignY !== "none") ? (p.meetOrSlice === "meet" && (e = h = n.util.findScaleToFit(this._element, D), E = (_ - v * e) / 2, p.alignX === "Min" && (m = -E), p.alignX === "Max" && (m = E), E = (T - c * h) / 2, p.alignY === "Min" && (b = -E), p.alignY === "Max" && (b = E)), p.meetOrSlice === "slice" && (e = h = n.util.findScaleToCover(this._element, D), E = v - _ / e, p.alignX === "Mid" && (f = E / 2), p.alignX === "Max" && (f = E), E = c - T / h, p.alignY === "Mid" && (k = E / 2), p.alignY === "Max" && (k = E), v = _ / e, c = T / h)) : (e = _ / v, h = T / c), {
            width: v,
            height: c,
            scaleX: e,
            scaleY: h,
            offsetLeft: m,
            offsetTop: b,
            cropX: f,
            cropY: k
          };
        }
      }
    ), n.Image.CSS_CANVAS = "canvas-img", n.Image.prototype.getSvgSrc = n.Image.prototype.getSrc, n.Image.fromObject = function(p, v) {
      var c = n.util.object.clone(p);
      n.util.loadImage(c.src, function(e, h) {
        if (h) {
          v && v(null, !0);
          return;
        }
        n.Image.prototype._initFilters.call(c, c.filters, function(m) {
          c.filters = m || [], n.Image.prototype._initFilters.call(c, [c.resizeFilter], function(b) {
            c.resizeFilter = b[0], n.util.enlivenObjectEnlivables(c, c, function() {
              var f = new n.Image(e, c);
              v(f, !1);
            });
          });
        });
      }, null, c.crossOrigin);
    }, n.Image.fromURL = function(p, v, c) {
      n.util.loadImage(p, function(e, h) {
        v && v(new n.Image(e, c), h);
      }, null, c && c.crossOrigin);
    }, n.Image.ATTRIBUTE_NAMES = n.SHARED_ATTRIBUTES.concat(
      "x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")
    ), n.Image.fromElement = function(p, v, c) {
      var e = n.parseAttributes(p, n.Image.ATTRIBUTE_NAMES);
      n.Image.fromURL(
        e["xlink:href"],
        v,
        l(c ? n.util.object.clone(c) : {}, e)
      );
    };
  }(i), n.util.object.extend(
    n.Object.prototype,
    /** @lends fabric.Object.prototype */
    {
      /**
       * @private
       * @return {Number} angle value
       */
      _getAngleValueForStraighten: function() {
        var d = this.angle % 360;
        return d > 0 ? Math.round((d - 1) / 90) * 90 : Math.round(d / 90) * 90;
      },
      /**
       * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      straighten: function() {
        return this.rotate(this._getAngleValueForStraighten());
      },
      /**
       * Same as {@link fabric.Object.prototype.straighten} but with animation
       * @param {Object} callbacks Object with callback functions
       * @param {Function} [callbacks.onComplete] Invoked on completion
       * @param {Function} [callbacks.onChange] Invoked on every step of animation
       * @return {fabric.Object} thisArg
       */
      fxStraighten: function(d) {
        d = d || {};
        var l = function() {
        }, p = d.onComplete || l, v = d.onChange || l, c = this;
        return n.util.animate({
          target: this,
          startValue: this.get("angle"),
          endValue: this._getAngleValueForStraighten(),
          duration: this.FX_DURATION,
          onChange: function(e) {
            c.rotate(e), v();
          },
          onComplete: function() {
            c.setCoords(), p();
          }
        });
      }
    }
  ), n.util.object.extend(
    n.StaticCanvas.prototype,
    /** @lends fabric.StaticCanvas.prototype */
    {
      /**
       * Straightens object, then rerenders canvas
       * @param {fabric.Object} object Object to straighten
       * @return {fabric.Canvas} thisArg
       * @chainable
       */
      straightenObject: function(d) {
        return d.straighten(), this.requestRenderAll(), this;
      },
      /**
       * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
       * @param {fabric.Object} object Object to straighten
       * @return {fabric.Canvas} thisArg
       */
      fxStraightenObject: function(d) {
        return d.fxStraighten({
          onChange: this.requestRenderAllBound
        });
      }
    }
  ), function() {
    function d(p, v) {
      var c = "precision " + v + ` float;
void main(){}`, e = p.createShader(p.FRAGMENT_SHADER);
      return p.shaderSource(e, c), p.compileShader(e), !!p.getShaderParameter(e, p.COMPILE_STATUS);
    }
    n.isWebglSupported = function(p) {
      if (n.isLikelyNode)
        return !1;
      p = p || n.WebglFilterBackend.prototype.tileSize;
      var v = document.createElement("canvas"), c = v.getContext("webgl") || v.getContext("experimental-webgl"), e = !1;
      if (c) {
        n.maxTextureSize = c.getParameter(c.MAX_TEXTURE_SIZE), e = n.maxTextureSize >= p;
        for (var h = ["highp", "mediump", "lowp"], m = 0; m < 3; m++)
          if (d(c, h[m])) {
            n.webGlPrecision = h[m];
            break;
          }
      }
      return this.isSupported = e, e;
    }, n.WebglFilterBackend = l;
    function l(p) {
      p && p.tileSize && (this.tileSize = p.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo();
    }
    l.prototype = /** @lends fabric.WebglFilterBackend.prototype */
    {
      tileSize: 2048,
      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you probably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {},
      /**
       * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
       */
      setupGLContext: function(p, v) {
        this.dispose(), this.createWebGLCanvas(p, v), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(p, v);
      },
      /**
       * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
       * putImageData is faster than drawImage for that specific operation.
       */
      chooseFastestCopyGLTo2DMethod: function(p, v) {
        var c = typeof window.performance < "u", e;
        try {
          new ImageData(1, 1), e = !0;
        } catch {
          e = !1;
        }
        var h = typeof ArrayBuffer < "u", m = typeof Uint8ClampedArray < "u";
        if (c && e && h && m) {
          var b = n.util.createCanvasElement(), f = new ArrayBuffer(p * v * 4);
          if (n.forceGLPutImageData) {
            this.imageBuffer = f, this.copyGLTo2D = S;
            return;
          }
          var k = {
            imageBuffer: f,
            destinationWidth: p,
            destinationHeight: v,
            targetCanvas: b
          }, E, _, T;
          b.width = p, b.height = v, E = window.performance.now(), w.call(k, this.gl, k), _ = window.performance.now() - E, E = window.performance.now(), S.call(k, this.gl, k), T = window.performance.now() - E, _ > T ? (this.imageBuffer = f, this.copyGLTo2D = S) : this.copyGLTo2D = w;
        }
      },
      /**
       * Create a canvas element and associated WebGL context and attaches them as
       * class properties to the GLFilterBackend class.
       */
      createWebGLCanvas: function(p, v) {
        var c = n.util.createCanvasElement();
        c.width = p, c.height = v;
        var e = {
          alpha: !0,
          premultipliedAlpha: !1,
          depth: !1,
          stencil: !1,
          antialias: !1
        }, h = c.getContext("webgl", e);
        h || (h = c.getContext("experimental-webgl", e)), h && (h.clearColor(0, 0, 0, 0), this.canvas = c, this.gl = h);
      },
      /**
       * Attempts to apply the requested filters to the source provided, drawing the filtered output
       * to the provided target canvas.
       *
       * @param {Array} filters The filters to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
       * @param {Number} width The width of the source input.
       * @param {Number} height The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
       * omitted, caching will be skipped.
       */
      applyFilters: function(p, v, c, e, h, m) {
        var b = this.gl, f;
        m && (f = this.getCachedTexture(m, v));
        var k = {
          originalWidth: v.width || v.originalWidth,
          originalHeight: v.height || v.originalHeight,
          sourceWidth: c,
          sourceHeight: e,
          destinationWidth: c,
          destinationHeight: e,
          context: b,
          sourceTexture: this.createTexture(b, c, e, !f && v),
          targetTexture: this.createTexture(b, c, e),
          originalTexture: f || this.createTexture(b, c, e, !f && v),
          passes: p.length,
          webgl: !0,
          aPosition: this.aPosition,
          programCache: this.programCache,
          pass: 0,
          filterBackend: this,
          targetCanvas: h
        }, E = b.createFramebuffer();
        return b.bindFramebuffer(b.FRAMEBUFFER, E), p.forEach(function(_) {
          _ && _.applyTo(k);
        }), y(k), this.copyGLTo2D(b, k), b.bindTexture(b.TEXTURE_2D, null), b.deleteTexture(k.sourceTexture), b.deleteTexture(k.targetTexture), b.deleteFramebuffer(E), h.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), k;
      },
      /**
       * Detach event listeners, remove references, and clean up caches.
       */
      dispose: function() {
        this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
      },
      /**
       * Wipe out WebGL-related caches.
       */
      clearWebGLCaches: function() {
        this.programCache = {}, this.textureCache = {};
      },
      /**
       * Create a WebGL texture object.
       *
       * Accepts specific dimensions to initialize the texture to or a source image.
       *
       * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
       * @param {Number} width The width to initialize the texture at.
       * @param {Number} height The height to initialize the texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
       * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants
       * @returns {WebGLTexture}
       */
      createTexture: function(p, v, c, e, h) {
        var m = p.createTexture();
        return p.bindTexture(p.TEXTURE_2D, m), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, h || p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, h || p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), e ? p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, p.RGBA, p.UNSIGNED_BYTE, e) : p.texImage2D(p.TEXTURE_2D, 0, p.RGBA, v, c, 0, p.RGBA, p.UNSIGNED_BYTE, null), m;
      },
      /**
       * Can be optionally used to get a texture from the cache array
       *
       * If an existing texture is not found, a new texture is created and cached.
       *
       * @param {String} uniqueId A cache key to use to find an existing texture.
       * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
       * texture cache entry if one does not already exist.
       */
      getCachedTexture: function(p, v) {
        if (this.textureCache[p])
          return this.textureCache[p];
        var c = this.createTexture(
          this.gl,
          v.width,
          v.height,
          v
        );
        return this.textureCache[p] = c, c;
      },
      /**
       * Clear out cached resources related to a source image that has been
       * filtered previously.
       *
       * @param {String} cacheKey The cache key provided when the source image was filtered.
       */
      evictCachesForKey: function(p) {
        this.textureCache[p] && (this.gl.deleteTexture(this.textureCache[p]), delete this.textureCache[p]);
      },
      copyGLTo2D: w,
      /**
       * Attempt to extract GPU information strings from a WebGL context.
       *
       * Useful information when debugging or blacklisting specific GPUs.
       *
       * @returns {Object} A GPU info object with renderer and vendor strings.
       */
      captureGPUInfo: function() {
        if (this.gpuInfo)
          return this.gpuInfo;
        var p = this.gl, v = { renderer: "", vendor: "" };
        if (!p)
          return v;
        var c = p.getExtension("WEBGL_debug_renderer_info");
        if (c) {
          var e = p.getParameter(c.UNMASKED_RENDERER_WEBGL), h = p.getParameter(c.UNMASKED_VENDOR_WEBGL);
          e && (v.renderer = e.toLowerCase()), h && (v.vendor = h.toLowerCase());
        }
        return this.gpuInfo = v, v;
      }
    };
  }();
  function y(d) {
    var l = d.targetCanvas, p = l.width, v = l.height, c = d.destinationWidth, e = d.destinationHeight;
    (p !== c || v !== e) && (l.width = c, l.height = e);
  }
  function w(d, l) {
    var p = d.canvas, v = l.targetCanvas, c = v.getContext("2d");
    c.translate(0, v.height), c.scale(1, -1);
    var e = p.height - v.height;
    c.drawImage(
      p,
      0,
      e,
      v.width,
      v.height,
      0,
      0,
      v.width,
      v.height
    );
  }
  function S(d, l) {
    var p = l.targetCanvas, v = p.getContext("2d"), c = l.destinationWidth, e = l.destinationHeight, h = c * e * 4, m = new Uint8Array(this.imageBuffer, 0, h), b = new Uint8ClampedArray(this.imageBuffer, 0, h);
    d.readPixels(0, 0, c, e, d.RGBA, d.UNSIGNED_BYTE, m);
    var f = new ImageData(b, c, e);
    v.putImageData(f, 0, 0);
  }
  (function() {
    var d = function() {
    };
    n.Canvas2dFilterBackend = l;
    function l() {
    }
    l.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */
    {
      evictCachesForKey: d,
      dispose: d,
      clearWebGLCaches: d,
      /**
       * Experimental. This object is a sort of repository of help layers used to avoid
       * of recreating them during frequent filtering. If you are previewing a filter with
       * a slider you probably do not want to create help layers every filter step.
       * in this object there will be appended some canvases, created once, resized sometimes
       * cleared never. Clearing is left to the developer.
       **/
      resources: {},
      /**
       * Apply a set of filters against a source image and draw the filtered output
       * to the provided destination canvas.
       *
       * @param {EnhancedFilter} filters The filter to apply.
       * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
       * @param {Number} sourceWidth The width of the source input.
       * @param {Number} sourceHeight The height of the source input.
       * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
       */
      applyFilters: function(p, v, c, e, h) {
        var m = h.getContext("2d");
        m.drawImage(v, 0, 0, c, e);
        var b = m.getImageData(0, 0, c, e), f = m.getImageData(0, 0, c, e), k = {
          sourceWidth: c,
          sourceHeight: e,
          imageData: b,
          originalEl: v,
          originalImageData: f,
          canvasEl: h,
          ctx: m,
          filterBackend: this
        };
        return p.forEach(function(E) {
          E.applyTo(k);
        }), (k.imageData.width !== c || k.imageData.height !== e) && (h.width = k.imageData.width, h.height = k.imageData.height), m.putImageData(k.imageData, 0, 0), k;
      }
    };
  })(), n.Image = n.Image || {}, n.Image.filters = n.Image.filters || {}, n.Image.filters.BaseFilter = n.util.createClass(
    /** @lends fabric.Image.filters.BaseFilter.prototype */
    {
      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: "BaseFilter",
      /**
       * Array of attributes to send with buffers. do not modify
       * @private
       */
      vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
void main() {
vTexCoord = aPosition;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`,
      fragmentSource: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D uTexture;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
}`,
      /**
       * Constructor
       * @param {Object} [options] Options object
       */
      initialize: function(d) {
        d && this.setOptions(d);
      },
      /**
       * Sets filter's properties from options
       * @param {Object} [options] Options object
       */
      setOptions: function(d) {
        for (var l in d)
          this[l] = d[l];
      },
      /**
       * Compile this filter's shader program.
       *
       * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
       * @param {String} fragmentSource fragmentShader source for compilation
       * @param {String} vertexSource vertexShader source for compilation
       */
      createProgram: function(d, l, p) {
        l = l || this.fragmentSource, p = p || this.vertexSource, n.webGlPrecision !== "highp" && (l = l.replace(
          /precision highp float/g,
          "precision " + n.webGlPrecision + " float"
        ));
        var v = d.createShader(d.VERTEX_SHADER);
        if (d.shaderSource(v, p), d.compileShader(v), !d.getShaderParameter(v, d.COMPILE_STATUS))
          throw new Error(
            // eslint-disable-next-line prefer-template
            "Vertex shader compile error for " + this.type + ": " + d.getShaderInfoLog(v)
          );
        var c = d.createShader(d.FRAGMENT_SHADER);
        if (d.shaderSource(c, l), d.compileShader(c), !d.getShaderParameter(c, d.COMPILE_STATUS))
          throw new Error(
            // eslint-disable-next-line prefer-template
            "Fragment shader compile error for " + this.type + ": " + d.getShaderInfoLog(c)
          );
        var e = d.createProgram();
        if (d.attachShader(e, v), d.attachShader(e, c), d.linkProgram(e), !d.getProgramParameter(e, d.LINK_STATUS))
          throw new Error(
            // eslint-disable-next-line prefer-template
            'Shader link error for "${this.type}" ' + d.getProgramInfoLog(e)
          );
        var h = this.getAttributeLocations(d, e), m = this.getUniformLocations(d, e) || {};
        return m.uStepW = d.getUniformLocation(e, "uStepW"), m.uStepH = d.getUniformLocation(e, "uStepH"), {
          program: e,
          attributeLocations: h,
          uniformLocations: m
        };
      },
      /**
       * Return a map of attribute names to WebGLAttributeLocation objects.
       *
       * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
       * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
       * @returns {Object} A map of attribute names to attribute locations.
       */
      getAttributeLocations: function(d, l) {
        return {
          aPosition: d.getAttribLocation(l, "aPosition")
        };
      },
      /**
       * Return a map of uniform names to WebGLUniformLocation objects.
       *
       * Intended to be overridden by subclasses.
       *
       * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
       * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
       * @returns {Object} A map of uniform names to uniform locations.
       */
      getUniformLocations: function() {
        return {};
      },
      /**
       * Send attribute data from this filter to its shader program on the GPU.
       *
       * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
       * @param {Object} attributeLocations A map of shader attribute names to their locations.
       */
      sendAttributeData: function(d, l, p) {
        var v = l.aPosition, c = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, c), d.enableVertexAttribArray(v), d.vertexAttribPointer(v, 2, d.FLOAT, !1, 0, 0), d.bufferData(d.ARRAY_BUFFER, p, d.STATIC_DRAW);
      },
      _setupFrameBuffer: function(d) {
        var l = d.context, p, v;
        d.passes > 1 ? (p = d.destinationWidth, v = d.destinationHeight, (d.sourceWidth !== p || d.sourceHeight !== v) && (l.deleteTexture(d.targetTexture), d.targetTexture = d.filterBackend.createTexture(l, p, v)), l.framebufferTexture2D(
          l.FRAMEBUFFER,
          l.COLOR_ATTACHMENT0,
          l.TEXTURE_2D,
          d.targetTexture,
          0
        )) : (l.bindFramebuffer(l.FRAMEBUFFER, null), l.finish());
      },
      _swapTextures: function(d) {
        d.passes--, d.pass++;
        var l = d.targetTexture;
        d.targetTexture = d.sourceTexture, d.sourceTexture = l;
      },
      /**
       * Generic isNeutral implementation for one parameter based filters.
       * Used only in image applyFilters to discard filters that will not have an effect
       * on the image
       * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )
       * @param {Object} options
       **/
      isNeutralState: function() {
        var d = this.mainParameter, l = n.Image.filters[this.type].prototype;
        if (d)
          if (Array.isArray(l[d])) {
            for (var p = l[d].length; p--; )
              if (this[d][p] !== l[d][p])
                return !1;
            return !0;
          } else
            return l[d] === this[d];
        else
          return !1;
      },
      /**
       * Apply this filter to the input image data provided.
       *
       * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyTo: function(d) {
        d.webgl ? (this._setupFrameBuffer(d), this.applyToWebGL(d), this._swapTextures(d)) : this.applyTo2d(d);
      },
      /**
       * Retrieves the cached shader.
       * @param {Object} options
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      retrieveShader: function(d) {
        return d.programCache.hasOwnProperty(this.type) || (d.programCache[this.type] = this.createProgram(d.context)), d.programCache[this.type];
      },
      /**
       * Apply this filter using webgl.
       *
       * @param {Object} options
       * @param {Number} options.passes The number of filters remaining to be executed
       * @param {Boolean} options.webgl Whether to use webgl to render the filter.
       * @param {WebGLTexture} options.originalTexture The texture of the original input image.
       * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
       * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
       * @param {WebGLRenderingContext} options.context The GL context used for rendering.
       * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
       */
      applyToWebGL: function(d) {
        var l = d.context, p = this.retrieveShader(d);
        d.pass === 0 && d.originalTexture ? l.bindTexture(l.TEXTURE_2D, d.originalTexture) : l.bindTexture(l.TEXTURE_2D, d.sourceTexture), l.useProgram(p.program), this.sendAttributeData(l, p.attributeLocations, d.aPosition), l.uniform1f(p.uniformLocations.uStepW, 1 / d.sourceWidth), l.uniform1f(p.uniformLocations.uStepH, 1 / d.sourceHeight), this.sendUniformData(l, p.uniformLocations), l.viewport(0, 0, d.destinationWidth, d.destinationHeight), l.drawArrays(l.TRIANGLE_STRIP, 0, 4);
      },
      bindAdditionalTexture: function(d, l, p) {
        d.activeTexture(p), d.bindTexture(d.TEXTURE_2D, l), d.activeTexture(d.TEXTURE0);
      },
      unbindAdditionalTexture: function(d, l) {
        d.activeTexture(l), d.bindTexture(d.TEXTURE_2D, null), d.activeTexture(d.TEXTURE0);
      },
      getMainParameter: function() {
        return this[this.mainParameter];
      },
      setMainParameter: function(d) {
        this[this.mainParameter] = d;
      },
      /**
       * Send uniform data from this filter to its shader program on the GPU.
       *
       * Intended to be overridden by subclasses.
       *
       * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
       * @param {Object} uniformLocations A map of shader uniform names to their locations.
       */
      sendUniformData: function() {
      },
      /**
       * If needed by a 2d filter, this functions can create an helper canvas to be used
       * remember that options.targetCanvas is available for use till end of chain.
       */
      createHelpLayer: function(d) {
        if (!d.helpLayer) {
          var l = document.createElement("canvas");
          l.width = d.sourceWidth, l.height = d.sourceHeight, d.helpLayer = l;
        }
      },
      /**
       * Returns object representation of an instance
       * @return {Object} Object representation of an instance
       */
      toObject: function() {
        var d = { type: this.type }, l = this.mainParameter;
        return l && (d[l] = this[l]), d;
      },
      /**
       * Returns a JSON representation of an instance
       * @return {Object} JSON
       */
      toJSON: function() {
        return this.toObject();
      }
    }
  ), n.Image.filters.BaseFilter.fromObject = function(d, l) {
    var p = new n.Image.filters[d.type](d);
    return l && l(p), p;
  }, function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.ColorMatrix = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.ColorMatrix.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "ColorMatrix",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
uniform mat4 uColorMatrix;
uniform vec4 uConstants;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color *= uColorMatrix;
color += uConstants;
gl_FragColor = color;
}`,
        /**
         * Colormatrix for pixels.
         * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
         * outside the -1, 1 range.
         * 0.0039215686 is the part of 1 that get translated to 1 in 2d
         * @param {Array} matrix array of 20 numbers.
         * @default
         */
        matrix: [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        mainParameter: "matrix",
        /**
         * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario
         * to save some calculation
         * @type Boolean
         * @default true
         */
        colorsOnly: !0,
        /**
         * Constructor
         * @param {Object} [options] Options object
         */
        initialize: function(c) {
          this.callSuper("initialize", c), this.matrix = this.matrix.slice(0);
        },
        /**
         * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8Array to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m = h.length, b = this.matrix, f, k, E, _, T, D = this.colorsOnly;
          for (T = 0; T < m; T += 4)
            f = h[T], k = h[T + 1], E = h[T + 2], D ? (h[T] = f * b[0] + k * b[1] + E * b[2] + b[4] * 255, h[T + 1] = f * b[5] + k * b[6] + E * b[7] + b[9] * 255, h[T + 2] = f * b[10] + k * b[11] + E * b[12] + b[14] * 255) : (_ = h[T + 3], h[T] = f * b[0] + k * b[1] + E * b[2] + _ * b[3] + b[4] * 255, h[T + 1] = f * b[5] + k * b[6] + E * b[7] + _ * b[8] + b[9] * 255, h[T + 2] = f * b[10] + k * b[11] + E * b[12] + _ * b[13] + b[14] * 255, h[T + 3] = f * b[15] + k * b[16] + E * b[17] + _ * b[18] + b[19] * 255);
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uColorMatrix: c.getUniformLocation(e, "uColorMatrix"),
            uConstants: c.getUniformLocation(e, "uConstants")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          var h = this.matrix, m = [
            h[0],
            h[1],
            h[2],
            h[3],
            h[5],
            h[6],
            h[7],
            h[8],
            h[10],
            h[11],
            h[12],
            h[13],
            h[15],
            h[16],
            h[17],
            h[18]
          ], b = [h[4], h[9], h[14], h[19]];
          c.uniformMatrix4fv(e.uColorMatrix, !1, m), c.uniform4fv(e.uConstants, b);
        }
      }
    ), l.Image.filters.ColorMatrix.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Brightness = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Brightness.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Brightness",
        /**
         * Fragment source for the brightness program
         */
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBrightness;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += uBrightness;
gl_FragColor = color;
}`,
        /**
         * Brightness value, from -1 to 1.
         * translated to -255 to 255 for 2d
         * 0.0039215686 is the part of 1 that get translated to 1 in 2d
         * @param {Number} brightness
         * @default
         */
        brightness: 0,
        /**
         * Describe the property that is the filter parameter
         * @param {String} m
         * @default
         */
        mainParameter: "brightness",
        /**
        * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
        *
        * @param {Object} options
        * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
        */
        applyTo2d: function(c) {
          if (this.brightness !== 0) {
            var e = c.imageData, h = e.data, m, b = h.length, f = Math.round(this.brightness * 255);
            for (m = 0; m < b; m += 4)
              h[m] = h[m] + f, h[m + 1] = h[m + 1] + f, h[m + 2] = h[m + 2] + f;
          }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uBrightness: c.getUniformLocation(e, "uBrightness")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1f(e.uBrightness, this.brightness);
        }
      }
    ), l.Image.filters.Brightness.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.Image.filters, c = l.util.createClass;
    v.Convolute = c(
      v.BaseFilter,
      /** @lends fabric.Image.filters.Convolute.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Convolute",
        /*
         * Opaque value (true/false)
         */
        opaque: !1,
        /*
         * matrix for the filter, max 9x9
         */
        matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],
        /**
         * Fragment source for the brightness program
         */
        fragmentSource: {
          Convolute_3_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_3_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_5_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_5_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_7_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_7_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_9_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_9_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`
        },
        /**
         * Constructor
         * @memberOf fabric.Image.filters.Convolute.prototype
         * @param {Object} [options] Options object
         * @param {Boolean} [options.opaque=false] Opaque value (true/false)
         * @param {Array} [options.matrix] Filter matrix
         */
        /**
        * Retrieves the cached shader.
        * @param {Object} options
        * @param {WebGLRenderingContext} options.context The GL context used for rendering.
        * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
        */
        retrieveShader: function(e) {
          var h = Math.sqrt(this.matrix.length), m = this.type + "_" + h + "_" + (this.opaque ? 1 : 0), b = this.fragmentSource[m];
          return e.programCache.hasOwnProperty(m) || (e.programCache[m] = this.createProgram(e.context, b)), e.programCache[m];
        },
        /**
         * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(e) {
          var h = e.imageData, m = h.data, b = this.matrix, f = Math.round(Math.sqrt(b.length)), k = Math.floor(f / 2), E = h.width, _ = h.height, T = e.ctx.createImageData(E, _), D = T.data, V = this.opaque ? 1 : 0, I, M, Q, G, z, re, he, de, Ce, xe, Ie, Be, L;
          for (Ie = 0; Ie < _; Ie++)
            for (xe = 0; xe < E; xe++) {
              for (z = (Ie * E + xe) * 4, I = 0, M = 0, Q = 0, G = 0, L = 0; L < f; L++)
                for (Be = 0; Be < f; Be++)
                  he = Ie + L - k, re = xe + Be - k, !(he < 0 || he >= _ || re < 0 || re >= E) && (de = (he * E + re) * 4, Ce = b[L * f + Be], I += m[de] * Ce, M += m[de + 1] * Ce, Q += m[de + 2] * Ce, V || (G += m[de + 3] * Ce));
              D[z] = I, D[z + 1] = M, D[z + 2] = Q, V ? D[z + 3] = m[z + 3] : D[z + 3] = G;
            }
          e.imageData = T;
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(e, h) {
          return {
            uMatrix: e.getUniformLocation(h, "uMatrix"),
            uOpaque: e.getUniformLocation(h, "uOpaque"),
            uHalfSize: e.getUniformLocation(h, "uHalfSize"),
            uSize: e.getUniformLocation(h, "uSize")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(e, h) {
          e.uniform1fv(h.uMatrix, this.matrix);
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return p(this.callSuper("toObject"), {
            opaque: this.opaque,
            matrix: this.matrix
          });
        }
      }
    ), l.Image.filters.Convolute.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Grayscale = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Grayscale.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Grayscale",
        fragmentSource: {
          average: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float average = (color.r + color.b + color.g) / 3.0;
gl_FragColor = vec4(average, average, average, color.a);
}`,
          lightness: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
gl_FragColor = vec4(average, average, average, col.a);
}`,
          luminosity: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
gl_FragColor = vec4(average, average, average, col.a);
}`
        },
        /**
         * Grayscale mode, between 'average', 'lightness', 'luminosity'
         * @param {String} type
         * @default
         */
        mode: "average",
        mainParameter: "mode",
        /**
         * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8Array to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m, b = h.length, f, k = this.mode;
          for (m = 0; m < b; m += 4)
            k === "average" ? f = (h[m] + h[m + 1] + h[m + 2]) / 3 : k === "lightness" ? f = (Math.min(h[m], h[m + 1], h[m + 2]) + Math.max(h[m], h[m + 1], h[m + 2])) / 2 : k === "luminosity" && (f = 0.21 * h[m] + 0.72 * h[m + 1] + 0.07 * h[m + 2]), h[m] = f, h[m + 1] = f, h[m + 2] = f;
        },
        /**
         * Retrieves the cached shader.
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        retrieveShader: function(c) {
          var e = this.type + "_" + this.mode;
          if (!c.programCache.hasOwnProperty(e)) {
            var h = this.fragmentSource[this.mode];
            c.programCache[e] = this.createProgram(c.context, h);
          }
          return c.programCache[e];
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uMode: c.getUniformLocation(e, "uMode")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          var h = 1;
          c.uniform1i(e.uMode, h);
        },
        /**
         * Grayscale filter isNeutralState implementation
         * The filter is never neutral
         * on the image
         **/
        isNeutralState: function() {
          return !1;
        }
      }
    ), l.Image.filters.Grayscale.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Invert = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Invert.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Invert",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform int uInvert;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
if (uInvert == 1) {
gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
} else {
gl_FragColor = color;
}
}`,
        /**
         * Filter invert. if false, does nothing
         * @param {Boolean} invert
         * @default
         */
        invert: !0,
        mainParameter: "invert",
        /**
         * Apply the Invert operation to a Uint8Array representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8Array to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m, b = h.length;
          for (m = 0; m < b; m += 4)
            h[m] = 255 - h[m], h[m + 1] = 255 - h[m + 1], h[m + 2] = 255 - h[m + 2];
        },
        /**
         * Invert filter isNeutralState implementation
         * Used only in image applyFilters to discard filters that will not have an effect
         * on the image
         * @param {Object} options
         **/
        isNeutralState: function() {
          return !this.invert;
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uInvert: c.getUniformLocation(e, "uInvert")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1i(e.uInvert, this.invert);
        }
      }
    ), l.Image.filters.Invert.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.Image.filters, c = l.util.createClass;
    v.Noise = c(
      v.BaseFilter,
      /** @lends fabric.Image.filters.Noise.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Noise",
        /**
         * Fragment source for the noise program
         */
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uStepH;
uniform float uNoise;
uniform float uSeed;
varying vec2 vTexCoord;
float rand(vec2 co, float seed, float vScale) {
return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
}
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
gl_FragColor = color;
}`,
        /**
         * Describe the property that is the filter parameter
         * @param {String} m
         * @default
         */
        mainParameter: "noise",
        /**
         * Noise value, from
         * @param {Number} noise
         * @default
         */
        noise: 0,
        /**
         * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(e) {
          if (this.noise !== 0) {
            var h = e.imageData, m = h.data, b, f = m.length, k = this.noise, E;
            for (b = 0, f = m.length; b < f; b += 4)
              E = (0.5 - Math.random()) * k, m[b] += E, m[b + 1] += E, m[b + 2] += E;
          }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(e, h) {
          return {
            uNoise: e.getUniformLocation(h, "uNoise"),
            uSeed: e.getUniformLocation(h, "uSeed")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(e, h) {
          e.uniform1f(h.uNoise, this.noise / 255), e.uniform1f(h.uSeed, Math.random());
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return p(this.callSuper("toObject"), {
            noise: this.noise
          });
        }
      }
    ), l.Image.filters.Noise.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Pixelate = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Pixelate.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Pixelate",
        blocksize: 4,
        mainParameter: "blocksize",
        /**
         * Fragment source for the Pixelate program
         */
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBlocksize;
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
float blockW = uBlocksize * uStepW;
float blockH = uBlocksize * uStepW;
int posX = int(vTexCoord.x / blockW);
int posY = int(vTexCoord.y / blockH);
float fposX = float(posX);
float fposY = float(posY);
vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
vec4 color = texture2D(uTexture, squareCoords);
gl_FragColor = color;
}`,
        /**
         * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m = e.height, b = e.width, f, k, E, _, T, D, V, I, M, Q, G;
          for (k = 0; k < m; k += this.blocksize)
            for (E = 0; E < b; E += this.blocksize)
              for (f = k * 4 * b + E * 4, _ = h[f], T = h[f + 1], D = h[f + 2], V = h[f + 3], Q = Math.min(k + this.blocksize, m), G = Math.min(E + this.blocksize, b), I = k; I < Q; I++)
                for (M = E; M < G; M++)
                  f = I * 4 * b + M * 4, h[f] = _, h[f + 1] = T, h[f + 2] = D, h[f + 3] = V;
        },
        /**
         * Indicate when the filter is not gonna apply changes to the image
         **/
        isNeutralState: function() {
          return this.blocksize === 1;
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uBlocksize: c.getUniformLocation(e, "uBlocksize"),
            uStepW: c.getUniformLocation(e, "uStepW"),
            uStepH: c.getUniformLocation(e, "uStepH")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1f(e.uBlocksize, this.blocksize);
        }
      }
    ), l.Image.filters.Pixelate.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.extend, v = l.Image.filters, c = l.util.createClass;
    v.RemoveColor = c(
      v.BaseFilter,
      /** @lends fabric.Image.filters.RemoveColor.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "RemoveColor",
        /**
         * Color to remove, in any format understood by fabric.Color.
         * @param {String} type
         * @default
         */
        color: "#FFFFFF",
        /**
         * Fragment source for the brightness program
         */
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
gl_FragColor.a = 0.0;
}
}`,
        /**
         * distance to actual color, as value up or down from each r,g,b
         * between 0 and 1
         **/
        distance: 0.02,
        /**
         * For color to remove inside distance, use alpha channel for a smoother deletion
         * NOT IMPLEMENTED YET
         **/
        useAlpha: !1,
        /**
         * Constructor
         * @memberOf fabric.Image.filters.RemoveWhite.prototype
         * @param {Object} [options] Options object
         * @param {Number} [options.color=#RRGGBB] Threshold value
         * @param {Number} [options.distance=10] Distance value
         */
        /**
         * Applies filter to canvas element
         * @param {Object} canvasEl Canvas element to apply filter to
         */
        applyTo2d: function(e) {
          var h = e.imageData, m = h.data, b, f = this.distance * 255, k, E, _, T = new l.Color(this.color).getSource(), D = [
            T[0] - f,
            T[1] - f,
            T[2] - f
          ], V = [
            T[0] + f,
            T[1] + f,
            T[2] + f
          ];
          for (b = 0; b < m.length; b += 4)
            k = m[b], E = m[b + 1], _ = m[b + 2], k > D[0] && E > D[1] && _ > D[2] && k < V[0] && E < V[1] && _ < V[2] && (m[b + 3] = 0);
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(e, h) {
          return {
            uLow: e.getUniformLocation(h, "uLow"),
            uHigh: e.getUniformLocation(h, "uHigh")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(e, h) {
          var m = new l.Color(this.color).getSource(), b = parseFloat(this.distance), f = [
            0 + m[0] / 255 - b,
            0 + m[1] / 255 - b,
            0 + m[2] / 255 - b,
            1
          ], k = [
            m[0] / 255 + b,
            m[1] / 255 + b,
            m[2] / 255 + b,
            1
          ];
          e.uniform4fv(h.uLow, f), e.uniform4fv(h.uHigh, k);
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return p(this.callSuper("toObject"), {
            color: this.color,
            distance: this.distance
          });
        }
      }
    ), l.Image.filters.RemoveColor.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass, c = {
      Brownie: [
        0.5997,
        0.34553,
        -0.27082,
        0,
        0.186,
        -0.0377,
        0.86095,
        0.15059,
        0,
        -0.1449,
        0.24113,
        -0.07441,
        0.44972,
        0,
        -0.02965,
        0,
        0,
        0,
        1,
        0
      ],
      Vintage: [
        0.62793,
        0.32021,
        -0.03965,
        0,
        0.03784,
        0.02578,
        0.64411,
        0.03259,
        0,
        0.02926,
        0.0466,
        -0.08512,
        0.52416,
        0,
        0.02023,
        0,
        0,
        0,
        1,
        0
      ],
      Kodachrome: [
        1.12855,
        -0.39673,
        -0.03992,
        0,
        0.24991,
        -0.16404,
        1.08352,
        -0.05498,
        0,
        0.09698,
        -0.16786,
        -0.56034,
        1.60148,
        0,
        0.13972,
        0,
        0,
        0,
        1,
        0
      ],
      Technicolor: [
        1.91252,
        -0.85453,
        -0.09155,
        0,
        0.04624,
        -0.30878,
        1.76589,
        -0.10601,
        0,
        -0.27589,
        -0.2311,
        -0.75018,
        1.84759,
        0,
        0.12137,
        0,
        0,
        0,
        1,
        0
      ],
      Polaroid: [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ],
      Sepia: [
        0.393,
        0.769,
        0.189,
        0,
        0,
        0.349,
        0.686,
        0.168,
        0,
        0,
        0.272,
        0.534,
        0.131,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ],
      BlackWhite: [
        1.5,
        1.5,
        1.5,
        0,
        -1,
        1.5,
        1.5,
        1.5,
        0,
        -1,
        1.5,
        1.5,
        1.5,
        0,
        -1,
        0,
        0,
        0,
        1,
        0
      ]
    };
    for (var e in c)
      p[e] = v(
        p.ColorMatrix,
        /** @lends fabric.Image.filters.Sepia.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: e,
          /**
           * Colormatrix for the effect
           * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
           * outside the -1, 1 range.
           * @param {Array} matrix array of 20 numbers.
           * @default
           */
          matrix: c[e],
          /**
           * Lock the matrix export for this kind of static, parameter less filters.
           */
          mainParameter: !1,
          /**
           * Lock the colormatrix on the color part, skipping alpha
           */
          colorsOnly: !0
        }
      ), l.Image.filters[e].fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric, p = l.Image.filters, v = l.util.createClass;
    p.BlendColor = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Blend.prototype */
      {
        type: "BlendColor",
        /**
         * Color to make the blend operation with. default to a reddish color since black or white
         * gives always strong result.
         * @type String
         * @default
         **/
        color: "#F95C63",
        /**
         * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
         * darken, lighten, overlay, exclusion, tint.
         * @type String
         * @default
         **/
        mode: "multiply",
        /**
         * alpha value. represent the strength of the blend color operation.
         * @type Number
         * @default
         **/
        alpha: 1,
        /**
         * Fragment source for the Multiply program
         */
        fragmentSource: {
          multiply: `gl_FragColor.rgb *= uColor.rgb;
`,
          screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`,
          add: `gl_FragColor.rgb += uColor.rgb;
`,
          diff: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`,
          subtract: `gl_FragColor.rgb -= uColor.rgb;
`,
          lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`,
          darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`,
          exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`,
          overlay: `if (uColor.r < 0.5) {
gl_FragColor.r *= 2.0 * uColor.r;
} else {
gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
}
if (uColor.g < 0.5) {
gl_FragColor.g *= 2.0 * uColor.g;
} else {
gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
}
if (uColor.b < 0.5) {
gl_FragColor.b *= 2.0 * uColor.b;
} else {
gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
}
`,
          tint: `gl_FragColor.rgb *= (1.0 - uColor.a);
gl_FragColor.rgb += uColor.rgb;
`
        },
        /**
         * build the fragment source for the filters, joining the common part with
         * the specific one.
         * @param {String} mode the mode of the filter, a key of this.fragmentSource
         * @return {String} the source to be compiled
         * @private
         */
        buildSource: function(c) {
          return `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uColor;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
gl_FragColor = color;
if (color.a > 0.0) {
` + this.fragmentSource[c] + `}
}`;
        },
        /**
         * Retrieves the cached shader.
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        retrieveShader: function(c) {
          var e = this.type + "_" + this.mode, h;
          return c.programCache.hasOwnProperty(e) || (h = this.buildSource(this.mode), c.programCache[e] = this.createProgram(c.context, h)), c.programCache[e];
        },
        /**
         * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m = h.length, b, f, k, E, _, T, D, V = 1 - this.alpha;
          D = new l.Color(this.color).getSource(), b = D[0] * this.alpha, f = D[1] * this.alpha, k = D[2] * this.alpha;
          for (var I = 0; I < m; I += 4)
            switch (E = h[I], _ = h[I + 1], T = h[I + 2], this.mode) {
              case "multiply":
                h[I] = E * b / 255, h[I + 1] = _ * f / 255, h[I + 2] = T * k / 255;
                break;
              case "screen":
                h[I] = 255 - (255 - E) * (255 - b) / 255, h[I + 1] = 255 - (255 - _) * (255 - f) / 255, h[I + 2] = 255 - (255 - T) * (255 - k) / 255;
                break;
              case "add":
                h[I] = E + b, h[I + 1] = _ + f, h[I + 2] = T + k;
                break;
              case "diff":
              case "difference":
                h[I] = Math.abs(E - b), h[I + 1] = Math.abs(_ - f), h[I + 2] = Math.abs(T - k);
                break;
              case "subtract":
                h[I] = E - b, h[I + 1] = _ - f, h[I + 2] = T - k;
                break;
              case "darken":
                h[I] = Math.min(E, b), h[I + 1] = Math.min(_, f), h[I + 2] = Math.min(T, k);
                break;
              case "lighten":
                h[I] = Math.max(E, b), h[I + 1] = Math.max(_, f), h[I + 2] = Math.max(T, k);
                break;
              case "overlay":
                h[I] = b < 128 ? 2 * E * b / 255 : 255 - 2 * (255 - E) * (255 - b) / 255, h[I + 1] = f < 128 ? 2 * _ * f / 255 : 255 - 2 * (255 - _) * (255 - f) / 255, h[I + 2] = k < 128 ? 2 * T * k / 255 : 255 - 2 * (255 - T) * (255 - k) / 255;
                break;
              case "exclusion":
                h[I] = b + E - 2 * b * E / 255, h[I + 1] = f + _ - 2 * f * _ / 255, h[I + 2] = k + T - 2 * k * T / 255;
                break;
              case "tint":
                h[I] = b + E * V, h[I + 1] = f + _ * V, h[I + 2] = k + T * V;
            }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uColor: c.getUniformLocation(e, "uColor")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          var h = new l.Color(this.color).getSource();
          h[0] = this.alpha * h[0] / 255, h[1] = this.alpha * h[1] / 255, h[2] = this.alpha * h[2] / 255, h[3] = this.alpha, c.uniform4fv(e.uColor, h);
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return {
            type: this.type,
            color: this.color,
            mode: this.mode,
            alpha: this.alpha
          };
        }
      }
    ), l.Image.filters.BlendColor.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric, p = l.Image.filters, v = l.util.createClass;
    p.BlendImage = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.BlendImage.prototype */
      {
        type: "BlendImage",
        /**
         * Color to make the blend operation with. default to a reddish color since black or white
         * gives always strong result.
         **/
        image: null,
        /**
         * Blend mode for the filter (one of "multiply", "mask")
         * @type String
         * @default
         **/
        mode: "multiply",
        /**
         * alpha value. represent the strength of the blend image operation.
         * not implemented.
         **/
        alpha: 1,
        vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
uniform mat3 uTransformMatrix;
void main() {
vTexCoord = aPosition;
vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`,
        /**
         * Fragment source for the Multiply program
         */
        fragmentSource: {
          multiply: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.rgba *= color2.rgba;
gl_FragColor = color;
}`,
          mask: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.a = color2.a;
gl_FragColor = color;
}`
        },
        /**
         * Retrieves the cached shader.
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        retrieveShader: function(c) {
          var e = this.type + "_" + this.mode, h = this.fragmentSource[this.mode];
          return c.programCache.hasOwnProperty(e) || (c.programCache[e] = this.createProgram(c.context, h)), c.programCache[e];
        },
        applyToWebGL: function(c) {
          var e = c.context, h = this.createTexture(c.filterBackend, this.image);
          this.bindAdditionalTexture(e, h, e.TEXTURE1), this.callSuper("applyToWebGL", c), this.unbindAdditionalTexture(e, e.TEXTURE1);
        },
        createTexture: function(c, e) {
          return c.getCachedTexture(e.cacheKey, e._element);
        },
        /**
         * Calculate a transformMatrix to adapt the image to blend over
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        calculateMatrix: function() {
          var c = this.image, e = c._element.width, h = c._element.height;
          return [
            1 / c.scaleX,
            0,
            0,
            0,
            1 / c.scaleY,
            0,
            -c.left / e,
            -c.top / h,
            1
          ];
        },
        /**
         * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = c.filterBackend.resources, m = e.data, b = m.length, f = e.width, k = e.height, E, _, T, D, V, I, M, Q, G, z, re = this.image, he;
          h.blendImage || (h.blendImage = l.util.createCanvasElement()), G = h.blendImage, z = G.getContext("2d"), G.width !== f || G.height !== k ? (G.width = f, G.height = k) : z.clearRect(0, 0, f, k), z.setTransform(re.scaleX, 0, 0, re.scaleY, re.left, re.top), z.drawImage(re._element, 0, 0, f, k), he = z.getImageData(0, 0, f, k).data;
          for (var de = 0; de < b; de += 4)
            switch (V = m[de], I = m[de + 1], M = m[de + 2], Q = m[de + 3], E = he[de], _ = he[de + 1], T = he[de + 2], D = he[de + 3], this.mode) {
              case "multiply":
                m[de] = V * E / 255, m[de + 1] = I * _ / 255, m[de + 2] = M * T / 255, m[de + 3] = Q * D / 255;
                break;
              case "mask":
                m[de + 3] = D;
                break;
            }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uTransformMatrix: c.getUniformLocation(e, "uTransformMatrix"),
            uImage: c.getUniformLocation(e, "uImage")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          var h = this.calculateMatrix();
          c.uniform1i(e.uImage, 1), c.uniformMatrix3fv(e.uTransformMatrix, !1, h);
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return {
            type: this.type,
            image: this.image && this.image.toObject(),
            mode: this.mode,
            alpha: this.alpha
          };
        }
      }
    ), l.Image.filters.BlendImage.fromObject = function(c, e) {
      l.Image.fromObject(c.image, function(h) {
        var m = l.util.object.clone(c);
        m.image = h, e(new l.Image.filters.BlendImage(m));
      });
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = Math.pow, v = Math.floor, c = Math.sqrt, e = Math.abs, h = Math.round, m = Math.sin, b = Math.ceil, f = l.Image.filters, k = l.util.createClass;
    f.Resize = k(
      f.BaseFilter,
      /** @lends fabric.Image.filters.Resize.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Resize",
        /**
         * Resize type
         * for webgl resizeType is just lanczos, for canvas2d can be:
         * bilinear, hermite, sliceHack, lanczos.
         * @param {String} resizeType
         * @default
         */
        resizeType: "hermite",
        /**
         * Scale factor for resizing, x axis
         * @param {Number} scaleX
         * @default
         */
        scaleX: 1,
        /**
         * Scale factor for resizing, y axis
         * @param {Number} scaleY
         * @default
         */
        scaleY: 1,
        /**
         * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
         * @param {Number} lanczosLobes
         * @default
         */
        lanczosLobes: 3,
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(E, _) {
          return {
            uDelta: E.getUniformLocation(_, "uDelta"),
            uTaps: E.getUniformLocation(_, "uTaps")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(E, _) {
          E.uniform2fv(_.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), E.uniform1fv(_.uTaps, this.taps);
        },
        /**
         * Retrieves the cached shader.
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        retrieveShader: function(E) {
          var _ = this.getFilterWindow(), T = this.type + "_" + _;
          if (!E.programCache.hasOwnProperty(T)) {
            var D = this.generateShader(_);
            E.programCache[T] = this.createProgram(E.context, D);
          }
          return E.programCache[T];
        },
        getFilterWindow: function() {
          var E = this.tempScale;
          return Math.ceil(this.lanczosLobes / E);
        },
        getTaps: function() {
          for (var E = this.lanczosCreate(this.lanczosLobes), _ = this.tempScale, T = this.getFilterWindow(), D = new Array(T), V = 1; V <= T; V++)
            D[V - 1] = E(V * _);
          return D;
        },
        /**
         * Generate vertex and shader sources from the necessary steps numbers
         * @param {Number} filterWindow
         */
        generateShader: function(D) {
          for (var _ = new Array(D), T = this.fragmentSourceTOP, D, V = 1; V <= D; V++)
            _[V - 1] = V + ".0 * uDelta";
          return T += "uniform float uTaps[" + D + `];
`, T += `void main() {
`, T += `  vec4 color = texture2D(uTexture, vTexCoord);
`, T += `  float sum = 1.0;
`, _.forEach(function(I, M) {
            T += "  color += texture2D(uTexture, vTexCoord + " + I + ") * uTaps[" + M + `];
`, T += "  color += texture2D(uTexture, vTexCoord - " + I + ") * uTaps[" + M + `];
`, T += "  sum += 2.0 * uTaps[" + M + `];
`;
          }), T += `  gl_FragColor = color / sum;
`, T += "}", T;
        },
        fragmentSourceTOP: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
`,
        /**
         * Apply the resize filter to the image
         * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
         *
         * @param {Object} options
         * @param {Number} options.passes The number of filters remaining to be executed
         * @param {Boolean} options.webgl Whether to use webgl to render the filter.
         * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
         * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        applyTo: function(E) {
          E.webgl ? (E.passes++, this.width = E.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = E.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), E.destinationWidth = this.dW, this._setupFrameBuffer(E), this.applyToWebGL(E), this._swapTextures(E), E.sourceWidth = E.destinationWidth, this.height = E.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), E.destinationHeight = this.dH, this._setupFrameBuffer(E), this.applyToWebGL(E), this._swapTextures(E), E.sourceHeight = E.destinationHeight) : this.applyTo2d(E);
        },
        isNeutralState: function() {
          return this.scaleX === 1 && this.scaleY === 1;
        },
        lanczosCreate: function(E) {
          return function(_) {
            if (_ >= E || _ <= -E)
              return 0;
            if (_ < 11920929e-14 && _ > -11920929e-14)
              return 1;
            _ *= Math.PI;
            var T = _ / E;
            return m(_) / _ * m(T) / T;
          };
        },
        /**
         * Applies filter to canvas element
         * @memberOf fabric.Image.filters.Resize.prototype
         * @param {Object} canvasEl Canvas element to apply filter to
         * @param {Number} scaleX
         * @param {Number} scaleY
         */
        applyTo2d: function(E) {
          var _ = E.imageData, T = this.scaleX, D = this.scaleY;
          this.rcpScaleX = 1 / T, this.rcpScaleY = 1 / D;
          var V = _.width, I = _.height, M = h(V * T), Q = h(I * D), G;
          this.resizeType === "sliceHack" ? G = this.sliceByTwo(E, V, I, M, Q) : this.resizeType === "hermite" ? G = this.hermiteFastResize(E, V, I, M, Q) : this.resizeType === "bilinear" ? G = this.bilinearFiltering(E, V, I, M, Q) : this.resizeType === "lanczos" && (G = this.lanczosResize(E, V, I, M, Q)), E.imageData = G;
        },
        /**
         * Filter sliceByTwo
         * @param {Object} canvasEl Canvas element to apply filter to
         * @param {Number} oW Original Width
         * @param {Number} oH Original Height
         * @param {Number} dW Destination Width
         * @param {Number} dH Destination Height
         * @returns {ImageData}
         */
        sliceByTwo: function(E, _, T, D, V) {
          var I = E.imageData, M = 0.5, Q = !1, G = !1, z = _ * M, re = T * M, he = l.filterBackend.resources, de, Ce, xe = 0, Ie = 0, Be = _, L = 0;
          for (he.sliceByTwo || (he.sliceByTwo = document.createElement("canvas")), de = he.sliceByTwo, (de.width < _ * 1.5 || de.height < T) && (de.width = _ * 1.5, de.height = T), Ce = de.getContext("2d"), Ce.clearRect(0, 0, _ * 1.5, T), Ce.putImageData(I, 0, 0), D = v(D), V = v(V); !Q || !G; )
            _ = z, T = re, D < v(z * M) ? z = v(z * M) : (z = D, Q = !0), V < v(re * M) ? re = v(re * M) : (re = V, G = !0), Ce.drawImage(de, xe, Ie, _, T, Be, L, z, re), xe = Be, Ie = L, L += re;
          return Ce.getImageData(xe, Ie, D, V);
        },
        /**
         * Filter lanczosResize
         * @param {Object} canvasEl Canvas element to apply filter to
         * @param {Number} oW Original Width
         * @param {Number} oH Original Height
         * @param {Number} dW Destination Width
         * @param {Number} dH Destination Height
         * @returns {ImageData}
         */
        lanczosResize: function(E, _, T, D, V) {
          function I(W) {
            var Y, me, K, R, le, fe, Se, we, De, Le, Ye;
            for (L.x = (W + 0.5) * re, Z.x = v(L.x), Y = 0; Y < V; Y++) {
              for (L.y = (Y + 0.5) * he, Z.y = v(L.y), le = 0, fe = 0, Se = 0, we = 0, De = 0, me = Z.x - xe; me <= Z.x + xe; me++)
                if (!(me < 0 || me >= _)) {
                  Le = v(1e3 * e(me - L.x)), Be[Le] || (Be[Le] = {});
                  for (var $ = Z.y - Ie; $ <= Z.y + Ie; $++)
                    $ < 0 || $ >= T || (Ye = v(1e3 * e($ - L.y)), Be[Le][Ye] || (Be[Le][Ye] = z(c(p(Le * de, 2) + p(Ye * Ce, 2)) / 1e3)), K = Be[Le][Ye], K > 0 && (R = ($ * _ + me) * 4, le += K, fe += K * M[R], Se += K * M[R + 1], we += K * M[R + 2], De += K * M[R + 3]));
                }
              R = (Y * D + W) * 4, G[R] = fe / le, G[R + 1] = Se / le, G[R + 2] = we / le, G[R + 3] = De / le;
            }
            return ++W < D ? I(W) : Q;
          }
          var M = E.imageData.data, Q = E.ctx.createImageData(D, V), G = Q.data, z = this.lanczosCreate(this.lanczosLobes), re = this.rcpScaleX, he = this.rcpScaleY, de = 2 / this.rcpScaleX, Ce = 2 / this.rcpScaleY, xe = b(re * this.lanczosLobes / 2), Ie = b(he * this.lanczosLobes / 2), Be = {}, L = {}, Z = {};
          return I(0);
        },
        /**
         * bilinearFiltering
         * @param {Object} canvasEl Canvas element to apply filter to
         * @param {Number} oW Original Width
         * @param {Number} oH Original Height
         * @param {Number} dW Destination Width
         * @param {Number} dH Destination Height
         * @returns {ImageData}
         */
        bilinearFiltering: function(E, _, T, D, V) {
          var I, M, Q, G, z, re, he, de, Ce, xe, Ie, Be, L = 0, Z, W = this.rcpScaleX, Y = this.rcpScaleY, me = 4 * (_ - 1), K = E.imageData, R = K.data, le = E.ctx.createImageData(D, V), fe = le.data;
          for (he = 0; he < V; he++)
            for (de = 0; de < D; de++)
              for (z = v(W * de), re = v(Y * he), Ce = W * de - z, xe = Y * he - re, Z = 4 * (re * _ + z), Ie = 0; Ie < 4; Ie++)
                I = R[Z + Ie], M = R[Z + 4 + Ie], Q = R[Z + me + Ie], G = R[Z + me + 4 + Ie], Be = I * (1 - Ce) * (1 - xe) + M * Ce * (1 - xe) + Q * xe * (1 - Ce) + G * Ce * xe, fe[L++] = Be;
          return le;
        },
        /**
         * hermiteFastResize
         * @param {Object} canvasEl Canvas element to apply filter to
         * @param {Number} oW Original Width
         * @param {Number} oH Original Height
         * @param {Number} dW Destination Width
         * @param {Number} dH Destination Height
         * @returns {ImageData}
         */
        hermiteFastResize: function(E, _, T, D, V) {
          for (var I = this.rcpScaleX, M = this.rcpScaleY, Q = b(I / 2), G = b(M / 2), z = E.imageData, re = z.data, he = E.ctx.createImageData(D, V), de = he.data, Ce = 0; Ce < V; Ce++)
            for (var xe = 0; xe < D; xe++) {
              for (var Ie = (xe + Ce * D) * 4, Be = 0, L = 0, Z = 0, W = 0, Y = 0, me = 0, K = 0, R = (Ce + 0.5) * M, le = v(Ce * M); le < (Ce + 1) * M; le++)
                for (var fe = e(R - (le + 0.5)) / G, Se = (xe + 0.5) * I, we = fe * fe, De = v(xe * I); De < (xe + 1) * I; De++) {
                  var Le = e(Se - (De + 0.5)) / Q, Ye = c(we + Le * Le);
                  Ye > 1 && Ye < -1 || (Be = 2 * Ye * Ye * Ye - 3 * Ye * Ye + 1, Be > 0 && (Le = 4 * (De + le * _), K += Be * re[Le + 3], Z += Be, re[Le + 3] < 255 && (Be = Be * re[Le + 3] / 250), W += Be * re[Le], Y += Be * re[Le + 1], me += Be * re[Le + 2], L += Be));
                }
              de[Ie] = W / L, de[Ie + 1] = Y / L, de[Ie + 2] = me / L, de[Ie + 3] = K / Z;
            }
          return he;
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          return {
            type: this.type,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            resizeType: this.resizeType,
            lanczosLobes: this.lanczosLobes
          };
        }
      }
    ), l.Image.filters.Resize.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Contrast = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Contrast.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Contrast",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uContrast;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
gl_FragColor = color;
}`,
        /**
         * contrast value, range from -1 to 1.
         * @param {Number} contrast
         * @default 0
         */
        contrast: 0,
        mainParameter: "contrast",
        /**
         * Constructor
         * @memberOf fabric.Image.filters.Contrast.prototype
         * @param {Object} [options] Options object
         * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
         */
        /**
          * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
          *
          * @param {Object} options
          * @param {ImageData} options.imageData The Uint8Array to be filtered.
          */
        applyTo2d: function(c) {
          if (this.contrast !== 0) {
            var e = c.imageData, h, b, m = e.data, b = m.length, f = Math.floor(this.contrast * 255), k = 259 * (f + 255) / (255 * (259 - f));
            for (h = 0; h < b; h += 4)
              m[h] = k * (m[h] - 128) + 128, m[h + 1] = k * (m[h + 1] - 128) + 128, m[h + 2] = k * (m[h + 2] - 128) + 128;
          }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uContrast: c.getUniformLocation(e, "uContrast")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1f(e.uContrast, this.contrast);
        }
      }
    ), l.Image.filters.Contrast.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Saturation = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Saturation.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Saturation",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uSaturation;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float rgMax = max(color.r, color.g);
float rgbMax = max(rgMax, color.b);
color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
gl_FragColor = color;
}`,
        /**
         * Saturation value, from -1 to 1.
         * Increases/decreases the color saturation.
         * A value of 0 has no effect.
         * 
         * @param {Number} saturation
         * @default
         */
        saturation: 0,
        mainParameter: "saturation",
        /**
         * Constructor
         * @memberOf fabric.Image.filters.Saturate.prototype
         * @param {Object} [options] Options object
         * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
         */
        /**
         * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(c) {
          if (this.saturation !== 0) {
            var e = c.imageData, h = e.data, m = h.length, b = -this.saturation, f, k;
            for (f = 0; f < m; f += 4)
              k = Math.max(h[f], h[f + 1], h[f + 2]), h[f] += k !== h[f] ? (k - h[f]) * b : 0, h[f + 1] += k !== h[f + 1] ? (k - h[f + 1]) * b : 0, h[f + 2] += k !== h[f + 2] ? (k - h[f + 2]) * b : 0;
          }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uSaturation: c.getUniformLocation(e, "uSaturation")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1f(e.uSaturation, -this.saturation);
        }
      }
    ), l.Image.filters.Saturation.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Vibrance = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Vibrance.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Vibrance",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uVibrance;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float max = max(color.r, max(color.g, color.b));
float avg = (color.r + color.g + color.b) / 3.0;
float amt = (abs(max - avg) * 2.0) * uVibrance;
color.r += max != color.r ? (max - color.r) * amt : 0.00;
color.g += max != color.g ? (max - color.g) * amt : 0.00;
color.b += max != color.b ? (max - color.b) * amt : 0.00;
gl_FragColor = color;
}`,
        /**
         * Vibrance value, from -1 to 1.
         * Increases/decreases the saturation of more muted colors with less effect on saturated colors.
         * A value of 0 has no effect.
         * 
         * @param {Number} vibrance
         * @default
         */
        vibrance: 0,
        mainParameter: "vibrance",
        /**
         * Constructor
         * @memberOf fabric.Image.filters.Vibrance.prototype
         * @param {Object} [options] Options object
         * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)
         */
        /**
         * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
         */
        applyTo2d: function(c) {
          if (this.vibrance !== 0) {
            var e = c.imageData, h = e.data, m = h.length, b = -this.vibrance, f, k, E, _;
            for (f = 0; f < m; f += 4)
              k = Math.max(h[f], h[f + 1], h[f + 2]), E = (h[f] + h[f + 1] + h[f + 2]) / 3, _ = Math.abs(k - E) * 2 / 255 * b, h[f] += k !== h[f] ? (k - h[f]) * _ : 0, h[f + 1] += k !== h[f + 1] ? (k - h[f + 1]) * _ : 0, h[f + 2] += k !== h[f + 2] ? (k - h[f + 2]) * _ : 0;
          }
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uVibrance: c.getUniformLocation(e, "uVibrance")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform1f(e.uVibrance, -this.vibrance);
        }
      }
    ), l.Image.filters.Vibrance.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Blur = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Blur.prototype */
      {
        type: "Blur",
        /*
        'gl_FragColor = vec4(0.0);',
        'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
        'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
        'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
        'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
        'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
        'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
        'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
        'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
        'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
        'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
        'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
        'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
        'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
        'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
        'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
        */
        /* eslint-disable max-len */
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
const float nSamples = 15.0;
vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
float random(vec3 scale) {
return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
}
void main() {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(v3offset);
for (float t = -nSamples; t <= nSamples; t++) {
float percent = (t + offset - 0.5) / nSamples;
float weight = 1.0 - abs(percent);
color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
total += weight;
}
gl_FragColor = color / total;
}`,
        /* eslint-enable max-len */
        /**
         * blur value, in percentage of image dimensions.
         * specific to keep the image blur constant at different resolutions
         * range between 0 and 1.
         * @type Number
         * @default
         */
        blur: 0,
        mainParameter: "blur",
        applyTo: function(c) {
          c.webgl ? (this.aspectRatio = c.sourceWidth / c.sourceHeight, c.passes++, this._setupFrameBuffer(c), this.horizontal = !0, this.applyToWebGL(c), this._swapTextures(c), this._setupFrameBuffer(c), this.horizontal = !1, this.applyToWebGL(c), this._swapTextures(c)) : this.applyTo2d(c);
        },
        applyTo2d: function(c) {
          c.imageData = this.simpleBlur(c);
        },
        simpleBlur: function(c) {
          var e = c.filterBackend.resources, h, m, b = c.imageData.width, f = c.imageData.height;
          e.blurLayer1 || (e.blurLayer1 = l.util.createCanvasElement(), e.blurLayer2 = l.util.createCanvasElement()), h = e.blurLayer1, m = e.blurLayer2, (h.width !== b || h.height !== f) && (m.width = h.width = b, m.height = h.height = f);
          var k = h.getContext("2d"), E = m.getContext("2d"), _ = 15, T, D, V, I, M = this.blur * 0.06 * 0.5;
          for (k.putImageData(c.imageData, 0, 0), E.clearRect(0, 0, b, f), I = -_; I <= _; I++)
            T = (Math.random() - 0.5) / 4, D = I / _, V = M * D * b + T, E.globalAlpha = 1 - Math.abs(D), E.drawImage(h, V, T), k.drawImage(m, 0, 0), E.globalAlpha = 1, E.clearRect(0, 0, m.width, m.height);
          for (I = -_; I <= _; I++)
            T = (Math.random() - 0.5) / 4, D = I / _, V = M * D * f + T, E.globalAlpha = 1 - Math.abs(D), E.drawImage(h, T, V), k.drawImage(m, 0, 0), E.globalAlpha = 1, E.clearRect(0, 0, m.width, m.height);
          c.ctx.drawImage(h, 0, 0);
          var Q = c.ctx.getImageData(0, 0, h.width, h.height);
          return k.globalAlpha = 1, k.clearRect(0, 0, h.width, h.height), Q;
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            delta: c.getUniformLocation(e, "uDelta")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          var h = this.chooseRightDelta();
          c.uniform2fv(e.delta, h);
        },
        /**
         * choose right value of image percentage to blur with
         * @returns {Array} a numeric array with delta values
         */
        chooseRightDelta: function() {
          var c = 1, e = [0, 0], h;
          return this.horizontal ? this.aspectRatio > 1 && (c = 1 / this.aspectRatio) : this.aspectRatio < 1 && (c = this.aspectRatio), h = c * this.blur * 0.12, this.horizontal ? e[0] = h : e[1] = h, e;
        }
      }
    ), p.Blur.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Gamma = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Gamma.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "Gamma",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec3 uGamma;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec3 correction = (1.0 / uGamma);
color.r = pow(color.r, correction.r);
color.g = pow(color.g, correction.g);
color.b = pow(color.b, correction.b);
gl_FragColor = color;
gl_FragColor.rgb *= color.a;
}`,
        /**
         * Gamma array value, from 0.01 to 2.2.
         * @param {Array} gamma
         * @default
         */
        gamma: [1, 1, 1],
        /**
         * Describe the property that is the filter parameter
         * @param {String} m
         * @default
         */
        mainParameter: "gamma",
        /**
         * Constructor
         * @param {Object} [options] Options object
         */
        initialize: function(c) {
          this.gamma = [1, 1, 1], p.BaseFilter.prototype.initialize.call(this, c);
        },
        /**
         * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
         *
         * @param {Object} options
         * @param {ImageData} options.imageData The Uint8Array to be filtered.
         */
        applyTo2d: function(c) {
          var e = c.imageData, h = e.data, m = this.gamma, b = h.length, f = 1 / m[0], k = 1 / m[1], E = 1 / m[2], _;
          for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), _ = 0, b = 256; _ < b; _++)
            this.rVals[_] = Math.pow(_ / 255, f) * 255, this.gVals[_] = Math.pow(_ / 255, k) * 255, this.bVals[_] = Math.pow(_ / 255, E) * 255;
          for (_ = 0, b = h.length; _ < b; _ += 4)
            h[_] = this.rVals[h[_]], h[_ + 1] = this.gVals[h[_ + 1]], h[_ + 2] = this.bVals[h[_ + 2]];
        },
        /**
         * Return WebGL uniform locations for this filter's shader.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {WebGLShaderProgram} program This filter's compiled shader program.
         */
        getUniformLocations: function(c, e) {
          return {
            uGamma: c.getUniformLocation(e, "uGamma")
          };
        },
        /**
         * Send data from this filter to its shader program's uniforms.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
         * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
         */
        sendUniformData: function(c, e) {
          c.uniform3fv(e.uGamma, this.gamma);
        }
      }
    ), l.Image.filters.Gamma.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.Composed = v(
      p.BaseFilter,
      /** @lends fabric.Image.filters.Composed.prototype */
      {
        type: "Composed",
        /**
         * A non sparse array of filters to apply
         */
        subFilters: [],
        /**
         * Constructor
         * @param {Object} [options] Options object
         */
        initialize: function(c) {
          this.callSuper("initialize", c), this.subFilters = this.subFilters.slice(0);
        },
        /**
         * Apply this container's filters to the input image provided.
         *
         * @param {Object} options
         * @param {Number} options.passes The number of filters remaining to be applied.
         */
        applyTo: function(c) {
          c.passes += this.subFilters.length - 1, this.subFilters.forEach(function(e) {
            e.applyTo(c);
          });
        },
        /**
         * Serialize this filter into JSON.
         *
         * @returns {Object} A JSON representation of this filter.
         */
        toObject: function() {
          return l.util.object.extend(this.callSuper("toObject"), {
            subFilters: this.subFilters.map(function(c) {
              return c.toObject();
            })
          });
        },
        isNeutralState: function() {
          return !this.subFilters.some(function(c) {
            return !c.isNeutralState();
          });
        }
      }
    ), l.Image.filters.Composed.fromObject = function(c, e) {
      var h = c.subFilters || [], m = h.map(function(f) {
        return new l.Image.filters[f.type](f);
      }), b = new l.Image.filters.Composed({ subFilters: m });
      return e && e(b), b;
    };
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.Image.filters, v = l.util.createClass;
    p.HueRotation = v(
      p.ColorMatrix,
      /** @lends fabric.Image.filters.HueRotation.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "HueRotation",
        /**
         * HueRotation value, from -1 to 1.
         * the unit is radians
         * @param {Number} myParameter
         * @default
         */
        rotation: 0,
        /**
         * Describe the property that is the filter parameter
         * @param {String} m
         * @default
         */
        mainParameter: "rotation",
        calculateMatrix: function() {
          var c = this.rotation * Math.PI, e = l.util.cos(c), h = l.util.sin(c), m = 1 / 3, b = Math.sqrt(m) * h, f = 1 - e;
          this.matrix = [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ], this.matrix[0] = e + f / 3, this.matrix[1] = m * f - b, this.matrix[2] = m * f + b, this.matrix[5] = m * f + b, this.matrix[6] = e + m * f, this.matrix[7] = m * f - b, this.matrix[10] = m * f - b, this.matrix[11] = m * f + b, this.matrix[12] = e + m * f;
        },
        /**
         * HueRotation isNeutralState implementation
         * Used only in image applyFilters to discard filters that will not have an effect
         * on the image
         * @param {Object} options
         **/
        isNeutralState: function(c) {
          return this.calculateMatrix(), p.BaseFilter.prototype.isNeutralState.call(this, c);
        },
        /**
         * Apply this filter to the input image data provided.
         *
         * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
         *
         * @param {Object} options
         * @param {Number} options.passes The number of filters remaining to be executed
         * @param {Boolean} options.webgl Whether to use webgl to render the filter.
         * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
         * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        applyTo: function(c) {
          this.calculateMatrix(), p.BaseFilter.prototype.applyTo.call(this, c);
        }
      }
    ), l.Image.filters.HueRotation.fromObject = l.Image.filters.BaseFilter.fromObject;
  }(i), function(d) {
    var l = d.fabric || (d.fabric = {}), p = l.util.object.clone;
    if (l.Text) {
      l.warn("fabric.Text is already defined");
      return;
    }
    var v = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" ");
    l.Text = l.util.createClass(
      l.Object,
      /** @lends fabric.Text.prototype */
      {
        /**
         * Properties which when set cause object to change dimensions
         * @type Array
         * @private
         */
        _dimensionAffectingProps: [
          "fontSize",
          "fontWeight",
          "fontFamily",
          "fontStyle",
          "lineHeight",
          "text",
          "charSpacing",
          "textAlign",
          "styles",
          "path",
          "pathStartOffset",
          "pathSide",
          "pathAlign"
        ],
        /**
         * @private
         */
        _reNewline: /\r?\n/,
        /**
         * Use this regular expression to filter for whitespaces that is not a new line.
         * Mostly used when text is 'justify' aligned.
         * @private
         */
        _reSpacesAndTabs: /[ \t\r]/g,
        /**
         * Use this regular expression to filter for whitespace that is not a new line.
         * Mostly used when text is 'justify' aligned.
         * @private
         */
        _reSpaceAndTab: /[ \t\r]/,
        /**
         * Use this regular expression to filter consecutive groups of non spaces.
         * Mostly used when text is 'justify' aligned.
         * @private
         */
        _reWords: /\S+/g,
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "text",
        /**
         * Font size (in pixels)
         * @type Number
         * @default
         */
        fontSize: 40,
        /**
         * Font weight (e.g. bold, normal, 400, 600, 800)
         * @type {(Number|String)}
         * @default
         */
        fontWeight: "normal",
        /**
         * Font family
         * @type String
         * @default
         */
        fontFamily: "Times New Roman",
        /**
         * Text decoration underline.
         * @type Boolean
         * @default
         */
        underline: !1,
        /**
         * Text decoration overline.
         * @type Boolean
         * @default
         */
        overline: !1,
        /**
         * Text decoration linethrough.
         * @type Boolean
         * @default
         */
        linethrough: !1,
        /**
         * Text alignment. Possible values: "left", "center", "right", "justify",
         * "justify-left", "justify-center" or "justify-right".
         * @type String
         * @default
         */
        textAlign: "left",
        /**
         * Font style . Possible values: "", "normal", "italic" or "oblique".
         * @type String
         * @default
         */
        fontStyle: "normal",
        /**
         * Line height
         * @type Number
         * @default
         */
        lineHeight: 1.16,
        /**
         * Superscript schema object (minimum overlap)
         * @type {Object}
         * @default
         */
        superscript: {
          size: 0.6,
          // fontSize factor
          baseline: -0.35
          // baseline-shift factor (upwards)
        },
        /**
         * Subscript schema object (minimum overlap)
         * @type {Object}
         * @default
         */
        subscript: {
          size: 0.6,
          // fontSize factor
          baseline: 0.11
          // baseline-shift factor (downwards)
        },
        /**
         * Background color of text lines
         * @type String
         * @default
         */
        textBackgroundColor: "",
        /**
         * List of properties to consider when checking if
         * state of an object is changed ({@link fabric.Object#hasStateChanged})
         * as well as for history (undo/redo) purposes
         * @type Array
         */
        stateProperties: l.Object.prototype.stateProperties.concat(v),
        /**
         * List of properties to consider when checking if cache needs refresh
         * @type Array
         */
        cacheProperties: l.Object.prototype.cacheProperties.concat(v),
        /**
         * When defined, an object is rendered via stroke and this property specifies its color.
         * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
         * @type String
         * @default
         */
        stroke: null,
        /**
         * Shadow object representing shadow of this shape.
         * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
         * @type fabric.Shadow
         * @default
         */
        shadow: null,
        /**
         * fabric.Path that the text should follow.
         * since 4.6.0 the path will be drawn automatically.
         * if you want to make the path visible, give it a stroke and strokeWidth or fill value
         * if you want it to be hidden, assign visible = false to the path.
         * This feature is in BETA, and SVG import/export is not yet supported.
         * @type fabric.Path
         * @example
         * var textPath = new fabric.Text('Text on a path', {
         *     top: 150,
         *     left: 150,
         *     textAlign: 'center',
         *     charSpacing: -50,
         *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {
         *         strokeWidth: 1,
         *         visible: false
         *     }),
         *     pathSide: 'left',
         *     pathStartOffset: 0
         * });
         * @default
         */
        path: null,
        /**
         * Offset amount for text path starting position
         * Only used when text has a path
         * @type Number
         * @default
         */
        pathStartOffset: 0,
        /**
         * Which side of the path the text should be drawn on.
         * Only used when text has a path
         * @type {String} 'left|right'
         * @default
         */
        pathSide: "left",
        /**
         * How text is aligned to the path. This property determines
         * the perpendicular position of each character relative to the path.
         * (one of "baseline", "center", "ascender", "descender")
         * This feature is in BETA, and its behavior may change
         * @type String
         * @default
         */
        pathAlign: "baseline",
        /**
         * @private
         */
        _fontSizeFraction: 0.222,
        /**
         * @private
         */
        offsets: {
          underline: 0.1,
          linethrough: -0.315,
          overline: -0.88
        },
        /**
         * Text Line proportion to font Size (in pixels)
         * @type Number
         * @default
         */
        _fontSizeMult: 1.13,
        /**
         * additional space between characters
         * expressed in thousands of em unit
         * @type Number
         * @default
         */
        charSpacing: 0,
        /**
         * Object containing character styles - top-level properties -> line numbers,
         * 2nd-level properties - character numbers
         * @type Object
         * @default
         */
        styles: null,
        /**
         * Reference to a context to measure text char or couple of chars
         * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
         * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every
         * text object created.
         * @type {CanvasRenderingContext2D}
         * @default
         */
        _measuringContext: null,
        /**
         * Baseline shift, styles only, keep at 0 for the main text object
         * @type {Number}
         * @default
         */
        deltaY: 0,
        /**
         * WARNING: EXPERIMENTAL. NOT SUPPORTED YET
         * determine the direction of the text.
         * This has to be set manually together with textAlign and originX for proper
         * experience.
         * some interesting link for the future
         * https://www.w3.org/International/questions/qa-bidi-unicode-controls
         * @since 4.5.0
         * @type {String} 'ltr|rtl'
         * @default
         */
        direction: "ltr",
        /**
         * Array of properties that define a style unit (of 'styles').
         * @type {Array}
         * @default
         */
        _styleProperties: [
          "stroke",
          "strokeWidth",
          "fill",
          "fontFamily",
          "fontSize",
          "fontWeight",
          "fontStyle",
          "underline",
          "overline",
          "linethrough",
          "deltaY",
          "textBackgroundColor"
        ],
        /**
         * contains characters bounding boxes
         */
        __charBounds: [],
        /**
         * use this size when measuring text. To avoid IE11 rounding errors
         * @type {Number}
         * @default
         * @readonly
         * @private
         */
        CACHE_FONT_SIZE: 400,
        /**
         * contains the min text width to avoid getting 0
         * @type {Number}
         * @default
         */
        MIN_TEXT_WIDTH: 2,
        /**
         * Constructor
         * @param {String} text Text string
         * @param {Object} [options] Options object
         * @return {fabric.Text} thisArg
         */
        initialize: function(c, e) {
          this.styles = e ? e.styles || {} : {}, this.text = c, this.__skipDimension = !0, this.callSuper("initialize", e), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" });
        },
        /**
         * If text has a path, it will add the extra information needed
         * for path and text calculations
         * @return {fabric.Text} thisArg
         */
        setPathInfo: function() {
          var c = this.path;
          c && (c.segmentsInfo = l.util.getPathSegmentsInfo(c.path));
        },
        /**
         * Return a context for measurement of text string.
         * if created it gets stored for reuse
         * this is for internal use, please do not use it
         * @private
         * @param {String} text Text string
         * @param {Object} [options] Options object
         * @return {fabric.Text} thisArg
         */
        getMeasuringContext: function() {
          return l._measuringContext || (l._measuringContext = this.canvas && this.canvas.contextCache || l.util.createCanvasElement().getContext("2d")), l._measuringContext;
        },
        /**
         * @private
         * Divides text into lines of text and lines of graphemes.
         */
        _splitText: function() {
          var c = this._splitTextIntoLines(this.text);
          return this.textLines = c.lines, this._textLines = c.graphemeLines, this._unwrappedTextLines = c._unwrappedLines, this._text = c.graphemeText, c;
        },
        /**
         * Initialize or update text dimensions.
         * Updates this.width and this.height with the proper values.
         * Does not return dimensions.
         */
        initDimensions: function() {
          this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" }));
        },
        /**
         * Enlarge space boxes and shift the others
         */
        enlargeSpaces: function() {
          for (var c, e, h, m, b, f, k, E = 0, _ = this._textLines.length; E < _; E++)
            if (!(this.textAlign !== "justify" && (E === _ - 1 || this.isEndOfWrapping(E))) && (m = 0, b = this._textLines[E], e = this.getLineWidth(E), e < this.width && (k = this.textLines[E].match(this._reSpacesAndTabs)))) {
              h = k.length, c = (this.width - e) / h;
              for (var T = 0, D = b.length; T <= D; T++)
                f = this.__charBounds[E][T], this._reSpaceAndTab.test(b[T]) ? (f.width += c, f.kernedWidth += c, f.left += m, m += c) : f.left += m;
            }
        },
        /**
         * Detect if the text line is ended with an hard break
         * text and itext do not have wrapping, return false
         * @return {Boolean}
         */
        isEndOfWrapping: function(c) {
          return c === this._textLines.length - 1;
        },
        /**
         * Detect if a line has a linebreak and so we need to account for it when moving
         * and counting style.
         * It return always for text and Itext.
         * @return Number
         */
        missingNewlineOffset: function() {
          return 1;
        },
        /**
         * Returns string representation of an instance
         * @return {String} String representation of text object
         */
        toString: function() {
          return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
        },
        /**
         * Return the dimension and the zoom level needed to create a cache canvas
         * big enough to host the object to be cached.
         * @private
         * @param {Object} dim.x width of object to be cached
         * @param {Object} dim.y height of object to be cached
         * @return {Object}.width width of canvas
         * @return {Object}.height height of canvas
         * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
         * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
         */
        _getCacheCanvasDimensions: function() {
          var c = this.callSuper("_getCacheCanvasDimensions"), e = this.fontSize;
          return c.width += e * c.zoomX, c.height += e * c.zoomY, c;
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(c) {
          var e = this.path;
          e && !e.isNotVisible() && e._render(c), this._setTextStyles(c), this._renderTextLinesBackground(c), this._renderTextDecoration(c, "underline"), this._renderText(c), this._renderTextDecoration(c, "overline"), this._renderTextDecoration(c, "linethrough");
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderText: function(c) {
          this.paintFirst === "stroke" ? (this._renderTextStroke(c), this._renderTextFill(c)) : (this._renderTextFill(c), this._renderTextStroke(c));
        },
        /**
         * Set the font parameter of the context with the object properties or with charStyle
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Object} [charStyle] object with font style properties
         * @param {String} [charStyle.fontFamily] Font Family
         * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
         * @param {String} [charStyle.fontWeight] Font weight
         * @param {String} [charStyle.fontStyle] Font style (italic|normal)
         */
        _setTextStyles: function(c, e, h) {
          if (c.textBaseline = "alphabetical", this.path)
            switch (this.pathAlign) {
              case "center":
                c.textBaseline = "middle";
                break;
              case "ascender":
                c.textBaseline = "top";
                break;
              case "descender":
                c.textBaseline = "bottom";
                break;
            }
          c.font = this._getFontDeclaration(e, h);
        },
        /**
         * calculate and return the text Width measuring each line.
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @return {Number} Maximum width of fabric.Text object
         */
        calcTextWidth: function() {
          for (var c = this.getLineWidth(0), e = 1, h = this._textLines.length; e < h; e++) {
            var m = this.getLineWidth(e);
            m > c && (c = m);
          }
          return c;
        },
        /**
         * @private
         * @param {String} method Method name ("fillText" or "strokeText")
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {String} line Text to render
         * @param {Number} left Left position of text
         * @param {Number} top Top position of text
         * @param {Number} lineIndex Index of a line in a text
         */
        _renderTextLine: function(c, e, h, m, b, f) {
          this._renderChars(c, e, h, m, b, f);
        },
        /**
         * Renders the text background for lines, taking care of style
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderTextLinesBackground: function(c) {
          if (!(!this.textBackgroundColor && !this.styleHas("textBackgroundColor"))) {
            for (var e, h, m = c.fillStyle, b, f, k = this._getLeftOffset(), E = this._getTopOffset(), _ = 0, T = 0, D, V, I = this.path, M, Q = 0, G = this._textLines.length; Q < G; Q++) {
              if (e = this.getHeightOfLine(Q), !this.textBackgroundColor && !this.styleHas("textBackgroundColor", Q)) {
                E += e;
                continue;
              }
              b = this._textLines[Q], h = this._getLineLeftOffset(Q), T = 0, _ = 0, f = this.getValueOfPropertyAt(Q, 0, "textBackgroundColor");
              for (var z = 0, re = b.length; z < re; z++)
                D = this.__charBounds[Q][z], V = this.getValueOfPropertyAt(Q, z, "textBackgroundColor"), I ? (c.save(), c.translate(D.renderLeft, D.renderTop), c.rotate(D.angle), c.fillStyle = V, V && c.fillRect(
                  -D.width / 2,
                  -e / this.lineHeight * (1 - this._fontSizeFraction),
                  D.width,
                  e / this.lineHeight
                ), c.restore()) : V !== f ? (M = k + h + _, this.direction === "rtl" && (M = this.width - M - T), c.fillStyle = f, f && c.fillRect(
                  M,
                  E,
                  T,
                  e / this.lineHeight
                ), _ = D.left, T = D.width, f = V) : T += D.kernedWidth;
              V && !I && (M = k + h + _, this.direction === "rtl" && (M = this.width - M - T), c.fillStyle = V, c.fillRect(
                M,
                E,
                T,
                e / this.lineHeight
              )), E += e;
            }
            c.fillStyle = m, this._removeShadow(c);
          }
        },
        /**
         * @private
         * @param {Object} decl style declaration for cache
         * @param {String} decl.fontFamily fontFamily
         * @param {String} decl.fontStyle fontStyle
         * @param {String} decl.fontWeight fontWeight
         * @return {Object} reference to cache
         */
        getFontCache: function(c) {
          var e = c.fontFamily.toLowerCase();
          l.charWidthsCache[e] || (l.charWidthsCache[e] = {});
          var h = l.charWidthsCache[e], m = c.fontStyle.toLowerCase() + "_" + (c.fontWeight + "").toLowerCase();
          return h[m] || (h[m] = {}), h[m];
        },
        /**
         * measure and return the width of a single character.
         * possibly overridden to accommodate different measure logic or
         * to hook some external lib for character measurement
         * @private
         * @param {String} _char, char to be measured
         * @param {Object} charStyle style of char to be measured
         * @param {String} [previousChar] previous char
         * @param {Object} [prevCharStyle] style of previous char
         */
        _measureChar: function(c, e, h, m) {
          var b = this.getFontCache(e), f = this._getFontDeclaration(e), k = this._getFontDeclaration(m), E = h + c, _ = f === k, T, D, V, I = e.fontSize / this.CACHE_FONT_SIZE, M;
          if (h && b[h] !== void 0 && (V = b[h]), b[c] !== void 0 && (M = T = b[c]), _ && b[E] !== void 0 && (D = b[E], M = D - V), T === void 0 || V === void 0 || D === void 0) {
            var Q = this.getMeasuringContext();
            this._setTextStyles(Q, e, !0);
          }
          return T === void 0 && (M = T = Q.measureText(c).width, b[c] = T), V === void 0 && _ && h && (V = Q.measureText(h).width, b[h] = V), _ && D === void 0 && (D = Q.measureText(E).width, b[E] = D, M = D - V), { width: T * I, kernedWidth: M * I };
        },
        /**
         * Computes height of character at given position
         * @param {Number} line the line index number
         * @param {Number} _char the character index number
         * @return {Number} fontSize of the character
         */
        getHeightOfChar: function(c, e) {
          return this.getValueOfPropertyAt(c, e, "fontSize");
        },
        /**
         * measure a text line measuring all characters.
         * @param {Number} lineIndex line number
         * @return {Number} Line width
         */
        measureLine: function(c) {
          var e = this._measureLine(c);
          return this.charSpacing !== 0 && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e;
        },
        /**
         * measure every grapheme of a line, populating __charBounds
         * @param {Number} lineIndex
         * @return {Object} object.width total width of characters
         * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
         */
        _measureLine: function(c) {
          var e = 0, h, m, b = this._textLines[c], f, k, E = 0, _ = new Array(b.length), T = 0, D, V, I = this.path, M = this.pathSide === "right";
          for (this.__charBounds[c] = _, h = 0; h < b.length; h++)
            m = b[h], k = this._getGraphemeBox(m, c, h, f), _[h] = k, e += k.kernedWidth, f = m;
          if (_[h] = {
            left: k ? k.left + k.width : 0,
            width: 0,
            kernedWidth: 0,
            height: this.fontSize
          }, I) {
            switch (V = I.segmentsInfo[I.segmentsInfo.length - 1].length, D = l.util.getPointOnPath(I.path, 0, I.segmentsInfo), D.x += I.pathOffset.x, D.y += I.pathOffset.y, this.textAlign) {
              case "left":
                T = M ? V - e : 0;
                break;
              case "center":
                T = (V - e) / 2;
                break;
              case "right":
                T = M ? 0 : V - e;
                break;
            }
            for (T += this.pathStartOffset * (M ? -1 : 1), h = M ? b.length - 1 : 0; M ? h >= 0 : h < b.length; M ? h-- : h++)
              k = _[h], T > V ? T %= V : T < 0 && (T += V), this._setGraphemeOnPath(T, k, D), T += k.kernedWidth;
          }
          return { width: e, numOfSpaces: E };
        },
        /**
         * Calculate the angle  and the left,top position of the char that follow a path.
         * It appends it to graphemeInfo to be reused later at rendering
         * @private
         * @param {Number} positionInPath to be measured
         * @param {Object} graphemeInfo current grapheme box information
         * @param {Object} startingPoint position of the point
         */
        _setGraphemeOnPath: function(c, e, h) {
          var m = c + e.kernedWidth / 2, b = this.path, f = l.util.getPointOnPath(b.path, m, b.segmentsInfo);
          e.renderLeft = f.x - h.x, e.renderTop = f.y - h.y, e.angle = f.angle + (this.pathSide === "right" ? Math.PI : 0);
        },
        /**
         * Measure and return the info of a single grapheme.
         * needs the the info of previous graphemes already filled
         * @private
         * @param {String} grapheme to be measured
         * @param {Number} lineIndex index of the line where the char is
         * @param {Number} charIndex position in the line
         * @param {String} [prevGrapheme] character preceding the one to be measured
         */
        _getGraphemeBox: function(c, e, h, m, b) {
          var f = this.getCompleteStyleDeclaration(e, h), k = m ? this.getCompleteStyleDeclaration(e, h - 1) : {}, E = this._measureChar(c, f, m, k), _ = E.kernedWidth, T = E.width, D;
          this.charSpacing !== 0 && (D = this._getWidthOfCharSpacing(), T += D, _ += D);
          var V = {
            width: T,
            left: 0,
            height: f.fontSize,
            kernedWidth: _,
            deltaY: f.deltaY
          };
          if (h > 0 && !b) {
            var I = this.__charBounds[e][h - 1];
            V.left = I.left + I.width + E.kernedWidth - E.width;
          }
          return V;
        },
        /**
         * Calculate height of line at 'lineIndex'
         * @param {Number} lineIndex index of line to calculate
         * @return {Number}
         */
        getHeightOfLine: function(c) {
          if (this.__lineHeights[c])
            return this.__lineHeights[c];
          for (var e = this._textLines[c], h = this.getHeightOfChar(c, 0), m = 1, b = e.length; m < b; m++)
            h = Math.max(this.getHeightOfChar(c, m), h);
          return this.__lineHeights[c] = h * this.lineHeight * this._fontSizeMult;
        },
        /**
         * Calculate text box height
         */
        calcTextHeight: function() {
          for (var c, e = 0, h = 0, m = this._textLines.length; h < m; h++)
            c = this.getHeightOfLine(h), e += h === m - 1 ? c / this.lineHeight : c;
          return e;
        },
        /**
         * @private
         * @return {Number} Left offset
         */
        _getLeftOffset: function() {
          return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
        },
        /**
         * @private
         * @return {Number} Top offset
         */
        _getTopOffset: function() {
          return -this.height / 2;
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {String} method Method name ("fillText" or "strokeText")
         */
        _renderTextCommon: function(c, e) {
          c.save();
          for (var h = 0, m = this._getLeftOffset(), b = this._getTopOffset(), f = 0, k = this._textLines.length; f < k; f++) {
            var E = this.getHeightOfLine(f), _ = E / this.lineHeight, T = this._getLineLeftOffset(f);
            this._renderTextLine(
              e,
              c,
              this._textLines[f],
              m + T,
              b + h + _,
              f
            ), h += E;
          }
          c.restore();
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderTextFill: function(c) {
          !this.fill && !this.styleHas("fill") || this._renderTextCommon(c, "fillText");
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderTextStroke: function(c) {
          (!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles() || (this.shadow && !this.shadow.affectStroke && this._removeShadow(c), c.save(), this._setLineDash(c, this.strokeDashArray), c.beginPath(), this._renderTextCommon(c, "strokeText"), c.closePath(), c.restore());
        },
        /**
         * @private
         * @param {String} method fillText or strokeText.
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Array} line Content of the line, splitted in an array by grapheme
         * @param {Number} left
         * @param {Number} top
         * @param {Number} lineIndex
         */
        _renderChars: function(c, e, h, m, b, f) {
          var k = this.getHeightOfLine(f), E = this.textAlign.indexOf("justify") !== -1, _, T, D = "", V, I = 0, M, Q = this.path, G = !E && this.charSpacing === 0 && this.isEmptyStyles(f) && !Q, z = this.direction === "ltr", re = this.direction === "ltr" ? 1 : -1, he, de = e.canvas.getAttribute("dir");
          if (e.save(), de !== this.direction && (e.canvas.setAttribute("dir", z ? "ltr" : "rtl"), e.direction = z ? "ltr" : "rtl", e.textAlign = z ? "left" : "right"), b -= k * this._fontSizeFraction / this.lineHeight, G) {
            this._renderChar(c, e, f, 0, h.join(""), m, b, k), e.restore();
            return;
          }
          for (var Ce = 0, xe = h.length - 1; Ce <= xe; Ce++)
            M = Ce === xe || this.charSpacing || Q, D += h[Ce], V = this.__charBounds[f][Ce], I === 0 ? (m += re * (V.kernedWidth - V.width), I += V.width) : I += V.kernedWidth, E && !M && this._reSpaceAndTab.test(h[Ce]) && (M = !0), M || (_ = _ || this.getCompleteStyleDeclaration(f, Ce), T = this.getCompleteStyleDeclaration(f, Ce + 1), M = l.util.hasStyleChanged(_, T, !1)), M && (Q ? (e.save(), e.translate(V.renderLeft, V.renderTop), e.rotate(V.angle), this._renderChar(c, e, f, Ce, D, -I / 2, 0, k), e.restore()) : (he = m, this._renderChar(c, e, f, Ce, D, he, b, k)), D = "", _ = T, m += re * I, I = 0);
          e.restore();
        },
        /**
         * This function try to patch the missing gradientTransform on canvas gradients.
         * transforming a context to transform the gradient, is going to transform the stroke too.
         * we want to transform the gradient but not the stroke operation, so we create
         * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
         * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size
         * is limited.
         * @private
         * @param {fabric.Gradient} filler a fabric gradient instance
         * @return {CanvasPattern} a pattern to use as fill/stroke style
         */
        _applyPatternGradientTransformText: function(c) {
          var e = l.util.createCanvasElement(), h, m = this.width + this.strokeWidth, b = this.height + this.strokeWidth;
          return e.width = m, e.height = b, h = e.getContext("2d"), h.beginPath(), h.moveTo(0, 0), h.lineTo(m, 0), h.lineTo(m, b), h.lineTo(0, b), h.closePath(), h.translate(m / 2, b / 2), h.fillStyle = c.toLive(h), this._applyPatternGradientTransform(h, c), h.fill(), h.createPattern(e, "no-repeat");
        },
        handleFiller: function(c, e, h) {
          var m, b;
          return h.toLive ? h.gradientUnits === "percentage" || h.gradientTransform || h.patternTransform ? (m = -this.width / 2, b = -this.height / 2, c.translate(m, b), c[e] = this._applyPatternGradientTransformText(h), { offsetX: m, offsetY: b }) : (c[e] = h.toLive(c, this), this._applyPatternGradientTransform(c, h)) : (c[e] = h, { offsetX: 0, offsetY: 0 });
        },
        _setStrokeStyles: function(c, e) {
          return c.lineWidth = e.strokeWidth, c.lineCap = this.strokeLineCap, c.lineDashOffset = this.strokeDashOffset, c.lineJoin = this.strokeLineJoin, c.miterLimit = this.strokeMiterLimit, this.handleFiller(c, "strokeStyle", e.stroke);
        },
        _setFillStyles: function(c, e) {
          return this.handleFiller(c, "fillStyle", e.fill);
        },
        /**
         * @private
         * @param {String} method
         * @param {CanvasRenderingContext2D} ctx Context to render on
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @param {String} _char
         * @param {Number} left Left coordinate
         * @param {Number} top Top coordinate
         * @param {Number} lineHeight Height of the line
         */
        _renderChar: function(c, e, h, m, b, f, k) {
          var E = this._getStyleDeclaration(h, m), _ = this.getCompleteStyleDeclaration(h, m), T = c === "fillText" && _.fill, D = c === "strokeText" && _.stroke && _.strokeWidth, V, I;
          !D && !T || (e.save(), T && (V = this._setFillStyles(e, _)), D && (I = this._setStrokeStyles(e, _)), e.font = this._getFontDeclaration(_), E && E.textBackgroundColor && this._removeShadow(e), E && E.deltaY && (k += E.deltaY), T && e.fillText(b, f - V.offsetX, k - V.offsetY), D && e.strokeText(b, f - I.offsetX, k - I.offsetY), e.restore());
        },
        /**
         * Turns the character into a 'superior figure' (i.e. 'superscript')
         * @param {Number} start selection start
         * @param {Number} end selection end
         * @returns {fabric.Text} thisArg
         * @chainable
         */
        setSuperscript: function(c, e) {
          return this._setScript(c, e, this.superscript);
        },
        /**
         * Turns the character into an 'inferior figure' (i.e. 'subscript')
         * @param {Number} start selection start
         * @param {Number} end selection end
         * @returns {fabric.Text} thisArg
         * @chainable
         */
        setSubscript: function(c, e) {
          return this._setScript(c, e, this.subscript);
        },
        /**
         * Applies 'schema' at given position
         * @private
         * @param {Number} start selection start
         * @param {Number} end selection end
         * @param {Number} schema
         * @returns {fabric.Text} thisArg
         * @chainable
         */
        _setScript: function(c, e, h) {
          var m = this.get2DCursorLocation(c, !0), b = this.getValueOfPropertyAt(m.lineIndex, m.charIndex, "fontSize"), f = this.getValueOfPropertyAt(m.lineIndex, m.charIndex, "deltaY"), k = { fontSize: b * h.size, deltaY: f + b * h.baseline };
          return this.setSelectionStyles(k, c, e), this;
        },
        /**
         * @private
         * @param {Number} lineIndex index text line
         * @return {Number} Line left offset
         */
        _getLineLeftOffset: function(c) {
          var e = this.getLineWidth(c), h = this.width - e, m = this.textAlign, b = this.direction, k, f = 0, k = this.isEndOfWrapping(c);
          return m === "justify" || m === "justify-center" && !k || m === "justify-right" && !k || m === "justify-left" && !k ? 0 : (m === "center" && (f = h / 2), m === "right" && (f = h), m === "justify-center" && (f = h / 2), m === "justify-right" && (f = h), b === "rtl" && (f -= h), f);
        },
        /**
         * @private
         */
        _clearCache: function() {
          this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
        },
        /**
         * @private
         */
        _shouldClearDimensionCache: function() {
          var c = this._forceClearCache;
          return c || (c = this.hasStateChanged("_dimensionAffectingProps")), c && (this.dirty = !0, this._forceClearCache = !1), c;
        },
        /**
         * Measure a single line given its index. Used to calculate the initial
         * text bounding box. The values are calculated and stored in __lineWidths cache.
         * @private
         * @param {Number} lineIndex line number
         * @return {Number} Line width
         */
        getLineWidth: function(c) {
          if (this.__lineWidths[c] !== void 0)
            return this.__lineWidths[c];
          var e = this.measureLine(c), h = e.width;
          return this.__lineWidths[c] = h, h;
        },
        _getWidthOfCharSpacing: function() {
          return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
        },
        /**
         * Retrieves the value of property at given character position
         * @param {Number} lineIndex the line number
         * @param {Number} charIndex the character number
         * @param {String} property the property name
         * @returns the value of 'property'
         */
        getValueOfPropertyAt: function(c, e, h) {
          var m = this._getStyleDeclaration(c, e);
          return m && typeof m[h] < "u" ? m[h] : this[h];
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _renderTextDecoration: function(c, e) {
          if (!(!this[e] && !this.styleHas(e))) {
            for (var h, m, b, f, k, E, _, T, D = this._getLeftOffset(), V = this._getTopOffset(), I, M, Q, G, z, re, he, de, Ce = this.path, xe = this._getWidthOfCharSpacing(), Ie = this.offsets[e], Be = 0, L = this._textLines.length; Be < L; Be++) {
              if (h = this.getHeightOfLine(Be), !this[e] && !this.styleHas(e, Be)) {
                V += h;
                continue;
              }
              _ = this._textLines[Be], re = h / this.lineHeight, f = this._getLineLeftOffset(Be), M = 0, Q = 0, T = this.getValueOfPropertyAt(Be, 0, e), de = this.getValueOfPropertyAt(Be, 0, "fill"), I = V + re * (1 - this._fontSizeFraction), m = this.getHeightOfChar(Be, 0), k = this.getValueOfPropertyAt(Be, 0, "deltaY");
              for (var Z = 0, W = _.length; Z < W; Z++)
                if (G = this.__charBounds[Be][Z], z = this.getValueOfPropertyAt(Be, Z, e), he = this.getValueOfPropertyAt(Be, Z, "fill"), b = this.getHeightOfChar(Be, Z), E = this.getValueOfPropertyAt(Be, Z, "deltaY"), Ce && z && he)
                  c.save(), c.fillStyle = de, c.translate(G.renderLeft, G.renderTop), c.rotate(G.angle), c.fillRect(
                    -G.kernedWidth / 2,
                    Ie * b + E,
                    G.kernedWidth,
                    this.fontSize / 15
                  ), c.restore();
                else if ((z !== T || he !== de || b !== m || E !== k) && Q > 0) {
                  var Y = D + f + M;
                  this.direction === "rtl" && (Y = this.width - Y - Q), T && de && (c.fillStyle = de, c.fillRect(
                    Y,
                    I + Ie * m + k,
                    Q,
                    this.fontSize / 15
                  )), M = G.left, Q = G.width, T = z, de = he, m = b, k = E;
                } else
                  Q += G.kernedWidth;
              var Y = D + f + M;
              this.direction === "rtl" && (Y = this.width - Y - Q), c.fillStyle = he, z && he && c.fillRect(
                Y,
                I + Ie * m + k,
                Q - xe,
                this.fontSize / 15
              ), V += h;
            }
            this._removeShadow(c);
          }
        },
        /**
         * return font declaration string for canvas context
         * @param {Object} [styleObject] object
         * @returns {String} font declaration formatted for canvas context.
         */
        _getFontDeclaration: function(c, e) {
          var h = c || this, m = this.fontFamily, b = l.Text.genericFonts.indexOf(m.toLowerCase()) > -1, f = m === void 0 || m.indexOf("'") > -1 || m.indexOf(",") > -1 || m.indexOf('"') > -1 || b ? h.fontFamily : '"' + h.fontFamily + '"';
          return [
            // node-canvas needs "weight style", while browsers need "style weight"
            // verify if this can be fixed in JSDOM
            l.isLikelyNode ? h.fontWeight : h.fontStyle,
            l.isLikelyNode ? h.fontStyle : h.fontWeight,
            e ? this.CACHE_FONT_SIZE + "px" : h.fontSize + "px",
            f
          ].join(" ");
        },
        /**
         * Renders text instance on a specified context
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        render: function(c) {
          this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", c)));
        },
        /**
         * Returns the text as an array of lines.
         * @param {String} text text to split
         * @returns {Array} Lines in the text
         */
        _splitTextIntoLines: function(c) {
          for (var e = c.split(this._reNewline), h = new Array(e.length), m = [`
`], b = [], f = 0; f < e.length; f++)
            h[f] = l.util.string.graphemeSplit(e[f]), b = b.concat(h[f], m);
          return b.pop(), { _unwrappedLines: h, lines: e, graphemeText: b, graphemeLines: h };
        },
        /**
         * Returns object representation of an instance
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} Object representation of an instance
         */
        toObject: function(c) {
          var e = v.concat(c), h = this.callSuper("toObject", e);
          return h.styles = l.util.stylesToArray(this.styles, this.text), h.path && (h.path = this.path.toObject()), h;
        },
        /**
         * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
         * @param {String|Object} key Property name or object (if object, iterate over the object properties)
         * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
         * @return {fabric.Object} thisArg
         * @chainable
         */
        set: function(c, e) {
          this.callSuper("set", c, e);
          var h = !1, m = !1;
          if (typeof c == "object")
            for (var b in c)
              b === "path" && this.setPathInfo(), h = h || this._dimensionAffectingProps.indexOf(b) !== -1, m = m || b === "path";
          else
            h = this._dimensionAffectingProps.indexOf(c) !== -1, m = c === "path";
          return m && this.setPathInfo(), h && (this.initDimensions(), this.setCoords()), this;
        },
        /**
         * Returns complexity of an instance
         * @return {Number} complexity
         */
        complexity: function() {
          return 1;
        }
      }
    ), l.Text.ATTRIBUTE_NAMES = l.SHARED_ATTRIBUTES.concat(
      "x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")
    ), l.Text.DEFAULT_SVG_FONT_SIZE = 16, l.Text.fromElement = function(c, e, h) {
      if (!c)
        return e(null);
      var m = l.parseAttributes(c, l.Text.ATTRIBUTE_NAMES), b = m.textAnchor || "left";
      if (h = l.util.object.extend(h ? p(h) : {}, m), h.top = h.top || 0, h.left = h.left || 0, m.textDecoration) {
        var f = m.textDecoration;
        f.indexOf("underline") !== -1 && (h.underline = !0), f.indexOf("overline") !== -1 && (h.overline = !0), f.indexOf("line-through") !== -1 && (h.linethrough = !0), delete h.textDecoration;
      }
      "dx" in m && (h.left += m.dx), "dy" in m && (h.top += m.dy), "fontSize" in h || (h.fontSize = l.Text.DEFAULT_SVG_FONT_SIZE);
      var k = "";
      "textContent" in c ? k = c.textContent : "firstChild" in c && c.firstChild !== null && "data" in c.firstChild && c.firstChild.data !== null && (k = c.firstChild.data), k = k.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
      var E = h.strokeWidth;
      h.strokeWidth = 0;
      var _ = new l.Text(k, h), T = _.getScaledHeight() / _.height, D = (_.height + _.strokeWidth) * _.lineHeight - _.height, V = D * T, I = _.getScaledHeight() + V, M = 0;
      b === "center" && (M = _.getScaledWidth() / 2), b === "right" && (M = _.getScaledWidth()), _.set({
        left: _.left - M,
        top: _.top - (I - _.fontSize * (0.07 + _._fontSizeFraction)) / _.lineHeight,
        strokeWidth: typeof E < "u" ? E : 1
      }), e(_);
    }, l.Text.fromObject = function(c, e) {
      var h = p(c), m = c.path;
      return delete h.path, l.Object._fromObject("Text", h, function(b) {
        b.styles = l.util.stylesFromArray(c.styles, c.text), m ? l.Object._fromObject("Path", m, function(f) {
          b.set("path", f), e(b);
        }, "path") : e(b);
      }, "text");
    }, l.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], l.util.createAccessors && l.util.createAccessors(l.Text);
  }(i), function() {
    n.util.object.extend(
      n.Text.prototype,
      /** @lends fabric.Text.prototype */
      {
        /**
         * Returns true if object has no styling or no styling in a line
         * @param {Number} lineIndex , lineIndex is on wrapped lines.
         * @return {Boolean}
         */
        isEmptyStyles: function(d) {
          if (!this.styles || typeof d < "u" && !this.styles[d])
            return !0;
          var l = typeof d > "u" ? this.styles : { line: this.styles[d] };
          for (var p in l)
            for (var v in l[p])
              for (var c in l[p][v])
                return !1;
          return !0;
        },
        /**
         * Returns true if object has a style property or has it ina specified line
         * This function is used to detect if a text will use a particular property or not.
         * @param {String} property to check for
         * @param {Number} lineIndex to check the style on
         * @return {Boolean}
         */
        styleHas: function(d, l) {
          if (!this.styles || !d || d === "" || typeof l < "u" && !this.styles[l])
            return !1;
          var p = typeof l > "u" ? this.styles : { 0: this.styles[l] };
          for (var v in p)
            for (var c in p[v])
              if (typeof p[v][c][d] < "u")
                return !0;
          return !1;
        },
        /**
         * Check if characters in a text have a value for a property
         * whose value matches the textbox's value for that property.  If so,
         * the character-level property is deleted.  If the character
         * has no other properties, then it is also deleted.  Finally,
         * if the line containing that character has no other characters
         * then it also is deleted.
         *
         * @param {string} property The property to compare between characters and text.
         */
        cleanStyle: function(d) {
          if (!this.styles || !d || d === "")
            return !1;
          var l = this.styles, p = 0, v, c, e = !0, h = 0, m;
          for (var b in l) {
            v = 0;
            for (var f in l[b]) {
              var m = l[b][f], k = m.hasOwnProperty(d);
              p++, k ? (c ? m[d] !== c && (e = !1) : c = m[d], m[d] === this[d] && delete m[d]) : e = !1, Object.keys(m).length !== 0 ? v++ : delete l[b][f];
            }
            v === 0 && delete l[b];
          }
          for (var E = 0; E < this._textLines.length; E++)
            h += this._textLines[E].length;
          e && p === h && (this[d] = c, this.removeStyle(d));
        },
        /**
         * Remove a style property or properties from all individual character styles
         * in a text object.  Deletes the character style object if it contains no other style
         * props.  Deletes a line style object if it contains no other character styles.
         *
         * @param {String} props The property to remove from character styles.
         */
        removeStyle: function(d) {
          if (!(!this.styles || !d || d === "")) {
            var l = this.styles, p, v, c;
            for (v in l) {
              p = l[v];
              for (c in p)
                delete p[c][d], Object.keys(p[c]).length === 0 && delete p[c];
              Object.keys(p).length === 0 && delete l[v];
            }
          }
        },
        /**
         * @private
         */
        _extendStyles: function(d, l) {
          var p = this.get2DCursorLocation(d);
          this._getLineStyle(p.lineIndex) || this._setLineStyle(p.lineIndex), this._getStyleDeclaration(p.lineIndex, p.charIndex) || this._setStyleDeclaration(p.lineIndex, p.charIndex, {}), n.util.object.extend(this._getStyleDeclaration(p.lineIndex, p.charIndex), l);
        },
        /**
         * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
         * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
         * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.
         */
        get2DCursorLocation: function(d, l) {
          typeof d > "u" && (d = this.selectionStart);
          for (var p = l ? this._unwrappedTextLines : this._textLines, v = p.length, c = 0; c < v; c++) {
            if (d <= p[c].length)
              return {
                lineIndex: c,
                charIndex: d
              };
            d -= p[c].length + this.missingNewlineOffset(c);
          }
          return {
            lineIndex: c - 1,
            charIndex: p[c - 1].length < d ? p[c - 1].length : d
          };
        },
        /**
         * Gets style of a current selection/cursor (at the start position)
         * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.
         * @param {Number} [startIndex] Start index to get styles at
         * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
         * @param {Boolean} [complete] get full style or not
         * @return {Array} styles an array with one, zero or more Style objects
         */
        getSelectionStyles: function(d, l, p) {
          typeof d > "u" && (d = this.selectionStart || 0), typeof l > "u" && (l = this.selectionEnd || d);
          for (var v = [], c = d; c < l; c++)
            v.push(this.getStyleAtPosition(c, p));
          return v;
        },
        /**
         * Gets style of a current selection/cursor position
         * @param {Number} position  to get styles at
         * @param {Boolean} [complete] full style if true
         * @return {Object} style Style object at a specified index
         * @private
         */
        getStyleAtPosition: function(d, l) {
          var p = this.get2DCursorLocation(d), v = l ? this.getCompleteStyleDeclaration(p.lineIndex, p.charIndex) : this._getStyleDeclaration(p.lineIndex, p.charIndex);
          return v || {};
        },
        /**
         * Sets style of a current selection, if no selection exist, do not set anything.
         * @param {Object} [styles] Styles object
         * @param {Number} [startIndex] Start index to get styles at
         * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
         * @return {fabric.IText} thisArg
         * @chainable
         */
        setSelectionStyles: function(d, l, p) {
          typeof l > "u" && (l = this.selectionStart || 0), typeof p > "u" && (p = this.selectionEnd || l);
          for (var v = l; v < p; v++)
            this._extendStyles(v, d);
          return this._forceClearCache = !0, this;
        },
        /**
         * get the reference, not a clone, of the style object for a given character
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @return {Object} style object
         */
        _getStyleDeclaration: function(d, l) {
          var p = this.styles && this.styles[d];
          return p ? p[l] : null;
        },
        /**
         * return a new object that contains all the style property for a character
         * the object returned is newly created
         * @param {Number} lineIndex of the line where the character is
         * @param {Number} charIndex position of the character on the line
         * @return {Object} style object
         */
        getCompleteStyleDeclaration: function(d, l) {
          for (var p = this._getStyleDeclaration(d, l) || {}, v = {}, c, e = 0; e < this._styleProperties.length; e++)
            c = this._styleProperties[e], v[c] = typeof p[c] > "u" ? this[c] : p[c];
          return v;
        },
        /**
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @param {Object} style
         * @private
         */
        _setStyleDeclaration: function(d, l, p) {
          this.styles[d][l] = p;
        },
        /**
         *
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @private
         */
        _deleteStyleDeclaration: function(d, l) {
          delete this.styles[d][l];
        },
        /**
         * @param {Number} lineIndex
         * @return {Boolean} if the line exists or not
         * @private
         */
        _getLineStyle: function(d) {
          return !!this.styles[d];
        },
        /**
         * Set the line style to an empty object so that is initialized
         * @param {Number} lineIndex
         * @private
         */
        _setLineStyle: function(d) {
          this.styles[d] = {};
        },
        /**
         * @param {Number} lineIndex
         * @private
         */
        _deleteLineStyle: function(d) {
          delete this.styles[d];
        }
      }
    );
  }(), function() {
    function d(l) {
      l.textDecoration && (l.textDecoration.indexOf("underline") > -1 && (l.underline = !0), l.textDecoration.indexOf("line-through") > -1 && (l.linethrough = !0), l.textDecoration.indexOf("overline") > -1 && (l.overline = !0), delete l.textDecoration);
    }
    n.IText = n.util.createClass(
      n.Text,
      n.Observable,
      /** @lends fabric.IText.prototype */
      {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "i-text",
        /**
         * Index where text selection starts (or where cursor is when there is no selection)
         * @type Number
         * @default
         */
        selectionStart: 0,
        /**
         * Index where text selection ends
         * @type Number
         * @default
         */
        selectionEnd: 0,
        /**
         * Color of text selection
         * @type String
         * @default
         */
        selectionColor: "rgba(17,119,255,0.3)",
        /**
         * Indicates whether text is in editing mode
         * @type Boolean
         * @default
         */
        isEditing: !1,
        /**
         * Indicates whether a text can be edited
         * @type Boolean
         * @default
         */
        editable: !0,
        /**
         * Border color of text object while it's in editing mode
         * @type String
         * @default
         */
        editingBorderColor: "rgba(102,153,255,0.25)",
        /**
         * Width of cursor (in px)
         * @type Number
         * @default
         */
        cursorWidth: 2,
        /**
         * Color of text cursor color in editing mode.
         * if not set (default) will take color from the text.
         * if set to a color value that fabric can understand, it will
         * be used instead of the color of the text at the current position.
         * @type String
         * @default
         */
        cursorColor: "",
        /**
         * Delay between cursor blink (in ms)
         * @type Number
         * @default
         */
        cursorDelay: 1e3,
        /**
         * Duration of cursor fadein (in ms)
         * @type Number
         * @default
         */
        cursorDuration: 600,
        /**
         * Indicates whether internal text char widths can be cached
         * @type Boolean
         * @default
         */
        caching: !0,
        /**
         * DOM container to append the hiddenTextarea.
         * An alternative to attaching to the document.body.
         * Useful to reduce laggish redraw of the full document.body tree and
         * also with modals event capturing that won't let the textarea take focus.
         * @type HTMLElement
         * @default
         */
        hiddenTextareaContainer: null,
        /**
         * @private
         */
        _reSpace: /\s|\n/,
        /**
         * @private
         */
        _currentCursorOpacity: 0,
        /**
         * @private
         */
        _selectionDirection: null,
        /**
         * @private
         */
        _abortCursorAnimation: !1,
        /**
         * @private
         */
        __widthOfSpace: [],
        /**
         * Helps determining when the text is in composition, so that the cursor
         * rendering is altered.
         */
        inCompositionMode: !1,
        /**
         * Constructor
         * @param {String} text Text string
         * @param {Object} [options] Options object
         * @return {fabric.IText} thisArg
         */
        initialize: function(l, p) {
          this.callSuper("initialize", l, p), this.initBehavior();
        },
        /**
         * Sets selection start (left boundary of a selection)
         * @param {Number} index Index to set selection start to
         */
        setSelectionStart: function(l) {
          l = Math.max(l, 0), this._updateAndFire("selectionStart", l);
        },
        /**
         * Sets selection end (right boundary of a selection)
         * @param {Number} index Index to set selection end to
         */
        setSelectionEnd: function(l) {
          l = Math.min(l, this.text.length), this._updateAndFire("selectionEnd", l);
        },
        /**
         * @private
         * @param {String} property 'selectionStart' or 'selectionEnd'
         * @param {Number} index new position of property
         */
        _updateAndFire: function(l, p) {
          this[l] !== p && (this._fireSelectionChanged(), this[l] = p), this._updateTextarea();
        },
        /**
         * Fires the even of selection changed
         * @private
         */
        _fireSelectionChanged: function() {
          this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
        },
        /**
         * Initialize text dimensions. Render all text on given context
         * or on a offscreen canvas to get the text width with measureText.
         * Updates this.width and this.height with the proper values.
         * Does not return dimensions.
         * @private
         */
        initDimensions: function() {
          this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions");
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        render: function(l) {
          this.clearContextTop(), this.callSuper("render", l), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
        },
        /**
         * @private
         * @param {CanvasRenderingContext2D} ctx Context to render on
         */
        _render: function(l) {
          this.callSuper("_render", l);
        },
        /**
         * Prepare and clean the contextTop
         */
        clearContextTop: function(l) {
          if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
            var p = this.canvas.contextTop, v = this.canvas.viewportTransform;
            p.save(), p.transform(v[0], v[1], v[2], v[3], v[4], v[5]), this.transform(p), this._clearTextArea(p), l || p.restore();
          }
        },
        /**
         * Renders cursor or selection (depending on what exists)
         * it does on the contextTop. If contextTop is not available, do nothing.
         */
        renderCursorOrSelection: function() {
          if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
            var l = this._getCursorBoundaries(), p = this.canvas.contextTop;
            this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(l, p) : this.renderSelection(l, p), p.restore();
          }
        },
        _clearTextArea: function(l) {
          var p = this.width + 4, v = this.height + 4;
          l.clearRect(-p / 2, -v / 2, p, v);
        },
        /**
         * Returns cursor boundaries (left, top, leftOffset, topOffset)
         * @private
         * @param {Array} chars Array of characters
         * @param {String} typeOfBoundaries
         */
        _getCursorBoundaries: function(l) {
          typeof l > "u" && (l = this.selectionStart);
          var p = this._getLeftOffset(), v = this._getTopOffset(), c = this._getCursorBoundariesOffsets(l);
          return {
            left: p,
            top: v,
            leftOffset: c.left,
            topOffset: c.top
          };
        },
        /**
         * @private
         */
        _getCursorBoundariesOffsets: function(l) {
          if (this.cursorOffsetCache && "top" in this.cursorOffsetCache)
            return this.cursorOffsetCache;
          var p, v, c, e = 0, h = 0, m, b = this.get2DCursorLocation(l);
          c = b.charIndex, v = b.lineIndex;
          for (var f = 0; f < v; f++)
            e += this.getHeightOfLine(f);
          p = this._getLineLeftOffset(v);
          var k = this.__charBounds[v][c];
          return k && (h = k.left), this.charSpacing !== 0 && c === this._textLines[v].length && (h -= this._getWidthOfCharSpacing()), m = {
            top: e,
            left: p + (h > 0 ? h : 0)
          }, this.direction === "rtl" && (m.left *= -1), this.cursorOffsetCache = m, this.cursorOffsetCache;
        },
        /**
         * Renders cursor
         * @param {Object} boundaries
         * @param {CanvasRenderingContext2D} ctx transformed context to draw on
         */
        renderCursor: function(l, p) {
          var v = this.get2DCursorLocation(), c = v.lineIndex, e = v.charIndex > 0 ? v.charIndex - 1 : 0, h = this.getValueOfPropertyAt(c, e, "fontSize"), m = this.scaleX * this.canvas.getZoom(), b = this.cursorWidth / m, f = l.topOffset, k = this.getValueOfPropertyAt(c, e, "deltaY");
          f += (1 - this._fontSizeFraction) * this.getHeightOfLine(c) / this.lineHeight - h * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(l, p), p.fillStyle = this.cursorColor || this.getValueOfPropertyAt(c, e, "fill"), p.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, p.fillRect(
            l.left + l.leftOffset - b / 2,
            f + l.top + k,
            b,
            h
          );
        },
        /**
         * Renders text selection
         * @param {Object} boundaries Object with left/top/leftOffset/topOffset
         * @param {CanvasRenderingContext2D} ctx transformed context to draw on
         */
        renderSelection: function(l, p) {
          for (var v = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, c = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, e = this.textAlign.indexOf("justify") !== -1, h = this.get2DCursorLocation(v), m = this.get2DCursorLocation(c), b = h.lineIndex, f = m.lineIndex, k = h.charIndex < 0 ? 0 : h.charIndex, E = m.charIndex < 0 ? 0 : m.charIndex, _ = b; _ <= f; _++) {
            var T = this._getLineLeftOffset(_) || 0, D = this.getHeightOfLine(_), V = 0, I = 0, M = 0;
            if (_ === b && (I = this.__charBounds[b][k].left), _ >= b && _ < f)
              M = e && !this.isEndOfWrapping(_) ? this.width : this.getLineWidth(_) || 5;
            else if (_ === f)
              if (E === 0)
                M = this.__charBounds[f][E].left;
              else {
                var Q = this._getWidthOfCharSpacing();
                M = this.__charBounds[f][E - 1].left + this.__charBounds[f][E - 1].width - Q;
              }
            V = D, (this.lineHeight < 1 || _ === f && this.lineHeight > 1) && (D /= this.lineHeight);
            var G = l.left + T + I, z = M - I, re = D, he = 0;
            this.inCompositionMode ? (p.fillStyle = this.compositionColor || "black", re = 1, he = D) : p.fillStyle = this.selectionColor, this.direction === "rtl" && (G = this.width - G - z), p.fillRect(
              G,
              l.top + l.topOffset + he,
              z,
              re
            ), l.topOffset += V;
          }
        },
        /**
         * High level function to know the height of the cursor.
         * the currentChar is the one that precedes the cursor
         * Returns fontSize of char at the current cursor
         * Unused from the library, is for the end user
         * @return {Number} Character font size
         */
        getCurrentCharFontSize: function() {
          var l = this._getCurrentCharIndex();
          return this.getValueOfPropertyAt(l.l, l.c, "fontSize");
        },
        /**
         * High level function to know the color of the cursor.
         * the currentChar is the one that precedes the cursor
         * Returns color (fill) of char at the current cursor
         * if the text object has a pattern or gradient for filler, it will return that.
         * Unused by the library, is for the end user
         * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)
         */
        getCurrentCharColor: function() {
          var l = this._getCurrentCharIndex();
          return this.getValueOfPropertyAt(l.l, l.c, "fill");
        },
        /**
         * Returns the cursor position for the getCurrent.. functions
         * @private
         */
        _getCurrentCharIndex: function() {
          var l = this.get2DCursorLocation(this.selectionStart, !0), p = l.charIndex > 0 ? l.charIndex - 1 : 0;
          return { l: l.lineIndex, c: p };
        }
      }
    ), n.IText.fromObject = function(l, p) {
      var v = n.util.stylesFromArray(l.styles, l.text), c = Object.assign({}, l, { styles: v });
      if (d(c), c.styles)
        for (var e in c.styles)
          for (var h in c.styles[e])
            d(c.styles[e][h]);
      n.Object._fromObject("IText", c, p, "text");
    };
  }(), function() {
    var d = n.util.object.clone;
    n.util.object.extend(
      n.IText.prototype,
      /** @lends fabric.IText.prototype */
      {
        /**
         * Initializes all the interactive behavior of IText
         */
        initBehavior: function() {
          this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
        },
        onDeselect: function() {
          this.isEditing && this.exitEditing(), this.selected = !1;
        },
        /**
         * Initializes "added" event handler
         */
        initAddedHandler: function() {
          var l = this;
          this.on("added", function() {
            var p = l.canvas;
            p && (p._hasITextHandlers || (p._hasITextHandlers = !0, l._initCanvasHandlers(p)), p._iTextInstances = p._iTextInstances || [], p._iTextInstances.push(l));
          });
        },
        initRemovedHandler: function() {
          var l = this;
          this.on("removed", function() {
            var p = l.canvas;
            p && (p._iTextInstances = p._iTextInstances || [], n.util.removeFromArray(p._iTextInstances, l), p._iTextInstances.length === 0 && (p._hasITextHandlers = !1, l._removeCanvasHandlers(p)));
          });
        },
        /**
         * register canvas event to manage exiting on other instances
         * @private
         */
        _initCanvasHandlers: function(l) {
          l._mouseUpITextHandler = function() {
            l._iTextInstances && l._iTextInstances.forEach(function(p) {
              p.__isMousedown = !1;
            });
          }, l.on("mouse:up", l._mouseUpITextHandler);
        },
        /**
         * remove canvas event to manage exiting on other instances
         * @private
         */
        _removeCanvasHandlers: function(l) {
          l.off("mouse:up", l._mouseUpITextHandler);
        },
        /**
         * @private
         */
        _tick: function() {
          this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete");
        },
        /**
         * @private
         */
        _animateCursor: function(l, p, v, c) {
          var e;
          return e = {
            isAborted: !1,
            abort: function() {
              this.isAborted = !0;
            }
          }, l.animate("_currentCursorOpacity", p, {
            duration: v,
            onComplete: function() {
              e.isAborted || l[c]();
            },
            onChange: function() {
              l.canvas && l.selectionStart === l.selectionEnd && l.renderCursorOrSelection();
            },
            abort: function() {
              return e.isAborted;
            }
          }), e;
        },
        /**
         * @private
         */
        _onTickComplete: function() {
          var l = this;
          this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function() {
            l._currentTickCompleteState = l._animateCursor(l, 0, this.cursorDuration / 2, "_tick");
          }, 100);
        },
        /**
         * Initializes delayed cursor
         */
        initDelayedCursor: function(l) {
          var p = this, v = l ? 0 : this.cursorDelay;
          this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function() {
            p._tick();
          }, v);
        },
        /**
         * Aborts cursor animation and clears all timeouts
         */
        abortCursorAnimation: function() {
          var l = this._currentTickState || this._currentTickCompleteState, p = this.canvas;
          this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, l && p && p.clearContext(p.contextTop || p.contextContainer);
        },
        /**
         * Selects entire text
         * @return {fabric.IText} thisArg
         * @chainable
         */
        selectAll: function() {
          return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
        },
        /**
         * Returns selected text
         * @return {String}
         */
        getSelectedText: function() {
          return this._text.slice(this.selectionStart, this.selectionEnd).join("");
        },
        /**
         * Find new selection index representing start of current word according to current selection index
         * @param {Number} startFrom Current selection index
         * @return {Number} New selection index
         */
        findWordBoundaryLeft: function(l) {
          var p = 0, v = l - 1;
          if (this._reSpace.test(this._text[v]))
            for (; this._reSpace.test(this._text[v]); )
              p++, v--;
          for (; /\S/.test(this._text[v]) && v > -1; )
            p++, v--;
          return l - p;
        },
        /**
         * Find new selection index representing end of current word according to current selection index
         * @param {Number} startFrom Current selection index
         * @return {Number} New selection index
         */
        findWordBoundaryRight: function(l) {
          var p = 0, v = l;
          if (this._reSpace.test(this._text[v]))
            for (; this._reSpace.test(this._text[v]); )
              p++, v++;
          for (; /\S/.test(this._text[v]) && v < this._text.length; )
            p++, v++;
          return l + p;
        },
        /**
         * Find new selection index representing start of current line according to current selection index
         * @param {Number} startFrom Current selection index
         * @return {Number} New selection index
         */
        findLineBoundaryLeft: function(l) {
          for (var p = 0, v = l - 1; !/\n/.test(this._text[v]) && v > -1; )
            p++, v--;
          return l - p;
        },
        /**
         * Find new selection index representing end of current line according to current selection index
         * @param {Number} startFrom Current selection index
         * @return {Number} New selection index
         */
        findLineBoundaryRight: function(l) {
          for (var p = 0, v = l; !/\n/.test(this._text[v]) && v < this._text.length; )
            p++, v++;
          return l + p;
        },
        /**
         * Finds index corresponding to beginning or end of a word
         * @param {Number} selectionStart Index of a character
         * @param {Number} direction 1 or -1
         * @return {Number} Index of the beginning or end of a word
         */
        searchWordBoundary: function(l, p) {
          for (var v = this._text, c = this._reSpace.test(v[l]) ? l - 1 : l, e = v[c], h = n.reNonWord; !h.test(e) && c > 0 && c < v.length; )
            c += p, e = v[c];
          return h.test(e) && (c += p === 1 ? 0 : 1), c;
        },
        /**
         * Selects a word based on the index
         * @param {Number} selectionStart Index of a character
         */
        selectWord: function(l) {
          l = l || this.selectionStart;
          var p = this.searchWordBoundary(l, -1), v = this.searchWordBoundary(l, 1);
          this.selectionStart = p, this.selectionEnd = v, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
        },
        /**
         * Selects a line based on the index
         * @param {Number} selectionStart Index of a character
         * @return {fabric.IText} thisArg
         * @chainable
         */
        selectLine: function(l) {
          l = l || this.selectionStart;
          var p = this.findLineBoundaryLeft(l), v = this.findLineBoundaryRight(l);
          return this.selectionStart = p, this.selectionEnd = v, this._fireSelectionChanged(), this._updateTextarea(), this;
        },
        /**
         * Enters editing state
         * @return {fabric.IText} thisArg
         * @chainable
         */
        enterEditing: function(l) {
          if (!(this.isEditing || !this.editable))
            return this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(l), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this;
        },
        exitEditingOnOthers: function(l) {
          l._iTextInstances && l._iTextInstances.forEach(function(p) {
            p.selected = !1, p.isEditing && p.exitEditing();
          });
        },
        /**
         * Initializes "mousemove" event handler
         */
        initMouseMoveHandler: function() {
          this.canvas.on("mouse:move", this.mouseMoveHandler);
        },
        /**
         * @private
         */
        mouseMoveHandler: function(l) {
          if (!(!this.__isMousedown || !this.isEditing)) {
            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();
            var p = this.getSelectionStartFromPointer(l.e), v = this.selectionStart, c = this.selectionEnd;
            (p !== this.__selectionStartOnMouseDown || v === c) && (v === p || c === p) || (p > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = p) : (this.selectionStart = p, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== v || this.selectionEnd !== c) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
          }
        },
        /**
         * @private
         */
        _setEditingProps: function() {
          this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
        },
        /**
         * convert from textarea to grapheme indexes
         */
        fromStringToGraphemeSelection: function(l, p, v) {
          var c = v.slice(0, l), e = n.util.string.graphemeSplit(c).length;
          if (l === p)
            return { selectionStart: e, selectionEnd: e };
          var h = v.slice(l, p), m = n.util.string.graphemeSplit(h).length;
          return { selectionStart: e, selectionEnd: e + m };
        },
        /**
         * convert from fabric to textarea values
         */
        fromGraphemeToStringSelection: function(l, p, v) {
          var c = v.slice(0, l), e = c.join("").length;
          if (l === p)
            return { selectionStart: e, selectionEnd: e };
          var h = v.slice(l, p), m = h.join("").length;
          return { selectionStart: e, selectionEnd: e + m };
        },
        /**
         * @private
         */
        _updateTextarea: function() {
          if (this.cursorOffsetCache = {}, !!this.hiddenTextarea) {
            if (!this.inCompositionMode) {
              var l = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
              this.hiddenTextarea.selectionStart = l.selectionStart, this.hiddenTextarea.selectionEnd = l.selectionEnd;
            }
            this.updateTextareaPosition();
          }
        },
        /**
         * @private
         */
        updateFromTextArea: function() {
          if (this.hiddenTextarea) {
            this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords());
            var l = this.fromStringToGraphemeSelection(
              this.hiddenTextarea.selectionStart,
              this.hiddenTextarea.selectionEnd,
              this.hiddenTextarea.value
            );
            this.selectionEnd = this.selectionStart = l.selectionEnd, this.inCompositionMode || (this.selectionStart = l.selectionStart), this.updateTextareaPosition();
          }
        },
        /**
         * @private
         */
        updateTextareaPosition: function() {
          if (this.selectionStart === this.selectionEnd) {
            var l = this._calcTextareaPosition();
            this.hiddenTextarea.style.left = l.left, this.hiddenTextarea.style.top = l.top;
          }
        },
        /**
         * @private
         * @return {Object} style contains style for hiddenTextarea
         */
        _calcTextareaPosition: function() {
          if (!this.canvas)
            return { x: 1, y: 1 };
          var l = this.inCompositionMode ? this.compositionStart : this.selectionStart, p = this._getCursorBoundaries(l), v = this.get2DCursorLocation(l), c = v.lineIndex, e = v.charIndex, h = this.getValueOfPropertyAt(c, e, "fontSize") * this.lineHeight, m = p.leftOffset, b = this.calcTransformMatrix(), f = {
            x: p.left + m,
            y: p.top + p.topOffset + h
          }, k = this.canvas.getRetinaScaling(), E = this.canvas.upperCanvasEl, _ = E.width / k, T = E.height / k, D = _ - h, V = T - h, I = E.clientWidth / _, M = E.clientHeight / T;
          return f = n.util.transformPoint(f, b), f = n.util.transformPoint(f, this.canvas.viewportTransform), f.x *= I, f.y *= M, f.x < 0 && (f.x = 0), f.x > D && (f.x = D), f.y < 0 && (f.y = 0), f.y > V && (f.y = V), f.x += this.canvas._offset.left, f.y += this.canvas._offset.top, { left: f.x + "px", top: f.y + "px", fontSize: h + "px", charHeight: h };
        },
        /**
         * @private
         */
        _saveEditingProps: function() {
          this._savedProps = {
            hasControls: this.hasControls,
            borderColor: this.borderColor,
            lockMovementX: this.lockMovementX,
            lockMovementY: this.lockMovementY,
            hoverCursor: this.hoverCursor,
            selectable: this.selectable,
            defaultCursor: this.canvas && this.canvas.defaultCursor,
            moveCursor: this.canvas && this.canvas.moveCursor
          };
        },
        /**
         * @private
         */
        _restoreEditingProps: function() {
          this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor));
        },
        /**
         * Exits from editing state
         * @return {fabric.IText} thisArg
         * @chainable
         */
        exitEditing: function() {
          var l = this._textBeforeEdit !== this.text, p = this.hiddenTextarea;
          return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, p && (p.blur && p.blur(), p.parentNode && p.parentNode.removeChild(p)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), l && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), l && this.canvas.fire("object:modified", { target: this })), this;
        },
        /**
         * @private
         */
        _removeExtraneousStyles: function() {
          for (var l in this.styles)
            this._textLines[l] || delete this.styles[l];
        },
        /**
         * remove and reflow a style block from start to end.
         * @param {Number} start linear start position for removal (included in removal)
         * @param {Number} end linear end position for removal ( excluded from removal )
         */
        removeStyleFromTo: function(l, p) {
          var v = this.get2DCursorLocation(l, !0), c = this.get2DCursorLocation(p, !0), e = v.lineIndex, h = v.charIndex, m = c.lineIndex, b = c.charIndex, f, k;
          if (e !== m) {
            if (this.styles[e])
              for (f = h; f < this._unwrappedTextLines[e].length; f++)
                delete this.styles[e][f];
            if (this.styles[m])
              for (f = b; f < this._unwrappedTextLines[m].length; f++)
                k = this.styles[m][f], k && (this.styles[e] || (this.styles[e] = {}), this.styles[e][h + f - b] = k);
            for (f = e + 1; f <= m; f++)
              delete this.styles[f];
            this.shiftLineStyles(m, e - m);
          } else if (this.styles[e]) {
            k = this.styles[e];
            var E = b - h, _, T;
            for (f = h; f < b; f++)
              delete k[f];
            for (T in this.styles[e])
              _ = parseInt(T, 10), _ >= b && (k[_ - E] = k[T], delete k[T]);
          }
        },
        /**
         * Shifts line styles up or down
         * @param {Number} lineIndex Index of a line
         * @param {Number} offset Can any number?
         */
        shiftLineStyles: function(l, p) {
          var v = d(this.styles);
          for (var c in this.styles) {
            var e = parseInt(c, 10);
            e > l && (this.styles[e + p] = v[e], v[e - p] || delete this.styles[e]);
          }
        },
        restartCursorIfNeeded: function() {
          (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor();
        },
        /**
         * Handle insertion of more consecutive style lines for when one or more
         * newlines gets added to the text. Since current style needs to be shifted
         * first we shift the current style of the number lines needed, then we add
         * new lines from the last to the first.
         * @param {Number} lineIndex Index of a line
         * @param {Number} charIndex Index of a char
         * @param {Number} qty number of lines to add
         * @param {Array} copiedStyle Array of objects styles
         */
        insertNewlineStyleObject: function(l, p, v, c) {
          var e, h = {}, m = !1, b = this._unwrappedTextLines[l].length === p;
          v || (v = 1), this.shiftLineStyles(l, v), this.styles[l] && (e = this.styles[l][p === 0 ? p : p - 1]);
          for (var f in this.styles[l]) {
            var k = parseInt(f, 10);
            k >= p && (m = !0, h[k - p] = this.styles[l][f], b && p === 0 || delete this.styles[l][f]);
          }
          var E = !1;
          for (m && !b && (this.styles[l + v] = h, E = !0), E && v--; v > 0; )
            c && c[v - 1] ? this.styles[l + v] = { 0: d(c[v - 1]) } : e ? this.styles[l + v] = { 0: d(e) } : delete this.styles[l + v], v--;
          this._forceClearCache = !0;
        },
        /**
         * Inserts style object for a given line/char index
         * @param {Number} lineIndex Index of a line
         * @param {Number} charIndex Index of a char
         * @param {Number} quantity number Style object to insert, if given
         * @param {Array} copiedStyle array of style objects
         */
        insertCharStyleObject: function(l, p, v, c) {
          this.styles || (this.styles = {});
          var e = this.styles[l], h = e ? d(e) : {};
          v || (v = 1);
          for (var m in h) {
            var b = parseInt(m, 10);
            b >= p && (e[b + v] = h[b], h[b - v] || delete e[b]);
          }
          if (this._forceClearCache = !0, c) {
            for (; v--; )
              Object.keys(c[v]).length && (this.styles[l] || (this.styles[l] = {}), this.styles[l][p + v] = d(c[v]));
            return;
          }
          if (e)
            for (var f = e[p ? p - 1 : 1]; f && v--; )
              this.styles[l][p + v] = d(f);
        },
        /**
         * Inserts style object(s)
         * @param {Array} insertedText Characters at the location where style is inserted
         * @param {Number} start cursor index for inserting style
         * @param {Array} [copiedStyle] array of style objects to insert.
         */
        insertNewStyleBlock: function(l, p, v) {
          for (var c = this.get2DCursorLocation(p, !0), e = [0], h = 0, m = 0; m < l.length; m++)
            l[m] === `
` ? (h++, e[h] = 0) : e[h]++;
          e[0] > 0 && (this.insertCharStyleObject(c.lineIndex, c.charIndex, e[0], v), v = v && v.slice(e[0] + 1)), h && this.insertNewlineStyleObject(
            c.lineIndex,
            c.charIndex + e[0],
            h
          );
          for (var m = 1; m < h; m++)
            e[m] > 0 ? this.insertCharStyleObject(c.lineIndex + m, 0, e[m], v) : v && this.styles[c.lineIndex + m] && v[0] && (this.styles[c.lineIndex + m][0] = v[0]), v = v && v.slice(e[m] + 1);
          e[m] > 0 && this.insertCharStyleObject(c.lineIndex + m, 0, e[m], v);
        },
        /**
         * Set the selectionStart and selectionEnd according to the new position of cursor
         * mimic the key - mouse navigation when shift is pressed.
         */
        setSelectionStartEndWithShift: function(l, p, v) {
          v <= l ? (p === l ? this._selectionDirection = "left" : this._selectionDirection === "right" && (this._selectionDirection = "left", this.selectionEnd = l), this.selectionStart = v) : v > l && v < p ? this._selectionDirection === "right" ? this.selectionEnd = v : this.selectionStart = v : (p === l ? this._selectionDirection = "right" : this._selectionDirection === "left" && (this._selectionDirection = "right", this.selectionStart = p), this.selectionEnd = v);
        },
        setSelectionInBoundaries: function() {
          var l = this.text.length;
          this.selectionStart > l ? this.selectionStart = l : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > l ? this.selectionEnd = l : this.selectionEnd < 0 && (this.selectionEnd = 0);
        }
      }
    );
  }(), n.util.object.extend(
    n.IText.prototype,
    /** @lends fabric.IText.prototype */
    {
      /**
       * Initializes "dbclick" event handler
       */
      initDoubleClickSimulation: function() {
        this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown);
      },
      /**
       * Default event handler to simulate triple click
       * @private
       */
      onMouseDown: function(d) {
        if (this.canvas) {
          this.__newClickTime = +/* @__PURE__ */ new Date();
          var l = d.pointer;
          this.isTripleClick(l) && (this.fire("tripleclick", d), this._stopEvent(d.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = l, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected;
        }
      },
      isTripleClick: function(d) {
        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === d.x && this.__lastPointer.y === d.y;
      },
      /**
       * @private
       */
      _stopEvent: function(d) {
        d.preventDefault && d.preventDefault(), d.stopPropagation && d.stopPropagation();
      },
      /**
       * Initializes event handlers related to cursor or selection
       */
      initCursorSelectionHandlers: function() {
        this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks();
      },
      /**
       * Default handler for double click, select a word
       */
      doubleClickHandler: function(d) {
        this.isEditing && this.selectWord(this.getSelectionStartFromPointer(d.e));
      },
      /**
       * Default handler for triple click, select a line
       */
      tripleClickHandler: function(d) {
        this.isEditing && this.selectLine(this.getSelectionStartFromPointer(d.e));
      },
      /**
       * Initializes double and triple click event handlers
       */
      initClicks: function() {
        this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler);
      },
      /**
       * Default event handler for the basic functionalities needed on _mouseDown
       * can be overridden to do something different.
       * Scope of this implementation is: find the click position, set selectionStart
       * find selectionEnd, initialize the drawing of either cursor or selection area
       * initializing a mousedDown on a text area will cancel fabricjs knowledge of
       * current compositionMode. It will be set to false.
       */
      _mouseDownHandler: function(d) {
        !this.canvas || !this.editable || d.e.button && d.e.button !== 1 || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(d.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()));
      },
      /**
       * Default event handler for the basic functionalities needed on mousedown:before
       * can be overridden to do something different.
       * Scope of this implementation is: verify the object is already selected when mousing down
       */
      _mouseDownHandlerBefore: function(d) {
        !this.canvas || !this.editable || d.e.button && d.e.button !== 1 || (this.selected = this === this.canvas._activeObject);
      },
      /**
       * Initializes "mousedown" event handler
       */
      initMousedownHandler: function() {
        this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore);
      },
      /**
       * Initializes "mouseup" event handler
       */
      initMouseupHandler: function() {
        this.on("mouseup", this.mouseUpHandler);
      },
      /**
       * standard handler for mouse up, overridable
       * @private
       */
      mouseUpHandler: function(d) {
        if (this.__isMousedown = !1, !(!this.editable || this.group || d.transform && d.transform.actionPerformed || d.e.button && d.e.button !== 1)) {
          if (this.canvas) {
            var l = this.canvas._activeObject;
            if (l && l !== this)
              return;
          }
          this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(d.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0;
        }
      },
      /**
       * Changes cursor location in a text depending on passed pointer (x/y) object
       * @param {Event} e Event object
       */
      setCursorByClick: function(d) {
        var l = this.getSelectionStartFromPointer(d), p = this.selectionStart, v = this.selectionEnd;
        d.shiftKey ? this.setSelectionStartEndWithShift(p, v, l) : (this.selectionStart = l, this.selectionEnd = l), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
      },
      /**
       * Returns index of a character corresponding to where an object was clicked
       * @param {Event} e Event object
       * @return {Number} Index of a character
       */
      getSelectionStartFromPointer: function(d) {
        for (var l = this.getLocalPointer(d), p = 0, v = 0, c = 0, e = 0, h = 0, m, b, f = 0, k = this._textLines.length; f < k && c <= l.y; f++)
          c += this.getHeightOfLine(f) * this.scaleY, h = f, f > 0 && (e += this._textLines[f - 1].length + this.missingNewlineOffset(f - 1));
        m = this._getLineLeftOffset(h), v = m * this.scaleX, b = this._textLines[h], this.direction === "rtl" && (l.x = this.width * this.scaleX - l.x + v);
        for (var E = 0, _ = b.length; E < _ && (p = v, v += this.__charBounds[h][E].kernedWidth * this.scaleX, v <= l.x); E++)
          e++;
        return this._getNewSelectionStartFromOffset(l, p, v, e, _);
      },
      /**
       * @private
       */
      _getNewSelectionStartFromOffset: function(d, l, p, v, c) {
        var e = d.x - l, h = p - d.x, m = h > e || h < 0 ? 0 : 1, b = v + m;
        return this.flipX && (b = c - b), b > this._text.length && (b = this._text.length), b;
      }
    }
  ), n.util.object.extend(
    n.IText.prototype,
    /** @lends fabric.IText.prototype */
    {
      /**
       * Initializes hidden textarea (needed to bring up keyboard in iOS)
       */
      initHiddenTextarea: function() {
        this.hiddenTextarea = n.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off");
        var d = this._calcTextareaPosition();
        this.hiddenTextarea.style.cssText = "position: absolute; top: " + d.top + "; left: " + d.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + d.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : n.document.body.appendChild(this.hiddenTextarea), n.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), n.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), n.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), n.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), n.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), n.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), n.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), n.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), n.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (n.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0);
      },
      /**
       * For functionalities on keyDown
       * Map a special key to a function of the instance/prototype
       * If you need different behaviour for ESC or TAB or arrows, you have to change
       * this map setting the name of a function that you build on the fabric.Itext or
       * your prototype.
       * the map change will affect all Instances unless you need for only some text Instances
       * in that case you have to clone this object and assign your Instance.
       * this.keysMap = fabric.util.object.clone(this.keysMap);
       * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
       */
      keysMap: {
        9: "exitEditing",
        27: "exitEditing",
        33: "moveCursorUp",
        34: "moveCursorDown",
        35: "moveCursorRight",
        36: "moveCursorLeft",
        37: "moveCursorLeft",
        38: "moveCursorUp",
        39: "moveCursorRight",
        40: "moveCursorDown"
      },
      keysMapRtl: {
        9: "exitEditing",
        27: "exitEditing",
        33: "moveCursorUp",
        34: "moveCursorDown",
        35: "moveCursorLeft",
        36: "moveCursorRight",
        37: "moveCursorRight",
        38: "moveCursorUp",
        39: "moveCursorLeft",
        40: "moveCursorDown"
      },
      /**
       * For functionalities on keyUp + ctrl || cmd
       */
      ctrlKeysMapUp: {
        67: "copy",
        88: "cut"
      },
      /**
       * For functionalities on keyDown + ctrl || cmd
       */
      ctrlKeysMapDown: {
        65: "selectAll"
      },
      onClick: function() {
        this.hiddenTextarea && this.hiddenTextarea.focus();
      },
      /**
       * Handles keydown event
       * only used for arrows and combination of modifier keys.
       * @param {Event} e Event object
       */
      onKeyDown: function(d) {
        if (this.isEditing) {
          var l = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
          if (d.keyCode in l)
            this[l[d.keyCode]](d);
          else if (d.keyCode in this.ctrlKeysMapDown && (d.ctrlKey || d.metaKey))
            this[this.ctrlKeysMapDown[d.keyCode]](d);
          else
            return;
          d.stopImmediatePropagation(), d.preventDefault(), d.keyCode >= 33 && d.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
        }
      },
      /**
       * Handles keyup event
       * We handle KeyUp because ie11 and edge have difficulties copy/pasting
       * if a copy/cut event fired, keyup is dismissed
       * @param {Event} e Event object
       */
      onKeyUp: function(d) {
        if (!this.isEditing || this._copyDone || this.inCompositionMode) {
          this._copyDone = !1;
          return;
        }
        if (d.keyCode in this.ctrlKeysMapUp && (d.ctrlKey || d.metaKey))
          this[this.ctrlKeysMapUp[d.keyCode]](d);
        else
          return;
        d.stopImmediatePropagation(), d.preventDefault(), this.canvas && this.canvas.requestRenderAll();
      },
      /**
       * Handles onInput event
       * @param {Event} e Event object
       */
      onInput: function(d) {
        var l = this.fromPaste;
        if (this.fromPaste = !1, d && d.stopPropagation(), !!this.isEditing) {
          var p = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, v = this._text.length, c = p.length, e, h, m = c - v, b = this.selectionStart, f = this.selectionEnd, k = b !== f, E, _, T;
          if (this.hiddenTextarea.value === "") {
            this.styles = {}, this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
            return;
          }
          var D = this.fromStringToGraphemeSelection(
            this.hiddenTextarea.selectionStart,
            this.hiddenTextarea.selectionEnd,
            this.hiddenTextarea.value
          ), V = b > D.selectionStart;
          k ? (e = this._text.slice(b, f), m += f - b) : c < v && (V ? e = this._text.slice(f + m, f) : e = this._text.slice(b, b - m)), h = p.slice(D.selectionEnd - m, D.selectionEnd), e && e.length && (h.length && (E = this.getSelectionStyles(b, b + 1, !1), E = h.map(function() {
            return E[0];
          })), k ? (_ = b, T = f) : V ? (_ = f - e.length, T = f) : (_ = f, T = f + e.length), this.removeStyleFromTo(_, T)), h.length && (l && h.join("") === n.copiedText && !n.disableStyleCopyPaste && (E = n.copiedTextStyle), this.insertNewStyleBlock(h, b, E)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
        }
      },
      /**
       * Composition start
       */
      onCompositionStart: function() {
        this.inCompositionMode = !0;
      },
      /**
       * Composition end
       */
      onCompositionEnd: function() {
        this.inCompositionMode = !1;
      },
      // /**
      //  * Composition update
      //  */
      onCompositionUpdate: function(d) {
        this.compositionStart = d.target.selectionStart, this.compositionEnd = d.target.selectionEnd, this.updateTextareaPosition();
      },
      /**
       * Copies selected text
       * @param {Event} e Event object
       */
      copy: function() {
        this.selectionStart !== this.selectionEnd && (n.copiedText = this.getSelectedText(), n.disableStyleCopyPaste ? n.copiedTextStyle = null : n.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0);
      },
      /**
       * Pastes text
       * @param {Event} e Event object
       */
      paste: function() {
        this.fromPaste = !0;
      },
      /**
       * @private
       * @param {Event} e Event object
       * @return {Object} Clipboard data object
       */
      _getClipboardData: function(d) {
        return d && d.clipboardData || n.window.clipboardData;
      },
      /**
       * Finds the width in pixels before the cursor on the same line
       * @private
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @return {Number} widthBeforeCursor width before cursor
       */
      _getWidthBeforeCursor: function(d, l) {
        var p = this._getLineLeftOffset(d), v;
        return l > 0 && (v = this.__charBounds[d][l - 1], p += v.left + v.width), p;
      },
      /**
       * Gets start offset of a selection
       * @param {Event} e Event object
       * @param {Boolean} isRight
       * @return {Number}
       */
      getDownCursorOffset: function(d, l) {
        var p = this._getSelectionForOffset(d, l), v = this.get2DCursorLocation(p), c = v.lineIndex;
        if (c === this._textLines.length - 1 || d.metaKey || d.keyCode === 34)
          return this._text.length - p;
        var e = v.charIndex, h = this._getWidthBeforeCursor(c, e), m = this._getIndexOnLine(c + 1, h), b = this._textLines[c].slice(e);
        return b.length + m + 1 + this.missingNewlineOffset(c);
      },
      /**
       * private
       * Helps finding if the offset should be counted from Start or End
       * @param {Event} e Event object
       * @param {Boolean} isRight
       * @return {Number}
       */
      _getSelectionForOffset: function(d, l) {
        return d.shiftKey && this.selectionStart !== this.selectionEnd && l ? this.selectionEnd : this.selectionStart;
      },
      /**
       * @param {Event} e Event object
       * @param {Boolean} isRight
       * @return {Number}
       */
      getUpCursorOffset: function(d, l) {
        var p = this._getSelectionForOffset(d, l), v = this.get2DCursorLocation(p), c = v.lineIndex;
        if (c === 0 || d.metaKey || d.keyCode === 33)
          return -p;
        var e = v.charIndex, h = this._getWidthBeforeCursor(c, e), m = this._getIndexOnLine(c - 1, h), b = this._textLines[c].slice(0, e), f = this.missingNewlineOffset(c - 1);
        return -this._textLines[c - 1].length + m - b.length + (1 - f);
      },
      /**
       * for a given width it founds the matching character.
       * @private
       */
      _getIndexOnLine: function(d, l) {
        for (var p = this._textLines[d], v = this._getLineLeftOffset(d), c = v, e = 0, h, m, b = 0, f = p.length; b < f; b++)
          if (h = this.__charBounds[d][b].width, c += h, c > l) {
            m = !0;
            var k = c - h, E = c, _ = Math.abs(k - l), T = Math.abs(E - l);
            e = T < _ ? b : b - 1;
            break;
          }
        return m || (e = p.length - 1), e;
      },
      /**
       * Moves cursor down
       * @param {Event} e Event object
       */
      moveCursorDown: function(d) {
        this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", d);
      },
      /**
       * Moves cursor up
       * @param {Event} e Event object
       */
      moveCursorUp: function(d) {
        this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", d);
      },
      /**
       * Moves cursor up or down, fires the events
       * @param {String} direction 'Up' or 'Down'
       * @param {Event} e Event object
       */
      _moveCursorUpOrDown: function(d, l) {
        var p = "get" + d + "CursorOffset", v = this[p](l, this._selectionDirection === "right");
        l.shiftKey ? this.moveCursorWithShift(v) : this.moveCursorWithoutShift(v), v !== 0 && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
      },
      /**
       * Moves cursor with shift
       * @param {Number} offset
       */
      moveCursorWithShift: function(d) {
        var l = this._selectionDirection === "left" ? this.selectionStart + d : this.selectionEnd + d;
        return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, l), d !== 0;
      },
      /**
       * Moves cursor up without shift
       * @param {Number} offset
       */
      moveCursorWithoutShift: function(d) {
        return d < 0 ? (this.selectionStart += d, this.selectionEnd = this.selectionStart) : (this.selectionEnd += d, this.selectionStart = this.selectionEnd), d !== 0;
      },
      /**
       * Moves cursor left
       * @param {Event} e Event object
       */
      moveCursorLeft: function(d) {
        this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", d);
      },
      /**
       * @private
       * @return {Boolean} true if a change happened
       */
      _move: function(d, l, p) {
        var v;
        if (d.altKey)
          v = this["findWordBoundary" + p](this[l]);
        else if (d.metaKey || d.keyCode === 35 || d.keyCode === 36)
          v = this["findLineBoundary" + p](this[l]);
        else
          return this[l] += p === "Left" ? -1 : 1, !0;
        if (typeof v < "u" && this[l] !== v)
          return this[l] = v, !0;
      },
      /**
       * @private
       */
      _moveLeft: function(d, l) {
        return this._move(d, l, "Left");
      },
      /**
       * @private
       */
      _moveRight: function(d, l) {
        return this._move(d, l, "Right");
      },
      /**
       * Moves cursor left without keeping selection
       * @param {Event} e
       */
      moveCursorLeftWithoutShift: function(d) {
        var l = !0;
        return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (l = this._moveLeft(d, "selectionStart")), this.selectionEnd = this.selectionStart, l;
      },
      /**
       * Moves cursor left while keeping selection
       * @param {Event} e
       */
      moveCursorLeftWithShift: function(d) {
        if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd)
          return this._moveLeft(d, "selectionEnd");
        if (this.selectionStart !== 0)
          return this._selectionDirection = "left", this._moveLeft(d, "selectionStart");
      },
      /**
       * Moves cursor right
       * @param {Event} e Event object
       */
      moveCursorRight: function(d) {
        this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", d);
      },
      /**
       * Moves cursor right or Left, fires event
       * @param {String} direction 'Left', 'Right'
       * @param {Event} e Event object
       */
      _moveCursorLeftOrRight: function(d, l) {
        var p = "moveCursor" + d + "With";
        this._currentCursorOpacity = 1, l.shiftKey ? p += "Shift" : p += "outShift", this[p](l) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
      },
      /**
       * Moves cursor right while keeping selection
       * @param {Event} e
       */
      moveCursorRightWithShift: function(d) {
        if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd)
          return this._moveRight(d, "selectionStart");
        if (this.selectionEnd !== this._text.length)
          return this._selectionDirection = "right", this._moveRight(d, "selectionEnd");
      },
      /**
       * Moves cursor right without keeping selection
       * @param {Event} e Event object
       */
      moveCursorRightWithoutShift: function(d) {
        var l = !0;
        return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (l = this._moveRight(d, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, l;
      },
      /**
       * Removes characters from start/end
       * start/end ar per grapheme position in _text array.
       *
       * @param {Number} start
       * @param {Number} end default to start + 1
       */
      removeChars: function(d, l) {
        typeof l > "u" && (l = d + 1), this.removeStyleFromTo(d, l), this._text.splice(d, l - d), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
      },
      /**
       * insert characters at start position, before start position.
       * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
       * if style array is provided, it must be as the same length of text in graphemes
       * if end is provided and is bigger than start, old text is replaced.
       * start/end ar per grapheme position in _text array.
       *
       * @param {String} text text to insert
       * @param {Array} style array of style objects
       * @param {Number} start
       * @param {Number} end default to start + 1
       */
      insertChars: function(d, l, p, v) {
        typeof v > "u" && (v = p), v > p && this.removeStyleFromTo(p, v);
        var c = n.util.string.graphemeSplit(d);
        this.insertNewStyleBlock(c, p, l), this._text = [].concat(this._text.slice(0, p), c, this._text.slice(v)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles();
      }
    }
  ), function() {
    var d = n.util.toFixed, l = /  +/g;
    n.util.object.extend(
      n.Text.prototype,
      /** @lends fabric.Text.prototype */
      {
        /**
         * Returns SVG representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        _toSVG: function() {
          var p = this._getSVGLeftTopOffsets(), v = this._getSVGTextAndBg(p.textTop, p.textLeft);
          return this._wrapSVGTextAndBg(v);
        },
        /**
         * Returns svg representation of an instance
         * @param {Function} [reviver] Method for further parsing of svg representation.
         * @return {String} svg representation of an instance
         */
        toSVG: function(p) {
          return this._createBaseSVGMarkup(
            this._toSVG(),
            { reviver: p, noStyle: !0, withShadow: !0 }
          );
        },
        /**
         * @private
         */
        _getSVGLeftTopOffsets: function() {
          return {
            textLeft: -this.width / 2,
            textTop: -this.height / 2,
            lineTop: this.getHeightOfLine(0)
          };
        },
        /**
         * @private
         */
        _wrapSVGTextAndBg: function(p) {
          var v = !0, c = this.getSvgTextDecoration(this);
          return [
            p.textBgRects.join(""),
            '		<text xml:space="preserve" ',
            this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "",
            this.fontSize ? 'font-size="' + this.fontSize + '" ' : "",
            this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "",
            this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "",
            c ? 'text-decoration="' + c + '" ' : "",
            'style="',
            this.getSvgStyles(v),
            '"',
            this.addPaintOrder(),
            " >",
            p.textSpans.join(""),
            `</text>
`
          ];
        },
        /**
         * @private
         * @param {Number} textTopOffset Text top offset
         * @param {Number} textLeftOffset Text left offset
         * @return {Object}
         */
        _getSVGTextAndBg: function(p, v) {
          var c = [], e = [], h = p, m;
          this._setSVGBg(e);
          for (var b = 0, f = this._textLines.length; b < f; b++)
            m = this._getLineLeftOffset(b), (this.textBackgroundColor || this.styleHas("textBackgroundColor", b)) && this._setSVGTextLineBg(e, b, v + m, h), this._setSVGTextLineText(c, b, v + m, h), h += this.getHeightOfLine(b);
          return {
            textSpans: c,
            textBgRects: e
          };
        },
        /**
         * @private
         */
        _createTextCharSpan: function(p, v, c, e) {
          var h = p !== p.trim() || p.match(l), m = this.getSvgSpanStyles(v, h), b = m ? 'style="' + m + '"' : "", f = v.deltaY, k = "", E = n.Object.NUM_FRACTION_DIGITS;
          return f && (k = ' dy="' + d(f, E) + '" '), [
            '<tspan x="',
            d(c, E),
            '" y="',
            d(e, E),
            '" ',
            k,
            b,
            ">",
            n.util.string.escapeXml(p),
            "</tspan>"
          ].join("");
        },
        _setSVGTextLineText: function(p, v, c, e) {
          var h = this.getHeightOfLine(v), m = this.textAlign.indexOf("justify") !== -1, b, f, k = "", E, _, T = 0, D = this._textLines[v], V;
          e += h * (1 - this._fontSizeFraction) / this.lineHeight;
          for (var I = 0, M = D.length - 1; I <= M; I++)
            V = I === M || this.charSpacing, k += D[I], E = this.__charBounds[v][I], T === 0 ? (c += E.kernedWidth - E.width, T += E.width) : T += E.kernedWidth, m && !V && this._reSpaceAndTab.test(D[I]) && (V = !0), V || (b = b || this.getCompleteStyleDeclaration(v, I), f = this.getCompleteStyleDeclaration(v, I + 1), V = n.util.hasStyleChanged(b, f, !0)), V && (_ = this._getStyleDeclaration(v, I) || {}, p.push(this._createTextCharSpan(k, _, c, e)), k = "", b = f, c += T, T = 0);
        },
        _pushTextBgRect: function(p, v, c, e, h, m) {
          var b = n.Object.NUM_FRACTION_DIGITS;
          p.push(
            "		<rect ",
            this._getFillAttributes(v),
            ' x="',
            d(c, b),
            '" y="',
            d(e, b),
            '" width="',
            d(h, b),
            '" height="',
            d(m, b),
            `"></rect>
`
          );
        },
        _setSVGTextLineBg: function(p, v, c, e) {
          for (var h = this._textLines[v], m = this.getHeightOfLine(v) / this.lineHeight, b = 0, f = 0, k, E, _ = this.getValueOfPropertyAt(v, 0, "textBackgroundColor"), T = 0, D = h.length; T < D; T++)
            k = this.__charBounds[v][T], E = this.getValueOfPropertyAt(v, T, "textBackgroundColor"), E !== _ ? (_ && this._pushTextBgRect(
              p,
              _,
              c + f,
              e,
              b,
              m
            ), f = k.left, b = k.width, _ = E) : b += k.kernedWidth;
          E && this._pushTextBgRect(
            p,
            E,
            c + f,
            e,
            b,
            m
          );
        },
        /**
         * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
         * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
         *
         * @private
         * @param {*} value
         * @return {String}
         */
        _getFillAttributes: function(p) {
          var v = p && typeof p == "string" ? new n.Color(p) : "";
          return !v || !v.getSource() || v.getAlpha() === 1 ? 'fill="' + p + '"' : 'opacity="' + v.getAlpha() + '" fill="' + v.setAlpha(1).toRgb() + '"';
        },
        /**
         * @private
         */
        _getSVGLineTopOffset: function(p) {
          for (var v = 0, c = 0, e = 0; e < p; e++)
            v += this.getHeightOfLine(e);
          return c = this.getHeightOfLine(e), {
            lineTop: v,
            offset: (this._fontSizeMult - this._fontSizeFraction) * c / (this.lineHeight * this._fontSizeMult)
          };
        },
        /**
         * Returns styles-string for svg-export
         * @param {Boolean} skipShadow a boolean to skip shadow filter output
         * @return {String}
         */
        getSvgStyles: function(p) {
          var v = n.Object.prototype.getSvgStyles.call(this, p);
          return v + " white-space: pre;";
        }
      }
    );
  }(), function(d) {
    var l = d.fabric || (d.fabric = {});
    l.Textbox = l.util.createClass(l.IText, l.Observable, {
      /**
       * Type of an object
       * @type String
       * @default
       */
      type: "textbox",
      /**
       * Minimum width of textbox, in pixels.
       * @type Number
       * @default
       */
      minWidth: 20,
      /**
       * Minimum calculated width of a textbox, in pixels.
       * fixed to 2 so that an empty textbox cannot go to 0
       * and is still selectable without text.
       * @type Number
       * @default
       */
      dynamicMinWidth: 2,
      /**
       * Cached array of text wrapping.
       * @type Array
       */
      __cachedLines: null,
      /**
       * Override standard Object class values
       */
      lockScalingFlip: !0,
      /**
       * Override standard Object class values
       * Textbox needs this on false
       */
      noScaleCache: !1,
      /**
       * Properties which when set cause object to change dimensions
       * @type Object
       * @private
       */
      _dimensionAffectingProps: l.Text.prototype._dimensionAffectingProps.concat("width"),
      /**
       * Use this regular expression to split strings in breakable lines
       * @private
       */
      _wordJoiners: /[ \t\r]/,
      /**
       * Use this boolean property in order to split strings that have no white space concept.
       * this is a cheap way to help with chinese/japanese
       * @type Boolean
       * @since 2.6.0
       */
      splitByGrapheme: !1,
      /**
       * Unlike superclass's version of this function, Textbox does not update
       * its width.
       * @private
       * @override
       */
      initDimensions: function() {
        this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" }));
      },
      /**
       * Generate an object that translates the style object so that it is
       * broken up by visual lines (new lines and automatic wrapping).
       * The original text styles object is broken up by actual lines (new lines only),
       * which is only sufficient for Text / IText
       * @private
       */
      _generateStyleMap: function(p) {
        for (var v = 0, c = 0, e = 0, h = {}, m = 0; m < p.graphemeLines.length; m++)
          p.graphemeText[e] === `
` && m > 0 ? (c = 0, e++, v++) : !this.splitByGrapheme && this._reSpaceAndTab.test(p.graphemeText[e]) && m > 0 && (c++, e++), h[m] = { line: v, offset: c }, e += p.graphemeLines[m].length, c += p.graphemeLines[m].length;
        return h;
      },
      /**
       * Returns true if object has a style property or has it on a specified line
       * @param {Number} lineIndex
       * @return {Boolean}
       */
      styleHas: function(p, v) {
        if (this._styleMap && !this.isWrapping) {
          var c = this._styleMap[v];
          c && (v = c.line);
        }
        return l.Text.prototype.styleHas.call(this, p, v);
      },
      /**
       * Returns true if object has no styling or no styling in a line
       * @param {Number} lineIndex , lineIndex is on wrapped lines.
       * @return {Boolean}
       */
      isEmptyStyles: function(p) {
        if (!this.styles)
          return !0;
        var v = 0, c = p + 1, e, h, m = !1, b = this._styleMap[p], f = this._styleMap[p + 1];
        b && (p = b.line, v = b.offset), f && (c = f.line, m = c === p, e = f.offset), h = typeof p > "u" ? this.styles : { line: this.styles[p] };
        for (var k in h)
          for (var E in h[k])
            if (E >= v && (!m || E < e))
              for (var _ in h[k][E])
                return !1;
        return !0;
      },
      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _getStyleDeclaration: function(p, v) {
        if (this._styleMap && !this.isWrapping) {
          var c = this._styleMap[p];
          if (!c)
            return null;
          p = c.line, v = c.offset + v;
        }
        return this.callSuper("_getStyleDeclaration", p, v);
      },
      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @param {Object} style
       * @private
       */
      _setStyleDeclaration: function(p, v, c) {
        var e = this._styleMap[p];
        p = e.line, v = e.offset + v, this.styles[p][v] = c;
      },
      /**
       * @param {Number} lineIndex
       * @param {Number} charIndex
       * @private
       */
      _deleteStyleDeclaration: function(p, v) {
        var c = this._styleMap[p];
        p = c.line, v = c.offset + v, delete this.styles[p][v];
      },
      /**
       * probably broken need a fix
       * Returns the real style line that correspond to the wrapped lineIndex line
       * Used just to verify if the line does exist or not.
       * @param {Number} lineIndex
       * @returns {Boolean} if the line exists or not
       * @private
       */
      _getLineStyle: function(p) {
        var v = this._styleMap[p];
        return !!this.styles[v.line];
      },
      /**
       * Set the line style to an empty object so that is initialized
       * @param {Number} lineIndex
       * @param {Object} style
       * @private
       */
      _setLineStyle: function(p) {
        var v = this._styleMap[p];
        this.styles[v.line] = {};
      },
      /**
       * Wraps text using the 'width' property of Textbox. First this function
       * splits text on newlines, so we preserve newlines entered by the user.
       * Then it wraps each line using the width of the Textbox by calling
       * _wrapLine().
       * @param {Array} lines The string array of text that is split into lines
       * @param {Number} desiredWidth width you want to wrap to
       * @returns {Array} Array of lines
       */
      _wrapText: function(p, v) {
        var c = [], e;
        for (this.isWrapping = !0, e = 0; e < p.length; e++)
          c = c.concat(this._wrapLine(p[e], e, v));
        return this.isWrapping = !1, c;
      },
      /**
       * Helper function to measure a string of text, given its lineIndex and charIndex offset
       * it gets called when charBounds are not available yet.
       * @param {CanvasRenderingContext2D} ctx
       * @param {String} text
       * @param {number} lineIndex
       * @param {number} charOffset
       * @returns {number}
       * @private
       */
      _measureWord: function(p, v, c) {
        var e = 0, h, m = !0;
        c = c || 0;
        for (var b = 0, f = p.length; b < f; b++) {
          var k = this._getGraphemeBox(p[b], v, b + c, h, m);
          e += k.kernedWidth, h = p[b];
        }
        return e;
      },
      /**
       * Wraps a line of text using the width of the Textbox and a context.
       * @param {Array} line The grapheme array that represent the line
       * @param {Number} lineIndex
       * @param {Number} desiredWidth width you want to wrap the line to
       * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
       * @returns {Array} Array of line(s) into which the given text is wrapped
       * to.
       */
      _wrapLine: function(p, v, c, G) {
        var h = 0, m = this.splitByGrapheme, b = [], f = [], k = m ? l.util.string.graphemeSplit(p) : p.split(this._wordJoiners), E = "", _ = 0, T = m ? "" : " ", D = 0, V = 0, I = 0, M = !0, Q = this._getWidthOfCharSpacing(), G = G || 0;
        k.length === 0 && k.push([]), c -= G;
        for (var z = 0; z < k.length; z++)
          E = m ? k[z] : l.util.string.graphemeSplit(k[z]), D = this._measureWord(E, v, _), _ += E.length, h += V + D - Q, h > c && !M ? (b.push(f), f = [], h = D, M = !0) : h += Q, !M && !m && f.push(T), f = f.concat(E), V = m ? 0 : this._measureWord([T], v, _), _++, M = !1, D > I && (I = D);
        return z && b.push(f), I + G > this.dynamicMinWidth && (this.dynamicMinWidth = I - Q + G), b;
      },
      /**
       * Detect if the text line is ended with an hard break
       * text and itext do not have wrapping, return false
       * @param {Number} lineIndex text to split
       * @return {Boolean}
       */
      isEndOfWrapping: function(p) {
        return !this._styleMap[p + 1] || this._styleMap[p + 1].line !== this._styleMap[p].line;
      },
      /**
       * Detect if a line has a linebreak and so we need to account for it when moving
       * and counting style.
       * @return Number
       */
      missingNewlineOffset: function(p) {
        return this.splitByGrapheme ? this.isEndOfWrapping(p) ? 1 : 0 : 1;
      },
      /**
      * Gets lines of text to render in the Textbox. This function calculates
      * text wrapping on the fly every time it is called.
      * @param {String} text text to split
      * @returns {Array} Array of lines in the Textbox.
      * @override
      */
      _splitTextIntoLines: function(p) {
        for (var v = l.Text.prototype._splitTextIntoLines.call(this, p), c = this._wrapText(v.lines, this.width), e = new Array(c.length), h = 0; h < c.length; h++)
          e[h] = c[h].join("");
        return v.lines = e, v.graphemeLines = c, v;
      },
      getMinWidth: function() {
        return Math.max(this.minWidth, this.dynamicMinWidth);
      },
      _removeExtraneousStyles: function() {
        var p = {};
        for (var v in this._styleMap)
          this._textLines[v] && (p[this._styleMap[v].line] = 1);
        for (var v in this.styles)
          p[v] || delete this.styles[v];
      },
      /**
       * Returns object representation of an instance
       * @method toObject
       * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
       * @return {Object} object representation of an instance
       */
      toObject: function(p) {
        return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(p));
      }
    }), l.Textbox.fromObject = function(p, v) {
      var c = l.util.stylesFromArray(p.styles, p.text), e = Object.assign({}, p, { styles: c });
      return l.Object._fromObject("Textbox", e, v, "text");
    };
  }(i), function() {
    var d = n.controlsUtils, l = d.scaleSkewCursorStyleHandler, p = d.scaleCursorStyleHandler, v = d.scalingEqually, c = d.scalingYOrSkewingX, e = d.scalingXOrSkewingY, h = d.scaleOrSkewActionName, m = n.Object.prototype.controls;
    if (m.ml = new n.Control({
      x: -0.5,
      y: 0,
      cursorStyleHandler: l,
      actionHandler: e,
      getActionName: h
    }), m.mr = new n.Control({
      x: 0.5,
      y: 0,
      cursorStyleHandler: l,
      actionHandler: e,
      getActionName: h
    }), m.mb = new n.Control({
      x: 0,
      y: 0.5,
      cursorStyleHandler: l,
      actionHandler: c,
      getActionName: h
    }), m.mt = new n.Control({
      x: 0,
      y: -0.5,
      cursorStyleHandler: l,
      actionHandler: c,
      getActionName: h
    }), m.tl = new n.Control({
      x: -0.5,
      y: -0.5,
      cursorStyleHandler: p,
      actionHandler: v
    }), m.tr = new n.Control({
      x: 0.5,
      y: -0.5,
      cursorStyleHandler: p,
      actionHandler: v
    }), m.bl = new n.Control({
      x: -0.5,
      y: 0.5,
      cursorStyleHandler: p,
      actionHandler: v
    }), m.br = new n.Control({
      x: 0.5,
      y: 0.5,
      cursorStyleHandler: p,
      actionHandler: v
    }), m.mtr = new n.Control({
      x: 0,
      y: -0.5,
      actionHandler: d.rotationWithSnapping,
      cursorStyleHandler: d.rotationStyleHandler,
      offsetY: -40,
      withConnection: !0,
      actionName: "rotate"
    }), n.Textbox) {
      var b = n.Textbox.prototype.controls = {};
      b.mtr = m.mtr, b.tr = m.tr, b.br = m.br, b.tl = m.tl, b.bl = m.bl, b.mt = m.mt, b.mb = m.mb, b.mr = new n.Control({
        x: 0.5,
        y: 0,
        actionHandler: d.changeWidth,
        cursorStyleHandler: l,
        actionName: "resizing"
      }), b.ml = new n.Control({
        x: -0.5,
        y: 0,
        actionHandler: d.changeWidth,
        cursorStyleHandler: l,
        actionName: "resizing"
      });
    }
  }();
})(Ne);
var Xr = /* @__PURE__ */ ((i) => (i.EMPTY = "", i.ONE = "one", i.MULTI = "multiple", i))(Xr || {}), Eo = /* @__PURE__ */ ((i) => (i.ONE = "selectOne", i.MULTI = "selectMultiple", i.CANCEL = "selectCancel", i))(Eo || {});
const Q8 = { SelectMode: Xr, SelectEvent: Eo };
function hf(i, n) {
  const s = document.createElement("a");
  s.href = i, s.download = `${si()}.${n}`, document.body.appendChild(s), s.click(), s.remove();
}
function Ik(i) {
  i && i.forEach((n) => {
    n.objects ? Ik(n.objects) : n.type === "text" && (n.type = "textbox");
  });
}
class lu {
  // public hotkeys: string[] = ['left', 'right', 'down', 'up'];
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "selectedMode");
    this.canvas = n, this.editor = s, this.selectedMode = Xr.EMPTY, this._initSelectEvent();
  }
  _initSelectEvent() {
    this.canvas.on("selection:created", () => this._emitSelectEvent()), this.canvas.on("selection:updated", () => this._emitSelectEvent()), this.canvas.on("selection:cleared", () => this._emitSelectEvent());
  }
  _emitSelectEvent() {
    if (!this.canvas)
      throw TypeError("还未初始化");
    const n = this.canvas.getActiveObjects().filter((s) => !(s instanceof Ne.fabric.GuideLine));
    n && n.length === 1 ? (this.selectedMode = Xr.ONE, this.editor.emit(Eo.ONE, n)) : n && n.length > 1 ? (this.selectedMode = Xr.MULTI, this.editor.emit(Eo.MULTI, n)) : this.editor.emit(Eo.CANCEL);
  }
  getSelectMode() {
    return String(this.selectedMode);
  }
  insert() {
    Vk({ accept: ".json" }).then((n) => {
      if (n && n.length > 0) {
        const s = n[0], u = new FileReader();
        u.readAsText(s, "UTF-8"), u.onload = () => {
          this.insertSvgFile(u.result);
        };
      }
    });
  }
  insertSvgFile(n, s) {
    this.editor.hooksEntity.hookImportBefore.callAsync(n, () => {
      this.canvas.loadFromJSON(n, () => {
        this.canvas.renderAll(), this.editor.hooksEntity.hookImportAfter.callAsync(n, () => {
          this.canvas.renderAll(), s && s();
        });
      });
    });
  }
  getJson() {
    return this.canvas.toJSON([
      "id",
      "gradientAngle",
      "selectable",
      "hasControls",
      "linkData"
    ]);
  }
  /**
   * @description: 拖拽添加到画布
   * @param {Event} event
   * @param {Object} item
   */
  dragAddItem(n, s) {
    if (s) {
      const { left: y, top: w } = this.canvas.getSelectionElement().getBoundingClientRect();
      if (s.x < y || s.y < w || n.width === void 0)
        return;
      const S = {
        x: s.x - y,
        y: s.y - w
      }, d = this.canvas.restorePointerVpt(S);
      n.left = d.x - n.width / 2, n.top = d.y;
    }
    const { width: u } = this._getSaveOption();
    u && n.scaleToWidth(u / 2), this.canvas.add(n), this.canvas.requestRenderAll();
  }
  clipboard() {
    const n = this.getJson();
    $k(JSON.stringify(n, null, "	"));
  }
  async saveJson() {
    const n = this.getJson();
    await Ik(n.objects);
    const s = `data:text/json;charset=utf-8,${encodeURIComponent(
      JSON.stringify(n, null, "	")
    )}`;
    hf(s, "json");
  }
  saveSvg() {
    this.editor.hooksEntity.hookSaveBefore.callAsync("", () => {
      const n = this._getSaveSvgOption(), s = this.canvas.toSVG(n), u = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
        s
      )}`;
      this.editor.hooksEntity.hookSaveAfter.callAsync(u, () => {
        hf(u, "svg");
      });
    });
  }
  saveImg() {
    this.editor.hooksEntity.hookSaveBefore.callAsync("", () => {
      const n = this._getSaveOption();
      this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      const s = this.canvas.toDataURL(n);
      this.editor.hooksEntity.hookSaveAfter.callAsync(s, () => {
        hf(s, "png");
      });
    });
  }
  preview() {
    return new Promise((n) => {
      this.editor.hooksEntity.hookSaveBefore.callAsync("", () => {
        const s = this._getSaveOption();
        this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]), this.canvas.renderAll();
        const u = this.canvas.toDataURL(s);
        this.editor.hooksEntity.hookSaveAfter.callAsync(u, () => {
          n(u);
        });
      });
    });
  }
  _getSaveSvgOption() {
    const n = this.canvas.getObjects().find((S) => S.id === "workspace"), { left: s, top: u, width: y, height: w } = n;
    return {
      width: y,
      height: w,
      viewBox: {
        x: s,
        y: u,
        width: y,
        height: w
      }
    };
  }
  _getSaveOption() {
    const n = this.canvas.getObjects().find((d) => d.id === "workspace"), { left: s, top: u, width: y, height: w } = n;
    return {
      name: "New Image",
      format: "png",
      quality: 1,
      width: y,
      height: w,
      left: s,
      top: u
    };
  }
  clear() {
    this.canvas.getObjects().forEach((n) => {
      n.id !== "workspace" && this.canvas.remove(n);
    }), this.canvas.discardActiveObject(), this.canvas.renderAll();
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(lu, "pluginName", "ServersPlugin"), Te(lu, "apis", [
  "insert",
  "insertSvgFile",
  "getJson",
  "dragAddItem",
  "clipboard",
  "saveJson",
  "saveSvg",
  "saveImg",
  "clear",
  "preview",
  "getSelectMode"
]), Te(lu, "events", [Xr.ONE, Xr.MULTI, Eo.CANCEL]);
var _m = {};
_m.deprecate = (i, n) => {
  let s = !0;
  return function() {
    return s && (console.warn("DeprecationWarning: " + n), s = !1), i.apply(this, arguments);
  };
};
const R4 = _m, j4 = R4.deprecate(
  () => {
  },
  "Hook.context is deprecated and will be removed"
), Lb = function(...i) {
  return this.call = this._createCall("sync"), this.call(...i);
}, zb = function(...i) {
  return this.callAsync = this._createCall("async"), this.callAsync(...i);
}, Rb = function(...i) {
  return this.promise = this._createCall("promise"), this.promise(...i);
};
let Mk = class {
  constructor(n = [], s = void 0) {
    this._args = n, this.name = s, this.taps = [], this.interceptors = [], this._call = Lb, this.call = Lb, this._callAsync = zb, this.callAsync = zb, this._promise = Rb, this.promise = Rb, this._x = void 0, this.compile = this.compile, this.tap = this.tap, this.tapAsync = this.tapAsync, this.tapPromise = this.tapPromise;
  }
  compile(n) {
    throw new Error("Abstract: should be overridden");
  }
  _createCall(n) {
    return this.compile({
      taps: this.taps,
      interceptors: this.interceptors,
      args: this._args,
      type: n
    });
  }
  _tap(n, s, u) {
    if (typeof s == "string")
      s = {
        name: s.trim()
      };
    else if (typeof s != "object" || s === null)
      throw new Error("Invalid tap options");
    if (typeof s.name != "string" || s.name === "")
      throw new Error("Missing name for tap");
    typeof s.context < "u" && j4(), s = Object.assign({ type: n, fn: u }, s), s = this._runRegisterInterceptors(s), this._insert(s);
  }
  tap(n, s) {
    this._tap("sync", n, s);
  }
  tapAsync(n, s) {
    this._tap("async", n, s);
  }
  tapPromise(n, s) {
    this._tap("promise", n, s);
  }
  _runRegisterInterceptors(n) {
    for (const s of this.interceptors)
      if (s.register) {
        const u = s.register(n);
        u !== void 0 && (n = u);
      }
    return n;
  }
  withOptions(n) {
    const s = (u) => Object.assign({}, n, typeof u == "string" ? { name: u } : u);
    return {
      name: this.name,
      tap: (u, y) => this.tap(s(u), y),
      tapAsync: (u, y) => this.tapAsync(s(u), y),
      tapPromise: (u, y) => this.tapPromise(s(u), y),
      intercept: (u) => this.intercept(u),
      isUsed: () => this.isUsed(),
      withOptions: (u) => this.withOptions(s(u))
    };
  }
  isUsed() {
    return this.taps.length > 0 || this.interceptors.length > 0;
  }
  intercept(n) {
    if (this._resetCompilation(), this.interceptors.push(Object.assign({}, n)), n.register)
      for (let s = 0; s < this.taps.length; s++)
        this.taps[s] = n.register(this.taps[s]);
  }
  _resetCompilation() {
    this.call = this._call, this.callAsync = this._callAsync, this.promise = this._promise;
  }
  _insert(n) {
    this._resetCompilation();
    let s;
    typeof n.before == "string" ? s = /* @__PURE__ */ new Set([n.before]) : Array.isArray(n.before) && (s = new Set(n.before));
    let u = 0;
    typeof n.stage == "number" && (u = n.stage);
    let y = this.taps.length;
    for (; y > 0; ) {
      y--;
      const w = this.taps[y];
      this.taps[y + 1] = w;
      const S = w.stage || 0;
      if (s) {
        if (s.has(w.name)) {
          s.delete(w.name);
          continue;
        }
        if (s.size > 0)
          continue;
      }
      if (!(S > u)) {
        y++;
        break;
      }
    }
    this.taps[y] = n;
  }
};
Object.setPrototypeOf(Mk.prototype, null);
var qi = Mk;
let H4 = class {
  constructor(n) {
    this.config = n, this.options = void 0, this._args = void 0;
  }
  create(n) {
    this.init(n);
    let s;
    switch (this.options.type) {
      case "sync":
        s = new Function(
          this.args(),
          `"use strict";
` + this.header() + this.contentWithInterceptors({
            onError: (S) => `throw ${S};
`,
            onResult: (S) => `return ${S};
`,
            resultReturns: !0,
            onDone: () => "",
            rethrowIfPossible: !0
          })
        );
        break;
      case "async":
        s = new Function(
          this.args({
            after: "_callback"
          }),
          `"use strict";
` + this.header() + this.contentWithInterceptors({
            onError: (S) => `_callback(${S});
`,
            onResult: (S) => `_callback(null, ${S});
`,
            onDone: () => `_callback();
`
          })
        );
        break;
      case "promise":
        let u = !1;
        const y = this.contentWithInterceptors({
          onError: (S) => (u = !0, `_error(${S});
`),
          onResult: (S) => `_resolve(${S});
`,
          onDone: () => `_resolve();
`
        });
        let w = "";
        w += `"use strict";
`, w += this.header(), w += `return new Promise((function(_resolve, _reject) {
`, u && (w += `var _sync = true;
`, w += `function _error(_err) {
`, w += `if(_sync)
`, w += `_resolve(Promise.resolve().then((function() { throw _err; })));
`, w += `else
`, w += `_reject(_err);
`, w += `};
`), w += y, u && (w += `_sync = false;
`), w += `}));
`, s = new Function(this.args(), w);
        break;
    }
    return this.deinit(), s;
  }
  setup(n, s) {
    n._x = s.taps.map((u) => u.fn);
  }
  /**
   * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
   */
  init(n) {
    this.options = n, this._args = n.args.slice();
  }
  deinit() {
    this.options = void 0, this._args = void 0;
  }
  contentWithInterceptors(n) {
    if (this.options.interceptors.length > 0) {
      const s = n.onError, u = n.onResult, y = n.onDone;
      let w = "";
      for (let S = 0; S < this.options.interceptors.length; S++) {
        const d = this.options.interceptors[S];
        d.call && (w += `${this.getInterceptor(S)}.call(${this.args({
          before: d.context ? "_context" : void 0
        })});
`);
      }
      return w += this.content(
        Object.assign(n, {
          onError: s && ((S) => {
            let d = "";
            for (let l = 0; l < this.options.interceptors.length; l++)
              this.options.interceptors[l].error && (d += `${this.getInterceptor(l)}.error(${S});
`);
            return d += s(S), d;
          }),
          onResult: u && ((S) => {
            let d = "";
            for (let l = 0; l < this.options.interceptors.length; l++)
              this.options.interceptors[l].result && (d += `${this.getInterceptor(l)}.result(${S});
`);
            return d += u(S), d;
          }),
          onDone: y && (() => {
            let S = "";
            for (let d = 0; d < this.options.interceptors.length; d++)
              this.options.interceptors[d].done && (S += `${this.getInterceptor(d)}.done();
`);
            return S += y(), S;
          })
        })
      ), w;
    } else
      return this.content(n);
  }
  header() {
    let n = "";
    return this.needContext() ? n += `var _context = {};
` : n += `var _context;
`, n += `var _x = this._x;
`, this.options.interceptors.length > 0 && (n += `var _taps = this.taps;
`, n += `var _interceptors = this.interceptors;
`), n;
  }
  needContext() {
    for (const n of this.options.taps)
      if (n.context)
        return !0;
    return !1;
  }
  callTap(n, { onError: s, onResult: u, onDone: y, rethrowIfPossible: w }) {
    let S = "", d = !1;
    for (let p = 0; p < this.options.interceptors.length; p++) {
      const v = this.options.interceptors[p];
      v.tap && (d || (S += `var _tap${n} = ${this.getTap(n)};
`, d = !0), S += `${this.getInterceptor(p)}.tap(${v.context ? "_context, " : ""}_tap${n});
`);
    }
    S += `var _fn${n} = ${this.getTapFn(n)};
`;
    const l = this.options.taps[n];
    switch (l.type) {
      case "sync":
        w || (S += `var _hasError${n} = false;
`, S += `try {
`), u ? S += `var _result${n} = _fn${n}(${this.args({
          before: l.context ? "_context" : void 0
        })});
` : S += `_fn${n}(${this.args({
          before: l.context ? "_context" : void 0
        })});
`, w || (S += `} catch(_err) {
`, S += `_hasError${n} = true;
`, S += s("_err"), S += `}
`, S += `if(!_hasError${n}) {
`), u && (S += u(`_result${n}`)), y && (S += y()), w || (S += `}
`);
        break;
      case "async":
        let p = "";
        u ? p += `(function(_err${n}, _result${n}) {
` : p += `(function(_err${n}) {
`, p += `if(_err${n}) {
`, p += s(`_err${n}`), p += `} else {
`, u && (p += u(`_result${n}`)), y && (p += y()), p += `}
`, p += "})", S += `_fn${n}(${this.args({
          before: l.context ? "_context" : void 0,
          after: p
        })});
`;
        break;
      case "promise":
        S += `var _hasResult${n} = false;
`, S += `var _promise${n} = _fn${n}(${this.args({
          before: l.context ? "_context" : void 0
        })});
`, S += `if (!_promise${n} || !_promise${n}.then)
`, S += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${n} + ')');
`, S += `_promise${n}.then((function(_result${n}) {
`, S += `_hasResult${n} = true;
`, u && (S += u(`_result${n}`)), y && (S += y()), S += `}), function(_err${n}) {
`, S += `if(_hasResult${n}) throw _err${n};
`, S += s(`_err${n}`), S += `});
`;
        break;
    }
    return S;
  }
  callTapsSeries({
    onError: n,
    onResult: s,
    resultReturns: u,
    onDone: y,
    doneReturns: w,
    rethrowIfPossible: S
  }) {
    if (this.options.taps.length === 0)
      return y();
    const d = this.options.taps.findIndex((e) => e.type !== "sync"), l = u || w;
    let p = "", v = y, c = 0;
    for (let e = this.options.taps.length - 1; e >= 0; e--) {
      const h = e;
      v !== y && (this.options.taps[h].type !== "sync" || c++ > 20) && (c = 0, p += `function _next${h}() {
`, p += v(), p += `}
`, v = () => `${l ? "return " : ""}_next${h}();
`);
      const b = v, f = (E) => E ? "" : y(), k = this.callTap(h, {
        onError: (E) => n(h, E, b, f),
        onResult: s && ((E) => s(h, E, b, f)),
        onDone: !s && b,
        rethrowIfPossible: S && (d < 0 || h < d)
      });
      v = () => k;
    }
    return p += v(), p;
  }
  callTapsLooping({ onError: n, onDone: s, rethrowIfPossible: u }) {
    if (this.options.taps.length === 0)
      return s();
    const y = this.options.taps.every((S) => S.type === "sync");
    let w = "";
    y || (w += `var _looper = (function() {
`, w += `var _loopAsync = false;
`), w += `var _loop;
`, w += `do {
`, w += `_loop = false;
`;
    for (let S = 0; S < this.options.interceptors.length; S++) {
      const d = this.options.interceptors[S];
      d.loop && (w += `${this.getInterceptor(S)}.loop(${this.args({
        before: d.context ? "_context" : void 0
      })});
`);
    }
    return w += this.callTapsSeries({
      onError: n,
      onResult: (S, d, l, p) => {
        let v = "";
        return v += `if(${d} !== undefined) {
`, v += `_loop = true;
`, y || (v += `if(_loopAsync) _looper();
`), v += p(!0), v += `} else {
`, v += l(), v += `}
`, v;
      },
      onDone: s && (() => {
        let S = "";
        return S += `if(!_loop) {
`, S += s(), S += `}
`, S;
      }),
      rethrowIfPossible: u && y
    }), w += `} while(_loop);
`, y || (w += `_loopAsync = true;
`, w += `});
`, w += `_looper();
`), w;
  }
  callTapsParallel({
    onError: n,
    onResult: s,
    onDone: u,
    rethrowIfPossible: y,
    onTap: w = (S, d) => d()
  }) {
    if (this.options.taps.length <= 1)
      return this.callTapsSeries({
        onError: n,
        onResult: s,
        onDone: u,
        rethrowIfPossible: y
      });
    let S = "";
    S += `do {
`, S += `var _counter = ${this.options.taps.length};
`, u && (S += `var _done = (function() {
`, S += u(), S += `});
`);
    for (let d = 0; d < this.options.taps.length; d++) {
      const l = () => u ? `if(--_counter === 0) _done();
` : "--_counter;", p = (v) => v || !u ? `_counter = 0;
` : `_counter = 0;
_done();
`;
      S += `if(_counter <= 0) break;
`, S += w(
        d,
        () => this.callTap(d, {
          onError: (v) => {
            let c = "";
            return c += `if(_counter > 0) {
`, c += n(d, v, l, p), c += `}
`, c;
          },
          onResult: s && ((v) => {
            let c = "";
            return c += `if(_counter > 0) {
`, c += s(d, v, l, p), c += `}
`, c;
          }),
          onDone: !s && (() => l()),
          rethrowIfPossible: y
        }),
        l,
        p
      );
    }
    return S += `} while(false);
`, S;
  }
  args({ before: n, after: s } = {}) {
    let u = this._args;
    return n && (u = [n].concat(u)), s && (u = u.concat(s)), u.length === 0 ? "" : u.join(", ");
  }
  getTapFn(n) {
    return `_x[${n}]`;
  }
  getTap(n) {
    return `_taps[${n}]`;
  }
  getInterceptor(n) {
    return `_interceptors[${n}]`;
  }
};
var Ji = H4;
const U4 = qi, W4 = Ji;
class Y4 extends W4 {
  content({ onError: n, onDone: s, rethrowIfPossible: u }) {
    return this.callTapsSeries({
      onError: (y, w) => n(w),
      onDone: s,
      rethrowIfPossible: u
    });
  }
}
const jb = new Y4(), K4 = () => {
  throw new Error("tapAsync is not supported on a SyncHook");
}, G4 = () => {
  throw new Error("tapPromise is not supported on a SyncHook");
}, X4 = function(i) {
  return jb.setup(this, i), jb.create(i);
};
function Ak(i = [], n = void 0) {
  const s = new U4(i, n);
  return s.constructor = Ak, s.tapAsync = K4, s.tapPromise = G4, s.compile = X4, s;
}
Ak.prototype = null;
const q4 = qi, J4 = Ji;
class Q4 extends J4 {
  content({ onError: n, onResult: s, resultReturns: u, onDone: y, rethrowIfPossible: w }) {
    return this.callTapsSeries({
      onError: (S, d) => n(d),
      onResult: (S, d, l) => `if(${d} !== undefined) {
${s(
        d
      )};
} else {
${l()}}
`,
      resultReturns: u,
      onDone: y,
      rethrowIfPossible: w
    });
  }
}
const Hb = new Q4(), Z4 = () => {
  throw new Error("tapAsync is not supported on a SyncBailHook");
}, ez = () => {
  throw new Error("tapPromise is not supported on a SyncBailHook");
}, tz = function(i) {
  return Hb.setup(this, i), Hb.create(i);
};
function Fk(i = [], n = void 0) {
  const s = new q4(i, n);
  return s.constructor = Fk, s.tapAsync = Z4, s.tapPromise = ez, s.compile = tz, s;
}
Fk.prototype = null;
const nz = qi, iz = Ji;
class rz extends iz {
  content({ onError: n, onResult: s, resultReturns: u, rethrowIfPossible: y }) {
    return this.callTapsSeries({
      onError: (w, S) => n(S),
      onResult: (w, S, d) => {
        let l = "";
        return l += `if(${S} !== undefined) {
`, l += `${this._args[0]} = ${S};
`, l += `}
`, l += d(), l;
      },
      onDone: () => s(this._args[0]),
      doneReturns: u,
      rethrowIfPossible: y
    });
  }
}
const Ub = new rz(), sz = () => {
  throw new Error("tapAsync is not supported on a SyncWaterfallHook");
}, oz = () => {
  throw new Error("tapPromise is not supported on a SyncWaterfallHook");
}, az = function(i) {
  return Ub.setup(this, i), Ub.create(i);
};
function Lk(i = [], n = void 0) {
  if (i.length < 1)
    throw new Error("Waterfall hooks must have at least one argument");
  const s = new nz(i, n);
  return s.constructor = Lk, s.tapAsync = sz, s.tapPromise = oz, s.compile = az, s;
}
Lk.prototype = null;
const lz = qi, cz = Ji;
class uz extends cz {
  content({ onError: n, onDone: s, rethrowIfPossible: u }) {
    return this.callTapsLooping({
      onError: (y, w) => n(w),
      onDone: s,
      rethrowIfPossible: u
    });
  }
}
const Wb = new uz(), hz = () => {
  throw new Error("tapAsync is not supported on a SyncLoopHook");
}, dz = () => {
  throw new Error("tapPromise is not supported on a SyncLoopHook");
}, fz = function(i) {
  return Wb.setup(this, i), Wb.create(i);
};
function zk(i = [], n = void 0) {
  const s = new lz(i, n);
  return s.constructor = zk, s.tapAsync = hz, s.tapPromise = dz, s.compile = fz, s;
}
zk.prototype = null;
const pz = qi, mz = Ji;
class gz extends mz {
  content({ onError: n, onDone: s }) {
    return this.callTapsParallel({
      onError: (u, y, w, S) => n(y) + S(!0),
      onDone: s
    });
  }
}
const Yb = new gz(), vz = function(i) {
  return Yb.setup(this, i), Yb.create(i);
};
function Rk(i = [], n = void 0) {
  const s = new pz(i, n);
  return s.constructor = Rk, s.compile = vz, s._call = void 0, s.call = void 0, s;
}
Rk.prototype = null;
const yz = qi, bz = Ji;
class Cz extends bz {
  content({ onError: n, onResult: s, onDone: u }) {
    let y = "";
    return y += `var _results = new Array(${this.options.taps.length});
`, y += `var _checkDone = function() {
`, y += `for(var i = 0; i < _results.length; i++) {
`, y += `var item = _results[i];
`, y += `if(item === undefined) return false;
`, y += `if(item.result !== undefined) {
`, y += s("item.result"), y += `return true;
`, y += `}
`, y += `if(item.error) {
`, y += n("item.error"), y += `return true;
`, y += `}
`, y += `}
`, y += `return false;
`, y += `}
`, y += this.callTapsParallel({
      onError: (w, S, d, l) => {
        let p = "";
        return p += `if(${w} < _results.length && ((_results.length = ${w + 1}), (_results[${w}] = { error: ${S} }), _checkDone())) {
`, p += l(!0), p += `} else {
`, p += d(), p += `}
`, p;
      },
      onResult: (w, S, d, l) => {
        let p = "";
        return p += `if(${w} < _results.length && (${S} !== undefined && (_results.length = ${w + 1}), (_results[${w}] = { result: ${S} }), _checkDone())) {
`, p += l(!0), p += `} else {
`, p += d(), p += `}
`, p;
      },
      onTap: (w, S, d, l) => {
        let p = "";
        return w > 0 && (p += `if(${w} >= _results.length) {
`, p += d(), p += `} else {
`), p += S(), w > 0 && (p += `}
`), p;
      },
      onDone: u
    }), y;
  }
}
const Kb = new Cz(), wz = function(i) {
  return Kb.setup(this, i), Kb.create(i);
};
function jk(i = [], n = void 0) {
  const s = new yz(i, n);
  return s.constructor = jk, s.compile = wz, s._call = void 0, s.call = void 0, s;
}
jk.prototype = null;
const kz = qi, Sz = Ji;
class Ez extends Sz {
  content({ onError: n, onDone: s }) {
    return this.callTapsSeries({
      onError: (u, y, w, S) => n(y) + S(!0),
      onDone: s
    });
  }
}
const Gb = new Ez(), xz = function(i) {
  return Gb.setup(this, i), Gb.create(i);
};
function Tm(i = [], n = void 0) {
  const s = new kz(i, n);
  return s.constructor = Tm, s.compile = xz, s._call = void 0, s.call = void 0, s;
}
Tm.prototype = null;
var _z = Tm;
const Tz = qi, Oz = Ji;
class Dz extends Oz {
  content({ onError: n, onResult: s, resultReturns: u, onDone: y }) {
    return this.callTapsSeries({
      onError: (w, S, d, l) => n(S) + l(!0),
      onResult: (w, S, d) => `if(${S} !== undefined) {
${s(
        S
      )}
} else {
${d()}}
`,
      resultReturns: u,
      onDone: y
    });
  }
}
const Xb = new Dz(), Nz = function(i) {
  return Xb.setup(this, i), Xb.create(i);
};
function Hk(i = [], n = void 0) {
  const s = new Tz(i, n);
  return s.constructor = Hk, s.compile = Nz, s._call = void 0, s.call = void 0, s;
}
Hk.prototype = null;
const Bz = qi, Pz = Ji;
class Vz extends Pz {
  content({ onError: n, onDone: s }) {
    return this.callTapsLooping({
      onError: (u, y, w, S) => n(y) + S(!0),
      onDone: s
    });
  }
}
const qb = new Vz(), $z = function(i) {
  return qb.setup(this, i), qb.create(i);
};
function Uk(i = [], n = void 0) {
  const s = new Bz(i, n);
  return s.constructor = Uk, s.compile = $z, s._call = void 0, s.call = void 0, s;
}
Uk.prototype = null;
const Iz = qi, Mz = Ji;
class Az extends Mz {
  content({ onError: n, onResult: s, onDone: u }) {
    return this.callTapsSeries({
      onError: (y, w, S, d) => n(w) + d(!0),
      onResult: (y, w, S) => {
        let d = "";
        return d += `if(${w} !== undefined) {
`, d += `${this._args[0]} = ${w};
`, d += `}
`, d += S(), d;
      },
      onDone: () => s(this._args[0])
    });
  }
}
const Jb = new Az(), Fz = function(i) {
  return Jb.setup(this, i), Jb.create(i);
};
function Wk(i = [], n = void 0) {
  if (i.length < 1)
    throw new Error("Waterfall hooks must have at least one argument");
  const s = new Iz(i, n);
  return s.constructor = Wk, s.compile = Fz, s._call = void 0, s.call = void 0, s;
}
Wk.prototype = null;
const Om = _m, Lz = (i, n) => n;
class Dm {
  constructor(n, s = void 0) {
    this._map = /* @__PURE__ */ new Map(), this.name = s, this._factory = n, this._interceptors = [];
  }
  get(n) {
    return this._map.get(n);
  }
  for(n) {
    const s = this.get(n);
    if (s !== void 0)
      return s;
    let u = this._factory(n);
    const y = this._interceptors;
    for (let w = 0; w < y.length; w++)
      u = y[w].factory(n, u);
    return this._map.set(n, u), u;
  }
  intercept(n) {
    this._interceptors.push(
      Object.assign(
        {
          factory: Lz
        },
        n
      )
    );
  }
}
Dm.prototype.tap = Om.deprecate(function(i, n, s) {
  return this.for(i).tap(n, s);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");
Dm.prototype.tapAsync = Om.deprecate(function(i, n, s) {
  return this.for(i).tapAsync(n, s);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");
Dm.prototype.tapPromise = Om.deprecate(function(i, n, s) {
  return this.for(i).tapPromise(n, s);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");
var zz = _z;
class tj extends nM {
  constructor() {
    super(...arguments);
    Te(this, "canvas");
    Te(this, "contextMenu");
    Te(this, "pluginMap", {});
    // 自定义事件
    Te(this, "customEvents", []);
    // 自定义API
    Te(this, "customApis", []);
    // 生命周期函数名
    Te(this, "hooks", [
      "hookImportBefore",
      "hookImportAfter",
      "hookSaveBefore",
      "hookSaveAfter"
    ]);
    Te(this, "hooksEntity", {});
  }
  init(s) {
    this.canvas = s, this._initContextMenu(), this._bindContextMenu(), this._initActionHooks(), this._initServersPlugin();
  }
  // 引入组件
  use(s, u) {
    if (this._checkPlugin(s)) {
      this._saveCustomAttr(s);
      const y = new s(
        this.canvas,
        this,
        u || {}
      );
      this.pluginMap[s.pluginName] = y, this._bindingHooks(y), this._bindingHotkeys(y), this._bindingApis(y);
    }
  }
  // 获取插件
  getPlugin(s) {
    if (this.pluginMap[s])
      return this.pluginMap[s];
  }
  // 检查组件
  _checkPlugin(s) {
    const { pluginName: u, events: y = [], apis: w = [] } = s;
    if (this.pluginMap[u])
      throw new Error(u + "插件重复初始化");
    return y.forEach((S) => {
      if (this.customEvents.find((d) => d === S))
        throw new Error(u + "插件中" + S + "重复");
    }), w.forEach((S) => {
      if (this.customApis.find((d) => d === S))
        throw new Error(u + "插件中" + S + "重复");
    }), !0;
  }
  // 绑定hooks方法
  _bindingHooks(s) {
    this.hooks.forEach((u) => {
      const y = s[u];
      y && this.hooksEntity[u].tapPromise(
        s.pluginName + u,
        function() {
          return y.apply(s, [...arguments]);
        }
      );
    });
  }
  // 绑定快捷键
  _bindingHotkeys(s) {
    var u;
    (u = s == null ? void 0 : s.hotkeys) == null || u.forEach((y) => {
      pr(y, { keyup: !0 }, (w) => {
        s.hotkeyEvent && s.hotkeyEvent(y, w);
      });
    });
  }
  // 保存组件自定义事件与API
  _saveCustomAttr(s) {
    const { events: u = [], apis: y = [] } = s;
    this.customApis = this.customApis.concat(y), this.customEvents = this.customEvents.concat(u);
  }
  // 代理API事件
  _bindingApis(s) {
    const { apis: u = [] } = s.constructor || {};
    u.forEach((y) => {
      this[y] = function() {
        return s[y].apply(s, [...arguments]);
      };
    });
  }
  // 右键菜单
  _bindContextMenu() {
    this.canvas.on("mouse:down", (s) => {
      if (s.button === 3) {
        let u = [];
        Object.keys(this.pluginMap).forEach((y) => {
          const w = this.pluginMap[y], S = w.contextMenu && w.contextMenu();
          S && (u = u.concat(S));
        }), this._renderMenu(s, u);
      }
    });
  }
  // 渲染右键菜单
  _renderMenu(s, u) {
    u.length !== 0 && (this.contextMenu.hideAll(), this.contextMenu.setData(u), this.contextMenu.show(s.e.clientX, s.e.clientY));
  }
  // 生命周期事件
  _initActionHooks() {
    this.hooks.forEach((s) => {
      this.hooksEntity[s] = new zz(["data"]);
    });
  }
  _initContextMenu() {
    this.contextMenu = new fu(this.canvas.wrapperEl, []), this.contextMenu.install();
  }
  _initServersPlugin() {
    this.use(lu);
  }
  // 解决 listener 为 undefined 的时候卸载错误
  off(s, u) {
    return u ? super.off(s, u) : this;
  }
}
class df {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "defautOption", {});
    Te(this, "hotkeys", ["space"]);
    Te(this, "dragMode", !1);
    this.canvas = n, this.editor = s, this.dragMode = !1, this.init();
  }
  init() {
    this._initDring();
  }
  startDring() {
    this.dragMode = !0, this.canvas.defaultCursor = "grab", this.editor.emit("startDring"), this.canvas.renderAll();
  }
  endDring() {
    this.dragMode = !1, this.canvas.defaultCursor = "default", this.canvas.isDragging = !1, this.editor.emit("endDring"), this.canvas.renderAll();
  }
  // 拖拽模式;
  _initDring() {
    const n = this;
    this.canvas.on("mouse:down", function(s) {
      const u = s.e;
      (u.altKey || n.dragMode) && (n.canvas.defaultCursor = "grabbing", n.canvas.discardActiveObject(), n._setDring(), this.selection = !1, this.isDragging = !0, this.lastPosX = u.clientX, this.lastPosY = u.clientY, this.requestRenderAll());
    }), this.canvas.on("mouse:move", function(s) {
      if (this.isDragging) {
        n.canvas.discardActiveObject(), n.canvas.defaultCursor = "grabbing";
        const { e: u } = s;
        if (!this.viewportTransform)
          return;
        const y = this.viewportTransform;
        y[4] += u.clientX - this.lastPosX, y[5] += u.clientY - this.lastPosY, this.lastPosX = u.clientX, this.lastPosY = u.clientY, this.requestRenderAll();
      }
    }), this.canvas.on("mouse:up", function() {
      this.viewportTransform && (this.setViewportTransform(this.viewportTransform), this.isDragging = !1, this.selection = !0, this.getObjects().forEach((s) => {
        s.id !== "workspace" && s.hasControls && (s.selectable = !0);
      }), n.canvas.defaultCursor = "default", this.requestRenderAll());
    });
  }
  _setDring() {
    this.canvas.selection = !1, this.canvas.defaultCursor = "grab", this.canvas.getObjects().forEach((n) => {
      n.selectable = !1;
    }), this.canvas.requestRenderAll();
  }
  destroy() {
    console.log("pluginDestroy");
  }
  // 快捷键扩展回调
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  hotkeyEvent(n, s) {
    s.code === "Space" && s.type === "keydown" && (this.dragMode || this.startDring()), s.code === "Space" && s.type === "keyup" && this.endDring();
  }
}
Te(df, "pluginName", "DringPlugin"), Te(df, "events", ["startDring", "endDring"]), Te(df, "apis", ["startDring", "endDring"]);
class ff {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "defautOption", {
      color: "rgba(255,95,95,1)",
      width: 1
    });
    Te(this, "hotkeys", [""]);
    Te(this, "dragMode", !1);
    this.canvas = n, this.editor = s, this.dragMode = !1, this.init();
  }
  init() {
    const { canvas: n } = this, s = n.getSelectionContext(), u = 5, y = 4, w = this;
    let S, d = 1;
    function l(m) {
      v(
        m.x + 0.5,
        m.y1 > m.y2 ? m.y2 : m.y1,
        m.x + 0.5,
        m.y2 > m.y1 ? m.y2 : m.y1
      );
    }
    function p(m) {
      v(
        m.x1 > m.x2 ? m.x2 : m.x1,
        m.y + 0.5,
        m.x2 > m.x1 ? m.x2 : m.x1,
        m.y + 0.5
      );
    }
    function v(m, b, f, k) {
      S != null && (s.save(), s.lineWidth = w.defautOption.width, s.strokeStyle = w.defautOption.color, s.beginPath(), s.moveTo(
        m * d + S[4],
        b * d + S[5]
      ), s.lineTo(
        f * d + S[4],
        k * d + S[5]
      ), s.stroke(), s.restore());
    }
    function c(m, b) {
      m = Math.round(m), b = Math.round(b);
      for (let f = m - y, k = m + y; f <= k; f++)
        if (f === b)
          return !0;
      return !1;
    }
    const e = [], h = [];
    n.on("mouse:down", () => {
      S = n.viewportTransform, d = n.getZoom();
    }), n.on("object:moving", (m) => {
      if (S === void 0 || m.target === void 0)
        return;
      const b = m.target, f = n.getObjects(), k = b.getCenterPoint(), E = k.x, _ = k.y, T = b.getBoundingRect(), D = T.height / S[3], V = T.width / S[0];
      let I = !1, M = !1;
      if (n._currentTransform) {
        for (let G = f.length; G--; ) {
          if (f[G] === b || b instanceof Ne.fabric.GuideLine && f[G] instanceof Ne.fabric.GuideLine)
            continue;
          const z = f[G].getCenterPoint(), re = z.x, he = z.y, de = f[G].getBoundingRect(), Ce = de.height / S[3], xe = de.width / S[0];
          c(re, E) && (M = !0, e.push({
            x: re,
            y1: he < _ ? he - Ce / 2 - u : he + Ce / 2 + u,
            y2: _ > he ? _ + D / 2 + u : _ - D / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(re, _),
            "center",
            "center"
          )), c(
            re - xe / 2,
            E - V / 2
          ) && (M = !0, e.push({
            x: re - xe / 2,
            y1: he < _ ? he - Ce / 2 - u : he + Ce / 2 + u,
            y2: _ > he ? _ + D / 2 + u : _ - D / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(
              re - xe / 2 + V / 2,
              _
            ),
            "center",
            "center"
          )), c(
            re + xe / 2,
            E + V / 2
          ) && (M = !0, e.push({
            x: re + xe / 2,
            y1: he < _ ? he - Ce / 2 - u : he + Ce / 2 + u,
            y2: _ > he ? _ + D / 2 + u : _ - D / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(
              re + xe / 2 - V / 2,
              _
            ),
            "center",
            "center"
          )), c(he, _) && (I = !0, h.push({
            y: he,
            x1: re < E ? re - xe / 2 - u : re + xe / 2 + u,
            x2: E > re ? E + V / 2 + u : E - V / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(E, he),
            "center",
            "center"
          )), c(
            he - Ce / 2,
            _ - D / 2
          ) && (I = !0, h.push({
            y: he - Ce / 2,
            x1: re < E ? re - xe / 2 - u : re + xe / 2 + u,
            x2: E > re ? E + V / 2 + u : E - V / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(
              E,
              he - Ce / 2 + D / 2
            ),
            "center",
            "center"
          )), c(
            he + Ce / 2,
            _ + D / 2
          ) && (I = !0, h.push({
            y: he + Ce / 2,
            x1: re < E ? re - xe / 2 - u : re + xe / 2 + u,
            x2: E > re ? E + V / 2 + u : E - V / 2 - u
          }), b.setPositionByOrigin(
            new Ne.fabric.Point(
              E,
              he + Ce / 2 - D / 2
            ),
            "center",
            "center"
          ));
        }
        I || (h.length = 0), M || (e.length = 0);
      }
    }), n.on("before:render", () => {
      if (n.contextTop !== null)
        try {
          n.clearContext(n.contextTop);
        } catch (m) {
          console.log(m);
        }
    }), n.on("after:render", () => {
      for (let m = e.length; m--; )
        l(e[m]);
      for (let m = h.length; m--; )
        p(h[m]);
      e.length = 0, h.length = 0;
    }), n.on("mouse:up", () => {
      e.length = 0, h.length = 0, n.renderAll();
    });
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(ff, "pluginName", "AlignGuidLinePlugin"), Te(ff, "events", ["", ""]), Te(ff, "apis", []);
const Rz = "data:image/svg+xml,%3csvg%20width='12'%20height='24'%20viewBox='0%200%2012%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d)'%3e%3crect%20x='4'%20y='4'%20width='4'%20height='16'%20rx='2'%20fill='white'/%3e%3crect%20x='4.25'%20y='4.25'%20width='3.5'%20height='15.5'%20rx='1.75'%20stroke='black'%20stroke-opacity='0.3'%20stroke-width='0.5'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_d'%20x='0'%20y='0'%20width='12'%20height='24'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'/%3e%3cfeOffset/%3e%3cfeGaussianBlur%20stdDeviation='2'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200.137674%200%200%200%200%200.190937%200%200%200%200%200.270833%200%200%200%200.15%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", jz = "data:image/svg+xml,%3csvg%20width='24'%20height='12'%20viewBox='0%200%2024%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d)'%3e%3crect%20x='20'%20y='4'%20width='4'%20height='16'%20rx='2'%20transform='rotate(90%2020%204)'%20fill='white'/%3e%3crect%20x='19.75'%20y='4.25'%20width='3.5'%20height='15.5'%20rx='1.75'%20transform='rotate(90%2019.75%204.25)'%20stroke='black'%20stroke-opacity='0.3'%20stroke-width='0.5'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_d'%20x='0'%20y='0'%20width='24'%20height='12'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'/%3e%3cfeOffset/%3e%3cfeGaussianBlur%20stdDeviation='2'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200.137674%200%200%200%200%200.190937%200%200%200%200%200.270833%200%200%200%200.15%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", Hz = "data:image/svg+xml,%3csvg%20width='19'%20height='18'%20viewBox='0%200%2019%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d)'%3e%3ccircle%20cx='9.99609'%20cy='9'%20r='5'%20fill='white'/%3e%3ccircle%20cx='9.99609'%20cy='9'%20r='4.75'%20stroke='black'%20stroke-opacity='0.3'%20stroke-width='0.5'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_d'%20x='0.996094'%20y='0'%20width='18'%20height='18'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'/%3e%3cfeOffset/%3e%3cfeGaussianBlur%20stdDeviation='2'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200.137674%200%200%200%200%200.190937%200%200%200%200%200.270833%200%200%200%200.15%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e", Uz = "data:image/svg+xml,%3csvg%20width='18'%20height='18'%20viewBox='0%200%2018%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20filter='url(%23filter0_d)'%3e%3ccircle%20cx='9'%20cy='9'%20r='5'%20fill='white'/%3e%3ccircle%20cx='9'%20cy='9'%20r='4.75'%20stroke='black'%20stroke-opacity='0.3'%20stroke-width='0.5'/%3e%3c/g%3e%3cpath%20d='M10.8047%2011.1242L9.49934%2011.1242L9.49934%209.81885'%20stroke='black'%20stroke-width='0.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M6.94856%206.72607L8.25391%206.72607L8.25391%208.03142'%20stroke='black'%20stroke-width='0.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9.69517%206.92267C10.007%207.03301%2010.2858%207.22054%2010.5055%207.46776C10.7252%207.71497%2010.8787%208.01382%2010.9517%208.33642C11.0247%208.65902%2011.0148%208.99485%2010.9229%209.31258C10.831%209.63031%2010.6601%209.91958%2010.4262%2010.1534L9.49701%2011.0421M8.25792%206.72607L7.30937%207.73554C7.07543%207.96936%206.90454%208.25863%206.81264%208.57636C6.72073%208.89408%206.71081%209.22992%206.78381%209.55251C6.8568%209.87511%207.01032%2010.174%207.23005%2010.4212C7.44978%2010.6684%207.72855%2010.8559%208.04036%2010.9663'%20stroke='black'%20stroke-width='0.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cdefs%3e%3cfilter%20id='filter0_d'%20x='0'%20y='0'%20width='18'%20height='18'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeColorMatrix%20in='SourceAlpha'%20type='matrix'%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%20127%200'/%3e%3cfeOffset/%3e%3cfeGaussianBlur%20stdDeviation='2'/%3e%3cfeColorMatrix%20type='matrix'%20values='0%200%200%200%200.137674%200%200%200%200%200.190937%200%200%200%200%200.270833%200%200%200%200.15%200'/%3e%3cfeBlend%20mode='normal'%20in2='BackgroundImageFix'%20result='effect1_dropShadow'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='effect1_dropShadow'%20result='shape'/%3e%3c/filter%3e%3c/defs%3e%3c/svg%3e";
Ne.fabric.Object.NUM_FRACTION_DIGITS = 4;
function Tl(i, n, s, u, y, w, S) {
  S !== void 0 && (i.save(), i.translate(n, s), i.rotate(Ne.fabric.util.degreesToRadians(S)), i.drawImage(u, -y / 2, -w / 2, y, w), i.restore());
}
function Wz() {
  const i = document.createElement("img");
  i.src = Rz;
  const n = document.createElement("img");
  n.src = jz;
  function s(y, w, S, d, l) {
    Tl(y, w, S, i, 20, 25, l.angle);
  }
  function u(y, w, S, d, l) {
    Tl(y, w, S, n, 25, 20, l.angle);
  }
  Ne.fabric.Object.prototype.controls.ml = new Ne.fabric.Control({
    x: -0.5,
    y: 0,
    offsetX: -1,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleSkewCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingXOrSkewingY,
    getActionName: Ne.fabric.controlsUtils.scaleOrSkewActionName,
    render: s
  }), Ne.fabric.Object.prototype.controls.mr = new Ne.fabric.Control({
    x: 0.5,
    y: 0,
    offsetX: 1,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleSkewCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingXOrSkewingY,
    getActionName: Ne.fabric.controlsUtils.scaleOrSkewActionName,
    render: s
  }), Ne.fabric.Object.prototype.controls.mb = new Ne.fabric.Control({
    x: 0,
    y: 0.5,
    offsetY: 1,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleSkewCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingYOrSkewingX,
    getActionName: Ne.fabric.controlsUtils.scaleOrSkewActionName,
    render: u
  }), Ne.fabric.Object.prototype.controls.mt = new Ne.fabric.Control({
    x: 0,
    y: -0.5,
    offsetY: -1,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleSkewCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingYOrSkewingX,
    getActionName: Ne.fabric.controlsUtils.scaleOrSkewActionName,
    render: u
  });
}
function Yz() {
  const i = document.createElement("img");
  i.src = Hz;
  function n(s, u, y, w, S) {
    Tl(s, u, y, i, 25, 25, S.angle);
  }
  Ne.fabric.Object.prototype.controls.tl = new Ne.fabric.Control({
    x: -0.5,
    y: -0.5,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingEqually,
    render: n
  }), Ne.fabric.Object.prototype.controls.bl = new Ne.fabric.Control({
    x: -0.5,
    y: 0.5,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingEqually,
    render: n
  }), Ne.fabric.Object.prototype.controls.tr = new Ne.fabric.Control({
    x: 0.5,
    y: -0.5,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingEqually,
    render: n
  }), Ne.fabric.Object.prototype.controls.br = new Ne.fabric.Control({
    x: 0.5,
    y: 0.5,
    cursorStyleHandler: Ne.fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.scalingEqually,
    render: n
  });
}
function Kz(i) {
  const n = "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3C!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3E%3Csvg version='1.1' id='Ebene_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' width='595.275px' height='595.275px' viewBox='200 215 230 470' xml:space='preserve'%3E%3Ccircle style='fill:%23F44336;' cx='299.76' cy='439.067' r='218.516'/%3E%3Cg%3E%3Crect x='267.162' y='307.978' transform='matrix(0.7071 -0.7071 0.7071 0.7071 -222.6202 340.6915)' style='fill:white;' width='65.545' height='262.18'/%3E%3Crect x='266.988' y='308.153' transform='matrix(0.7071 0.7071 -0.7071 0.7071 398.3889 -83.3116)' style='fill:white;' width='65.544' height='262.179'/%3E%3C/g%3E%3C/svg%3E", s = document.createElement("img");
  s.src = n;
  function u(w, S, d, l, p) {
    Tl(w, S, d, s, 24, 24, p.angle);
  }
  function y(w, S) {
    if (S.action === "rotate")
      return !0;
    const d = i.getActiveObjects();
    return d && (d.map((l) => i.remove(l)), i.requestRenderAll(), i.discardActiveObject()), !0;
  }
  Ne.fabric.Object.prototype.controls.deleteControl = new Ne.fabric.Control({
    x: 0.5,
    y: -0.5,
    offsetY: -16,
    offsetX: 16,
    cursorStyle: "pointer",
    mouseUpHandler: y,
    render: u
    // cornerSize: 24,
  });
}
function Gz() {
  const i = document.createElement("img");
  i.src = Uz;
  function n(s, u, y, w, S) {
    Tl(s, u, y, i, 40, 40, S.angle);
  }
  Ne.fabric.Object.prototype.controls.mtr = new Ne.fabric.Control({
    x: 0,
    y: 0.5,
    cursorStyleHandler: Ne.fabric.controlsUtils.rotationStyleHandler,
    actionHandler: Ne.fabric.controlsUtils.rotationWithSnapping,
    offsetY: 30,
    // withConnecton: false,
    actionName: "rotate",
    render: n
  });
}
class Xz {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s, this.init();
  }
  init() {
    Kz(this.canvas), Yz(), Wz(), Gz(), Ne.fabric.Object.prototype.set({
      transparentCorners: !1,
      borderColor: "#51B9F9",
      cornerColor: "#FFF",
      borderScaleFactor: 2.5,
      cornerStyle: "circle",
      cornerStrokeColor: "#0E98FC",
      borderOpacityWhenMoving: 1
    });
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(Xz, "pluginName", "ControlsPlugin");
function jr(i) {
  return `url("data:image/svg+xml,%3Csvg height='18' width='18' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: black;'%3E%3Cg fill='none' transform='rotate(${i} 16 16)'%3E%3Cpath d='M22.4484 0L32 9.57891L22.4484 19.1478V13.1032C17.6121 13.8563 13.7935 17.6618 13.0479 22.4914H19.2141L9.60201 32.01L0 22.4813H6.54912C7.36524 14.1073 14.0453 7.44023 22.4484 6.61688V0Z' fill='white'/%3E%3Cpath d='M24.0605 3.89587L29.7229 9.57896L24.0605 15.252V11.3562C17.0479 11.4365 11.3753 17.0895 11.3048 24.0879H15.3048L9.60201 29.7308L3.90932 24.0879H8.0806C8.14106 15.3223 15.2645 8.22345 24.0605 8.14313V3.89587Z' fill='black'/%3E%3C/g%3E%3C/svg%3E ") 12 12,crosshair`;
}
class qz {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s, this.init();
  }
  init() {
    const { canvas: n } = this;
    Ne.fabric.Object.prototype.controls.mtr = new Ne.fabric.Control({
      x: -0.5,
      y: -0.5,
      offsetY: -10,
      offsetX: -10,
      rotate: 20,
      actionName: "rotate",
      actionHandler: Ne.fabric.controlsUtils.rotationWithSnapping,
      render: () => ""
    }), Ne.fabric.Object.prototype.controls.mtr2 = new Ne.fabric.Control({
      x: 0.5,
      y: -0.5,
      offsetY: -10,
      offsetX: 10,
      rotate: 20,
      actionName: "rotate",
      actionHandler: Ne.fabric.controlsUtils.rotationWithSnapping,
      render: () => ""
    }), Ne.fabric.Object.prototype.controls.mtr3 = new Ne.fabric.Control({
      x: 0.5,
      y: 0.5,
      offsetY: 10,
      offsetX: 10,
      rotate: 20,
      actionName: "rotate",
      actionHandler: Ne.fabric.controlsUtils.rotationWithSnapping,
      render: () => ""
    }), Ne.fabric.Object.prototype.controls.mtr4 = new Ne.fabric.Control({
      x: -0.5,
      y: 0.5,
      offsetY: 10,
      offsetX: -10,
      rotate: 20,
      actionName: "rotate",
      actionHandler: Ne.fabric.controlsUtils.rotationWithSnapping,
      render: () => ""
    }), n.on("after:render", () => {
      var y;
      const s = n.getActiveObject(), u = (y = s == null ? void 0 : s.angle) == null ? void 0 : y.toFixed(2);
      u !== void 0 && (Ne.fabric.Object.prototype.controls.mtr.cursorStyle = jr(
        Number(u)
      ), Ne.fabric.Object.prototype.controls.mtr2.cursorStyle = jr(
        Number(u) + 90
      ), Ne.fabric.Object.prototype.controls.mtr3.cursorStyle = jr(
        Number(u) + 180
      ), Ne.fabric.Object.prototype.controls.mtr4.cursorStyle = jr(
        Number(u) + 270
      ));
    }), n.on("object:rotating", (s) => {
      var w, S, d;
      const u = n.lowerCanvasEl.nextSibling, y = (S = (w = n.getActiveObject()) == null ? void 0 : w.angle) == null ? void 0 : S.toFixed(2);
      if (y !== void 0)
        switch ((d = s.transform) == null ? void 0 : d.corner) {
          case "mtr":
            u.style.cursor = jr(Number(y));
            break;
          case "mtr2":
            u.style.cursor = jr(Number(y) + 90);
            break;
          case "mtr3":
            u.style.cursor = jr(Number(y) + 180);
            break;
          case "mtr4":
            u.style.cursor = jr(Number(y) + 270);
            break;
        }
    });
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(qz, "pluginName", "ControlsRotatePlugin");
class Qb {
  // public hotkeys: string[] = ['space'];
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  center(n, s) {
    const u = n.getCenterPoint();
    return this.canvas._centerObject(s, u);
  }
  centerV(n, s) {
    return this.canvas._centerObject(
      s,
      new Ne.fabric.Point(s.getCenterPoint().x, n.getCenterPoint().y)
    );
  }
  centerH(n, s) {
    return this.canvas._centerObject(
      s,
      new Ne.fabric.Point(n.getCenterPoint().x, s.getCenterPoint().y)
    );
  }
  position(n) {
    const s = ["centerH", "center", "centerV"], u = this.canvas.getActiveObject();
    if (s.includes(n) && u) {
      const y = this.canvas.getObjects().find((w) => w.id === "workspace");
      y && (console.log(this[n]), this[n](y, u)), this.canvas.renderAll();
    }
  }
  contextMenu() {
    if (this.canvas.getActiveObject())
      return [
        {
          text: "水平垂直居中",
          hotkey: "Ctrl+V",
          disabled: !1,
          onclick: () => this.position("center")
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(Qb, "pluginName", "CenterAlignPlugin"), Te(Qb, "apis", ["centerH", "center", "position", "centerV"]);
class Zb {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  _getWorkspace() {
    return this.canvas.getObjects().find((n) => n.id === "workspace");
  }
  _workspaceSendToBack() {
    const n = this._getWorkspace();
    n && n.sendToBack();
  }
  up() {
    const n = this.canvas.getActiveObjects();
    if (n && n.length === 1) {
      const s = this.canvas.getActiveObjects()[0];
      s && s.bringForward(), this.canvas.renderAll(), this._workspaceSendToBack();
    }
  }
  upTop() {
    const n = this.canvas.getActiveObjects();
    if (n && n.length === 1) {
      const s = this.canvas.getActiveObjects()[0];
      s && s.bringToFront(), this.canvas.renderAll(), console.log(this), this._workspaceSendToBack();
    }
  }
  down() {
    const n = this.canvas.getActiveObjects();
    if (n && n.length === 1) {
      const s = this.canvas.getActiveObjects()[0];
      s && s.sendBackwards(), this.canvas.renderAll(), this._workspaceSendToBack();
    }
  }
  downTop() {
    const n = this.canvas.getActiveObjects();
    if (n && n.length === 1) {
      const s = this.canvas.getActiveObjects()[0];
      s && s.sendToBack(), this.canvas.renderAll(), this._workspaceSendToBack();
    }
  }
  contextMenu() {
    if (this.canvas.getActiveObject())
      return [
        {
          text: "图层管理",
          hotkey: "❯",
          subitems: [
            {
              text: "上一个",
              hotkey: "key",
              onclick: () => this.up()
            },
            {
              text: "下一个",
              hotkey: "key",
              onclick: () => this.down()
            },
            {
              text: "置顶",
              hotkey: "key",
              onclick: () => this.upTop()
            },
            {
              text: "置底",
              hotkey: "key",
              onclick: () => this.downTop()
            }
          ]
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(Zb, "pluginName", "LayerPlugin"), Te(Zb, "apis", ["up", "upTop", "down", "downTop"]);
class eC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "hotkeys", ["ctrl+v", "ctrl+c"]);
    Te(this, "cache");
    this.canvas = n, this.editor = s, this.cache = null, this.initPaste();
  }
  // 多选对象复制
  _copyActiveSelection(n) {
    const u = this.canvas;
    n == null || n.clone((y) => {
      y.clone((w) => {
        u.discardActiveObject(), !(w.left === void 0 || w.top === void 0) && (w.canvas = u, w.set({
          left: w.left + 10,
          top: w.top + 10,
          evented: !0,
          id: si()
        }), w.forEachObject((S) => {
          S.id = si(), u.add(S);
        }), w.setCoords(), u.setActiveObject(w), u.requestRenderAll());
      });
    });
  }
  // 单个对象复制
  _copyObject(n) {
    const u = this.canvas;
    n == null || n.clone((y) => {
      y.left === void 0 || y.top === void 0 || (u.discardActiveObject(), y.set({
        left: y.left + 10,
        top: y.top + 10,
        evented: !0,
        id: si()
      }), u.add(y), u.setActiveObject(y), u.requestRenderAll());
    });
  }
  // 复制元素
  clone(n) {
    const s = n || this.canvas.getActiveObject();
    s && ((s == null ? void 0 : s.type) === "activeSelection" ? this._copyActiveSelection(s) : this._copyObject(s));
  }
  // 快捷键扩展回调
  hotkeyEvent(n, s) {
    if (n === "ctrl+c" && s.type === "keydown") {
      const u = this.canvas.getActiveObject();
      this.cache = u;
    }
    n === "ctrl+v" && s.type === "keydown" && this.cache && this.clone(this.cache);
  }
  contextMenu() {
    if (this.canvas.getActiveObject())
      return [
        {
          text: "复制",
          hotkey: "Ctrl+V",
          disabled: !1,
          onclick: () => this.clone()
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy"), window.removeEventListener("paste", (n) => this.pasteListener(n));
  }
  initPaste() {
    window.addEventListener("paste", (n) => this.pasteListener(n));
  }
  async pasteListener(n) {
    const s = this.canvas;
    if (document.activeElement === document.body)
      n.preventDefault();
    else
      return;
    const u = (n.clipboardData || n.originalEvent.clipboardData).items, y = ".pdf,.psd,.cdr,.ai,.svg,.jpg,.jpeg,.png,.webp,.json";
    for (const w of u)
      if (w.kind === "file") {
        const S = w.getAsFile(), d = S.name.split(".").pop();
        if (!y.split(",").includes(`.${d}`))
          return;
        if (d === "svg") {
          const l = await Pk(S);
          if (!l)
            throw new Error("file is undefined");
          Ne.fabric.loadSVGFromURL(l, (p, v) => {
            const c = Ne.fabric.util.groupSVGElements(p, {
              ...v,
              name: "defaultSVG",
              id: si()
            });
            s.add(c).centerObject(c).renderAll();
          });
        }
        if (w.type.indexOf("image/") === 0) {
          const l = URL.createObjectURL(S), p = document.createElement("img");
          p.src = l, document.body.appendChild(p), p.onload = () => {
            const v = new Ne.fabric.Image(p, {
              id: si(),
              name: "图片1",
              left: 100,
              top: 100
            });
            s.add(v), s.setActiveObject(v), s.renderAll(), p.remove();
          };
        }
      } else
        w.kind === "string" && w.type.indexOf("text/plain") === 0 && w.getAsString((S) => {
          const d = s.getActiveObject();
          if (d && (d.type === "textbox" || d.type === "i-text") && d.text) {
            const l = d.selectionStart, p = d.text.substring(
              0,
              l
            ), v = d.text.substring(
              l
            );
            d.set(
              "text",
              p + S + v
            ), d.selectionStart = l + S.length, d.selectionEnd = l + S.length, d.dirty = !0, s.renderAll();
          } else {
            const l = new Ne.fabric.IText(S, {
              left: 100,
              top: 100,
              fontSize: 80,
              id: si()
            });
            s.add(l), s.setActiveObject(l);
          }
        });
    u.length || this.cache && this.clone(this.cache);
  }
}
Te(eC, "pluginName", "CopyPlugin"), Te(eC, "apis", ["clone"]);
class Jz {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "hotkeys", ["left", "right", "down", "up"]);
    this.canvas = n, this.editor = s;
  }
  // 快捷键扩展回调
  hotkeyEvent(n, s) {
    if (s.type === "keydown") {
      const { canvas: u } = this, y = u.getActiveObject();
      if (!y)
        return;
      switch (n) {
        case "left":
          if (y.left === void 0)
            return;
          y.set("left", y.left - 1);
          break;
        case "right":
          if (y.left === void 0)
            return;
          y.set("left", y.left + 1);
          break;
        case "down":
          if (y.top === void 0)
            return;
          y.set("top", y.top + 1);
          break;
        case "up":
          if (y.top === void 0)
            return;
          y.set("top", y.top - 1);
          break;
      }
      u.renderAll();
    }
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(Jz, "pluginName", "MoveHotKeyPlugin");
class tC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "hotkeys", ["backspace"]);
    this.canvas = n, this.editor = s;
  }
  // 快捷键扩展回调
  hotkeyEvent(n, s) {
    s.type === "keydown" && n === "backspace" && this.del();
  }
  del() {
    const { canvas: n } = this, s = n.getActiveObjects();
    s && (s.map((u) => n.remove(u)), n.requestRenderAll(), n.discardActiveObject());
  }
  contextMenu() {
    if (this.canvas.getActiveObject())
      return [
        null,
        {
          text: "删除",
          hotkey: "Ctrl+V",
          disabled: !1,
          onclick: () => this.del()
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(tC, "pluginName", "DeleteHotKeyPlugin"), Te(tC, "apis", ["del"]);
class nC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  // 拆分组
  unGroup() {
    const n = this.canvas.getActiveObject();
    if (!n)
      return;
    const s = n.getObjects();
    n.toActiveSelection();
    for (const u of s)
      u.set("id", si());
    this.canvas.discardActiveObject().renderAll();
  }
  group() {
    const n = this.canvas.getActiveObject();
    if (!n)
      return;
    const s = n.toGroup(), u = s.getObjects();
    s.clone((y) => {
      y.set("id", si()), this.canvas.remove(s), u.forEach((w) => {
        this.canvas.remove(w);
      }), this.canvas.add(y), this.canvas.setActiveObject(y);
    });
  }
  contextMenu() {
    const n = this.canvas.getActiveObject();
    if (n && n.type === "group")
      return [
        {
          text: "拆分组合",
          hotkey: "Ctrl+V",
          disabled: !1,
          onclick: () => this.unGroup()
        }
      ];
    if (this.canvas.getActiveObjects().length > 1)
      return [
        {
          text: "组合",
          hotkey: "Ctrl+V",
          disabled: !1,
          onclick: () => this.group()
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(nC, "pluginName", "GroupPlugin"), Te(nC, "apis", ["unGroup", "group"]);
Ne.fabric.Arrow = Ne.fabric.util.createClass(Ne.fabric.Line, {
  type: "arrow",
  superType: "drawing",
  initialize(i, n) {
    if (!i) {
      const { x1: s, x2: u, y1: y, y2: w } = n;
      i = [s, y, u, w];
    }
    n = n || {}, this.callSuper("initialize", i, n);
  },
  _render(i) {
    this.callSuper("_render", i), i.save();
    const n = this.x2 - this.x1, s = this.y2 - this.y1, u = Math.atan2(s, n);
    i.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2), i.rotate(u), i.beginPath(), i.moveTo(5, 0), i.lineTo(-5, 5), i.lineTo(-5, -5), i.closePath(), i.fillStyle = this.stroke, i.fill(), i.restore();
  }
});
Ne.fabric.Arrow.fromObject = (i, n) => {
  const { x1: s, x2: u, y1: y, y2: w } = i;
  return n(new Ne.fabric.Arrow([s, y, u, w], i));
};
const Qz = Ne.fabric.Arrow;
class iC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "isDrawingLineMode");
    Te(this, "isArrow");
    Te(this, "lineToDraw");
    Te(this, "pointer");
    Te(this, "pointerPoints");
    Te(this, "isDrawingLine");
    this.canvas = n, this.editor = s, this.isDrawingLine = !1, this.isDrawingLineMode = !1, this.isArrow = !1, this.lineToDraw = null, this.pointer = null, this.pointerPoints = null, this.init();
  }
  init() {
    const { canvas: n } = this;
    n.on("mouse:down", (s) => {
      if (!this.isDrawingLineMode)
        return;
      n.discardActiveObject(), n.getObjects().forEach((y) => {
        y.selectable = !1, y.hasControls = !1;
      }), n.requestRenderAll(), this.isDrawingLine = !0, this.pointer = n.getPointer(s.e), this.pointerPoints = [
        this.pointer.x,
        this.pointer.y,
        this.pointer.x,
        this.pointer.y
      ];
      const u = this.isArrow ? Qz : Ne.fabric.Line;
      this.lineToDraw = new u(this.pointerPoints, {
        strokeWidth: 2,
        stroke: "#000000",
        id: si()
      }), this.lineToDraw.selectable = !1, this.lineToDraw.evented = !1, this.lineToDraw.strokeUniform = !0, n.add(this.lineToDraw);
    }), n.on("mouse:move", (s) => {
      if (!(!this.isDrawingLine || (n.discardActiveObject(), n.getActiveObject()))) {
        if (this.pointer = n.getPointer(s.e), s.e.shiftKey) {
          const y = this.pointerPoints[0], w = this.pointerPoints[1], S = this.pointer.x - y, d = this.pointer.y - w, l = Math.sqrt(S * S + d * d);
          let p = Math.atan2(d, S) / Math.PI * 180;
          p = ~~((p + 7.5) % 360 / 15) * 15;
          const v = l * Math.cos(p * Math.PI / 180), c = l * Math.sin(p * Math.PI / 180);
          this.lineToDraw.set({
            x2: v + y,
            y2: c + w
          });
        } else
          this.lineToDraw.set({
            x2: this.pointer.x,
            y2: this.pointer.y
          });
        n.renderAll();
      }
    }), n.on("mouse:up", () => {
      this.isDrawingLine && (this.lineToDraw.setCoords(), this.isDrawingLine = !1, n.discardActiveObject());
    });
  }
  setArrow(n) {
    this.isArrow = n;
  }
  setMode(n) {
    this.isDrawingLineMode = n, this.isDrawingLineMode || this.endRest();
  }
  endRest() {
    this.canvas.getObjects().forEach((n) => {
      n.id !== "workspace" && (n.selectable = !0, n.hasControls = !0);
    });
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(iC, "pluginName", "DrawLinePlugin"), Te(iC, "apis", ["setArrow", "setMode"]);
class Zz {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "isDown", !1);
    this.canvas = n, this.editor = s, this._init();
  }
  // 组内文本输入
  _init() {
    this.canvas.on("mouse:down", (n) => {
      this.isDown = !0, n.target && !n.target.lockMovementX && !n.target.lockMovementY && !n.target.lockRotation && !n.target.lockScalingX && !n.target.lockScalingY && (n.target.hasControls = !0);
    }), this.canvas.on("mouse:up", () => {
      this.isDown = !1;
    }), this.canvas.on("mouse:dblclick", (n) => {
      if (n.target && n.target.type === "group") {
        const s = this._getGroupObj(n);
        if (!s)
          return;
        if (s.selectable = !0, s.hasControls && (s.hasControls = !1), this.isText(s)) {
          this._bedingTextEditingEvent(s, n);
          return;
        }
        this.canvas.setActiveObject(s), this.canvas.renderAll();
      }
    });
  }
  // 获取点击区域内的组内文字元素
  _getGroupTextObj(n) {
    var y;
    const s = this.canvas.getPointer(n.e, !0), u = this.canvas._searchPossibleTargets(
      (y = n.target) == null ? void 0 : y._objects,
      s
    );
    return u && this.isText(u) ? u : !1;
  }
  _getGroupObj(n) {
    var y;
    const s = this.canvas.getPointer(n.e, !0);
    return this.canvas._searchPossibleTargets(
      (y = n.target) == null ? void 0 : y._objects,
      s
    );
  }
  // 通过组合重新组装来编辑文字，可能会耗性能。
  _bedingTextEditingEvent(n, s) {
    if (!s.target)
      return;
    const u = n.toObject(), y = s.target, S = {
      "i-text": "IText",
      text: "Text",
      textbox: "Textbox"
    }[u.type], d = y.calcTransformMatrix(), l = d[0], p = d[1], v = d[2], c = d[3], e = d[4], h = d[5], m = l * n.left + v * n.top + e, b = p * n.left + c * n.top + h, f = new Ne.fabric[S](n.text, {
      ...u,
      scaleX: u.scaleX * l,
      scaleY: u.scaleY * l,
      textAlign: n.textAlign,
      left: m,
      top: b,
      styles: n.styles,
      groupCopyed: n.group
    });
    f.id = si(), n.visible = !1, s.target.addWithUpdate(), f.visible = !0, f.selectable = !0, f.hasConstrols = !1, f.editable = !0, this.canvas.add(f), this.canvas.setActiveObject(f), f.enterEditing(), f.selectAll(), f.on("editing:exited", () => {
      n.set({
        text: f.text,
        visible: !0
      }), s.target.addWithUpdate(), f.visible = !1, this.canvas.remove(f), this.canvas.setActiveObject(s.target);
    });
  }
  // 绑定编辑取消事件
  _bedingEditingEvent(n, s) {
    if (!s.target)
      return;
    const u = s.target.left, y = s.target.top, w = this._unGroup() || [], S = () => {
      const d = this.canvas.getObjects().filter((p) => p.id && w.includes(p.id));
      d.forEach((p) => this.canvas.remove(p));
      const l = new Ne.fabric.Group([...d]);
      l.set("left", u), l.set("top", y), l.set("id", si()), n.off("editing:exited", S), this.canvas.add(l), this.canvas.discardActiveObject().renderAll();
    };
    n.on("editing:exited", S);
  }
  // 拆分组合并返回ID
  _unGroup() {
    const n = [], s = this.canvas.getActiveObject();
    if (s)
      return s.getObjects().forEach((u) => {
        const y = si();
        n.push(y), u.set("id", y);
      }), s.toActiveSelection(), n;
  }
  isText(n) {
    return n.type && ["i-text", "text", "textbox"].includes(n.type);
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(Zz, "pluginName", "GroupTextEditorPlugin");
class rC {
  // public hotkeys: string[] = ['space'];
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  left() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { left: y = 0 } = s;
      n.discardActiveObject(), u.forEach((S) => {
        const d = S.getBoundingRect(!0);
        S.set({
          left: y - d.left + Number(S.left)
        }), S.setCoords();
      });
      const w = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(w), n.requestRenderAll();
    }
  }
  right() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { left: y = 0, width: w = 0 } = s;
      n.discardActiveObject(), u.forEach((d) => {
        const l = d.getBoundingRect(!0);
        d.set({
          left: y + w - (l.left + l.width) + Number(d.left)
        });
      });
      const S = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(S), n.requestRenderAll();
    }
  }
  xcenter() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { left: y = 0, width: w = 0 } = s;
      n.discardActiveObject(), u.forEach((d) => {
        const l = d.getBoundingRect(!0);
        d.set({
          left: y + w / 2 - (l.left + l.width / 2) + Number(d.left)
        });
      });
      const S = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(S), n.requestRenderAll();
    }
  }
  ycenter() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { top: y = 0, height: w = 0 } = s;
      n.discardActiveObject(), u.forEach((d) => {
        const l = d.getBoundingRect(!0);
        d.set({
          top: y + w / 2 - (l.top + l.height / 2) + Number(d.top)
        });
      });
      const S = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(S), n.requestRenderAll();
    }
  }
  top() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { top: y = 0 } = s;
      n.discardActiveObject(), u.forEach((S) => {
        const d = S.getBoundingRect(!0);
        S.set({
          top: y - d.top + Number(S.top)
        });
      });
      const w = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(w), n.requestRenderAll();
    }
  }
  bottom() {
    const { canvas: n } = this, s = n.getActiveObject(), u = n.getActiveObjects();
    if (s) {
      const { top: y = 0, height: w = 0 } = s;
      n.discardActiveObject(), u.forEach((d) => {
        const l = d.getBoundingRect(!0);
        d.set({
          top: y + w - (l.top + l.height) + Number(d.top)
        });
      });
      const S = new Ne.fabric.ActiveSelection(u, {
        canvas: n
      });
      n.setActiveObject(S), n.requestRenderAll();
    }
  }
  xequation() {
    const { canvas: n } = this, s = n.getActiveObject();
    function u(d) {
      return d.aCoords.tr.x - d.aCoords.tl.x;
    }
    function y() {
      let d = 0;
      return s && s.forEachObject((l) => {
        d += u(l);
      }), d;
    }
    function w() {
      const d = y();
      if (s)
        return (Number(s.width) - d) / (s._objects.length - 1);
    }
    function S(d) {
      if (d === 0)
        return 0;
      let l = 0;
      if (s)
        for (let p = 0; p < d; p++)
          l += u(s._objects[p]);
      return l;
    }
    if (s && s.type === "activeSelection") {
      s._objects.sort((v, c) => v.left - c.left);
      const l = w(), p = Number(s.width) / 2;
      s.forEachObject((v, c) => {
        const e = S(c), h = l * c + e - p;
        v.set("left", h);
      }), n.renderAll();
    }
  }
  yequation() {
    const { canvas: n } = this, s = n.getActiveObject() || { top: 0, height: 0 };
    function u(d) {
      return d.aCoords.bl.y - d.aCoords.tl.y;
    }
    function y() {
      let d = 0;
      return s.forEachObject((l) => {
        d += u(l);
      }), d;
    }
    function w() {
      const d = y();
      return (s.height - d) / (s._objects.length - 1);
    }
    function S(d) {
      if (d === 0)
        return 0;
      let l = 0;
      for (let p = 0; p < d; p++)
        l += u(s._objects[p]);
      return l;
    }
    if (s && s.type === "activeSelection") {
      s._objects.sort((v, c) => v.top - c.top);
      const l = w(), p = Number(s.height) / 2;
      s.forEachObject((v, c) => {
        const e = S(c), h = l * c + e - p;
        v.set("top", h);
      }), n.renderAll();
    }
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(rC, "pluginName", "GroupAlignPlugin"), Te(rC, "apis", [
  "left",
  "right",
  "xcenter",
  "ycenter",
  "top",
  "bottom",
  "xequation",
  "yequation"
]);
var eR = typeof global == "object" && global && global.Object === Object && global, tR = typeof self == "object" && self && self.Object === Object && self, Yk = eR || tR || Function("return this")(), Nu = Yk.Symbol, Kk = Object.prototype, nR = Kk.hasOwnProperty, iR = Kk.toString, Fa = Nu ? Nu.toStringTag : void 0;
function rR(i) {
  var n = nR.call(i, Fa), s = i[Fa];
  try {
    i[Fa] = void 0;
    var u = !0;
  } catch {
  }
  var y = iR.call(i);
  return u && (n ? i[Fa] = s : delete i[Fa]), y;
}
var sR = Object.prototype, oR = sR.toString;
function aR(i) {
  return oR.call(i);
}
var lR = "[object Null]", cR = "[object Undefined]", sC = Nu ? Nu.toStringTag : void 0;
function uR(i) {
  return i == null ? i === void 0 ? cR : lR : sC && sC in Object(i) ? rR(i) : aR(i);
}
function hR(i) {
  return i != null && typeof i == "object";
}
var dR = "[object Symbol]";
function fR(i) {
  return typeof i == "symbol" || hR(i) && uR(i) == dR;
}
var pR = /\s/;
function mR(i) {
  for (var n = i.length; n-- && pR.test(i.charAt(n)); )
    ;
  return n;
}
var gR = /^\s+/;
function vR(i) {
  return i && i.slice(0, mR(i) + 1).replace(gR, "");
}
function Bu(i) {
  var n = typeof i;
  return i != null && (n == "object" || n == "function");
}
var oC = NaN, yR = /^[-+]0x[0-9a-f]+$/i, bR = /^0b[01]+$/i, CR = /^0o[0-7]+$/i, wR = parseInt;
function aC(i) {
  if (typeof i == "number")
    return i;
  if (fR(i))
    return oC;
  if (Bu(i)) {
    var n = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = Bu(n) ? n + "" : n;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = vR(i);
  var s = bR.test(i);
  return s || CR.test(i) ? wR(i.slice(2), s ? 2 : 8) : yR.test(i) ? oC : +i;
}
var pf = function() {
  return Yk.Date.now();
}, kR = "Expected a function", SR = Math.max, ER = Math.min;
function xR(i, n, s) {
  var u, y, w, S, d, l, p = 0, v = !1, c = !1, e = !0;
  if (typeof i != "function")
    throw new TypeError(kR);
  n = aC(n) || 0, Bu(s) && (v = !!s.leading, c = "maxWait" in s, w = c ? SR(aC(s.maxWait) || 0, n) : w, e = "trailing" in s ? !!s.trailing : e);
  function h(V) {
    var I = u, M = y;
    return u = y = void 0, p = V, S = i.apply(M, I), S;
  }
  function m(V) {
    return p = V, d = setTimeout(k, n), v ? h(V) : S;
  }
  function b(V) {
    var I = V - l, M = V - p, Q = n - I;
    return c ? ER(Q, w - M) : Q;
  }
  function f(V) {
    var I = V - l, M = V - p;
    return l === void 0 || I >= n || I < 0 || c && M >= w;
  }
  function k() {
    var V = pf();
    if (f(V))
      return E(V);
    d = setTimeout(k, b(V));
  }
  function E(V) {
    return d = void 0, e && u ? h(V) : (u = y = void 0, S);
  }
  function _() {
    d !== void 0 && clearTimeout(d), p = 0, u = l = y = d = void 0;
  }
  function T() {
    return d === void 0 ? S : E(pf());
  }
  function D() {
    var V = pf(), I = f(V);
    if (u = arguments, y = this, l = V, I) {
      if (d === void 0)
        return m(l);
      if (c)
        return clearTimeout(d), d = setTimeout(k, n), h(l);
    }
    return d === void 0 && (d = setTimeout(k, n)), S;
  }
  return D.cancel = _, D.flush = T, D;
}
var _R = "Expected a function";
function ep(i, n, s) {
  var u = !0, y = !0;
  if (typeof i != "function")
    throw new TypeError(_R);
  return Bu(s) && (u = "leading" in s ? !!s.leading : u, y = "trailing" in s ? !!s.trailing : y), xR(i, n, {
    leading: u,
    maxWait: n,
    trailing: y
  });
}
class mf {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "workspaceEl");
    Te(this, "workspace");
    Te(this, "option");
    this.canvas = n, this.editor = s, this.workspace = null, this.init({
      width: 900,
      height: 2e3
    });
  }
  init(n) {
    const s = document.querySelector("#workspace");
    if (!s)
      throw new Error("element #workspace is missing, plz check!");
    this.workspaceEl = s, this.workspace = null, this.option = n, this._initBackground(), this._initWorkspace(), this._initResizeObserve(), this._bindWheel();
  }
  hookImportAfter() {
    return new Promise((n) => {
      const s = this.canvas.getObjects().find((u) => u.id === "workspace");
      s && (s.set("selectable", !1), s.set("hasControls", !1), this.setSize(s.width, s.height), this.editor.emit("sizeChange", s.width, s.height)), n("");
    });
  }
  hookSaveAfter() {
    return new Promise((n) => {
      this.auto(), n(!0);
    });
  }
  // 初始化背景
  _initBackground() {
    this.canvas.backgroundImage = "", this.canvas.setWidth(this.workspaceEl.offsetWidth), this.canvas.setHeight(this.workspaceEl.offsetHeight);
  }
  // 初始化画布
  _initWorkspace() {
    const { width: n, height: s } = this.option, u = new Ne.fabric.Rect({
      fill: "rgba(255,255,255,1)",
      width: n,
      height: s,
      id: "workspace",
      strokeWidth: 0
    });
    u.set("selectable", !1), u.set("hasControls", !1), u.hoverCursor = "default", this.canvas.add(u), this.canvas.renderAll(), this.workspace = u, this.canvas.clearHistory && this.canvas.clearHistory(), this.auto();
  }
  /**
   * 设置画布中心到指定对象中心点上
   * @param {Object} obj 指定的对象
   */
  setCenterFromObject(n) {
    const { canvas: s } = this, u = n.getCenterPoint(), y = s.viewportTransform;
    s.width === void 0 || s.height === void 0 || !y || (y[4] = s.width / 2 - u.x * y[0], y[5] = s.height / 2 - u.y * y[3], s.setViewportTransform(y), s.renderAll());
  }
  // 初始化监听器
  _initResizeObserve() {
    new ResizeObserver(
      ep(() => {
        this.auto();
      }, 50)
    ).observe(this.workspaceEl);
  }
  setSize(n, s) {
    this._initBackground(), this.option.width = n, this.option.height = s, this.workspace = this.canvas.getObjects().find((u) => u.id === "workspace"), this.workspace.set("width", n), this.workspace.set("height", s), this.editor.emit("sizeChange", this.workspace.width, this.workspace.height), this.auto();
  }
  setZoomAuto(n, s) {
    const { workspaceEl: u } = this, y = u.offsetWidth, w = u.offsetHeight;
    this.canvas.setWidth(y), this.canvas.setHeight(w);
    const S = this.canvas.getCenter();
    this.canvas.setViewportTransform(Ne.fabric.iMatrix.concat()), this.canvas.zoomToPoint(new Ne.fabric.Point(S.left, S.top), n), this.workspace && (this.setCenterFromObject(this.workspace), this.workspace.clone((d) => {
      this.canvas.clipPath = d, this.canvas.requestRenderAll();
    }), s && s(this.workspace.left, this.workspace.top));
  }
  _getScale() {
    const n = this.workspaceEl.offsetWidth, s = this.workspaceEl.offsetHeight;
    return n / s < this.option.width / this.option.height ? n / this.option.width : s / this.option.height;
  }
  // 放大
  big() {
    let n = this.canvas.getZoom();
    n += 0.05;
    const s = this.canvas.getCenter();
    this.canvas.zoomToPoint(
      new Ne.fabric.Point(s.left, s.top),
      n
    );
  }
  // 缩小
  small() {
    let n = this.canvas.getZoom();
    n -= 0.05;
    const s = this.canvas.getCenter();
    this.canvas.zoomToPoint(
      new Ne.fabric.Point(s.left, s.top),
      n < 0 ? 0.01 : n
    );
  }
  // 自动缩放
  auto() {
    const n = this._getScale();
    this.setZoomAuto(n - 0.08);
  }
  // 1:1 放大
  one() {
    this.setZoomAuto(0.8 - 0.08), this.canvas.requestRenderAll();
  }
  _bindWheel() {
    this.canvas.on("mouse:wheel", function(n) {
      const s = n.e.deltaY;
      let u = this.getZoom();
      u *= 0.999 ** s, u > 20 && (u = 20), u < 0.01 && (u = 0.01);
      const y = this.getCenter();
      this.zoomToPoint(new Ne.fabric.Point(y.left, y.top), u), n.e.preventDefault(), n.e.stopPropagation();
    });
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(mf, "pluginName", "WorkspacePlugin"), Te(mf, "events", ["sizeChange"]), Te(mf, "apis", ["big", "small", "auto", "one", "setSize"]);
var Gk = { exports: {} };
(function(i) {
  (function() {
    function n(b, f) {
      document.addEventListener ? b.addEventListener("scroll", f, !1) : b.attachEvent("scroll", f);
    }
    function s(b) {
      document.body ? b() : document.addEventListener ? document.addEventListener("DOMContentLoaded", function f() {
        document.removeEventListener("DOMContentLoaded", f), b();
      }) : document.attachEvent("onreadystatechange", function f() {
        (document.readyState == "interactive" || document.readyState == "complete") && (document.detachEvent("onreadystatechange", f), b());
      });
    }
    function u(b) {
      this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(b)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i);
    }
    function y(b, f) {
      b.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + f + ";";
    }
    function w(b) {
      var f = b.g.offsetWidth, k = f + 100;
      return b.j.style.width = k + "px", b.i.scrollLeft = k, b.h.scrollLeft = b.h.scrollWidth + 100, b.l !== f ? (b.l = f, !0) : !1;
    }
    function S(b, f) {
      function k() {
        var _ = E;
        w(_) && _.g.parentNode !== null && f(_.l);
      }
      var E = b;
      n(b.h, k), n(b.i, k), w(b);
    }
    function d(b, f, k) {
      f = f || {}, k = k || window, this.family = b, this.style = f.style || "normal", this.weight = f.weight || "normal", this.stretch = f.stretch || "normal", this.context = k;
    }
    var l = null, p = null, v = null, c = null;
    function e(b) {
      return p === null && (h(b) && /Apple/.test(window.navigator.vendor) ? (b = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), p = !!b && 603 > parseInt(b[1], 10)) : p = !1), p;
    }
    function h(b) {
      return c === null && (c = !!b.document.fonts), c;
    }
    function m(b, f) {
      var k = b.style, E = b.weight;
      if (v === null) {
        var _ = document.createElement("div");
        try {
          _.style.font = "condensed 100px sans-serif";
        } catch {
        }
        v = _.style.font !== "";
      }
      return [k, E, v ? b.stretch : "", "100px", f].join(" ");
    }
    d.prototype.load = function(b, f) {
      var k = this, E = b || "BESbswy", _ = 0, T = f || 3e3, D = (/* @__PURE__ */ new Date()).getTime();
      return new Promise(function(V, I) {
        if (h(k.context) && !e(k.context)) {
          var M = new Promise(function(G, z) {
            function re() {
              (/* @__PURE__ */ new Date()).getTime() - D >= T ? z(Error("" + T + "ms timeout exceeded")) : k.context.document.fonts.load(m(k, '"' + k.family + '"'), E).then(function(he) {
                1 <= he.length ? G() : setTimeout(re, 25);
              }, z);
            }
            re();
          }), Q = new Promise(function(G, z) {
            _ = setTimeout(function() {
              z(Error("" + T + "ms timeout exceeded"));
            }, T);
          });
          Promise.race([Q, M]).then(function() {
            clearTimeout(_), V(k);
          }, I);
        } else
          s(function() {
            function G() {
              var Y;
              (Y = Ce != -1 && xe != -1 || Ce != -1 && Ie != -1 || xe != -1 && Ie != -1) && ((Y = Ce != xe && Ce != Ie && xe != Ie) || (l === null && (Y = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), l = !!Y && (536 > parseInt(Y[1], 10) || parseInt(Y[1], 10) === 536 && 11 >= parseInt(Y[2], 10))), Y = l && (Ce == Be && xe == Be && Ie == Be || Ce == L && xe == L && Ie == L || Ce == Z && xe == Z && Ie == Z)), Y = !Y), Y && (W.parentNode !== null && W.parentNode.removeChild(W), clearTimeout(_), V(k));
            }
            function z() {
              if ((/* @__PURE__ */ new Date()).getTime() - D >= T)
                W.parentNode !== null && W.parentNode.removeChild(W), I(Error("" + T + "ms timeout exceeded"));
              else {
                var Y = k.context.document.hidden;
                (Y === !0 || Y === void 0) && (Ce = re.g.offsetWidth, xe = he.g.offsetWidth, Ie = de.g.offsetWidth, G()), _ = setTimeout(z, 50);
              }
            }
            var re = new u(E), he = new u(E), de = new u(E), Ce = -1, xe = -1, Ie = -1, Be = -1, L = -1, Z = -1, W = document.createElement("div");
            W.dir = "ltr", y(re, m(k, "sans-serif")), y(he, m(k, "serif")), y(de, m(k, "monospace")), W.appendChild(re.g), W.appendChild(he.g), W.appendChild(de.g), k.context.document.body.appendChild(W), Be = re.g.offsetWidth, L = he.g.offsetWidth, Z = de.g.offsetWidth, z(), S(re, function(Y) {
              Ce = Y, G();
            }), y(re, m(k, '"' + k.family + '",sans-serif')), S(he, function(Y) {
              xe = Y, G();
            }), y(he, m(k, '"' + k.family + '",serif')), S(de, function(Y) {
              Ie = Y, G();
            }), y(de, m(k, '"' + k.family + '",monospace'));
          });
      });
    }, i.exports = d;
  })();
})(Gk);
var TR = Gk.exports;
const OR = /* @__PURE__ */ SC(TR);
function DR(i) {
  const n = ["arial", "Microsoft YaHei"], u = JSON.parse(i).objects.filter(
    (y) => (
      // 为text 并且不为包含字体
      // eslint-disable-next-line implicit-arrow-linebreak
      y.type.includes("text") && !n.includes(y.fontFamily)
    )
  ).map((y) => y.fontFamily).map((y) => new OR(y).load(null, 15e4));
  return Promise.all(u);
}
class NR {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  hookImportBefore(n) {
    return DR(n);
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(NR, "pluginName", "DownFontPlugin");
fabric.Canvas.prototype.initialize = /* @__PURE__ */ function(i) {
  return function(...n) {
    return i.call(this, ...n), this._historyInit(), this;
  };
}(fabric.Canvas.prototype.initialize), fabric.Canvas.prototype.dispose = /* @__PURE__ */ function(i) {
  return function(...n) {
    return i.call(this, ...n), this._historyDispose(), this;
  };
}(fabric.Canvas.prototype.dispose), fabric.Canvas.prototype._historyNext = function() {
  return JSON.stringify(this.toDatalessJSON(this.extraProps));
}, fabric.Canvas.prototype._historyEvents = function() {
  return { "object:added": this._historySaveAction, "object:removed": this._historySaveAction, "object:modified": this._historySaveAction, "object:skewing": this._historySaveAction };
}, fabric.Canvas.prototype._historyInit = function() {
  this.historyUndo = [], this.historyRedo = [], this.extraProps = ["selectable", "editable"], this.historyNextState = this._historyNext(), this.on(this._historyEvents());
}, fabric.Canvas.prototype._historyDispose = function() {
  this.off(this._historyEvents());
}, fabric.Canvas.prototype._historySaveAction = function() {
  if (this.historyProcessing)
    return;
  const i = this.historyNextState;
  this.historyUndo.push(i), this.historyNextState = this._historyNext(), this.fire("history:append", { json: i });
}, fabric.Canvas.prototype.undo = function(i) {
  this.historyProcessing = !0;
  const n = this.historyUndo.pop();
  n ? (this.historyRedo.push(this._historyNext()), this.historyNextState = n, this._loadHistory(n, "history:undo", i)) : this.historyProcessing = !1;
}, fabric.Canvas.prototype.redo = function(i) {
  this.historyProcessing = !0;
  const n = this.historyRedo.pop();
  n ? (this.historyUndo.push(this._historyNext()), this.historyNextState = n, this._loadHistory(n, "history:redo", i)) : this.historyProcessing = !1;
}, fabric.Canvas.prototype._loadHistory = function(i, n, s) {
  var u = this;
  this.loadFromJSON(i, function() {
    u.renderAll(), u.fire(n), u.historyProcessing = !1, s && typeof s == "function" && s();
  });
}, fabric.Canvas.prototype.clearHistory = function() {
  this.historyUndo = [], this.historyRedo = [], this.fire("history:clear");
}, fabric.Canvas.prototype.onHistory = function() {
  this.historyProcessing = !1, this._historySaveAction();
}, fabric.Canvas.prototype.offHistory = function() {
  this.historyProcessing = !0;
};
class gf {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "hotkeys", ["ctrl+z", "ctrl+shift+z", "⌘+z", "⌘+shift+z"]);
    this.canvas = n, this.editor = s, Ne.fabric.Canvas.prototype._historyNext = () => this.editor.getJson(), this._init();
  }
  _init() {
    this.canvas.on("history:append", () => {
      this.historyUpdate();
    }), window.addEventListener("beforeunload", (n) => {
      this.canvas.historyUndo.length > 0 && ((n || window.event).returnValue = "确认离开");
    });
  }
  historyUpdate() {
    const { historyUndo: n, historyRedo: s } = this.canvas;
    this.editor.emit("historyUpdate", n.length, s.length);
  }
  // 导入模板之后，清理 History 缓存
  hookImportAfter() {
    this.canvas.clearHistory(), this.historyUpdate();
  }
  undo() {
    if (this.canvas.historyUndo.length === 1) {
      this.editor.clear(), this.canvas.clearHistory();
      return;
    }
    this.canvas.undo(), this.historyUpdate();
  }
  redo() {
    this.canvas.redo(), this.historyUpdate();
  }
  // 快捷键扩展回调
  hotkeyEvent(n, s) {
    if (s.type === "keydown")
      switch (n) {
        case "ctrl+z":
        case "⌘+z":
          this.undo();
          break;
        case "ctrl+shift+z":
        case "⌘+shift+z":
          this.redo();
          break;
      }
  }
}
Te(gf, "pluginName", "HistoryPlugin"), Te(gf, "apis", ["undo", "redo"]), Te(gf, "events", ["historyUpdate"]);
const lC = (i) => i;
class cC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    this.canvas = n, this.editor = s;
  }
  flip(n) {
    const s = this.canvas.getActiveObject();
    s && (s.set(`flip${n}`, !s[`flip${n}`]).setCoords(), this.canvas.requestRenderAll());
  }
  contextMenu() {
    if (this.editor.getSelectMode() === Xr.ONE)
      return [
        {
          text: "翻转",
          hotkey: "❯",
          subitems: [
            {
              text: lC("flip.x"),
              hotkey: "|",
              onclick: () => this.flip("X")
            },
            {
              text: lC("flip.y"),
              hotkey: "-",
              onclick: () => this.flip("Y")
            }
          ]
        }
      ];
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(cC, "pluginName", "FlipPlugin"), Te(cC, "apis", ["flip"]);
const BR = (i) => {
  const n = [0.02, 0.03, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 18], s = [5e3, 2500, 1e3, 500, 250, 100, 50, 25, 10, 5, 2];
  let u = 0;
  for (; u < n.length && n[u] < i; )
    u++;
  return s[u - 1] || 5e3;
}, uC = (i, n) => {
  const s = n ? "left" : "top", u = n ? "width" : "height";
  i.sort((S, d) => S[s] - d[s]);
  const y = [];
  let w = Object.assign({}, i[0]);
  for (const S of i) {
    const d = Object.assign({}, S);
    w[s] + w[u] >= d[s] ? w[u] = Math.max(
      w[s] + w[u],
      d[s] + d[u]
    ) - w[s] : (y.push(w), w = Object.assign({}, d));
  }
  return y.push(w), y;
}, vf = (i, n) => {
  i.save();
  const { left: s, top: u, width: y, height: w, stroke: S, lineWidth: d } = n;
  i.beginPath(), S && (i.strokeStyle = S), i.lineWidth = d ?? 1, i.moveTo(s, u), i.lineTo(s + y, u + w), i.stroke(), i.restore();
}, yf = (i, n) => {
  i.save();
  const { left: s, top: u, text: y, fill: w, align: S, angle: d, fontSize: l } = n;
  w && (i.fillStyle = w), i.textAlign = S ?? "left", i.textBaseline = "top", i.font = `${l ?? 10}px sans-serif`, d && (i.translate(s, u), i.rotate(Math.PI / 180 * d), i.translate(-s, -u)), i.fillText(y, s, u), i.restore();
}, tp = (i, n) => {
  i.save();
  const { left: s, top: u, width: y, height: w, fill: S, stroke: d, strokeWidth: l } = n;
  i.beginPath(), S && (i.fillStyle = S), i.rect(s, u, y, w), i.fill(), d && (i.strokeStyle = d, i.lineWidth = l ?? 1, i.stroke()), i.restore();
}, eu = (i, n) => {
  i.save();
  const { isHorizontal: s, left: u, top: y, width: w, height: S, backgroundColor: d } = n, l = s ? i.createLinearGradient(u, S / 2, u + w, S / 2) : i.createLinearGradient(w / 2, y, w / 2, S + y), p = new Ne.fabric.Color(d);
  p.setAlpha(0), l.addColorStop(0, p.toRgba()), l.addColorStop(0.33, d), l.addColorStop(0.67, d), l.addColorStop(1, p.toRgba()), tp(i, {
    left: u,
    top: y,
    width: w,
    height: S,
    fill: l
  }), i.restore();
};
function PR() {
  Ne.fabric.GuideLine || (Ne.fabric.GuideLine = Ne.fabric.util.createClass(Ne.fabric.Line, {
    type: "GuideLine",
    selectable: !1,
    hasControls: !1,
    hasBorders: !1,
    stroke: "#4bec13",
    originX: "center",
    originY: "center",
    padding: 4,
    // 填充，让辅助线选择范围更大，方便选中
    globalCompositeOperation: "difference",
    axis: "horizontal",
    // excludeFromExport: true,
    initialize(i, n) {
      const s = n.axis === "horizontal";
      this.hoverCursor = s ? "ns-resize" : "ew-resize";
      const u = s ? [-999999, i, 999999, i] : [i, -999999, i, 999999];
      n[s ? "lockMovementX" : "lockMovementY"] = !0, this.callSuper("initialize", u, n), this.on("mousedown:before", (y) => {
        this.activeOn === "down" && this.canvas && this.canvas.setActiveObject(this, y.e);
      }), this.on("moving", (y) => {
        this.canvas && this.canvas.ruler.options.enabled && this.isPointOnRuler(y.e) ? this.moveCursor = "not-allowed" : this.moveCursor = this.isHorizontal() ? "ns-resize" : "ew-resize", this.canvas && this.canvas.fire("guideline:moving", {
          target: this,
          e: y.e
        });
      }), this.on("mouseup", (y) => {
        if (this.canvas && this.canvas.ruler.options.enabled && this.isPointOnRuler(y.e)) {
          this.canvas.remove(this);
          return;
        }
        this.moveCursor = this.isHorizontal() ? "ns-resize" : "ew-resize", this.canvas && this.canvas.fire("guideline:mouseup", {
          target: this,
          e: y.e
        });
      }), this.on("removed", () => {
        this.off("removed"), this.off("mousedown:before"), this.off("moving"), this.off("mouseup");
      });
    },
    getBoundingRect(i, n) {
      this.bringToFront();
      const s = this.isHorizontal(), u = this.callSuper("getBoundingRect", i, n);
      return u[s ? "top" : "left"] += u[s ? "height" : "width"] / 2, u[s ? "height" : "width"] = 0, u;
    },
    isPointOnRuler(i) {
      const n = this.isHorizontal(), s = this.canvas && this.canvas.ruler.isPointOnRuler(
        new Ne.fabric.Point(i.offsetX, i.offsetY)
      );
      return n && s === "horizontal" || !n && s === "vertical" ? s : !1;
    },
    isHorizontal() {
      return this.height === 0;
    }
  }), Ne.fabric.GuideLine.fromObject = function(i, n) {
    const s = Ne.fabric.util.object.clone;
    function u(S) {
      delete S.xy, n && n(S);
    }
    const y = s(i, !0), w = y.height === 0;
    y.xy = w ? y.y1 : y.x1, y.axis = w ? "horizontal" : "vertical", Ne.fabric.Object._fromObject(y.type, y, u, "xy");
  });
}
Ne.fabric.GuideLine;
class VR {
  constructor(n) {
    Te(this, "ctx");
    /**
     * 配置
     */
    Te(this, "options");
    /**
     * 标尺起始点
     */
    Te(this, "startCalibration");
    Te(this, "activeOn", "up");
    /**
     * 选取对象矩形坐标
     */
    Te(this, "objectRect");
    /**
     * 事件句柄缓存
     */
    Te(this, "eventHandler", {
      // calcCalibration: this.calcCalibration.bind(this),
      calcObjectRect: ep(this.calcObjectRect.bind(this), 15),
      clearStatus: this.clearStatus.bind(this),
      canvasMouseDown: this.canvasMouseDown.bind(this),
      canvasMouseMove: ep(this.canvasMouseMove.bind(this), 15),
      canvasMouseUp: this.canvasMouseUp.bind(this),
      render: (n) => {
        n.ctx && this.render();
      }
    });
    Te(this, "lastAttr", {
      status: "out",
      cursor: void 0,
      selection: void 0
    });
    Te(this, "tempGuidelLine");
    Te(this, "getCommonEventInfo", (n) => {
      if (!(!this.tempGuidelLine || !n.absolutePointer))
        return {
          e: n.e,
          transform: this.tempGuidelLine.get("transform"),
          pointer: {
            x: n.absolutePointer.x,
            y: n.absolutePointer.y
          },
          target: this.tempGuidelLine
        };
    });
    this.options = Object.assign(
      {
        ruleSize: 20,
        fontSize: 10,
        enabled: !1,
        backgroundColor: "#fff",
        borderColor: "#ddd",
        highlightColor: "#007fff",
        textColor: "#888"
      },
      n
    ), this.ctx = this.options.canvas.getContext(), Ne.fabric.util.object.extend(this.options.canvas, {
      ruler: this
    }), PR(), this.options.enabled && this.enable();
  }
  // 销毁
  destroy() {
    this.disable();
  }
  /**
   * 移除全部辅助线
   */
  clearGuideline() {
    this.options.canvas.remove(
      ...this.options.canvas.getObjects(Ne.fabric.GuideLine.prototype.type)
    );
  }
  /**
   * 显示全部辅助线
   */
  showGuideline() {
    this.options.canvas.getObjects(Ne.fabric.GuideLine.prototype.type).forEach((n) => {
      n.set("visible", !0);
    }), this.options.canvas.renderAll();
  }
  /**
   * 隐藏全部辅助线
   */
  hideGuideline() {
    this.options.canvas.getObjects(Ne.fabric.GuideLine.prototype.type).forEach((n) => {
      n.set("visible", !1);
    }), this.options.canvas.renderAll();
  }
  /**
   * 启用
   */
  enable() {
    this.options.enabled = !0, this.options.canvas.on("after:render", this.eventHandler.calcObjectRect), this.options.canvas.on("after:render", this.eventHandler.render), this.options.canvas.on("mouse:down", this.eventHandler.canvasMouseDown), this.options.canvas.on("mouse:move", this.eventHandler.canvasMouseMove), this.options.canvas.on("mouse:up", this.eventHandler.canvasMouseUp), this.options.canvas.on("selection:cleared", this.eventHandler.clearStatus), this.showGuideline(), this.render();
  }
  /**
   * 禁用
   */
  disable() {
    this.options.canvas.off("after:render", this.eventHandler.calcObjectRect), this.options.canvas.off("after:render", this.eventHandler.render), this.options.canvas.off("mouse:down", this.eventHandler.canvasMouseDown), this.options.canvas.off("mouse:move", this.eventHandler.canvasMouseMove), this.options.canvas.off("mouse:up", this.eventHandler.canvasMouseUp), this.options.canvas.off("selection:cleared", this.eventHandler.clearStatus), this.hideGuideline(), this.options.enabled = !1;
  }
  /**
   * 绘制
   */
  render() {
    var s, u;
    const n = this.options.canvas.viewportTransform;
    n && (this.draw({
      isHorizontal: !0,
      rulerLength: this.getSize().width,
      // startCalibration: -(vpt[4] / vpt[0]),
      startCalibration: (s = this.startCalibration) != null && s.x ? this.startCalibration.x : -(n[4] / n[0])
    }), this.draw({
      isHorizontal: !1,
      rulerLength: this.getSize().height,
      // startCalibration: -(vpt[5] / vpt[3]),
      startCalibration: (u = this.startCalibration) != null && u.y ? this.startCalibration.y : -(n[5] / n[3])
    }), eu(this.ctx, {
      isHorizontal: !0,
      left: -10,
      top: -10,
      width: this.options.ruleSize * 2 + 10,
      height: this.options.ruleSize + 10,
      backgroundColor: this.options.backgroundColor
    }), eu(this.ctx, {
      isHorizontal: !1,
      left: -10,
      top: -10,
      width: this.options.ruleSize + 10,
      height: this.options.ruleSize * 2 + 10,
      backgroundColor: this.options.backgroundColor
    }));
  }
  /**
   * 获取画板尺寸
   */
  getSize() {
    return {
      width: this.options.canvas.width ?? 0,
      height: this.options.canvas.height ?? 0
    };
  }
  getZoom() {
    return this.options.canvas.getZoom();
  }
  draw(n) {
    const { isHorizontal: s, rulerLength: u, startCalibration: y } = n, w = this.getZoom(), S = BR(w), d = u / w, l = Math[y > 0 ? "floor" : "ceil"](y / S) * S, p = l - y, v = this.getSize();
    tp(this.ctx, {
      left: 0,
      top: 0,
      width: s ? v.width : this.options.ruleSize,
      height: s ? this.options.ruleSize : v.height,
      fill: this.options.backgroundColor,
      stroke: this.options.borderColor
    });
    const c = new Ne.fabric.Color(this.options.textColor);
    for (let e = 0; e + p <= Math.ceil(d); e += S) {
      const h = (p + e) * w, m = l + e + "", b = 10 * m.length / 4, f = s ? h - b - 1 : this.options.ruleSize / 2 - this.options.fontSize / 2 - 4, k = s ? this.options.ruleSize / 2 - this.options.fontSize / 2 - 4 : h + b;
      yf(this.ctx, {
        text: m,
        left: f,
        top: k,
        fill: c.toRgb(),
        angle: s ? 0 : -90
      });
    }
    for (let e = 0; e + p <= Math.ceil(d); e += S) {
      const h = Math.round((p + e) * w), m = s ? h : this.options.ruleSize - 8, b = s ? this.options.ruleSize - 8 : h, f = s ? 0 : 8, k = s ? 8 : 0;
      vf(this.ctx, {
        left: m,
        top: b,
        width: f,
        height: k,
        stroke: c.toRgb()
      });
    }
    if (this.objectRect) {
      const e = s ? "x" : "y";
      this.objectRect[e].forEach((h) => {
        if (h.skip === e)
          return;
        const m = (M) => Math.round(M / w + y) + "", b = m(s ? h.left : h.top), f = m(
          s ? h.left + h.width : h.top + h.height
        ), k = b === f, E = {
          isHorizontal: s,
          width: s ? 160 : this.options.ruleSize - 8,
          height: s ? this.options.ruleSize - 8 : 160,
          backgroundColor: this.options.backgroundColor
        };
        eu(this.ctx, {
          ...E,
          left: s ? h.left - 80 : 0,
          top: s ? 0 : h.top - 80
        }), k || eu(this.ctx, {
          ...E,
          left: s ? h.width + h.left - 80 : 0,
          top: s ? 0 : h.height + h.top - 80
        });
        const _ = new Ne.fabric.Color(this.options.highlightColor);
        _.setAlpha(0.5), tp(this.ctx, {
          left: s ? h.left : this.options.ruleSize - 8,
          top: s ? this.options.ruleSize - 8 : h.top,
          width: s ? h.width : 8,
          height: s ? 8 : h.height,
          fill: _.toRgba()
        });
        const T = this.options.ruleSize / 2 - this.options.fontSize / 2 - 4, D = {
          fill: _.toRgba(),
          angle: s ? 0 : -90
        };
        yf(this.ctx, {
          ...D,
          text: b,
          left: s ? h.left - 2 : T,
          top: s ? T : h.top - 2,
          align: k ? "center" : s ? "right" : "left"
        }), k || yf(this.ctx, {
          ...D,
          text: f,
          left: s ? h.left + h.width + 2 : T,
          top: s ? T : h.top + h.height + 2,
          align: s ? "left" : "right"
        });
        const V = k ? 8 : 14;
        _.setAlpha(1);
        const I = {
          width: s ? 0 : V,
          height: s ? V : 0,
          stroke: _.toRgba()
        };
        vf(this.ctx, {
          ...I,
          left: s ? h.left : this.options.ruleSize - V,
          top: s ? this.options.ruleSize - V : h.top
        }), k || vf(this.ctx, {
          ...I,
          left: s ? h.left + h.width : this.options.ruleSize - V,
          top: s ? this.options.ruleSize - V : h.top + h.height
        });
      });
    }
  }
  /**
   * 计算起始点
   */
  // private calcCalibration() {
  //   if (this.startCalibration) return;
  //   // console.log('calcCalibration');
  //   const workspace = this.options.canvas.getObjects().find((item: any) => {
  //     return item.id === 'workspace';
  //   });
  //   if (!workspace) return;
  //   const rect = workspace.getBoundingRect(false);
  //   this.startCalibration = new fabric.Point(-rect.left, -rect.top).divide(this.getZoom());
  // }
  calcObjectRect() {
    const n = this.options.canvas.getActiveObjects();
    if (n.length === 0)
      return;
    const s = n.reduce((u, y) => {
      const w = y.getBoundingRect(!1, !0);
      if (y.group) {
        const S = {
          top: 0,
          left: 0,
          width: 0,
          height: 0,
          scaleX: 1,
          scaleY: 1,
          ...y.group
        };
        w.width *= S.scaleX, w.height *= S.scaleY;
        const d = S.width / 2 + S.left, l = (S.width / 2 + (y.left ?? 0)) * (1 - S.scaleX);
        w.left += (d - l) * this.getZoom();
        const p = S.height / 2 + S.top, v = (S.height / 2 + (y.top ?? 0)) * (1 - S.scaleY);
        w.top += (p - v) * this.getZoom();
      }
      return y instanceof Ne.fabric.GuideLine && (w.skip = y.isHorizontal() ? "x" : "y"), u.push(w), u;
    }, []);
    s.length !== 0 && (this.objectRect = {
      x: uC(s, !0),
      y: uC(s, !1)
    });
  }
  /**
   * 清除起始点和矩形坐标
   */
  clearStatus() {
    this.objectRect = void 0;
  }
  /**
    判断鼠标是否在标尺上
   * @param point 
   * @returns "vertical" | "horizontal" | false
   */
  isPointOnRuler(n) {
    return new Ne.fabric.Rect({
      left: 0,
      top: 0,
      width: this.options.ruleSize,
      height: this.options.canvas.height
    }).containsPoint(n) ? "vertical" : new Ne.fabric.Rect({
      left: 0,
      top: 0,
      width: this.options.canvas.width,
      height: this.options.ruleSize
    }).containsPoint(n) ? "horizontal" : !1;
  }
  canvasMouseDown(n) {
    if (!n.pointer || !n.absolutePointer)
      return;
    const s = this.isPointOnRuler(n.pointer);
    s && this.activeOn === "up" && (this.lastAttr.selection = this.options.canvas.selection, this.options.canvas.selection = !1, this.activeOn = "down", this.tempGuidelLine = new Ne.fabric.GuideLine(
      s === "horizontal" ? n.absolutePointer.y : n.absolutePointer.x,
      {
        axis: s,
        visible: !1
      }
    ), this.options.canvas.add(this.tempGuidelLine), this.options.canvas.setActiveObject(this.tempGuidelLine), this.options.canvas._setupCurrentTransform(
      n.e,
      this.tempGuidelLine,
      !0
    ), this.tempGuidelLine.fire("down", this.getCommonEventInfo(n)));
  }
  canvasMouseMove(n) {
    if (!n.pointer)
      return;
    if (this.tempGuidelLine && n.absolutePointer) {
      const u = {};
      this.tempGuidelLine.axis === "horizontal" ? u.top = n.absolutePointer.y : u.left = n.absolutePointer.x, this.tempGuidelLine.set({ ...u, visible: !0 }), this.options.canvas.requestRenderAll();
      const y = this.getCommonEventInfo(n);
      this.options.canvas.fire("object:moving", y), this.tempGuidelLine.fire("moving", y);
    }
    const s = this.isPointOnRuler(n.pointer);
    if (!s) {
      this.lastAttr.status !== "out" && (this.options.canvas.defaultCursor = this.lastAttr.cursor, this.lastAttr.status = "out");
      return;
    }
    (this.lastAttr.status === "out" || s !== this.lastAttr.status) && (this.lastAttr.cursor = this.options.canvas.defaultCursor, this.options.canvas.defaultCursor = s === "horizontal" ? "ns-resize" : "ew-resize", this.lastAttr.status = s);
  }
  canvasMouseUp(n) {
    var s;
    this.activeOn === "down" && (this.options.canvas.selection = this.lastAttr.selection, this.activeOn = "up", (s = this.tempGuidelLine) == null || s.fire("up", this.getCommonEventInfo(n)), this.tempGuidelLine = void 0);
  }
}
function $R(i, n) {
  const s = new VR({
    canvas: i,
    ...n
  });
  let u;
  const y = () => {
    u = i.getObjects().find((S) => S.id === "workspace");
  }, w = (S, d) => {
    const { top: l, height: p, left: v, width: c } = S;
    if (l === void 0 || p === void 0 || v === void 0 || c === void 0)
      return !1;
    const e = d.getBoundingRect(!0, !0), {
      top: h,
      height: m,
      left: b,
      width: f
    } = e;
    return d.isHorizontal() && (l > h + 1 || l + p < h + m - 1) ? !0 : !d.isHorizontal() && (v > b + 1 || v + c < b + f - 1);
  };
  return i.on("guideline:moving", (S) => {
    if (!u) {
      y();
      return;
    }
    const { target: d } = S;
    w(u, d) && (d.moveCursor = "not-allowed");
  }), i.on("guideline:mouseup", (S) => {
    if (!u) {
      y();
      return;
    }
    const { target: d } = S;
    w(u, d) && (i.remove(d), i.setCursor(i.defaultCursor ?? ""));
  }), s;
}
class hC {
  constructor(n, s) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "ruler");
    this.canvas = n, this.editor = s, this.init();
  }
  hookSaveBefore() {
    return new Promise((n) => {
      this.hideGuideline(), n(!0);
    });
  }
  hookSaveAfter() {
    return new Promise((n) => {
      this.showGuideline(), n(!0);
    });
  }
  init() {
    this.ruler = $R(this.canvas);
  }
  hideGuideline() {
    this.ruler.hideGuideline();
  }
  showGuideline() {
    this.ruler.showGuideline();
  }
  rulerEnable() {
    this.ruler.enable();
  }
  rulerDisable() {
    this.ruler.disable();
  }
  destroy() {
    console.log("pluginDestroy");
  }
}
Te(hC, "pluginName", "RulerPlugin"), // static events = ['sizeChange'];
Te(hC, "apis", [
  "hideGuideline",
  "showGuideline",
  "rulerEnable",
  "rulerDisable"
]);
function Xk(i, n) {
  return function() {
    return i.apply(n, arguments);
  };
}
const { toString: IR } = Object.prototype, { getPrototypeOf: Nm } = Object, kh = /* @__PURE__ */ ((i) => (n) => {
  const s = IR.call(n);
  return i[s] || (i[s] = s.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Qi = (i) => (i = i.toLowerCase(), (n) => kh(n) === i), Sh = (i) => (n) => typeof n === i, { isArray: Yo } = Array, Ol = Sh("undefined");
function MR(i) {
  return i !== null && !Ol(i) && i.constructor !== null && !Ol(i.constructor) && Ci(i.constructor.isBuffer) && i.constructor.isBuffer(i);
}
const qk = Qi("ArrayBuffer");
function AR(i) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(i) : n = i && i.buffer && qk(i.buffer), n;
}
const FR = Sh("string"), Ci = Sh("function"), Jk = Sh("number"), Eh = (i) => i !== null && typeof i == "object", LR = (i) => i === !0 || i === !1, cu = (i) => {
  if (kh(i) !== "object")
    return !1;
  const n = Nm(i);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in i) && !(Symbol.iterator in i);
}, zR = Qi("Date"), RR = Qi("File"), jR = Qi("Blob"), HR = Qi("FileList"), UR = (i) => Eh(i) && Ci(i.pipe), WR = (i) => {
  let n;
  return i && (typeof FormData == "function" && i instanceof FormData || Ci(i.append) && ((n = kh(i)) === "formdata" || // detect form-data instance
  n === "object" && Ci(i.toString) && i.toString() === "[object FormData]"));
}, YR = Qi("URLSearchParams"), KR = (i) => i.trim ? i.trim() : i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ul(i, n, { allOwnKeys: s = !1 } = {}) {
  if (i === null || typeof i > "u")
    return;
  let u, y;
  if (typeof i != "object" && (i = [i]), Yo(i))
    for (u = 0, y = i.length; u < y; u++)
      n.call(null, i[u], u, i);
  else {
    const w = s ? Object.getOwnPropertyNames(i) : Object.keys(i), S = w.length;
    let d;
    for (u = 0; u < S; u++)
      d = w[u], n.call(null, i[d], d, i);
  }
}
function Qk(i, n) {
  n = n.toLowerCase();
  const s = Object.keys(i);
  let u = s.length, y;
  for (; u-- > 0; )
    if (y = s[u], n === y.toLowerCase())
      return y;
  return null;
}
const Zk = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, eS = (i) => !Ol(i) && i !== Zk;
function np() {
  const { caseless: i } = eS(this) && this || {}, n = {}, s = (u, y) => {
    const w = i && Qk(n, y) || y;
    cu(n[w]) && cu(u) ? n[w] = np(n[w], u) : cu(u) ? n[w] = np({}, u) : Yo(u) ? n[w] = u.slice() : n[w] = u;
  };
  for (let u = 0, y = arguments.length; u < y; u++)
    arguments[u] && Ul(arguments[u], s);
  return n;
}
const GR = (i, n, s, { allOwnKeys: u } = {}) => (Ul(n, (y, w) => {
  s && Ci(y) ? i[w] = Xk(y, s) : i[w] = y;
}, { allOwnKeys: u }), i), XR = (i) => (i.charCodeAt(0) === 65279 && (i = i.slice(1)), i), qR = (i, n, s, u) => {
  i.prototype = Object.create(n.prototype, u), i.prototype.constructor = i, Object.defineProperty(i, "super", {
    value: n.prototype
  }), s && Object.assign(i.prototype, s);
}, JR = (i, n, s, u) => {
  let y, w, S;
  const d = {};
  if (n = n || {}, i == null)
    return n;
  do {
    for (y = Object.getOwnPropertyNames(i), w = y.length; w-- > 0; )
      S = y[w], (!u || u(S, i, n)) && !d[S] && (n[S] = i[S], d[S] = !0);
    i = s !== !1 && Nm(i);
  } while (i && (!s || s(i, n)) && i !== Object.prototype);
  return n;
}, QR = (i, n, s) => {
  i = String(i), (s === void 0 || s > i.length) && (s = i.length), s -= n.length;
  const u = i.indexOf(n, s);
  return u !== -1 && u === s;
}, ZR = (i) => {
  if (!i)
    return null;
  if (Yo(i))
    return i;
  let n = i.length;
  if (!Jk(n))
    return null;
  const s = new Array(n);
  for (; n-- > 0; )
    s[n] = i[n];
  return s;
}, e8 = /* @__PURE__ */ ((i) => (n) => i && n instanceof i)(typeof Uint8Array < "u" && Nm(Uint8Array)), t8 = (i, n) => {
  const u = (i && i[Symbol.iterator]).call(i);
  let y;
  for (; (y = u.next()) && !y.done; ) {
    const w = y.value;
    n.call(i, w[0], w[1]);
  }
}, n8 = (i, n) => {
  let s;
  const u = [];
  for (; (s = i.exec(n)) !== null; )
    u.push(s);
  return u;
}, i8 = Qi("HTMLFormElement"), r8 = (i) => i.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(s, u, y) {
    return u.toUpperCase() + y;
  }
), dC = (({ hasOwnProperty: i }) => (n, s) => i.call(n, s))(Object.prototype), s8 = Qi("RegExp"), tS = (i, n) => {
  const s = Object.getOwnPropertyDescriptors(i), u = {};
  Ul(s, (y, w) => {
    n(y, w, i) !== !1 && (u[w] = y);
  }), Object.defineProperties(i, u);
}, o8 = (i) => {
  tS(i, (n, s) => {
    if (Ci(i) && ["arguments", "caller", "callee"].indexOf(s) !== -1)
      return !1;
    const u = i[s];
    if (Ci(u)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + s + "'");
      });
    }
  });
}, a8 = (i, n) => {
  const s = {}, u = (y) => {
    y.forEach((w) => {
      s[w] = !0;
    });
  };
  return Yo(i) ? u(i) : u(String(i).split(n)), s;
}, l8 = () => {
}, c8 = (i, n) => (i = +i, Number.isFinite(i) ? i : n), bf = "abcdefghijklmnopqrstuvwxyz", fC = "0123456789", nS = {
  DIGIT: fC,
  ALPHA: bf,
  ALPHA_DIGIT: bf + bf.toUpperCase() + fC
}, u8 = (i = 16, n = nS.ALPHA_DIGIT) => {
  let s = "";
  const { length: u } = n;
  for (; i--; )
    s += n[Math.random() * u | 0];
  return s;
};
function h8(i) {
  return !!(i && Ci(i.append) && i[Symbol.toStringTag] === "FormData" && i[Symbol.iterator]);
}
const d8 = (i) => {
  const n = new Array(10), s = (u, y) => {
    if (Eh(u)) {
      if (n.indexOf(u) >= 0)
        return;
      if (!("toJSON" in u)) {
        n[y] = u;
        const w = Yo(u) ? [] : {};
        return Ul(u, (S, d) => {
          const l = s(S, y + 1);
          !Ol(l) && (w[d] = l);
        }), n[y] = void 0, w;
      }
    }
    return u;
  };
  return s(i, 0);
}, f8 = Qi("AsyncFunction"), p8 = (i) => i && (Eh(i) || Ci(i)) && Ci(i.then) && Ci(i.catch), Pe = {
  isArray: Yo,
  isArrayBuffer: qk,
  isBuffer: MR,
  isFormData: WR,
  isArrayBufferView: AR,
  isString: FR,
  isNumber: Jk,
  isBoolean: LR,
  isObject: Eh,
  isPlainObject: cu,
  isUndefined: Ol,
  isDate: zR,
  isFile: RR,
  isBlob: jR,
  isRegExp: s8,
  isFunction: Ci,
  isStream: UR,
  isURLSearchParams: YR,
  isTypedArray: e8,
  isFileList: HR,
  forEach: Ul,
  merge: np,
  extend: GR,
  trim: KR,
  stripBOM: XR,
  inherits: qR,
  toFlatObject: JR,
  kindOf: kh,
  kindOfTest: Qi,
  endsWith: QR,
  toArray: ZR,
  forEachEntry: t8,
  matchAll: n8,
  isHTMLForm: i8,
  hasOwnProperty: dC,
  hasOwnProp: dC,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: tS,
  freezeMethods: o8,
  toObjectSet: a8,
  toCamelCase: r8,
  noop: l8,
  toFiniteNumber: c8,
  findKey: Qk,
  global: Zk,
  isContextDefined: eS,
  ALPHABET: nS,
  generateString: u8,
  isSpecCompliantForm: h8,
  toJSONObject: d8,
  isAsyncFn: f8,
  isThenable: p8
};
function At(i, n, s, u, y) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = i, this.name = "AxiosError", n && (this.code = n), s && (this.config = s), u && (this.request = u), y && (this.response = y);
}
Pe.inherits(At, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Pe.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const iS = At.prototype, rS = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((i) => {
  rS[i] = { value: i };
});
Object.defineProperties(At, rS);
Object.defineProperty(iS, "isAxiosError", { value: !0 });
At.from = (i, n, s, u, y, w) => {
  const S = Object.create(iS);
  return Pe.toFlatObject(i, S, function(l) {
    return l !== Error.prototype;
  }, (d) => d !== "isAxiosError"), At.call(S, i.message, n, s, u, y), S.cause = i, S.name = i.name, w && Object.assign(S, w), S;
};
const m8 = null;
function ip(i) {
  return Pe.isPlainObject(i) || Pe.isArray(i);
}
function sS(i) {
  return Pe.endsWith(i, "[]") ? i.slice(0, -2) : i;
}
function pC(i, n, s) {
  return i ? i.concat(n).map(function(y, w) {
    return y = sS(y), !s && w ? "[" + y + "]" : y;
  }).join(s ? "." : "") : n;
}
function g8(i) {
  return Pe.isArray(i) && !i.some(ip);
}
const v8 = Pe.toFlatObject(Pe, {}, null, function(n) {
  return /^is[A-Z]/.test(n);
});
function xh(i, n, s) {
  if (!Pe.isObject(i))
    throw new TypeError("target must be an object");
  n = n || new FormData(), s = Pe.toFlatObject(s, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(b, f) {
    return !Pe.isUndefined(f[b]);
  });
  const u = s.metaTokens, y = s.visitor || v, w = s.dots, S = s.indexes, l = (s.Blob || typeof Blob < "u" && Blob) && Pe.isSpecCompliantForm(n);
  if (!Pe.isFunction(y))
    throw new TypeError("visitor must be a function");
  function p(m) {
    if (m === null)
      return "";
    if (Pe.isDate(m))
      return m.toISOString();
    if (!l && Pe.isBlob(m))
      throw new At("Blob is not supported. Use a Buffer instead.");
    return Pe.isArrayBuffer(m) || Pe.isTypedArray(m) ? l && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function v(m, b, f) {
    let k = m;
    if (m && !f && typeof m == "object") {
      if (Pe.endsWith(b, "{}"))
        b = u ? b : b.slice(0, -2), m = JSON.stringify(m);
      else if (Pe.isArray(m) && g8(m) || (Pe.isFileList(m) || Pe.endsWith(b, "[]")) && (k = Pe.toArray(m)))
        return b = sS(b), k.forEach(function(_, T) {
          !(Pe.isUndefined(_) || _ === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            S === !0 ? pC([b], T, w) : S === null ? b : b + "[]",
            p(_)
          );
        }), !1;
    }
    return ip(m) ? !0 : (n.append(pC(f, b, w), p(m)), !1);
  }
  const c = [], e = Object.assign(v8, {
    defaultVisitor: v,
    convertValue: p,
    isVisitable: ip
  });
  function h(m, b) {
    if (!Pe.isUndefined(m)) {
      if (c.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + b.join("."));
      c.push(m), Pe.forEach(m, function(k, E) {
        (!(Pe.isUndefined(k) || k === null) && y.call(
          n,
          k,
          Pe.isString(E) ? E.trim() : E,
          b,
          e
        )) === !0 && h(k, b ? b.concat(E) : [E]);
      }), c.pop();
    }
  }
  if (!Pe.isObject(i))
    throw new TypeError("data must be an object");
  return h(i), n;
}
function mC(i) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(i).replace(/[!'()~]|%20|%00/g, function(u) {
    return n[u];
  });
}
function Bm(i, n) {
  this._pairs = [], i && xh(i, this, n);
}
const oS = Bm.prototype;
oS.append = function(n, s) {
  this._pairs.push([n, s]);
};
oS.toString = function(n) {
  const s = n ? function(u) {
    return n.call(this, u, mC);
  } : mC;
  return this._pairs.map(function(y) {
    return s(y[0]) + "=" + s(y[1]);
  }, "").join("&");
};
function y8(i) {
  return encodeURIComponent(i).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function aS(i, n, s) {
  if (!n)
    return i;
  const u = s && s.encode || y8, y = s && s.serialize;
  let w;
  if (y ? w = y(n, s) : w = Pe.isURLSearchParams(n) ? n.toString() : new Bm(n, s).toString(u), w) {
    const S = i.indexOf("#");
    S !== -1 && (i = i.slice(0, S)), i += (i.indexOf("?") === -1 ? "?" : "&") + w;
  }
  return i;
}
class gC {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, s, u) {
    return this.handlers.push({
      fulfilled: n,
      rejected: s,
      synchronous: u ? u.synchronous : !1,
      runWhen: u ? u.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    Pe.forEach(this.handlers, function(u) {
      u !== null && n(u);
    });
  }
}
const lS = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, b8 = typeof URLSearchParams < "u" ? URLSearchParams : Bm, C8 = typeof FormData < "u" ? FormData : null, w8 = typeof Blob < "u" ? Blob : null, k8 = (() => {
  let i;
  return typeof navigator < "u" && ((i = navigator.product) === "ReactNative" || i === "NativeScript" || i === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), S8 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Wi = {
  isBrowser: !0,
  classes: {
    URLSearchParams: b8,
    FormData: C8,
    Blob: w8
  },
  isStandardBrowserEnv: k8,
  isStandardBrowserWebWorkerEnv: S8,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function E8(i, n) {
  return xh(i, new Wi.classes.URLSearchParams(), Object.assign({
    visitor: function(s, u, y, w) {
      return Wi.isNode && Pe.isBuffer(s) ? (this.append(u, s.toString("base64")), !1) : w.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function x8(i) {
  return Pe.matchAll(/\w+|\[(\w*)]/g, i).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function _8(i) {
  const n = {}, s = Object.keys(i);
  let u;
  const y = s.length;
  let w;
  for (u = 0; u < y; u++)
    w = s[u], n[w] = i[w];
  return n;
}
function cS(i) {
  function n(s, u, y, w) {
    let S = s[w++];
    const d = Number.isFinite(+S), l = w >= s.length;
    return S = !S && Pe.isArray(y) ? y.length : S, l ? (Pe.hasOwnProp(y, S) ? y[S] = [y[S], u] : y[S] = u, !d) : ((!y[S] || !Pe.isObject(y[S])) && (y[S] = []), n(s, u, y[S], w) && Pe.isArray(y[S]) && (y[S] = _8(y[S])), !d);
  }
  if (Pe.isFormData(i) && Pe.isFunction(i.entries)) {
    const s = {};
    return Pe.forEachEntry(i, (u, y) => {
      n(x8(u), y, s, 0);
    }), s;
  }
  return null;
}
const T8 = {
  "Content-Type": void 0
};
function O8(i, n, s) {
  if (Pe.isString(i))
    try {
      return (n || JSON.parse)(i), Pe.trim(i);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (s || JSON.stringify)(i);
}
const _h = {
  transitional: lS,
  adapter: ["xhr", "http"],
  transformRequest: [function(n, s) {
    const u = s.getContentType() || "", y = u.indexOf("application/json") > -1, w = Pe.isObject(n);
    if (w && Pe.isHTMLForm(n) && (n = new FormData(n)), Pe.isFormData(n))
      return y && y ? JSON.stringify(cS(n)) : n;
    if (Pe.isArrayBuffer(n) || Pe.isBuffer(n) || Pe.isStream(n) || Pe.isFile(n) || Pe.isBlob(n))
      return n;
    if (Pe.isArrayBufferView(n))
      return n.buffer;
    if (Pe.isURLSearchParams(n))
      return s.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let d;
    if (w) {
      if (u.indexOf("application/x-www-form-urlencoded") > -1)
        return E8(n, this.formSerializer).toString();
      if ((d = Pe.isFileList(n)) || u.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return xh(
          d ? { "files[]": n } : n,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return w || y ? (s.setContentType("application/json", !1), O8(n)) : n;
  }],
  transformResponse: [function(n) {
    const s = this.transitional || _h.transitional, u = s && s.forcedJSONParsing, y = this.responseType === "json";
    if (n && Pe.isString(n) && (u && !this.responseType || y)) {
      const S = !(s && s.silentJSONParsing) && y;
      try {
        return JSON.parse(n);
      } catch (d) {
        if (S)
          throw d.name === "SyntaxError" ? At.from(d, At.ERR_BAD_RESPONSE, this, null, this.response) : d;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Wi.classes.FormData,
    Blob: Wi.classes.Blob
  },
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
Pe.forEach(["delete", "get", "head"], function(n) {
  _h.headers[n] = {};
});
Pe.forEach(["post", "put", "patch"], function(n) {
  _h.headers[n] = Pe.merge(T8);
});
const Pm = _h, D8 = Pe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), N8 = (i) => {
  const n = {};
  let s, u, y;
  return i && i.split(`
`).forEach(function(S) {
    y = S.indexOf(":"), s = S.substring(0, y).trim().toLowerCase(), u = S.substring(y + 1).trim(), !(!s || n[s] && D8[s]) && (s === "set-cookie" ? n[s] ? n[s].push(u) : n[s] = [u] : n[s] = n[s] ? n[s] + ", " + u : u);
  }), n;
}, vC = Symbol("internals");
function La(i) {
  return i && String(i).trim().toLowerCase();
}
function uu(i) {
  return i === !1 || i == null ? i : Pe.isArray(i) ? i.map(uu) : String(i);
}
function B8(i) {
  const n = /* @__PURE__ */ Object.create(null), s = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let u;
  for (; u = s.exec(i); )
    n[u[1]] = u[2];
  return n;
}
const P8 = (i) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(i.trim());
function Cf(i, n, s, u, y) {
  if (Pe.isFunction(u))
    return u.call(this, n, s);
  if (y && (n = s), !!Pe.isString(n)) {
    if (Pe.isString(u))
      return n.indexOf(u) !== -1;
    if (Pe.isRegExp(u))
      return u.test(n);
  }
}
function V8(i) {
  return i.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, s, u) => s.toUpperCase() + u);
}
function $8(i, n) {
  const s = Pe.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((u) => {
    Object.defineProperty(i, u + s, {
      value: function(y, w, S) {
        return this[u].call(this, n, y, w, S);
      },
      configurable: !0
    });
  });
}
class Th {
  constructor(n) {
    n && this.set(n);
  }
  set(n, s, u) {
    const y = this;
    function w(d, l, p) {
      const v = La(l);
      if (!v)
        throw new Error("header name must be a non-empty string");
      const c = Pe.findKey(y, v);
      (!c || y[c] === void 0 || p === !0 || p === void 0 && y[c] !== !1) && (y[c || l] = uu(d));
    }
    const S = (d, l) => Pe.forEach(d, (p, v) => w(p, v, l));
    return Pe.isPlainObject(n) || n instanceof this.constructor ? S(n, s) : Pe.isString(n) && (n = n.trim()) && !P8(n) ? S(N8(n), s) : n != null && w(s, n, u), this;
  }
  get(n, s) {
    if (n = La(n), n) {
      const u = Pe.findKey(this, n);
      if (u) {
        const y = this[u];
        if (!s)
          return y;
        if (s === !0)
          return B8(y);
        if (Pe.isFunction(s))
          return s.call(this, y, u);
        if (Pe.isRegExp(s))
          return s.exec(y);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, s) {
    if (n = La(n), n) {
      const u = Pe.findKey(this, n);
      return !!(u && this[u] !== void 0 && (!s || Cf(this, this[u], u, s)));
    }
    return !1;
  }
  delete(n, s) {
    const u = this;
    let y = !1;
    function w(S) {
      if (S = La(S), S) {
        const d = Pe.findKey(u, S);
        d && (!s || Cf(u, u[d], d, s)) && (delete u[d], y = !0);
      }
    }
    return Pe.isArray(n) ? n.forEach(w) : w(n), y;
  }
  clear(n) {
    const s = Object.keys(this);
    let u = s.length, y = !1;
    for (; u--; ) {
      const w = s[u];
      (!n || Cf(this, this[w], w, n, !0)) && (delete this[w], y = !0);
    }
    return y;
  }
  normalize(n) {
    const s = this, u = {};
    return Pe.forEach(this, (y, w) => {
      const S = Pe.findKey(u, w);
      if (S) {
        s[S] = uu(y), delete s[w];
        return;
      }
      const d = n ? V8(w) : String(w).trim();
      d !== w && delete s[w], s[d] = uu(y), u[d] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const s = /* @__PURE__ */ Object.create(null);
    return Pe.forEach(this, (u, y) => {
      u != null && u !== !1 && (s[y] = n && Pe.isArray(u) ? u.join(", ") : u);
    }), s;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, s]) => n + ": " + s).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...s) {
    const u = new this(n);
    return s.forEach((y) => u.set(y)), u;
  }
  static accessor(n) {
    const u = (this[vC] = this[vC] = {
      accessors: {}
    }).accessors, y = this.prototype;
    function w(S) {
      const d = La(S);
      u[d] || ($8(y, S), u[d] = !0);
    }
    return Pe.isArray(n) ? n.forEach(w) : w(n), this;
  }
}
Th.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Pe.freezeMethods(Th.prototype);
Pe.freezeMethods(Th);
const mr = Th;
function wf(i, n) {
  const s = this || Pm, u = n || s, y = mr.from(u.headers);
  let w = u.data;
  return Pe.forEach(i, function(d) {
    w = d.call(s, w, y.normalize(), n ? n.status : void 0);
  }), y.normalize(), w;
}
function uS(i) {
  return !!(i && i.__CANCEL__);
}
function Wl(i, n, s) {
  At.call(this, i ?? "canceled", At.ERR_CANCELED, n, s), this.name = "CanceledError";
}
Pe.inherits(Wl, At, {
  __CANCEL__: !0
});
function I8(i, n, s) {
  const u = s.config.validateStatus;
  !s.status || !u || u(s.status) ? i(s) : n(new At(
    "Request failed with status code " + s.status,
    [At.ERR_BAD_REQUEST, At.ERR_BAD_RESPONSE][Math.floor(s.status / 100) - 4],
    s.config,
    s.request,
    s
  ));
}
const M8 = Wi.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  /* @__PURE__ */ function() {
    return {
      write: function(s, u, y, w, S, d) {
        const l = [];
        l.push(s + "=" + encodeURIComponent(u)), Pe.isNumber(y) && l.push("expires=" + new Date(y).toGMTString()), Pe.isString(w) && l.push("path=" + w), Pe.isString(S) && l.push("domain=" + S), d === !0 && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(s) {
        const u = document.cookie.match(new RegExp("(^|;\\s*)(" + s + ")=([^;]*)"));
        return u ? decodeURIComponent(u[3]) : null;
      },
      remove: function(s) {
        this.write(s, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function A8(i) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(i);
}
function F8(i, n) {
  return n ? i.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : i;
}
function hS(i, n) {
  return i && !A8(n) ? F8(i, n) : n;
}
const L8 = Wi.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const n = /(msie|trident)/i.test(navigator.userAgent), s = document.createElement("a");
    let u;
    function y(w) {
      let S = w;
      return n && (s.setAttribute("href", S), S = s.href), s.setAttribute("href", S), {
        href: s.href,
        protocol: s.protocol ? s.protocol.replace(/:$/, "") : "",
        host: s.host,
        search: s.search ? s.search.replace(/^\?/, "") : "",
        hash: s.hash ? s.hash.replace(/^#/, "") : "",
        hostname: s.hostname,
        port: s.port,
        pathname: s.pathname.charAt(0) === "/" ? s.pathname : "/" + s.pathname
      };
    }
    return u = y(window.location.href), function(S) {
      const d = Pe.isString(S) ? y(S) : S;
      return d.protocol === u.protocol && d.host === u.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function z8(i) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(i);
  return n && n[1] || "";
}
function R8(i, n) {
  i = i || 10;
  const s = new Array(i), u = new Array(i);
  let y = 0, w = 0, S;
  return n = n !== void 0 ? n : 1e3, function(l) {
    const p = Date.now(), v = u[w];
    S || (S = p), s[y] = l, u[y] = p;
    let c = w, e = 0;
    for (; c !== y; )
      e += s[c++], c = c % i;
    if (y = (y + 1) % i, y === w && (w = (w + 1) % i), p - S < n)
      return;
    const h = v && p - v;
    return h ? Math.round(e * 1e3 / h) : void 0;
  };
}
function yC(i, n) {
  let s = 0;
  const u = R8(50, 250);
  return (y) => {
    const w = y.loaded, S = y.lengthComputable ? y.total : void 0, d = w - s, l = u(d), p = w <= S;
    s = w;
    const v = {
      loaded: w,
      total: S,
      progress: S ? w / S : void 0,
      bytes: d,
      rate: l || void 0,
      estimated: l && S && p ? (S - w) / l : void 0,
      event: y
    };
    v[n ? "download" : "upload"] = !0, i(v);
  };
}
const j8 = typeof XMLHttpRequest < "u", H8 = j8 && function(i) {
  return new Promise(function(s, u) {
    let y = i.data;
    const w = mr.from(i.headers).normalize(), S = i.responseType;
    let d;
    function l() {
      i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    Pe.isFormData(y) && (Wi.isStandardBrowserEnv || Wi.isStandardBrowserWebWorkerEnv ? w.setContentType(!1) : w.setContentType("multipart/form-data;", !1));
    let p = new XMLHttpRequest();
    if (i.auth) {
      const h = i.auth.username || "", m = i.auth.password ? unescape(encodeURIComponent(i.auth.password)) : "";
      w.set("Authorization", "Basic " + btoa(h + ":" + m));
    }
    const v = hS(i.baseURL, i.url);
    p.open(i.method.toUpperCase(), aS(v, i.params, i.paramsSerializer), !0), p.timeout = i.timeout;
    function c() {
      if (!p)
        return;
      const h = mr.from(
        "getAllResponseHeaders" in p && p.getAllResponseHeaders()
      ), b = {
        data: !S || S === "text" || S === "json" ? p.responseText : p.response,
        status: p.status,
        statusText: p.statusText,
        headers: h,
        config: i,
        request: p
      };
      I8(function(k) {
        s(k), l();
      }, function(k) {
        u(k), l();
      }, b), p = null;
    }
    if ("onloadend" in p ? p.onloadend = c : p.onreadystatechange = function() {
      !p || p.readyState !== 4 || p.status === 0 && !(p.responseURL && p.responseURL.indexOf("file:") === 0) || setTimeout(c);
    }, p.onabort = function() {
      p && (u(new At("Request aborted", At.ECONNABORTED, i, p)), p = null);
    }, p.onerror = function() {
      u(new At("Network Error", At.ERR_NETWORK, i, p)), p = null;
    }, p.ontimeout = function() {
      let m = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const b = i.transitional || lS;
      i.timeoutErrorMessage && (m = i.timeoutErrorMessage), u(new At(
        m,
        b.clarifyTimeoutError ? At.ETIMEDOUT : At.ECONNABORTED,
        i,
        p
      )), p = null;
    }, Wi.isStandardBrowserEnv) {
      const h = (i.withCredentials || L8(v)) && i.xsrfCookieName && M8.read(i.xsrfCookieName);
      h && w.set(i.xsrfHeaderName, h);
    }
    y === void 0 && w.setContentType(null), "setRequestHeader" in p && Pe.forEach(w.toJSON(), function(m, b) {
      p.setRequestHeader(b, m);
    }), Pe.isUndefined(i.withCredentials) || (p.withCredentials = !!i.withCredentials), S && S !== "json" && (p.responseType = i.responseType), typeof i.onDownloadProgress == "function" && p.addEventListener("progress", yC(i.onDownloadProgress, !0)), typeof i.onUploadProgress == "function" && p.upload && p.upload.addEventListener("progress", yC(i.onUploadProgress)), (i.cancelToken || i.signal) && (d = (h) => {
      p && (u(!h || h.type ? new Wl(null, i, p) : h), p.abort(), p = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const e = z8(v);
    if (e && Wi.protocols.indexOf(e) === -1) {
      u(new At("Unsupported protocol " + e + ":", At.ERR_BAD_REQUEST, i));
      return;
    }
    p.send(y || null);
  });
}, hu = {
  http: m8,
  xhr: H8
};
Pe.forEach(hu, (i, n) => {
  if (i) {
    try {
      Object.defineProperty(i, "name", { value: n });
    } catch {
    }
    Object.defineProperty(i, "adapterName", { value: n });
  }
});
const U8 = {
  getAdapter: (i) => {
    i = Pe.isArray(i) ? i : [i];
    const { length: n } = i;
    let s, u;
    for (let y = 0; y < n && (s = i[y], !(u = Pe.isString(s) ? hu[s.toLowerCase()] : s)); y++)
      ;
    if (!u)
      throw u === !1 ? new At(
        `Adapter ${s} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        Pe.hasOwnProp(hu, s) ? `Adapter '${s}' is not available in the build` : `Unknown adapter '${s}'`
      );
    if (!Pe.isFunction(u))
      throw new TypeError("adapter is not a function");
    return u;
  },
  adapters: hu
};
function kf(i) {
  if (i.cancelToken && i.cancelToken.throwIfRequested(), i.signal && i.signal.aborted)
    throw new Wl(null, i);
}
function bC(i) {
  return kf(i), i.headers = mr.from(i.headers), i.data = wf.call(
    i,
    i.transformRequest
  ), ["post", "put", "patch"].indexOf(i.method) !== -1 && i.headers.setContentType("application/x-www-form-urlencoded", !1), U8.getAdapter(i.adapter || Pm.adapter)(i).then(function(u) {
    return kf(i), u.data = wf.call(
      i,
      i.transformResponse,
      u
    ), u.headers = mr.from(u.headers), u;
  }, function(u) {
    return uS(u) || (kf(i), u && u.response && (u.response.data = wf.call(
      i,
      i.transformResponse,
      u.response
    ), u.response.headers = mr.from(u.response.headers))), Promise.reject(u);
  });
}
const CC = (i) => i instanceof mr ? i.toJSON() : i;
function Lo(i, n) {
  n = n || {};
  const s = {};
  function u(p, v, c) {
    return Pe.isPlainObject(p) && Pe.isPlainObject(v) ? Pe.merge.call({ caseless: c }, p, v) : Pe.isPlainObject(v) ? Pe.merge({}, v) : Pe.isArray(v) ? v.slice() : v;
  }
  function y(p, v, c) {
    if (Pe.isUndefined(v)) {
      if (!Pe.isUndefined(p))
        return u(void 0, p, c);
    } else
      return u(p, v, c);
  }
  function w(p, v) {
    if (!Pe.isUndefined(v))
      return u(void 0, v);
  }
  function S(p, v) {
    if (Pe.isUndefined(v)) {
      if (!Pe.isUndefined(p))
        return u(void 0, p);
    } else
      return u(void 0, v);
  }
  function d(p, v, c) {
    if (c in n)
      return u(p, v);
    if (c in i)
      return u(void 0, p);
  }
  const l = {
    url: w,
    method: w,
    data: w,
    baseURL: S,
    transformRequest: S,
    transformResponse: S,
    paramsSerializer: S,
    timeout: S,
    timeoutMessage: S,
    withCredentials: S,
    adapter: S,
    responseType: S,
    xsrfCookieName: S,
    xsrfHeaderName: S,
    onUploadProgress: S,
    onDownloadProgress: S,
    decompress: S,
    maxContentLength: S,
    maxBodyLength: S,
    beforeRedirect: S,
    transport: S,
    httpAgent: S,
    httpsAgent: S,
    cancelToken: S,
    socketPath: S,
    responseEncoding: S,
    validateStatus: d,
    headers: (p, v) => y(CC(p), CC(v), !0)
  };
  return Pe.forEach(Object.keys(Object.assign({}, i, n)), function(v) {
    const c = l[v] || y, e = c(i[v], n[v], v);
    Pe.isUndefined(e) && c !== d || (s[v] = e);
  }), s;
}
const dS = "1.4.0", Vm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((i, n) => {
  Vm[i] = function(u) {
    return typeof u === i || "a" + (n < 1 ? "n " : " ") + i;
  };
});
const wC = {};
Vm.transitional = function(n, s, u) {
  function y(w, S) {
    return "[Axios v" + dS + "] Transitional option '" + w + "'" + S + (u ? ". " + u : "");
  }
  return (w, S, d) => {
    if (n === !1)
      throw new At(
        y(S, " has been removed" + (s ? " in " + s : "")),
        At.ERR_DEPRECATED
      );
    return s && !wC[S] && (wC[S] = !0, console.warn(
      y(
        S,
        " has been deprecated since v" + s + " and will be removed in the near future"
      )
    )), n ? n(w, S, d) : !0;
  };
};
function W8(i, n, s) {
  if (typeof i != "object")
    throw new At("options must be an object", At.ERR_BAD_OPTION_VALUE);
  const u = Object.keys(i);
  let y = u.length;
  for (; y-- > 0; ) {
    const w = u[y], S = n[w];
    if (S) {
      const d = i[w], l = d === void 0 || S(d, w, i);
      if (l !== !0)
        throw new At("option " + w + " must be " + l, At.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (s !== !0)
      throw new At("Unknown option " + w, At.ERR_BAD_OPTION);
  }
}
const rp = {
  assertOptions: W8,
  validators: Vm
}, Hr = rp.validators;
class Pu {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new gC(),
      response: new gC()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(n, s) {
    typeof n == "string" ? (s = s || {}, s.url = n) : s = n || {}, s = Lo(this.defaults, s);
    const { transitional: u, paramsSerializer: y, headers: w } = s;
    u !== void 0 && rp.assertOptions(u, {
      silentJSONParsing: Hr.transitional(Hr.boolean),
      forcedJSONParsing: Hr.transitional(Hr.boolean),
      clarifyTimeoutError: Hr.transitional(Hr.boolean)
    }, !1), y != null && (Pe.isFunction(y) ? s.paramsSerializer = {
      serialize: y
    } : rp.assertOptions(y, {
      encode: Hr.function,
      serialize: Hr.function
    }, !0)), s.method = (s.method || this.defaults.method || "get").toLowerCase();
    let S;
    S = w && Pe.merge(
      w.common,
      w[s.method]
    ), S && Pe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete w[m];
      }
    ), s.headers = mr.concat(S, w);
    const d = [];
    let l = !0;
    this.interceptors.request.forEach(function(b) {
      typeof b.runWhen == "function" && b.runWhen(s) === !1 || (l = l && b.synchronous, d.unshift(b.fulfilled, b.rejected));
    });
    const p = [];
    this.interceptors.response.forEach(function(b) {
      p.push(b.fulfilled, b.rejected);
    });
    let v, c = 0, e;
    if (!l) {
      const m = [bC.bind(this), void 0];
      for (m.unshift.apply(m, d), m.push.apply(m, p), e = m.length, v = Promise.resolve(s); c < e; )
        v = v.then(m[c++], m[c++]);
      return v;
    }
    e = d.length;
    let h = s;
    for (c = 0; c < e; ) {
      const m = d[c++], b = d[c++];
      try {
        h = m(h);
      } catch (f) {
        b.call(this, f);
        break;
      }
    }
    try {
      v = bC.call(this, h);
    } catch (m) {
      return Promise.reject(m);
    }
    for (c = 0, e = p.length; c < e; )
      v = v.then(p[c++], p[c++]);
    return v;
  }
  getUri(n) {
    n = Lo(this.defaults, n);
    const s = hS(n.baseURL, n.url);
    return aS(s, n.params, n.paramsSerializer);
  }
}
Pe.forEach(["delete", "get", "head", "options"], function(n) {
  Pu.prototype[n] = function(s, u) {
    return this.request(Lo(u || {}, {
      method: n,
      url: s,
      data: (u || {}).data
    }));
  };
});
Pe.forEach(["post", "put", "patch"], function(n) {
  function s(u) {
    return function(w, S, d) {
      return this.request(Lo(d || {}, {
        method: n,
        headers: u ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: w,
        data: S
      }));
    };
  }
  Pu.prototype[n] = s(), Pu.prototype[n + "Form"] = s(!0);
});
const du = Pu;
class $m {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let s;
    this.promise = new Promise(function(w) {
      s = w;
    });
    const u = this;
    this.promise.then((y) => {
      if (!u._listeners)
        return;
      let w = u._listeners.length;
      for (; w-- > 0; )
        u._listeners[w](y);
      u._listeners = null;
    }), this.promise.then = (y) => {
      let w;
      const S = new Promise((d) => {
        u.subscribe(d), w = d;
      }).then(y);
      return S.cancel = function() {
        u.unsubscribe(w);
      }, S;
    }, n(function(w, S, d) {
      u.reason || (u.reason = new Wl(w, S, d), s(u.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const s = this._listeners.indexOf(n);
    s !== -1 && this._listeners.splice(s, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new $m(function(y) {
        n = y;
      }),
      cancel: n
    };
  }
}
const Y8 = $m;
function K8(i) {
  return function(s) {
    return i.apply(null, s);
  };
}
function G8(i) {
  return Pe.isObject(i) && i.isAxiosError === !0;
}
const sp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(sp).forEach(([i, n]) => {
  sp[n] = i;
});
const X8 = sp;
function fS(i) {
  const n = new du(i), s = Xk(du.prototype.request, n);
  return Pe.extend(s, du.prototype, n, { allOwnKeys: !0 }), Pe.extend(s, n, null, { allOwnKeys: !0 }), s.create = function(y) {
    return fS(Lo(i, y));
  }, s;
}
const dn = fS(Pm);
dn.Axios = du;
dn.CanceledError = Wl;
dn.CancelToken = Y8;
dn.isCancel = uS;
dn.VERSION = dS;
dn.toFormData = xh;
dn.AxiosError = At;
dn.Cancel = dn.CanceledError;
dn.all = function(n) {
  return Promise.all(n);
};
dn.spread = K8;
dn.isAxiosError = G8;
dn.mergeConfig = Lo;
dn.AxiosHeaders = mr;
dn.formToJSON = (i) => cS(Pe.isHTMLForm(i) ? new FormData(i) : i);
dn.HttpStatusCode = X8;
dn.default = dn;
class kC {
  constructor(n, s, u) {
    Te(this, "canvas");
    Te(this, "editor");
    Te(this, "apiMapUrl");
    this.canvas = n, this.editor = s, this.apiMapUrl = {
      template: u.repoSrc + "/template/type.json",
      svg: u.repoSrc + "/svg/type.json"
    };
  }
  // 根据素材类型获取分裂列表
  async getMaterialType(n) {
    const s = this.apiMapUrl[n];
    return (await dn.get(s, { params: { typeId: n } })).data.data;
  }
  async getMaterialInfo(n) {
    const s = this.apiMapUrl[n];
    return (await dn.get(s, { params: { typeId: n } })).data.data;
  }
}
Te(kC, "pluginName", "MaterialPlugin"), Te(kC, "apis", ["getMaterialType", "getMaterialList"]);
export {
  ff as AlignGuidLinePlugin,
  Qb as CenterAlignPlugin,
  Xz as ControlsPlugin,
  qz as ControlsRotatePlugin,
  eC as CopyPlugin,
  tC as DeleteHotKeyPlugin,
  NR as DownFontPlugin,
  iC as DrawLinePlugin,
  df as DringPlugin,
  Q8 as EventType,
  cC as FlipPlugin,
  rC as GroupAlignPlugin,
  nC as GroupPlugin,
  Zz as GroupTextEditorPlugin,
  gf as HistoryPlugin,
  Zb as LayerPlugin,
  kC as MaterialPlugin,
  Jz as MoveHotKeyPlugin,
  hC as RulerPlugin,
  J8 as Utils,
  mf as WorkspacePlugin,
  tj as default
};
